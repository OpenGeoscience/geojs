{"version":3,"file":"geo.min.js","sources":["../src/core/init.js","../src/core/version.js","../src/util/init.js","../src/util/wigglemaps.js","../src/core/object.js","../src/core/sceneObject.js","../src/core/timestamp.js","../src/core/ellipsoid.js","../src/core/mercator.js","../src/core/latlng.js","../src/core/layer.js","../src/core/featureLayer.js","../src/core/event.js","../src/core/mapInteractor.js","../src/core/clock.js","../src/core/fileReader.js","../src/core/jsonReader.js","../src/core/map.js","../src/core/feature.js","../src/core/pointFeature.js","../src/core/lineFeature.js","../src/core/pathFeature.js","../src/core/polygonFeature.js","../src/core/planeFeature.js","../src/core/vectorFeature.js","../src/core/geomFeature.js","../src/core/graphFeature.js","../src/core/transform.js","../src/core/renderer.js","../src/core/osmLayer.js","../src/gl/init.js","../src/gl/renderer.js","../src/gl/lineFeature.js","../src/gl/pointFeature.js","../src/gl/geomFeature.js","../src/gl/planeFeature.js","../src/gl/polygonFeature.js","../src/gl/vglRenderer.js","../src/d3/init.js","../src/d3/object.js","../src/d3/pointFeature.js","../src/d3/lineFeature.js","../src/d3/pathFeature.js","../src/d3/graphFeature.js","../src/d3/planeFeature.js","../src/d3/vectorFeature.js","../src/d3/d3Renderer.js","../src/ui/init.js","../src/ui/uiLayer.js","../src/ui/widget.js","../src/ui/sliderWidget.js","../src/ui/legendWidget.js","../src/plugin/jquery-plugin.js"],"names":["geo","window","renderers","features","fileReaders","inherit","C","P","F","func","prototype","constructor","registerFileReader","name","undefined","createFileReader","opts","hasOwnProperty","registerRenderer","createRenderer","layer","canvas","ren","_init","registerFeature","category","createFeature","renderer","arg","api","options","$","extend","registerLayer","layers","createLayer","map","registerWidget","widgets","createWidget","requestAnimationFrame","setTimeout","Math","log2","log","apply","arguments","LN2","version","setNumeric","i","length","isFinite","chars","util","pointInPolygon","point","outer","inner","inside","n","forEach","vert","j","intersect","y","x","hole","isFunction","f","ensureFunction","randomString","s","r","floor","random","substring","convertColor","color","g","b","cssColors","charAt","parseInt","slice","normalizeCoordinates","p","Array","isArray","z","latlng","lng","lat","longitude","lon","latitude","elevation","elev","height","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","vect","Vector2D","RangeNode","elem","start","end","current","this","data","left","right","subtree","push","sort","a","xrange","x_in","yrange","y_in","subquery","result","box","y_left","x_right","search","contains","x_left","RangeTree","root","_box","clone","Box","v1","v2","min","max","y_right","area","width","vertex","index","intersects","union","centroid","add","v","sub","scale","sqrt","normalize","div","zero","tol","dot","cross","rotate","omega","cos","sin","xp","yp","array","dist","dir","c","d","intersect2dt","denom","num_t","t","intersect2dpos","num_s","object","m_this","m_eventHandlers","m_idleHandlers","m_deferredCount","onIdle","handler","addDeferred","defer","done","splice","geoOn","event","e","geoTrigger","args","call","geoOff","filter","_exit","vgl","sceneObject","m_parent","m_children","s_exit","s_trigger","s_addDeferred","s_onIdle","parent","addChild","child","removeChild","children","draw","childrenOnly","geoArgs","stopPropagation","_triggeredBy","timestamp","ellipsoid","defaultValue","console","m_radii","vec3","fromValues","m_radiiSquared","m_minimumRadius","m_maximumRadius","radii","radiiSquared","maximumRadius","minimumRadius","computeGeodeticSurfaceNormal","cosLatitude","create","transformPoint","PI","k","gamma","multiply","transformGeometry","geom","sourceData","vertexAttributeKeys","Position","sourceDataArray","noOfComponents","attributeNumberOfComponents","stride","attributeStride","offset","attributeOffset","sizeOfDataType","sizeOfAttributeDataType","count","WGS84","freezeObject","UNIT_SPHERE","mercator","r_major","r_minor","spherical","long2tilex","rad","pow","lat2tiley","long2tilex2","ret","frac","lat2tiley2","tilex2long","tiley2lat","atan","exp","y2lat","lat2y","deg2rad","rad2deg","ll2m","temp","es","eccent","phi","sinphi","con","com","con2","ts","m2ll","pjPhi2","dphi","N_ITER","HALFPI","TOL","eccnth","Phi","abs","arg1","arg2","arg3","m_lat","m_lng","m_elv","elv","val","m_style","style","opacity","visible","bin","m_id","id","newLayerId","m_name","m_gcs","m_timeRange","m_source","source","m_map","m_isReference","m_x","m_y","m_width","m_height","m_node","m_canvas","m_renderer","m_initialized","m_rendererName","m_dataTime","m_updateTime","m_drawTime","m_sticky","sticky","m_active","active","node","modified","gcs","transform","transformLayer","baseLayer","timeRange","append","viewport","dataTime","updateTime","drawTime","query","referenceLayer","initialized","toLocal","input","fromLocal","document","createElement","attr","css","off","remove","_update","_resize","w","h","resize","currentId","spec","type","warn","feature","featureLayer","m_features","s_init","s_update","s_draw","featureName","newFeature","deleteFeature","_render","pan","zoom","request","getMTime","clear","layerAdd","layerRemove","drawEnd","mousemove","mouseclick","brush","brushend","brushstart","transitionstart","transitionend","clock","play","stop","pause","change","mouseover","mouseout","mouseon","mouseoff","mapInteractor","eventMatch","button","modifiers","m_mouse","buttons","alt","meta","shift","ctrl","calcSpeed","doRespond","m_disableThrottle","m_wait","m_wheelQueue","m_throttleTime","modifyVelocity","deltaT","sf","springForce","speed","vx","vy","m_options","momentum","drag","minSpeed","xplus","xminus","yplus","yminus","spring","enabled","ul","gcsToDisplay","lr","springConstant","m_keyboard","m_state","$node","m_selectionLayer","m_selectionPlane","panMoveButton","panMoveModifiers","zoomMoveButton","zoomMoveModifiers","panWheelEnabled","panWheelModifiers","zoomWheelEnabled","zoomWheelModifiers","wheelScaleX","wheelScaleY","zoomScale","selectionButton","selectionModifiers","maxSpeed","page","middle","time","Date","deltaTime","velocity","_connectEvents","_disconnectEvents","on","_handleMouseMove","_handleMouseDown","_handleMouseUp","_handleMouseWheel","_getMousePosition","evt","dt","valueOf","pageX","pageY","top","displayToGcs","_getMouseButton","which","_getMouseModifiers","altKey","ctrlKey","metaKey","shiftKey","_getSelection","origin","mouse","display","upperLeft","lowerRight","upperRight","lowerLeft","cancel","action","out","delta","deleteLayer","screenCoordinates","fillOpacity","_handleMouseMoveDocument","_handleMouseUpDocument","dx","dy","selectionObj","preventDefault","oldAction","springBack","zoomFactor","direction","deltaFactor","deltaX","deltaY","initialVelocity","last","transition","_handleDoubleClick","destroy","keyboard","state","simulateEvent","wheelDelta","Event","indexOf","trigger","m_now","m_start","m_end","m_step","m_rate","m_loop","Number","POSITIVE_INFINITY","m_currentLoop","m_currentAnimation","m_object","_attached","now","previous","step","loop","_animate","framerate","stepForward","_setNextFrame","stepBackward","next","frame","myAnimation","fileReader","newFileReader","progress","reader","FileReader","onprogress","onloadend","error","m_layer","canRead","read","file","_getString","readAsText","_getArrayBuffer","jsonReader","strokeWidth","strokeColor","strokeOpacity","fillColor","File","match","JSON","parse","_featureArray","_readObject","onDone","fileString","ajax","url","dataType","fail","coordinates","_featureType","geometry","_getCoordinates","_getStyle","properties","_done","allFeatures","fill","_addFeature","stroke","_buildData","coord","_style","line","position","resizeSelf","m_uigcs","uigcs","m_center","m_zoom","m_baseLayer","m_fileReader","m_interactor","m_validZoomRange","m_transition","m_queuedTransition","m_clock","m_bounds","center","autoResize","clampBounds","base","recenter","zoomLevel","screenPosition","eventType","_updateBounds","force","pt","corner1","corner2","screenDelta","newCenter","currentCenter","layerName","newLayer","target","toggle","layerToggle","world","output","Object","worldToDisplay","displayToWorld","save","readerType","addLayer","exit","interactor","originalEvent","dataTransfer","dropEffect","files","zoomRange","interp1","p0","p1","defaultInterp","zoom2z","z2zoom","anim","defaultOpts","duration","ease","interp","zCoord","cancelNavigation","cancelAnimation","bounds","l","m_selectionAPI","selectionAPI","m_visible","m_bin","m_buildTime","m_selectedFeatures","_bindMouseHandlers","_unbindMouseHandlers","_handleMousemove","_handleMouseclick","_handleBrushend","_handleBrush","pointSearch","found","over","newFeatures","oldFeatures","lastTop","eventID","idx","boxSearch","get","key","tmp","all","toLowerCase","drawables","_drawables","buildTime","_build","pointFeature","m_rangeTree","s_data","s_style","m_maxRadius","_updateRangeTree","pts","radius","ifound","q","pos","_boundingBox","defaultStyle","sprites","sprites_image","lineFeature","lineDist2","u","l2","dist2","indices","ceil","err","partial","strokeStyle","pathFeature","m_position","polygonFeature","getCoordinates","posFunc","polyFunc","polygon","m_coordinates","poly","d0","m_polygon","coordinate","planeFeature","depth","m_origin","m_upperLeft","m_lowerRight","m_defaultDepth","m_drawOnAsyncResourceLoad","drawOnAsyncResourceLoad","image","vectorFeature","geomFeature","point_sprites","point_sprites_image","graphFeature","m_nodes","m_points","m_links","nodes","links","linkType","link","nodeFeature","linkFeatures","nLinks","osmTransformFeature","destGcs","inplace","yCoord","pointOffset","inPos","outPos","srcGcs","transformFeature","positions","projPoint","projSrcGcs","proj4","Proj","projDestGcs","Point","osmLayer","transformCoordinates","numberOfComponents","handleLatLngCoordinates","xAcc","yAcc","writer","handleArrayCoordinates","zAcc","handleObjectCoordinates","xCoord","reset","worldToGcs","relMouseCoords","totalOffsetX","totalOffsetY","canvasX","canvasY","currentElement","offsetLeft","scrollLeft","offsetTop","scrollTop","offsetParent","isTileVisible","tile","m_visibleTilesRange","index_x","startX","endX","index_y","startY","endY","drawTiles","_removeTiles","m_pendingNewTilesStat","m_updateTimerId","updateOSMTiles","m_lastVisibleZoom","_addTiles","m_tileUrl","m_tiles","m_hiddenBinNumber","m_lastVisibleBinNumber","m_visibleBinNumber","m_pendingNewTiles","m_pendingInactiveTiles","m_numberOfCachedTiles","m_tileCacheSize","m_baseUrl","m_mapOpacity","m_imageFormat","m_updateDefer","baseUrl","mapOpacity","imageFormat","displayLast","tileUrl","tileCacheSize","_hasTile","_addTile","noOfTilesX","noOfTilesY","totalLatDegrees","lonPerTile","latPerTile","llx","lly","urx","ury","Image","LOADING","LOADED","REMOVED","REMOVING","INVALID","crossOrigin","lastused","src","currZoom","lastZoom","tileOnLoad","Deferred","updateTimerId","total","resolve","lastStartX","lastStartY","lastEndX","lastEndY","currStartX","currStartY","currEndX","currEndY","distWorldDeltaPerTile","tile1x","tile1y","tile2x","tile2y","invJ","worldPt1","worldPt2","worldDeltaY","displayDeltaY","worldDelta","displayDelta","noOfTilesRequired","worldDeltaPerTile","minDistWorldDeltaPerTile","round","onload","_updateTiles","clearTimeout","updateBaseUrl","gl","contextRenderer","createVertexShader","vertexShaderSource","join","shader","VERTEX_SHADER","setShaderSource","createFragmentShader","fragmentShaderSource","FRAGMENT_SHADER","createGLLines","len","lineItem","lineItemData","vertTemp","posIdx3","posBuf","nextBuf","prevBuf","offsetBuf","indicesBuf","strokeWidthBuf","strokeColorBuf","strokeOpacityBuf","dest","dest3","numSegments","strkWidthFunc","strkColorFunc","strkOpacityFunc","order","featureVertices","m_mapper","geometryData","getBuffer","primitive","Uint16Array","setIndices","prev","boundsDirty","boundsDirtyTimestamp","srcName","sourceByName","Float32Array","setData","m_actor","m_material","m_pixelWidthUnif","m_aspectUniform","m_dynamicDraw","dynamicDraw","verticesPerFeature","prog","shaderProgram","vs","fs","posAttr","vertexAttribute","prvAttr","nxtAttr","offAttr","strkWidthAttr","strkColorAttr","strkOpacityAttr","mviUnif","modelViewUniform","prjUnif","projectionUniform","posData","sourceDataP3fv","prvPosData","sourceDataAnyfv","vertexAttributeKeysIndexed","Four","nxtPosData","Five","offPosData","Six","strkWidthData","One","strkColorData","Two","strkOpacityData","Three","triangles","floatUniform","material","mapper","addVertexAttribute","addUniform","addShader","addAttribute","blend","actor","setMaterial","setMapper","addSource","addPrimitive","setGeometryData","actors","removeActor","addActor","set","setVisible","setBinNumber","pointPolygon","verts","m_primitiveShape","createGLPoints","posVal","unitBuf","radiusVal","radFunc","strokeVal","strokeFunc","strokeWidthVal","strokeWidthFunc","strokeOpacityVal","strokeOpactityFunc","strokeColorVal","strokeColorFunc","fillVal","fillFunc","fillOpacityVal","fillOpacityFunc","fillColorVal","fillColorFunc","item","ivpf","ivpf3","iunit","i3","numPts","unit","vpf","m_pixelWidthUniform","primitiveShape","concat","vertexShader","fragmentShader","unitAttr","radAttr","strokeWidthAttr","fillColorAttr","fillAttr","strokeColorAttr","strokeAttr","fillOpacityAttr","strokeOpacityAttr","mat","sourcePositions","sourceUnits","sourceRadius","sourceStrokeWidth","sourceFillColor","sourceFill","sourceStrokeColor","sourceStroke","Seven","sourceAlpha","Eight","sourceStrokeOpacity","Nine","points","render","m_geom","m_scalar","m_color","m_noOfPrimitives","Scalar","Color","primitiveType","POINTS","utils","createPointSpritesMaterial","lookupTable","updateRange","scalarRange","createColorMappedMaterial","createColorMaterial","createSolidColorMaterial","updateColorMappedMaterial","m_onloadCallback","coords","or","img","texture","createTexturePlane","uniform","complete","setImage","createPlane","createGLPolygons","itemIndex","polygonItemCoordIndex","fillColorNew","fillOpacityNew","polygonItem","buffers","DataBuffers","sourceFillOpacity","trianglePrimitive","holes","extRing","extIndex","extLength","intIndex","posInstance","triangulator","PNLTRI","Triangulator","triangList","newTriangList","fillColorInstance","currentIndex","extRingCoords","intRingCoords","triangulate_polygon","newIndices","polygonIndex","polygonItemCoords","alloc","write","pushBack","_vglViewerInstances","viewers","maps","vglViewerInstance","makeViewer","viewer","renderWindow","removeRenderer","activeRenderer","init","mapIdx","deleteCache","vglRenderer","m_viewer","m_contextRenderer","setResetScene","cam","camera","fdp","focusDisplayPoint","vec4","viewMatrix","projectionMatrix","fp","focalPoint","setLayer","addRenderer","positionAndResize","_updateRendererCamera","cr","resetCameraClippingRange","clippingRange","setPosition","setFocalPoint","setClippingRange","focusPoint","centerDisplay","centerGeo","newCenterDisplay","newCenterGeo","newZ","d3","strLength","uniqueID","strArray","d3Rescale","_d3id","select","_removeFeature","pos_func","attributes","_convertScale","cx","cy","classes","_drawFeatures","svg","wrapStyle","ln","diag","diagonal","trg","selection","fill_color","markerID","updateMarkers","sel","_definitions","selectAll","enter","_convertColor","getScale","scaleFactor","orig_func","size_func","cache","NEGATIVE_INFINITY","x1","y1","x2","y2","marker-end","d3Renderer","setAttrs","attrs","setStyles","styles","getMap","getGroup","m_svg","initCorners","m_corners","setTransform","group","m_scale","m_dx","m_dy","baseToLocal","localToBase","m_defs","rgb","_convertPosition","shadow","dataIndex","__render","gui","uiLayer","widgetName","newWidget","deleteWidget","widget","_deleteFeature","_createFeature","sliderWidget","put_icon","icon","size","m_xscale","m_yscale","m_plus","m_minus","m_track","m_nub","m_plusIcon","m_minusIcon","m_group","m_lowContrast","m_nubSize","m_highlightDur","respond","trans","invert","zrange","x0","y0","linear","domain","range","classed","datum","cursor","mouseOver","mouseOut","obj","value","clamp","legendWidget","m_categories","m_top","m_border","m_spacing","m_padding","categories","test","text","getBBox","applyColor","_scale","labels","nw","margin","stroke-width","fill-opacity","load","isColorKey","makeColorScale","acc","wrap","cannotHandle","doNotHandle","categorical","values","category10","category20","fn","geojsMap","Error","baseRenderer","_create","_map","element","_baseLayer","_layers","update","scl","_size","extent","redraw"],"mappings":"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","sourcesContent":["/** @namespace */\nvar geo = {};     // jshint ignore: line\nwindow.geo = geo; // jshint ignore: line\n\ngeo.renderers = {};\ngeo.features = {};\ngeo.fileReaders = {};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convenient function to define JS inheritance\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.inherit = function (C, P) { // jshint ignore: line\n  \"use strict\";\n\n  var F = inherit.func();\n  F.prototype = P.prototype;\n  C.prototype = new F();\n  C.prototype.constructor = C;\n};\ngeo.inherit.func = function () {\n  \"use strict\";\n  return function () {};\n};\n\n// Should get rid of this at some point.\nwindow.inherit = geo.inherit;\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Register a new file reader type\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.registerFileReader = function (name, func) {\n  \"use strict\";\n\n  if (geo.fileReaders === undefined) {\n    geo.fileReaders = {};\n  }\n\n  geo.fileReaders[name] = func;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new file reader\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.createFileReader = function (name, opts) {\n  \"use strict\";\n\n  if (geo.fileReaders.hasOwnProperty(name)) {\n    return geo.fileReaders[name](opts);\n  }\n  return null;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Register a new renderer type\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.registerRenderer = function (name, func) {\n  \"use strict\";\n\n  if (geo.renderers === undefined) {\n    geo.renderers = {};\n  }\n\n  geo.renderers[name] = func;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create new instance of the renderer\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.createRenderer  = function (name, layer, canvas) {\n  \"use strict\";\n\n  if (geo.renderers.hasOwnProperty(name)) {\n    var ren = geo.renderers[name](\n      {\"layer\": layer, \"canvas\": canvas}\n    );\n    ren._init();\n    return ren;\n  }\n  return null;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Register a new feature type\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.registerFeature = function (category, name, func) {\n  \"use strict\";\n\n  if (geo.features === undefined) {\n    geo.features = {};\n  }\n\n  if (!(category in geo.features)) {\n    geo.features[category] = {};\n  }\n\n  // TODO Add warning if the name already exists\n  geo.features[category][name] = func;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create new instance of the renderer\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.createFeature  = function (name, layer, renderer, arg) {\n  \"use strict\";\n\n  var category = renderer.api(),\n      options = {\"layer\": layer, \"renderer\": renderer};\n  if (category in geo.features && name in geo.features[category]) {\n    if (arg !== undefined) {\n      $.extend(true, options, arg);\n    }\n    return geo.features[category][name](options);\n  }\n  return null;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Register a new layer type\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.registerLayer = function (name, func) {\n  \"use strict\";\n\n  if (geo.layers === undefined) {\n    geo.layers = {};\n  }\n\n  geo.layers[name] = func;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create new instance of the layer\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.createLayer = function (name, map, arg) {\n  \"use strict\";\n\n  /// Default renderer is vgl\n  var options = {\"map\": map, \"renderer\": \"vgl\"},\n      layer = null;\n\n  if (name in geo.layers) {\n    if (arg !== undefined) {\n      $.extend(true, options, arg);\n    }\n    layer = geo.layers[name](options);\n    layer._init();\n    return layer;\n  } else {\n    return null;\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Register a new widget type\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.registerWidget = function (category, name, func) {\n  \"use strict\";\n\n  if (geo.widgets === undefined) {\n    geo.widgets = {};\n  }\n\n  if (!(category in geo.widgets)) {\n    geo.widgets[category] = {};\n  }\n\n  // TODO Add warning if the name already exists\n  geo.widgets[category][name] = func;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create new instance of the widget\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.createWidget  = function (name, layer, renderer, arg) {\n  \"use strict\";\n\n  var category = renderer.api(),\n      options = {\"layer\": layer, \"renderer\": renderer};\n  if (category in geo.widgets && name in geo.widgets[category]) {\n    if (arg !== undefined) {\n      $.extend(true, options, arg);\n    }\n    return geo.widgets[category][name](options);\n  }\n  return null;\n};\n\n// Add a polyfill for window.requestAnimationFrame.\nif (!window.requestAnimationFrame) {\n  window.requestAnimationFrame = function (func) {\n    \"use strict\";\n\n    window.setTimeout(func, 15);\n  };\n}\n\n// Add a polyfill for Math.log2\nif (!Math.log2) {\n  Math.log2 = function () {\n    \"use strict\";\n\n    return Math.log.apply(Math, arguments) / Math.LN2;\n  };\n}\n","/*global geo*/\n\ngeo.version = \"0.4.0\";\n","\n(function () {\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n  /**\n   * Takes a variable number of arguments and returns the first numeric value\n   * it finds.\n   * @private\n   */\n  function setNumeric() {\n    var i;\n    for (i = 0; i < arguments.length; i += 1) {\n      if (isFinite(arguments[i])) {\n        return arguments[i];\n      }\n    }\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Contains utility classes and methods used by geojs.\n   * @namespace\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  geo.util = {\n    /**\n     * Returns true if the given point lies in the given polygon.\n     * Algorithm description:\n     *   http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n     * @param {geo.screenPosition} point The test point\n     * @param {geo.screenPosition[]} outer The outer boundary of the polygon\n     * @param {geo.screenPosition[][]?} inner Inner boundaries (holes)\n     */\n    pointInPolygon: function (point, outer, inner) {\n      var inside = false, n = outer.length;\n\n      if (n < 3) {\n        // we need 3 coordinates for this to make sense\n        return false;\n      }\n\n      outer.forEach(function (vert, i) {\n        var j = (n + i - 1) % n;\n        var intersect = (\n          ((outer[i].y > point.y) !== (outer[j].y > point.y)) &&\n          (point.x < (outer[j].x - outer[i].x) *\n                     (point.y - outer[i].y) /\n                     (outer[j].y - outer[i].y) + outer[i].x)\n        );\n        if (intersect) {\n          inside = !inside;\n        }\n      });\n\n      (inner || []).forEach(function (hole) {\n        inside = inside && !geo.util.pointInPolygon(point, hole);\n      });\n\n      return inside;\n    },\n\n    /**\n     * Returns true if the argument is a function.\n     */\n    isFunction: function (f) {\n      return typeof f === \"function\";\n    },\n\n    /**\n     * Returns the argument if it is function, otherwise returns a function\n     * that returns the argument.\n     */\n    ensureFunction: function (f) {\n      if (geo.util.isFunction(f)) {\n        return f;\n      } else {\n        return function () { return f; };\n      }\n    },\n\n    /**\n     * Return a random string of length n || 8.\n     */\n    randomString: function (n) {\n      var s, i, r;\n      n = n || 8;\n      s = \"\";\n      for (i = 0; i < n; i += 1) {\n        r = Math.floor(Math.random() * chars.length);\n        s += chars.substring(r, r + 1);\n      }\n      return s;\n    },\n\n    /**\n     * Convert a color from hex value or css name to rgb objects\n     */\n    convertColor: function (color) {\n      if (color.r !== undefined && color.g !== undefined &&\n          color.b !== undefined) {\n        return color;\n      }\n      if (typeof color === \"string\") {\n        if (geo.util.cssColors.hasOwnProperty(color)) {\n          color = geo.util.cssColors[color];\n        } else if (color.charAt(0) === \"#\") {\n          color = parseInt(color.slice(1), 16);\n        }\n      }\n      // jshint -W016\n      if (isFinite(color)) {\n        color = {\n          r: ((color & 0xff0000) >> 16) / 255,\n          g: ((color & 0xff00) >> 8) / 255,\n          b: ((color & 0xff)) / 255\n        };\n      }\n      // jshint +W016\n      return color;\n    },\n\n    /**\n     * Normalize a coordinate object into {x: ..., y: ..., z: ... } form.\n     * Accepts 2-3d arrays,\n     * latlng objects\n     * latitude -> lat -> y\n     * longitude -> lon -> lng -> x\n     */\n    normalizeCoordinates: function (p) {\n      p = p || {};\n      if (Array.isArray(p)) {\n        return {\n          x: p[0],\n          y: p[1],\n          z: p[2] || 0\n        };\n      }\n      if (p instanceof geo.latlng) {\n        return {\n          x: p.lng(),\n          y: p.lat(),\n          z: 0\n        };\n      }\n      return {\n        x: setNumeric(\n          p.x,\n          p.longitude,\n          p.lng,\n          p.lon,\n          0\n        ),\n        y: setNumeric(\n          p.y,\n          p.latitude,\n          p.lat,\n          0\n        ),\n        z: setNumeric(\n          p.z,\n          p.elevation,\n          p.elev,\n          p.height,\n          0\n        )\n      };\n    }\n  };\n\n  geo.util.cssColors = {\n    aliceblue: 0xf0f8ff,\n    antiquewhite: 0xfaebd7,\n    aqua: 0x00ffff,\n    aquamarine: 0x7fffd4,\n    azure: 0xf0ffff,\n    beige: 0xf5f5dc,\n    bisque: 0xffe4c4,\n    black: 0x000000,\n    blanchedalmond: 0xffebcd,\n    blue: 0x0000ff,\n    blueviolet: 0x8a2be2,\n    brown: 0xa52a2a,\n    burlywood: 0xdeb887,\n    cadetblue: 0x5f9ea0,\n    chartreuse: 0x7fff00,\n    chocolate: 0xd2691e,\n    coral: 0xff7f50,\n    cornflowerblue: 0x6495ed,\n    cornsilk: 0xfff8dc,\n    crimson: 0xdc143c,\n    cyan: 0x00ffff,\n    darkblue: 0x00008b,\n    darkcyan: 0x008b8b,\n    darkgoldenrod: 0xb8860b,\n    darkgray: 0xa9a9a9,\n    darkgreen: 0x006400,\n    darkgrey: 0xa9a9a9,\n    darkkhaki: 0xbdb76b,\n    darkmagenta: 0x8b008b,\n    darkolivegreen: 0x556b2f,\n    darkorange: 0xff8c00,\n    darkorchid: 0x9932cc,\n    darkred: 0x8b0000,\n    darksalmon: 0xe9967a,\n    darkseagreen: 0x8fbc8f,\n    darkslateblue: 0x483d8b,\n    darkslategray: 0x2f4f4f,\n    darkslategrey: 0x2f4f4f,\n    darkturquoise: 0x00ced1,\n    darkviolet: 0x9400d3,\n    deeppink: 0xff1493,\n    deepskyblue: 0x00bfff,\n    dimgray: 0x696969,\n    dimgrey: 0x696969,\n    dodgerblue: 0x1e90ff,\n    firebrick: 0xb22222,\n    floralwhite: 0xfffaf0,\n    forestgreen: 0x228b22,\n    fuchsia: 0xff00ff,\n    gainsboro: 0xdcdcdc,\n    ghostwhite: 0xf8f8ff,\n    gold: 0xffd700,\n    goldenrod: 0xdaa520,\n    gray: 0x808080,\n    green: 0x008000,\n    greenyellow: 0xadff2f,\n    grey: 0x808080,\n    honeydew: 0xf0fff0,\n    hotpink: 0xff69b4,\n    indianred: 0xcd5c5c,\n    indigo: 0x4b0082,\n    ivory: 0xfffff0,\n    khaki: 0xf0e68c,\n    lavender: 0xe6e6fa,\n    lavenderblush: 0xfff0f5,\n    lawngreen: 0x7cfc00,\n    lemonchiffon: 0xfffacd,\n    lightblue: 0xadd8e6,\n    lightcoral: 0xf08080,\n    lightcyan: 0xe0ffff,\n    lightgoldenrodyellow: 0xfafad2,\n    lightgray: 0xd3d3d3,\n    lightgreen: 0x90ee90,\n    lightgrey: 0xd3d3d3,\n    lightpink: 0xffb6c1,\n    lightsalmon: 0xffa07a,\n    lightseagreen: 0x20b2aa,\n    lightskyblue: 0x87cefa,\n    lightslategray: 0x778899,\n    lightslategrey: 0x778899,\n    lightsteelblue: 0xb0c4de,\n    lightyellow: 0xffffe0,\n    lime: 0x00ff00,\n    limegreen: 0x32cd32,\n    linen: 0xfaf0e6,\n    magenta: 0xff00ff,\n    maroon: 0x800000,\n    mediumaquamarine: 0x66cdaa,\n    mediumblue: 0x0000cd,\n    mediumorchid: 0xba55d3,\n    mediumpurple: 0x9370db,\n    mediumseagreen: 0x3cb371,\n    mediumslateblue: 0x7b68ee,\n    mediumspringgreen: 0x00fa9a,\n    mediumturquoise: 0x48d1cc,\n    mediumvioletred: 0xc71585,\n    midnightblue: 0x191970,\n    mintcream: 0xf5fffa,\n    mistyrose: 0xffe4e1,\n    moccasin: 0xffe4b5,\n    navajowhite: 0xffdead,\n    navy: 0x000080,\n    oldlace: 0xfdf5e6,\n    olive: 0x808000,\n    olivedrab: 0x6b8e23,\n    orange: 0xffa500,\n    orangered: 0xff4500,\n    orchid: 0xda70d6,\n    palegoldenrod: 0xeee8aa,\n    palegreen: 0x98fb98,\n    paleturquoise: 0xafeeee,\n    palevioletred: 0xdb7093,\n    papayawhip: 0xffefd5,\n    peachpuff: 0xffdab9,\n    peru: 0xcd853f,\n    pink: 0xffc0cb,\n    plum: 0xdda0dd,\n    powderblue: 0xb0e0e6,\n    purple: 0x800080,\n    red: 0xff0000,\n    rosybrown: 0xbc8f8f,\n    royalblue: 0x4169e1,\n    saddlebrown: 0x8b4513,\n    salmon: 0xfa8072,\n    sandybrown: 0xf4a460,\n    seagreen: 0x2e8b57,\n    seashell: 0xfff5ee,\n    sienna: 0xa0522d,\n    silver: 0xc0c0c0,\n    skyblue: 0x87ceeb,\n    slateblue: 0x6a5acd,\n    slategray: 0x708090,\n    slategrey: 0x708090,\n    snow: 0xfffafa,\n    springgreen: 0x00ff7f,\n    steelblue: 0x4682b4,\n    tan: 0xd2b48c,\n    teal: 0x008080,\n    thistle: 0xd8bfd8,\n    tomato: 0xff6347,\n    turquoise: 0x40e0d0,\n    violet: 0xee82ee,\n    wheat: 0xf5deb3,\n    white: 0xffffff,\n    whitesmoke: 0xf5f5f5,\n    yellow: 0xffff00,\n    yellowgreen: 0x9acd32\n  };\n}());\n","//////////////////////////////////////////////////////////////////////////////\n/*\n * Includes several support classes adapted from wigglemaps.\n *\n * https://github.com/dotskapes/wigglemaps\n *\n * Copyright 2013 Preston and Krejci (dotSkapes Virtual Lab)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n//////////////////////////////////////////////////////////////////////////////\n\n/* jshint ignore: start */\n(function () {\n    'use strict';\n\n    var RangeNode = function (elem, start, end, current) {\n        this.data = elem[current];\n        this.left = null;\n        this.right = null;\n        if (start != current)\n            this.left = new RangeNode (elem, start, current - 1, parseInt ((start + (current - 1)) / 2, 10));\n        if (end != current)\n            this.right = new RangeNode (elem, current + 1, end, parseInt ((end + (current + 1)) / 2, 10));\n        this.subtree = [];\n        for (var i = start; i <= end; i ++) {\n            this.subtree.push (elem[i]);\n        }\n        this.subtree.sort (function (a, b) {\n            return a.y - b.y;\n        });\n\n        var xrange = function (b) {\n            return (b.x_in (elem[start]) && b.x_in (elem[end]));\n        };\n\n        this.yrange = function (b, start, end) {\n            return (b.y_in (this.subtree[start]) && b.y_in (this.subtree[end]));\n        };\n\n        this.subquery = function (result, box, start, end, current) {\n            if (this.yrange (box, start, end)) {\n                for (var i = start; i <= end; i ++) {\n                    result.push (this.subtree[i]);\n                }\n                return;\n            }\n            if (box.y_in (this.subtree[current]))\n                result.push (this.subtree[current]);\n            if (box.y_left (this.subtree[current])){\n                if (current != end)\n                    this.subquery (result, box, current + 1, end, parseInt ((end + (current + 1)) / 2, 10));\n            }\n            else if (box.x_right (this.subtree[current])) {\n                if (current != start)\n                    this.subquery (result, box, start, current - 1, parseInt ((start + (current - 1)) / 2, 10));\n            }\n            else {\n                if (current != end)\n                    this.subquery (result, box, current + 1, end, parseInt ((end + (current + 1)) / 2, 10));\n                if (current != start)\n                    this.subquery (result, box, start, current - 1, parseInt ((start + (current - 1)) / 2, 10));\n            }\n        };\n        \n        this.search = function (result, box) {\n            if (xrange (box)) {\n                this.subquery (result, box, 0, this.subtree.length - 1, parseInt ((this.subtree.length - 1) / 2, 10));\n                return;\n            }\n            else {\n                if (box.contains (this.data))\n                    result.push (this.data);\n                if (box.x_left (this.data)) {\n                    if (this.right)\n                        this.right.search (result, box);\n                }\n                else if (box.x_right (this.data)) {\n                    if (this.left)\n                        this.left.search (result, box);\n                }\n                else {\n                    if (this.left)\n                        this.left.search (result, box);\n                    if (this.right)\n                        this.right.search (result, box);\n                }\n            }\n        };\n    };\n\n    var RangeTree = function (elem) {\n        elem.sort (function (a, b) {\n            return a.x - b.x;\n        });\n        if (elem.length > 0)\n            this.root = new RangeNode (elem, 0, elem.length - 1, parseInt ((elem.length - 1) / 2, 10));\n        else\n            this.root = null;\n\n        this.search = function (_box) {\n            if (!this.root)\n                return [];\n            //var box = new Box (min, max);\n            var box = _box.clone ();\n            var result = [];\n            this.root.search (result, box);\n            return result;\n        };\n    };\n\n    var Box = function (v1, v2) {\n        this.min = v1.clone ();\n        this.max = v2.clone ();\n        this.contains = function (p) {\n            return (v1.x <= p.x) && (v2.x >= p.x) && (v1.y <= p.y) && (v2.y >= p.y);\n        };\n\n        this.x_in = function (p) {\n            return (v1.x <= p.x) && (v2.x >= p.x);\n        };\n\n        this.x_left = function (p) {\n            return (v1.x >= p.x);\n        };\n\n        this.x_right = function (p) {\n            return (v2.x <= p.x);\n        };\n\n        this.y_in = function (p) {\n            return (v1.y <= p.y) && (v2.y >= p.y);\n        };\n\n        this.y_left = function (p) {\n            return (v1.y >= p.y);\n        };\n\n        this.y_right = function (p) {\n            return (v2.y <= p.y);\n        };\n\n        this.area = function () {\n            return (this.max.x - this.min.x) * (this.max.y - this.min.y);\n        };\n\n        this.height = function () {\n            return this.max.y - this.min.y;\n        };\n\n        this.width = function () {\n            return this.max.x - this.min.x;\n        };\n        \n        this.vertex = function (index) {\n            switch (index) {\n            case 0:\n                return this.min.clone ();\n            case 1:\n                return new vect (this.max.x, this.min.y);\n            case 2:\n                return this.max.clone ();\n            case 3:\n                return new vect (this.min.x, this.max.y);\n            default:\n                throw \"Index out of bounds: \" + index ;\n            }\n        };\n\n        this.intersects = function (box) {\n            for (var i = 0; i < 4; i ++) {\n                for (var j = 0; j < 4; j ++) {\n                    if (vect.intersects (this.vertex (i), this.vertex ((i + 1) % 4),\n                                         box.vertex (j), box.vertex ((j + 1) % 4)))\n                        return true;\n                }\n            }\n            if (this.contains (box.min) &&\n                this.contains (box.max) &&\n                this.contains (new vect (box.min.x, box.max.y)) &&\n                this.contains (new vect (box.max.x, box.min.y)))\n                return true;\n            if (box.contains (this.min) &&\n                box.contains (this.max) &&\n                box.contains (new vect (this.min.x, this.max.y)) &&\n                box.contains (new vect (this.max.x, this.min.y)))\n                return true;\n            return false;\n        };\n\n        this.union = function (b) {\n            this.min.x = Math.min (this.min.x, b.min.x);\n            this.min.y = Math.min (this.min.y, b.min.y);\n\n            this.max.x = Math.max (this.max.x, b.max.x);\n            this.max.y = Math.max (this.max.y, b.max.y);\n        };\n\n        this.centroid = function () {\n            return new vect ((this.max.x + this.min.x) / 2, (this.max.y + this.min.y) / 2);\n        };\n\n        this.clone = function () {\n            return new Box (v1, v2);\n        };\n    };\n\n    // A basic vector type. Supports standard 2D vector operations\n    var Vector2D = function (x, y) {\n        this.x = x;\n        this.y = y;\n\n        this.add = function (v) {\n            this.x += v.x;\n            this.y += v.y;\n            return this;\n        };\n        this.sub = function (v) {\n            this.x -= v.x;\n            this.y -= v.y;\n            return this;\n        };\n        this.scale = function (s) {\n            this.x *= s;\n            this.y *= s;\n            return this;\n        };\n        this.length = function () {\n            return Math.sqrt (this.x * this.x + this.y * this.y);\n        };\n        this.normalize = function () {\n            var scale = this.length ();\n            if (scale === 0)\n                return this;\n            this.x /= scale;\n            this.y /= scale;\n            return this;\n        };\n        this.div = function (v) {\n            this.x /= v.x;\n            this.y /= v.y;\n            return this;\n        };\n        this.floor = function () {\n            this.x = Math.floor (this.x);\n            this.y = Math.floor (this.y);\n            return this;\n        };\n        this.zero = function (tol) {\n            tol = tol || 0;\n            return (this.length() <= tol);\n        };\n        this.dot = function (v) {\n            return (this.x * v.x) + (this.y * v.y);\n        };\n        this.cross = function (v) {\n            return (this.x * v.y) - (this.y * v.x);\n        };\n        this.rotate = function (omega) {\n            var cos = Math.cos (omega);\n            var sin = Math.sin (omega);\n            xp = cos * this.x - sin * this.y;\n            yp = sin * this.x + cos * this.y;\n            this.x = xp;\n            this.y = yp;\n            return this;\n        };\n        this.clone = function () {\n            return new Vector2D (this.x, this.y); \n        };\n\n        this.array = function () {\n            return [this.x, this.y];\n        };\n    };\n\n    // A shortcut for the vector constructor\n    function vect (x, y) {\n        return new Vector2D (x, y);\n    }\n\n    // Shorthand operations for vectors for operations that make new vectors\n\n    vect.scale = function (v, s) {\n        return v.clone ().scale (s);\n    };\n\n    vect.add = function (v1, v2) {\n        return v1.clone ().add (v2);\n    };\n\n    vect.sub = function (v1, v2) {\n        return v1.clone ().sub (v2);\n    };\n\n    vect.dist = function (v1, v2) {\n        return v1.clone ().sub (v2).length ();\n    };\n\n    vect.dir = function (v1, v2) {\n        return v1.clone ().sub (v2).normalize ();\n    };\n\n    vect.dot = function (v1, v2) {\n        return (v1.x * v2.x) + (v1.y * v2.y);\n    };\n\n    vect.cross = function (v1, v2) {\n        return (v1.x * v2.y) - (v1.y * v2.x);\n    };\n\n    vect.left = function (a, b, c, tol) {\n        if (!tol)\n            tol = 0;\n        var v1 = vect.sub (b, a);\n        var v2 = vect.sub (c, a);\n        return (vect.cross (v1, v2) >= -tol);\n    };\n\n    vect.intersects = function (a, b, c, d, tol) {\n        if (!tol)\n            tol = 0;\n        return (vect.left (a, b, c, tol) != vect.left (a, b, d, tol) &&\n                vect.left (c, d, b, tol) != vect.left (c, d, a, tol));\n    };\n\n    vect.intersect2dt = function (a, b, c, d) {\n        var denom = a.x * (d.y - c.y) +\n            b.x * (c.y - d.y) +\n            d.x * (b.y - a.y) +\n            c.x * (a.y - b.y);\n\n        if (denom === 0)\n            return Infinity;\n        \n        var num_s = a.x * (d.y - c.y) +\n            c.x * (a.y - d.y) +\n            d.x * (c.y - a.y);\n        var s = num_s / denom;\n\n        var num_t = -(a.x * (c.y - b.y) +\n                      b.x * (a.y - c.y) +\n                      c.x * (b.y - a.y));\n        var t = num_t / denom;\n        \n        return t;\n    };\n\n    vect.intersect2dpos = function (a, b, c, d) {\n        var denom = a.x * (d.y - c.y) +\n            b.x * (c.y - d.y) +\n            d.x * (b.y - a.y) +\n            c.x * (a.y - b.y);\n\n        if (denom === 0)\n            return Infinity;\n        \n        var num_s = a.x * (d.y - c.y) +\n            c.x * (a.y - d.y) +\n            d.x * (c.y - a.y);\n        var s = num_s / denom;\n\n        /*var num_t = -(a.x * (c.y - b.y) +\n                      b.x * (a.y - c.y) +\n                      c.x * (b.y - a.y));\n        var t = num_t / denom;*/\n        \n        var dir = vect.sub (b, a);\n        dir.scale (s);\n        return vect.add (a, dir);\n    };\n\n    vect.rotate = function (v, omega) {\n        var cos = Math.cos (omega);\n        var sin = Math.sin (omega);\n        xp = cos * v.x - sin * v.y;\n        yp = sin * v.x + cos * v.y;\n        var c = new vect (xp, yp);\n        return c;\n    };\n\n    vect.normalize = function (v) {\n        return v.clone ().normalize ();\n    };\n\n    // Export to geo.util module\n    geo.util.RangeTree = RangeTree;\n    geo.util.Box = Box;\n    geo.util.vect = vect;\n}());\n/* jshint ignore: end */\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class object\n *\n * @class\n * @extends vgl.object\n * @returns {geo.object}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.object = function () {\n  \"use strict\";\n  if (!(this instanceof geo.object)) {\n    return new geo.object();\n  }\n\n  var m_this = this,\n      m_eventHandlers = {},\n      m_idleHandlers = [],\n      m_deferredCount = 0;\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Bind a handler that will be called once when all deferreds are resolved.\n   *\n   *  @param {function} handler A function taking no arguments\n   *  @returns {geo.object[]|geo.object} this\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.onIdle = function (handler) {\n    if (m_deferredCount) {\n      m_idleHandlers.push(handler);\n    } else {\n      handler();\n    }\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Add a new deferred object preventing idle event handlers from being called.\n   *\n   *  @param {$.defer} defer A jquery defered object\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.addDeferred = function (defer) {\n    m_deferredCount += 1;\n    defer.done(function () {\n      m_deferredCount -= 1;\n      if (!m_deferredCount) {\n        m_idleHandlers.splice(0, m_idleHandlers.length)\n          .forEach(function (handler) {\n            handler();\n          });\n      }\n    });\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Bind an event handler to this object\n   *\n   *  @param {String} event\n   *    An event from {geo.events}\n   *  @param {function} handler\n   *    A function that will be called when ``event`` is triggered.  The\n   *    function will be given an event object as a first parameter and\n   *    optionally a second argument provided by the triggerer.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.geoOn = function (event, handler) {\n    if (Array.isArray(event)) {\n      event.forEach(function (e) {\n        m_this.geoOn(e, handler);\n      });\n      return m_this;\n    }\n    if (!m_eventHandlers.hasOwnProperty(event)) {\n      m_eventHandlers[event] = [];\n    }\n    m_eventHandlers[event].push(handler);\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Trigger an event (or events) on this object and call all handlers\n   *\n   *  @param {String} event An event from {geo.events}\n   *  @param {Object} args An optional argument to pass to handlers\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.geoTrigger = function (event, args) {\n\n    // if we have an array of events, recall with single events\n    if (Array.isArray(event)) {\n      event.forEach(function (e) {\n        m_this.geoTrigger(e, args);\n      });\n      return m_this;\n    }\n\n    if (m_eventHandlers.hasOwnProperty(event)) {\n      m_eventHandlers[event].forEach(function (handler) {\n        handler.call(m_this, args);\n      });\n    }\n\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Remove handlers from an event (or an array of events).  If no event is\n   *  provided all hanlders will be removed.\n   *\n   *  @param {string?} event An event from {geo.events}\n   *  @param {object?} arg A function or array of functions to remove from the events\n   *                      or if falsey remove all handlers from the events\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.geoOff = function (event, arg) {\n    if (event === undefined) {\n      m_eventHandlers = {};\n      m_idleHandlers = [];\n      m_deferredCount = 0;\n    }\n    if (Array.isArray(event)) {\n      event.forEach(function (e) {\n        m_this.geoOff(e, arg);\n      });\n      return m_this;\n    }\n    if (!arg) {\n      m_eventHandlers[event] = [];\n    } else if (Array.isArray(arg)) {\n      arg.forEach(function (handler) {\n        m_this.geoOff(event, handler);\n      });\n      return m_this;\n    }\n    // What do we do if the handler is not already bound?\n    //   ignoring for now...\n    if (m_eventHandlers.hasOwnProperty(event)) {\n      m_eventHandlers[event] = m_eventHandlers[event].filter(function (f) {\n          return f !== arg;\n        }\n      );\n    }\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Free all resources and destroy the object.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.geoOff();\n  };\n\n  vgl.object.call(this);\n\n  return this;\n};\n\ninherit(geo.object, vgl.object);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class sceneObject, which extends the object's\n * event handling with a tree-based event propagation.\n *\n * @class\n * @extends geo.object\n * @returns {geo.sceneObject}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.sceneObject = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.sceneObject)) {\n    return new geo.sceneObject();\n  }\n  geo.object.call(this, arg);\n\n  var m_this = this,\n      m_parent = null,\n      m_children = [],\n      s_exit = this._exit,\n      s_trigger = this.geoTrigger,\n      s_addDeferred = this.addDeferred,\n      s_onIdle = this.onIdle;\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Override object.addDeferred to propagate up the scene tree.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.addDeferred = function (defer) {\n    if (m_parent) {\n      m_parent.addDeferred(defer);\n    } else {\n      s_addDeferred(defer);\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Override object.onIdle to propagate up the scene tree.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.onIdle = function (handler) {\n    if (m_parent) {\n      m_parent.onIdle(handler);\n    } else {\n      s_onIdle(handler);\n    }\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Get/set parent of the object\n   *  @param {?geo.sceneObject} parent\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.parent = function (arg) {\n    if (arg === undefined) {\n      return m_parent;\n    }\n    m_parent = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Add a child (or an array of children) to the object\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.addChild = function (child) {\n    if (Array.isArray(child)) {\n      child.forEach(m_this.addChild);\n      return m_this;\n    }\n    child.parent(m_this);\n    m_children.push(child);\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Remove a child (or array of children) from the object\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.removeChild = function (child) {\n    if (Array.isArray(child)) {\n      child.forEach(m_this.removeChild);\n      return m_this;\n    }\n    m_children = m_children.filter(function (c) { return c !== child; });\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Get an array of child objects\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.children = function () {\n    return m_children.slice();\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Force redraw of a scene object, to be implemented by subclasses.\n   *  Base class just calls draw of child objects.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.draw = function (arg) {\n    m_this.children().forEach(function (child) {\n      child.draw(arg);\n    });\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   *  Trigger an event (or events) on this object and call all handlers.\n   *  @param {String} event the event to trigger\n   *  @param {Object} args arbitrary argument to pass to the handler\n   *  @param {Boolean} childrenOnly if true, only propagate down the tree\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.geoTrigger = function (event, args, childrenOnly) {\n\n    var geoArgs;\n\n    args = args || {};\n    geoArgs = args.geo || {};\n    args.geo = geoArgs;\n\n    // stop propagation if requested by the handler\n    if (geoArgs.stopPropagation) {\n      return m_this;\n    }\n\n    // If the event was not triggered by the parent, just propagate up the tree\n    if (!childrenOnly && m_parent && geoArgs._triggeredBy !== m_parent) {\n      geoArgs._triggeredBy = m_this;\n      m_parent.geoTrigger(event, args);\n      return m_this;\n    }\n\n    // call the object's own handlers\n    s_trigger.call(m_this, event, args);\n\n    // stop propagation if requested by the handler\n    if (geoArgs.stopPropagation) {\n      return m_this;\n    }\n\n    // trigger the event on the children\n    m_children.forEach(function (child) {\n      geoArgs._triggeredBy = m_this;\n      child.geoTrigger(event, args);\n    });\n\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Free all resources and destroy the object.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.children = [];\n    delete m_this.parent;\n    s_exit();\n  };\n\n  return this;\n};\n\ninherit(geo.sceneObject, geo.object);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class timestamp\n *\n * @class\n * @extends vgl.timestamp\n * @returns {geo.timestamp}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.timestamp = function () {\n  'use strict';\n  if (!(this instanceof geo.timestamp)) {\n    return new geo.timestamp();\n  }\n  vgl.timestamp.call(this);\n};\n\ninherit(geo.timestamp, vgl.timestamp);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create an instance of quadratic surface generator\n * in Cartesian coordinates by the equation\n * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>. Used\n * primarily to create planetary bodies\n *\n * @class\n * @param {Number} [x=0]  Radius in X direction\n * @param {Number} [y=0]  Radius in Y direction\n * @param {Number} [z=0]  Radius in Z direction\n *\n * @returns {geo.ellipsoid}\n */\n //////////////////////////////////////////////////////////////////////////////\ngeo.ellipsoid = function (x, y, z) {\n  'use strict';\n  if (!(this instanceof geo.ellipsoid)) {\n    return new geo.ellipsoid(x, y, z);\n  }\n\n  x = vgl.defaultValue(x, 0.0);\n  y = vgl.defaultValue(y, 0.0);\n  z = vgl.defaultValue(z, 0.0);\n\n  if (x < 0.0 || y < 0.0 || z < 0.0) {\n    return console.log('[error] Al radii components must be greater than zero');\n  }\n\n  var m_this = this,\n      m_radii = new vec3.fromValues(x, y, z),\n      m_radiiSquared = new vec3.fromValues(\n        x * x, y * y, z * z),\n      m_minimumRadius = Math.min(x, y, z),\n      m_maximumRadius = Math.max(x, y, z);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return radii of ellipsoid\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.radii = function () {\n    return m_radii;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return squared radii of the ellipsoid\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.radiiSquared = function () {\n    return m_radiiSquared;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return maximum radius of the ellipsoid\n   *\n   * @return {Number} The maximum radius of the ellipsoid\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.maximumRadius = function () {\n    return m_maximumRadius;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return minimum radius of the ellipsoid\n   *\n   * @return {Number} The maximum radius of the ellipsoid\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.minimumRadius = function () {\n    return m_minimumRadius;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Computes the normal of the plane tangent to the surface of\n   * the ellipsoid at the provided position\n   *\n   * @param {Number} lat The cartographic latitude for which\n   *  to to determine the geodetic normal\n   * @param {Number} lon The cartographic longitude for which\n   *  to to determine the geodetic normal\n   *\n   * @return {vec3}\n   *\n   * @exception {DeveloperError} cartographic is required.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.computeGeodeticSurfaceNormal = function (lat, lon) {\n    if (typeof lat === 'undefined' || typeof lon === 'undefined') {\n      throw '[error] Valid latitude and longitude is required';\n    }\n\n    var cosLatitude = Math.cos(lat),\n        result = vec3.create();\n\n    result[0] = cosLatitude * Math.cos(lon);\n    result[1] = cosLatitude * Math.sin(lon);\n    result[2] = Math.sin(lat);\n\n    vec3.normalize(result, result);\n    return result;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Converts the provided geographic latitude, longitude,\n   * and height to WGS84 coordinate system\n   *\n   * @param {Number} lat Latitude in radians\n   * @param {Number} lon Longitude in radians\n   * @param {Number} elev Elevation\n   * @return {vec3} Position in the WGS84 coordinate system\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.transformPoint = function (lat, lon, elev) {\n    lat = lat *  (Math.PI / 180.0);\n    lon = lon * (Math.PI / 180.0);\n\n    var n = m_this.computeGeodeticSurfaceNormal(lat, lon),\n        k = vec3.create(),\n        gamma  = Math.sqrt(vec3.dot(n, k)),\n        result = vec3.create();\n\n    vec3.multiply(k, m_radiiSquared, n);\n    vec3.scale(k, k, 1 / gamma);\n    vec3.scale(n, n, elev);\n    vec3.add(result, n, k);\n    return result;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Converts the provided geographic latitude, longitude,\n   * and height to WGS84 coordinate system\n   *\n   * @param {vgl.geometryData} geom\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.transformGeometry = function (geom) {\n    if (!geom) {\n      throw '[error] Failed to transform to cartesian. Invalid geometry.';\n    }\n\n    var sourceData = geom.sourceData(vgl.vertexAttributeKeys.Position),\n        sourceDataArray = sourceData.data(),\n        noOfComponents =  sourceData.attributeNumberOfComponents(\n          vgl.vertexAttributeKeys.Position),\n        stride = sourceData.attributeStride(\n          vgl.vertexAttributeKeys.Position),\n        offset = sourceData.attributeOffset(\n          vgl.vertexAttributeKeys.Position),\n        sizeOfDataType = sourceData.sizeOfAttributeDataType(\n          vgl.vertexAttributeKeys.Position),\n        index = null,\n        count = sourceDataArray.length * (1.0 / noOfComponents),\n        gamma = null,\n        n = null,\n        j = 0,\n        k = vec3.create(),\n        result = vec3.create();\n\n    stride /= sizeOfDataType;\n    offset /= sizeOfDataType;\n\n    if (noOfComponents !== 3) {\n      throw ('[error] Requires positions with three components');\n    }\n\n    for (j = 0; j < count; j += 1) {\n      index = j * stride + offset;\n\n      sourceDataArray[index] = sourceDataArray[index] * (Math.PI / 180.0);\n      sourceDataArray[index + 1] = sourceDataArray[index + 1] * (Math.PI / 180.0);\n\n      n = m_this.computeGeodeticSurfaceNormal(sourceDataArray[index + 1],\n                                            sourceDataArray[index]);\n      vec3.multiply(k, m_radiiSquared, n);\n      gamma = Math.sqrt(vec3.dot(n, k));\n      vec3.scale(k, k, 1 / gamma);\n      vec3.scale(n, n, sourceDataArray[index + 2]);\n      vec3.add(result, n, k);\n\n      sourceDataArray[index] = result[0];\n      sourceDataArray[index + 1] = result[1];\n      sourceDataArray[index + 2] = result[2];\n    }\n  };\n\n  return m_this;\n};\n\n////////////////////////////////////////////////////////////////////////////\n/**\n * An Ellipsoid instance initialized to the WGS84 standard.\n * @memberof ellipsoid\n *\n */\n////////////////////////////////////////////////////////////////////////////\ngeo.ellipsoid.WGS84 = vgl.freezeObject(\n  geo.ellipsoid(6378137.0, 6378137.0, 6356752.3142451793));\n\n////////////////////////////////////////////////////////////////////////////\n/**\n * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).\n * @memberof ellipsoid\n */\n////////////////////////////////////////////////////////////////////////////\ngeo.ellipsoid.UNIT_SPHERE = vgl.freezeObject(\n  geo.ellipsoid(1.0, 1.0, 1.0));\n","/** @namespace */\ngeo.mercator = {\n  r_major: 6378137.0  //Equatorial Radius, WGS84\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Returns the polar radius based on the projection.\n *\n * @param {Boolean} sperical\n * @returns {Number}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.r_minor = function (spherical) {\n  'use strict';\n\n  var r_minor;\n\n  spherical = spherical !== undefined ? spherical : false;\n\n  if (spherical) {\n    r_minor = 6378137.0;\n  } else {\n    r_minor = 6356752.314245179;\n  }\n\n  return r_minor;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * 1/f=(a-b)/a , a=r_major, b=r_minor\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.f = function (spherical) {\n  'use strict';\n\n  return (geo.mercator.r_major - geo.mercator.r_minor(spherical)) / geo.mercator.r_major;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert longitude (Degree) to Tile X\n *\n *  @param {float} lon\n *  @param {integer} z\n *  @returns {integer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.long2tilex = function (lon, z) {\n  'use strict';\n  var rad = (lon + 180.0) / 360.0,\n      f = Math.floor(rad * Math.pow(2.0, z));\n  return f;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert latitude (Degree) to Tile Y\n *\n *  @param {float} lat\n *  @param {integer} z\n *  @returns {integer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.lat2tiley = function (lat, z) {\n  'use strict';\n  var rad = lat * Math.PI / 180.0;\n  return Math.floor((1.0 - rad / Math.PI) / 2.0 * Math.pow(2.0, z));\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert Longitute (Degree) to Tile X and fraction.\n *\n *  @param {float} lon\n *  @param {integer} z\n *  @returns {number[]}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.long2tilex2 = function (lon, z) {\n  'use strict';\n  var rad = (lon + 180.0) / 360.0,\n      f = rad * Math.pow(2.0, z),\n      ret = Math.floor(f),\n      frac = f - ret;\n  return [ret, frac];\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert Latitude (Degree) to Tile Y and fraction\n *\n *  @param {float} lat\n *  @param {integer} z\n *  @returns {number[]}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.lat2tiley2 = function (lat, z) {\n  'use strict';\n  var rad = lat * Math.PI / 180.0,\n      f = (1.0 - Math.log(Math.tan(rad) + 1.0 / Math.cos(rad)) /\n           Math.PI) / 2.0 * Math.pow(2.0, z),\n      ret = Math.floor(f),\n      frac = f - ret;\n  return [ret, frac];\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert Tile X to Longitute (Degree)\n *\n *  @param {integer} x\n *  @param {integer} z\n *  @returns {float}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.tilex2long = function (x, z) {\n  'use strict';\n  return x / Math.pow(2.0, z) * 360.0 - 180.0;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert Tile Y to Latitute (Degree)\n *\n *  @param {integer} y\n *  @param {integer} z\n *  @returns {float}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.tiley2lat = function (y, z) {\n  'use strict';\n  var n = Math.PI - 2.0 * Math.PI * y / Math.pow(2.0, z);\n  return 180.0 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert spherical mercator Y to latitude\n *\n *  @param {float} a\n *  @returns {float}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.y2lat = function (a) {\n  'use strict';\n  return 180 / Math.PI * (2 * Math.atan(Math.exp(a * Math.PI / 180)) - Math.PI / 2);\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert latitude into Y position in spherical mercator\n *\n *  @param {float} a\n *  @returns {float}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.lat2y = function (a) {\n  'use strict';\n  return 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + a * (Math.PI / 180) / 2));\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n *\n * @param {float} d\n * @returns {number}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.deg2rad = function (d) {\n  'use strict';\n  var r = d * (Math.PI / 180.0);\n  return r;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert radian to degree\n *\n * @param {float} r\n * @returns {number}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.rad2deg = function (r) {\n  'use strict';\n  var d = r / (Math.PI / 180.0);\n  return d;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert latlon to mercator\n *\n * @param {float} lon\n * @param {float} lat\n * @returns {object}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.ll2m = function (lon, lat, spherical) {\n  'use strict';\n\n  if (lat > 89.5) {\n    lat = 89.5;\n  }\n\n  if (lat < -89.5) {\n    lat = -89.5;\n  }\n\n  var x = this.r_major * this.deg2rad(lon),\n      temp = this.r_minor(spherical) / this.r_major,\n      es = 1.0 - (temp * temp),\n      eccent = Math.sqrt(es),\n      phi = this.deg2rad(lat),\n      sinphi = Math.sin(phi),\n      con = eccent * sinphi,\n      com = 0.5 * eccent,\n      con2 = Math.pow((1.0 - con) / (1.0 + con), com),\n      ts = Math.tan(0.5 * (Math.PI * 0.5 - phi)) / con2,\n      y = -this.r_major * Math.log(ts),\n      ret = {'x': x, 'y': y};\n\n  return ret;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Convert mercator to lat lon\n *\n * @param {float} x\n * @param {float} y\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.m2ll = function (x, y, spherical) {\n  'use strict';\n  var lon = this.rad2deg((x / this.r_major)),\n      temp = this.r_minor(spherical) / this.r_major,\n      e = Math.sqrt(1.0 - (temp * temp)),\n      lat = this.rad2deg(this.pjPhi2(Math.exp(-(y / this.r_major)), e)),\n      ret = {'lon': lon, 'lat': lat};\n\n  return ret;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * pjPhi2\n *\n * @param {float} ts\n * @param {float} e\n * @returns {number}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mercator.pjPhi2 = function (ts, e) {\n  'use strict';\n  var N_ITER = 15,\n      HALFPI = Math.PI / 2,\n      TOL = 0.0000000001,\n      con, dphi,\n      i = N_ITER,\n      eccnth = 0.5 * e,\n      Phi = HALFPI - 2.0 * Math.atan(ts);\n\n  do {\n    con = e * Math.sin(Phi);\n    dphi = HALFPI - 2.0 * Math.atan(ts * Math.pow(\n            (1.0 - con) / (1.0 + con), eccnth)) - Phi;\n    Phi += dphi;\n    i -= 1;\n  } while (Math.abs(dphi) > TOL && i);\n  return Phi;\n};\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of latlng\n *\n * A latlng encapsulates geodesy coordinates defined by latitude and\n * longitude (depreciated)\n *\n * @class\n * @returns {geo.latlng}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.latlng = function (arg1, arg2, arg3) {\n  \"use strict\";\n  if (!(this instanceof geo.latlng)) {\n    return new geo.latlng(arg1, arg2, arg3);\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      m_lat = arg2 === undefined && arg3 === undefined ? arg1.lat() : arg1,\n      m_lng = arg2 === undefined && arg3 === undefined ? arg1.lng() : arg2,\n      m_elv = arg2 === undefined && arg3 === undefined ? arg1.elv() : arg3;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return latitude\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.lat = function (val) {\n    if (val === undefined) {\n      return m_lat;\n    } else {\n      m_lat = val;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return longitude\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.lng = function (val) {\n    if (val === undefined) {\n      return m_lng;\n    } else {\n      m_lng = val;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return elevation\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.elv = function (val) {\n    if (val === undefined) {\n      return m_elv;\n    } else {\n      m_elv = val;\n    }\n  };\n\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return x coordinate\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.x = function (val) {\n    if (val === undefined) {\n      return m_this.lng();\n    } else {\n      m_lng = val;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return y coordinate\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.y = function (val) {\n    if (val === undefined) {\n      return m_this.lat();\n    } else {\n      m_lat = val;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return z coordinate\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.z = function (val) {\n    if (val === undefined) {\n      return m_this.elv();\n    } else {\n      m_elv = val;\n    }\n  };\n\n\n  return this;\n};\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * @class\n * @extends geo.sceneObject\n * @returns {geo.layer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.layer = function (arg) {\n  \"use strict\";\n\n  if (!(this instanceof geo.layer)) {\n    return new geo.layer(arg);\n  }\n  arg = arg || {};\n  geo.sceneObject.call(this, arg);\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_exit = this._exit,\n      m_style = arg.style === undefined ? {\"opacity\": 0.5,\n                                           \"color\": [0.8, 0.8, 0.8],\n                                           \"visible\": true,\n                                           \"bin\": 100} : arg.style,\n      m_id = arg.id === undefined ? geo.layer.newLayerId() : arg.id,\n      m_name = \"\",\n      m_gcs = \"EPSG:4326\",\n      m_timeRange = null,\n      m_source = arg.source || null,\n      m_map = arg.map === undefined ? null : arg.map,\n      m_isReference = false,\n      m_x = 0,\n      m_y = 0,\n      m_width = 0,\n      m_height = 0,\n      m_node = null,\n      m_canvas = null,\n      m_renderer = null,\n      m_initialized = false,\n      m_rendererName = arg.renderer  === undefined ? \"vgl\" : arg.renderer,\n      m_dataTime = geo.timestamp(),\n      m_updateTime = geo.timestamp(),\n      m_drawTime = geo.timestamp(),\n      m_sticky = arg.sticky === undefined ? true : arg.sticky,\n      m_active = arg.active === undefined ? true : arg.active;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get whether or not the layer is sticky (navigates with the map).\n   *\n   * @returns {Boolean}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.sticky = function () {\n    return m_sticky;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get whether or not the layer is active.  An active layer will receive\n   * native mouse when the layer is on top.  Non-active layers will never\n   * receive native mouse events.\n   *\n   * @returns {Boolean}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.active = function () {\n    return m_active;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set root node of the layer\n   *\n   * @returns {div}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.node = function () {\n    return m_node;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set id of the layer\n   *\n   * @returns {String}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.id = function (val) {\n    if (val === undefined) {\n      return m_id;\n    }\n    m_id = geo.newLayerId();\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set name of the layer\n   *\n   * @returns {String}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.name = function (val) {\n    if (val === undefined) {\n      return m_name;\n    }\n    m_name = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set opacity of the layer\n   *\n   * @returns {Number}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.opacity = function (val) {\n    if (val === undefined) {\n      return m_style.opacity;\n    }\n    m_style.opacity = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set visibility of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.visible = function (val) {\n    if (val === undefined) {\n      return m_style.visible;\n    }\n    m_style.visible = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set bin of the layer\n   *\n   * @returns {Number}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.bin = function (val) {\n    if (val === undefined) {\n      return m_style.bin;\n    }\n    m_style.bin = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set projection of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.gcs = function (val) {\n    if (val === undefined) {\n      return m_gcs;\n    }\n    m_gcs = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Transform layer to the reference layer gcs\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.transform = function (val) {\n    geo.transform.transformLayer(val, m_this, m_map.baseLayer());\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set time range of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.timeRange = function (val) {\n    if (val === undefined) {\n      return m_timeRange;\n    }\n    m_timeRange = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set source of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.source = function (val) {\n    if (val === undefined) {\n      return m_source;\n    }\n    m_source = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set map of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.map = function (val) {\n    if (val === undefined) {\n      return m_map;\n    }\n    m_map = val;\n    m_map.node().append(m_node);\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get renderer for the layer if any\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.renderer = function () {\n    return m_renderer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get canvas of the layer\n   *\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.canvas = function () {\n    return m_canvas;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get viewport of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.viewport = function () {\n    return [m_x, m_y, m_width, m_height];\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return last time data got changed\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.dataTime = function () {\n    return m_dataTime;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the modified time for the last update that did something\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.updateTime = function () {\n    return m_updateTime;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the modified time for the last draw call that did something\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.drawTime = function () {\n    return m_drawTime;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Run query and return results for it\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.query = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set layer as the reference layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.referenceLayer = function (val) {\n    if (val !== undefined) {\n      m_isReference = val;\n      m_this.modified();\n      return m_this;\n    }\n    return m_isReference;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set if the layer has been initialized\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.initialized = function (val) {\n    if (val !== undefined) {\n      m_initialized = val;\n      return m_this;\n    }\n    return m_initialized;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Transform a point or array of points in GCS space to\n   * local space of the layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.toLocal = function (input) {\n    return input;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Transform a point or array of points in local space to\n   * latitude-longitude space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.fromLocal = function (input) {\n    return input;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Init layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    if (m_initialized) {\n      return m_this;\n    }\n\n    // Create top level div for the layer\n    m_node = $(document.createElement(\"div\"));\n    m_node.attr(\"id\", m_name);\n    // TODO: need to position according to offsets from the map element\n    //       and maybe respond to events in case the map element moves\n    //       around the page.\n    m_node.css(\"position\", \"absolute\");\n\n    if (m_map) {\n      m_map.node().append(m_node);\n\n    }\n\n    // Share context if have valid one\n    if (m_canvas) {\n      m_renderer = geo.createRenderer(m_rendererName, m_this, m_canvas);\n    } else {\n      m_renderer = geo.createRenderer(m_rendererName, m_this);\n      m_canvas = m_renderer.canvas();\n    }\n\n    if (!m_this.active()) {\n      m_node.css(\"pointerEvents\", \"none\");\n    }\n\n    m_initialized = true;\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Clean up resouces\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_renderer._exit();\n    m_node.off();\n    m_node.remove();\n    m_node = null;\n    arg = {};\n    m_canvas = null;\n    m_renderer = null;\n    s_exit();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Respond to resize event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._resize = function (x, y, w, h) {\n    m_x = x;\n    m_y = y;\n    m_width = w;\n    m_height = h;\n    m_node.width(w);\n    m_node.height(h);\n\n    m_this.modified();\n    m_this.geoTrigger(geo.event.resize,\n      {x: x, y: y, width: m_width, height: m_height});\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the width of the layer in pixels\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.width = function () {\n    return m_width;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the height of the layer in pixels\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.height = function () {\n    return m_height;\n  };\n\n  return this;\n};\n\n/**\n * Gets a new id number for a layer.\n * @protected\n * @instance\n * @returns {number}\n */\ngeo.layer.newLayerId = (function () {\n    \"use strict\";\n    var currentId = 1;\n    return function () {\n      var id = currentId;\n      currentId += 1;\n      return id;\n    };\n  }()\n);\n\n/**\n * General object specification for feature types.\n * @typedef geo.layer.spec\n * @type {object}\n * @property {string} [type=\"feature\"] For feature compatibility\n * with more than one kind of creatable layer\n * @property {object[]} [data=[]] The default data array to\n * apply to each feature if none exists\n * @property {string} [renderer=\"vgl\"] The renderer to use\n * @property {geo.feature.spec[]} [features=[]] Features\n * to add to the layer\n */\n\n/**\n * Create a layer from an object.  Any errors in the creation\n * of the layer will result in returning null.\n * @param {geo.map} map The map to add the layer to\n * @param {geo.layer.spec} spec The object specification\n * @returns {geo.layer|null}\n */\ngeo.layer.create = function (map, spec) {\n  \"use strict\";\n\n  spec = spec || {};\n\n  // add osmLayer later\n  spec.type = \"feature\";\n  if (spec.type !== \"feature\") {\n    console.warn(\"Unsupported layer type\");\n    return null;\n  }\n\n  spec.renderer = spec.renderer || \"vgl\";\n  if (spec.renderer !== \"d3\" && spec.renderer !== \"vgl\") {\n    console.warn(\"Invalid renderer\");\n    return null;\n  }\n\n  var layer = map.createLayer(spec.type, spec);\n  if (!layer) {\n    console.warn(\"Unable to create a layer\");\n    return null;\n  }\n\n  // probably move this down to featureLayer eventually\n  spec.features.forEach(function (f) {\n    f.data = f.data || spec.data;\n    f.feature = geo.feature.create(layer, f);\n  });\n\n  return layer;\n};\n\ninherit(geo.layer, geo.sceneObject);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Layer to draw points, lines, and polygons on the map The polydata layer\n * provide mechanisms to create and draw geometrical shapes such as points,\n * lines, and polygons.\n * @class\n * @extends geo.layer\n * @returns {geo.featureLayer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.featureLayer = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.featureLayer)) {\n    return new geo.featureLayer(arg);\n  }\n  geo.layer.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      m_features = [],\n      s_init = this._init,\n      s_exit = this._exit,\n      s_update = this._update,\n      s_draw = this.draw;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create feature give a name\n   *\n   * @returns {geo.Feature} Will return a new feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.createFeature = function (featureName, arg) {\n\n    var newFeature = geo.createFeature(\n      featureName, m_this, m_this.renderer(), arg);\n\n    m_this.addChild(newFeature);\n    m_features.push(newFeature);\n    m_this.features(m_features);\n    m_this.modified();\n    return newFeature;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Delete feature\n   *\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.deleteFeature = function (feature) {\n    var i;\n\n    for (i = 0; i < m_features.length; i += 1) {\n      if (m_features[i] === feature) {\n        m_features[i]._exit();\n        m_this.dataTime().modified();\n        m_this.modified();\n        m_features.splice(i, 1);\n      }\n    }\n    m_this.removeChild(feature);\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set drawables\n   *\n   * @returns {Array}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.features = function (val) {\n    if (val === undefined) {\n      return m_features;\n    } else {\n      m_features = val.slice(0);\n      m_this.dataTime().modified();\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   *\n   * Do not call parent _init method as its already been executed\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    if (m_this.initialized()) {\n      return m_this;\n    }\n\n    /// Call super class init\n    s_init.call(m_this);\n\n    /// Bind events to handlers\n    m_this.geoOn(geo.event.resize, function (event) {\n      m_this.renderer()._resize(event.x, event.y, event.width, event.height);\n      m_this._update({});\n      m_this.renderer()._render();\n    });\n\n    m_this.geoOn(geo.event.pan, function (event) {\n      m_this._update({event: event});\n      m_this.renderer()._render();\n    });\n\n    m_this.geoOn(geo.event.zoom, function (event) {\n      m_this._update({event: event});\n      m_this.renderer()._render();\n    });\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function (request) {\n    var i;\n\n    if (!m_features.length) {\n      return m_this;\n    }\n\n    /// Call base class update\n    s_update.call(m_this, request);\n\n    if (!m_this.source() && m_features && m_features.length === 0) {\n      console.log(\"[info] No valid data source found.\");\n      return;\n    }\n\n    if (m_this.dataTime().getMTime() > m_this.updateTime().getMTime()) {\n      for (i = 0; i < m_features.length; i += 1) {\n        m_features[i].renderer(m_this.renderer());\n      }\n    }\n\n    for (i = 0; i < m_features.length; i += 1) {\n      m_features[i]._update();\n    }\n\n    m_this.updateTime().modified();\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Free all resources\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.clear();\n    s_exit();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Draw\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.draw = function () {\n    // Call sceneObject.draw, which calls draw on all child objects.\n    s_draw();\n\n    // Now call render on the renderer. In certain cases it may not do\n    // anything if the if the child objects are drawn on the screen already.\n    m_this.renderer()._render();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Clear all features in layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.clear = function () {\n    var i;\n\n    if (!m_features.length) {\n      return m_this;\n    }\n\n    for (i = 0; i < m_features.length; i += 1) {\n      m_features[i]._exit();\n      m_this.removeChild(m_features[i]);\n    }\n\n    m_this.dataTime().modified();\n    m_this.modified();\n    m_features = [];\n\n    return m_this;\n  };\n\n  return m_this;\n};\n\ninherit(geo.featureLayer, geo.layer);\n\n// Now register it\ngeo.registerLayer(\"feature\", geo.featureLayer);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Common object containing all event types that are provided by the GeoJS\n * API.  Each property contained here is a valid target for event handling\n * via {@link geo.object#geoOn}.  The event object provided to handlers is\n * different for each event type.  Each handler will generally be called\n * with a the <code>this</code> context being the class that caused the event.<br>\n * <br>\n * The following properties are common to all event objects:\n *\n * @namespace\n * @property type {string} The event type that was triggered\n * @property geo {object} A universal event object for controlling propagation\n *\n * @example\n * map.geoOn(geo.event.layerAdd, function (event) {\n *   // event is an object with type: {@link geo.event.layerAdd}\n * });\n *\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event = {};\n\n//////////////////////////////////////////////////////////////////////////////\n/*\n * Event types\n */\n//////////////////////////////////////////////////////////////////////////////\n\n// The following were not triggered nor used anywhere.  Removing until their\n// purpose is defined more clearly.\n//\n// geo.event.update = \"geo_update\";\n// geo.event.opacityUpdate = \"geo_opacityUpdate\";\n// geo.event.layerToggle = \"geo_layerToggle\";\n// geo.event.layerSelect = \"geo_layerSelect\";\n// geo.event.layerUnselect = \"geo_layerUnselect\";\n// geo.event.rotate = \"geo_rotate\";\n// geo.event.query = \"geo_query\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered when a layer is added to the map.\n *\n * @property target {geo.map} The current map\n * @property layer {geo.layer} The new layer\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.layerAdd = \"geo_layerAdd\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered when a layer is removed from the map.\n *\n * @property target {geo.map} The current map\n * @property layer {geo.layer} The old layer\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.layerRemove = \"geo_layerRemove\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered when the map's zoom level is changed.  Note that zoom is never\n * triggered on the map itself.  Instead it is triggered individually on\n * layers, starting with the base layer.\n *\n * @property zoomLevel {Number} New zoom level\n * @property screenPosition {object} The screen position of mouse pointer\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.zoom = \"geo_zoom\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered when the map is panned either by user interaction or map\n * transition.\n *\n * @property screenDelta {object} The number of pixels to pan the map by\n * @property center {object} The new map center\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.pan = \"geo_pan\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered when the map's canvas is resized.\n *\n * @property width {Number} The new width in pixels\n * @property height {Number} The new height in pixels\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.resize = \"geo_resize\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered on every call to {@link geo.map#draw} before the map is rendered.\n *\n * @property target {geo.map} The current map\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.draw = \"geo_draw\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered on every call to {@link geo.map#draw} after the map is rendered.\n *\n * @property target {geo.map} The current map\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.drawEnd = \"geo_drawEnd\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered on every \"mousemove\" over the map's DOM element.  The event\n * object extends {@link geo.mouseState}.\n * @mixes geo.mouseState\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.mousemove = \"geo_mousemove\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered on every \"mousedown\" over the map's DOM element.  The event\n * object extends {@link geo.mouseState}.\n * @mixes geo.mouseState\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.mouseclick = \"geo_mouseclick\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered on every \"mousemove\" during a brushing selection.\n * The event object extends {@link geo.brushSelection}.\n * @mixes geo.brushSelection\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.brush = \"geo_brush\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered after a brush selection ends.\n * The event object extends {@link geo.brushSelection}.\n * @mixes geo.brushSelection\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.brushend = \"geo_brushend\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered when a brush selection starts.\n * The event object extends {@link geo.brushSelection}.\n * @mixes geo.brushSelection\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.brushstart = \"geo_brushstart\";\n\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered before a map navigation animation begins.  Set\n * <code>event.geo.cancelAnimation</code> to cancel the animation\n * of the navigation.  This will cause the map to navigate to the\n * target location immediately.  Set <code>event.geo.cancelNavigation</code>\n * to cancel the navigation completely.  The transition options can\n * be modified in place.\n *\n * @property {geo.geoPosition} center The target center\n * @property {Number} zoom The target zoom level\n * @property {Number} duration The duration of the transition in milliseconds\n * @property {function} ease The easing function\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.transitionstart = \"geo_transitionstart\";\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Triggered after a map navigation animation ends.\n *\n * @property {geo.geoPosition} center The target center\n * @property {Number} zoom The target zoom level\n * @property {Number} duration The duration of the transition in milliseconds\n * @property {function} ease The easing function\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.event.transitionend = \"geo_transitionend\";\n\n////////////////////////////////////////////////////////////////////////////\n/**\n * @namespace\n */\n////////////////////////////////////////////////////////////////////////////\ngeo.event.clock = {\n  play: \"geo_clock_play\",\n  stop: \"geo_clock_stop\",\n  pause: \"geo_clock_pause\",\n  change: \"geo_clock_change\"\n};\n\n////////////////////////////////////////////////////////////////////////////\n/**\n * This event object provides mouse/keyboard events that can be handled\n * by the features.  This provides a similar interface as core events,\n * but with different names so the events don't interfere.  Subclasses\n * can override this to provide custom events.\n *\n * These events will only be triggered on features which were instantiated\n * with the option \"selectionAPI\".\n * @namespace\n */\n////////////////////////////////////////////////////////////////////////////\ngeo.event.feature = {\n  mousemove:  \"geo_feature_mousemove\",\n  mouseover:  \"geo_feature_mouseover\",\n  mouseout:   \"geo_feature_mouseout\",\n  mouseon:    \"geo_feature_mouseon\",\n  mouseoff:   \"geo_feature_mouseoff\",\n  mouseclick: \"geo_feature_mouseclick\",\n  brushend:   \"geo_feature_brushend\",\n  brush:      \"geo_feature_brush\"\n};\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of mapInteractor\n *\n * @class\n * @extends geo.object\n * @returns {geo.mapInteractor}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.mapInteractor = function (args) {\n  'use strict';\n  if (!(this instanceof geo.mapInteractor)) {\n    return new geo.mapInteractor(args);\n  }\n  geo.object.call(this);\n\n  var m_options = args || {},\n      m_this = this,\n      m_mouse,\n      m_keyboard,\n      m_state,\n      $node,\n      m_wheelQueue = { x: 0, y: 0 },\n      m_throttleTime = 10,\n      m_wait = false,\n      m_disableThrottle = true,\n      m_selectionLayer = null,\n      m_selectionPlane = null;\n\n  // Helper method to decide if the current button/modifiers match a set of\n  // conditions.\n  // button: 'left' | 'right' | 'middle'\n  // modifiers: [ 'alt' | 'meta' | 'ctrl' | 'shift' ]\n  function eventMatch(button, modifiers) {\n    /* jshint -W018 */\n    return (button === 'wheel' || m_mouse.buttons[button]) &&\n      (!!m_mouse.modifiers.alt)   === (!!modifiers.alt)   &&\n      (!!m_mouse.modifiers.meta)  === (!!modifiers.meta)  &&\n      (!!m_mouse.modifiers.shift) === (!!modifiers.shift) &&\n      (!!m_mouse.modifiers.ctrl)  === (!!modifiers.ctrl);\n    /* jshint +W018 */\n  }\n\n  // Helper method to calculate the speed from a velocity\n  function calcSpeed(v) {\n    var x = v.x, y = v.y;\n    return Math.sqrt(x * x + y * y);\n  }\n\n  // For throttling mouse events this is a function that\n  // returns true if no actions are in progress and starts\n  // a timer to block events for the next `m_throttleTime` ms.\n  // If it returns false, the caller should ignore the\n  // event.\n  function doRespond() {\n    if (m_disableThrottle) {\n      return true;\n    }\n    if (m_wait) {\n      return false;\n    }\n    m_wait = true;\n    window.setTimeout(function () {\n      m_wait = false;\n      m_wheelQueue = {\n        x: 0,\n        y: 0\n      };\n    }, m_throttleTime);\n    return true;\n  }\n\n  // copy the options object with defaults\n  m_options = $.extend(\n    true,\n    {\n      panMoveButton: 'left',\n      panMoveModifiers: {},\n      zoomMoveButton: 'right',\n      zoomMoveModifiers: {},\n      panWheelEnabled: false,\n      panWheelModifiers: {},\n      zoomWheelEnabled: true,\n      zoomWheelModifiers: {},\n      wheelScaleX: 1,\n      wheelScaleY: 1,\n      zoomScale: 1,\n      selectionButton: 'left',\n      selectionModifiers: {'shift': true},\n      momentum: {\n        enabled: true,\n        maxSpeed: 2.5,\n        minSpeed: 0.01,\n        drag: 0.01\n      },\n      spring: {\n        enabled: false,\n        springConstant: 0.00005\n      }\n    },\n    m_options\n  );\n\n  // options supported:\n  // {\n  //   // button that must be pressed to initiate a pan on mousedown\n  //   panMoveButton: 'right' | 'left' | 'middle'\n  //\n  //   // modifier keys that must be pressed to initiate a pan on mousemove\n  //   panMoveModifiers: { 'ctrl' | 'alt' | 'meta' | 'shift' }\n  //\n  //   // button that must be pressed to initiate a zoom on mousedown\n  //   zoomMoveButton: 'right' | 'left' | 'middle'\n  //\n  //   // modifier keys that must be pressed to initiate a zoom on mousemove\n  //   zoomMoveModifiers: { 'ctrl' | 'alt' | 'meta' | 'shift' }\n  //\n  //   // enable or disable panning with the mouse wheel\n  //   panWheelEnabled: true | false\n  //\n  //   // modifier keys that must be pressed to trigger a pan on wheel\n  //   panWheelModifiers: {...}\n  //\n  //   // enable or disable zooming with the mouse wheel\n  //   zoomWheelEnabled: true | false\n  //\n  //   // modifier keys that must be pressed to trigger a zoom on wheel\n  //   zoomWheelModifiers: {...}\n  //\n  //   // wheel scale factor to change the magnitude of wheel interactions\n  //   wheelScaleX: 1\n  //   wheelScaleY: 1\n  //\n  //   // zoom scale factor to change the magnitude of zoom move interactions\n  //   zoomScale: 1\n  //\n  //   // button that must be pressed to enable drag selection\n  //    selectionButton: 'right' | 'left' | 'middle'\n  //\n  //   // keyboard modifiers that must be pressed to initiate a selection\n  //   selectionModifiers: {...}\n  //\n  //   // enable momentum when panning\n  //   momentum: {\n  //     enabled: true | false,\n  //     drag: number, // drag coefficient\n  //     maxSpeed: number, // don't allow animation to pan faster than this\n  //     minSpeed: number  // stop animations if the speed is less than this\n  //   }\n  //\n  //   // enable spring clamping to screen edges to enforce clamping\n  //   spring: {\n  //     enabled: true | false,\n  //     springConstant: number,\n  //   }\n  // }\n\n  // A bunch of type definitions for api documentation:\n  /**\n   * General representation of rectangular bounds in world coordinates\n   * @typedef geo.geoBounds\n   * @type {object}\n   * @property {geo.geoPosition} upperLeft Upper left corner\n   * @property {geo.geoPosition} upperRight Upper right corner\n   * @property {geo.geoPosition} lowerLeft Lower left corner\n   * @property {geo.geoPosition} lowerRight Lower right corner\n   */\n\n  /**\n   * General representation of rectangular bounds in pixel coordinates\n   * @typedef geo.screenBounds\n   * @type {object}\n   * @property {geo.screenPosition} upperLeft Upper left corner\n   * @property {geo.screenPosition} upperRight Upper right corner\n   * @property {geo.screenPosition} lowerLeft Lower left corner\n   * @property {geo.screenPosition} lowerRight Lower right corner\n   */\n\n  /**\n   * General representation of a point on the screen.\n   * @typedef geo.screenPosition\n   * @type {object}\n   * @property {Number} x Horizontal coordinate in pixels\n   * @property {Number} y Vertical coordinate in pixels\n   */\n\n  /**\n   * General represention of a point on the earth.\n   * @typedef geo.geoPosition\n   * @type {object}\n   * @property {Number} x Horizontal coordinate in degrees longitude\n   * @property {Number} y Vertical coordinate in degrees latitude\n   */\n\n  /**\n   * The status of all mouse buttons.\n   * @typedef geo.mouseButtons\n   * @type {object}\n   * @property {true|false} left The left mouse button\n   * @property {true|false} right The right mouse button\n   * @property {true|false} middle The middle mouse button\n   */\n\n  /**\n   * The status of all modifier keys these are copied from the\n   * standard DOM events.\n   * @typedef geo.modifierKeys\n   * @type {object}\n   * @property {true|false} alt <code>Event.alt</code>\n   * @property {true|false} ctrl <code>Event.ctrl</code>\n   * @property {true|false} shift <code>Event.shift</code>\n   * @property {true|false} meta <code>Event.meta</code>\n   */\n\n  /**\n   * Provides information about the state of the mouse\n   * @typedef geo.mouseState\n   * @type {object}\n   * @property {geo.screenPosition} page Mouse location in pixel space\n   * @property {geo.geoPosition} map Mouse location in world space\n   * @property {geo.mouseButtons} buttons The current state of the mouse buttons\n   * @property {geo.modifierKeys} modifiers The current state of all modifier keys\n   * @property {Date} time The timestamp the event took place\n   * @property {Number} deltaTime The time in milliseconds since the last mouse event\n   * @property {geo.screenPosition} velocity The velocity of the mouse pointer\n   * in pixels per second\n   */\n\n  /**\n   * @typedef geo.brushSelection\n   * @type {object}\n   * @property {geo.screenBounds} display The selection bounds in pixel space\n   * @property {geo.geoBounds} gcs The selection bounds in world space\n   * @property {geo.mouseState} mouse The current mouse state\n   * @property {geo.mouseState} origin The mouse state at the start of the\n   * brush action\n   */\n\n\n  // default mouse object\n  m_mouse = {\n    page: { // mouse position relative to the page\n      x: 0,\n      y: 0\n    },\n    map: { // mouse position relative to the map\n      x: 0,\n      y: 0\n    },\n    // mouse button status\n    buttons: {\n      left: false,\n      right: false,\n      middle: false\n    },\n    // keyboard modifier status\n    modifiers: {\n      alt: false,\n      ctrl: false,\n      shift: false,\n      meta: false\n    },\n    // time the event was captured\n    time: new Date(),\n    // time elapsed since the last mouse event\n    deltaTime: 1,\n    // pixels/ms\n    velocity: {\n      x: 0,\n      y: 0\n    }\n  };\n\n  // default keyboard object\n  // (keyboard events not implemented yet)\n  m_keyboard = {\n  };\n\n  // The interactor state determines what actions are taken in response to\n  // core browser events.\n  //\n  // i.e.\n  // {\n  //    'action': 'pan',      // an ongoing pan event\n  //    'origin': {...},      // mouse object at the start of the action\n  //    'delta': {x: *, y: *} // mouse movement since action start\n  //                          // not including the current event\n  //  }\n  //\n  //  {\n  //    'action': 'zoom',  // an ongoing zoom event\n  //    ...\n  //  }\n  //\n  //  {\n  //    'acton': 'select',\n  //    'origin': {...},\n  //    'delta': {x: *, y: *}\n  //  }\n  //\n  //  {\n  //    'action': 'momentum',\n  //    'origin': {...},\n  //    'handler': function () { }, // called in animation loop\n  //    'timer': animate loop timer\n  //  }\n  m_state = {};\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Connects events to a map.  If the map is not set, then this does nothing.\n   * @returns {geo.mapInteractor}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._connectEvents = function () {\n    if (!m_options.map) {\n      return m_this;\n    }\n\n    // prevent double binding to dom elements\n    m_this._disconnectEvents();\n\n    // store the connected element\n    $node = $(m_options.map.node());\n\n\n    // add event handlers\n    $node.on('mousemove.geojs', m_this._handleMouseMove);\n    $node.on('mousedown.geojs', m_this._handleMouseDown);\n    $node.on('mouseup.geojs', m_this._handleMouseUp);\n    $node.on('mousewheel.geojs', m_this._handleMouseWheel);\n    if (m_options.panMoveButton === 'right' ||\n        m_options.zoomMoveButton === 'right') {\n      $node.on('contextmenu.geojs', function () { return false; });\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Disonnects events to a map.  If the map is not set, then this does nothing.\n   * @returns {geo.mapInteractor}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._disconnectEvents = function () {\n    if ($node) {\n      $node.off('.geojs');\n      $node = null;\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Sets or gets map for this interactor, adds draw region layer if needed\n   *\n   * @param {geo.map} newMap optional\n   * @returns {geo.interactorStyle|geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.map = function (val) {\n    if (val !== undefined) {\n      m_options.map = val;\n      m_this._connectEvents();\n      return m_this;\n    }\n    return m_options.map;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Gets/sets the options object for the interactor.\n   *\n   * @param {Object} opts optional\n   * @returns {geo.interactorStyle|Object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.options = function (opts) {\n    if (opts === undefined) {\n      return $.extend({}, m_options);\n    }\n    $.extend(m_options, opts);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Stores the current mouse position from an event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._getMousePosition = function (evt) {\n    var offset = $node.offset(), dt, t;\n\n    t = (new Date()).valueOf();\n    dt = t - m_mouse.time;\n    m_mouse.time = t;\n    m_mouse.deltaTime = dt;\n    m_mouse.velocity = {\n      x: (evt.pageX - m_mouse.page.x) / dt,\n      y: (evt.pageY - m_mouse.page.y) / dt\n    };\n    m_mouse.page = {\n      x: evt.pageX,\n      y: evt.pageY\n    };\n    m_mouse.map = {\n      x: evt.pageX - offset.left,\n      y: evt.pageY - offset.top\n    };\n    try {\n      m_mouse.geo = m_this.map().displayToGcs(m_mouse.map);\n    } catch (e) {\n      // catch georeferencing problems and move on\n      // needed for handling the map before the base layer\n      // is attached\n      m_mouse.geo = null;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Stores the current mouse button\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._getMouseButton = function (evt) {\n    if (evt.which === 1) {\n      m_mouse.buttons.left = evt.type !== 'mouseup';\n    } else if (evt.which === 3) {\n      m_mouse.buttons.right = evt.type !== 'mouseup';\n    } else if (evt.which === 2) {\n      m_mouse.buttons.middle = evt.type !== 'mouseup';\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Stores the current keyboard modifiers\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._getMouseModifiers = function (evt) {\n    m_mouse.modifiers.alt = evt.altKey;\n    m_mouse.modifiers.ctrl = evt.ctrlKey;\n    m_mouse.modifiers.meta = evt.metaKey;\n    m_mouse.modifiers.shift = evt.shiftKey;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Compute a selection information object.\n   * @private\n   * @returns {Object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._getSelection = function () {\n    var origin = m_state.origin,\n        mouse = m_this.mouse(),\n        map = m_this.map(),\n        display = {}, gcs = {};\n\n    // TODO: clamp to map bounds\n    // Get the display coordinates\n    display.upperLeft = {\n      x: Math.min(origin.map.x, mouse.map.x),\n      y: Math.min(origin.map.y, mouse.map.y)\n    };\n\n    display.lowerRight = {\n      x: Math.max(origin.map.x, mouse.map.x),\n      y: Math.max(origin.map.y, mouse.map.y)\n    };\n\n    display.upperRight = {\n      x: display.lowerRight.x,\n      y: display.upperLeft.y\n    };\n\n    display.lowerLeft = {\n      x: display.upperLeft.x,\n      y: display.lowerRight.y\n    };\n\n    // Get the gcs coordinates\n    gcs.upperLeft = map.displayToGcs(display.upperLeft);\n    gcs.lowerRight = map.displayToGcs(display.lowerRight);\n    gcs.upperRight = map.displayToGcs(display.upperRight);\n    gcs.lowerLeft = map.displayToGcs(display.lowerLeft);\n\n    m_selectionPlane.origin([\n      display.lowerLeft.x,\n      display.lowerLeft.y,\n      0\n    ]);\n    m_selectionPlane.upperLeft([\n      display.upperLeft.x,\n      display.upperLeft.y,\n      0\n    ]);\n    m_selectionPlane.lowerRight([\n      display.lowerRight.x,\n      display.lowerRight.y,\n      0\n    ]);\n    m_selectionPlane.draw();\n\n    return {\n      display: display,\n      gcs: gcs,\n      mouse: mouse,\n      origin: $.extend({}, m_state.origin)\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Immediately cancel an ongoing action.\n   *\n   * @param {string?} action The action type, if null cancel any action\n   * @returns {bool} If an action was canceled\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.cancel = function (action) {\n    var out;\n    if (!action) {\n      out = !!m_state.action;\n    } else {\n      out = m_state.action === action;\n    }\n    if (out) {\n      m_state = {};\n    }\n    return out;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle event when a mouse button is pressed\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseDown = function (evt) {\n    var action = null;\n\n    if (m_state.action === 'momentum') {\n      // cancel momentum on click\n      m_state = {};\n    }\n\n    m_this._getMousePosition(evt);\n    m_this._getMouseButton(evt);\n    m_this._getMouseModifiers(evt);\n\n    if (eventMatch(m_options.panMoveButton, m_options.panMoveModifiers)) {\n      action = 'pan';\n    } else if (eventMatch(m_options.zoomMoveButton, m_options.zoomMoveModifiers)) {\n      action = 'zoom';\n    } else if (eventMatch(m_options.selectionButton, m_options.selectionModifiers)) {\n      action = 'select';\n    }\n\n    m_mouse.velocity = {\n      x: 0,\n      y: 0\n    };\n\n    if (action) {\n      // store the state object\n      m_state = {\n        action: action,\n        origin: $.extend(true, {}, m_mouse),\n        delta: {x: 0, y: 0}\n      };\n\n      if (action === 'select') {\n        // Make sure the old selection layer is gone.\n        if (m_selectionLayer) {\n          m_selectionLayer.clear();\n          m_this.map().deleteLayer(m_selectionLayer);\n          m_selectionLayer = null;\n        }\n        // Create a feature layer and plane feature to show the selection bounds\n        m_selectionLayer = m_this.map().createLayer('feature', {renderer: 'd3'});\n        m_selectionPlane = m_selectionLayer.createFeature('plane');\n        m_selectionPlane.style({\n          screenCoordinates: true,\n          fillOpacity: function () { return 0.25; }\n        });\n        m_this.map().geoTrigger(geo.event.brushstart, m_this._getSelection());\n      }\n\n      // bind temporary handlers to document\n      $(document).on('mousemove.geojs', m_this._handleMouseMoveDocument);\n      $(document).on('mouseup.geojs', m_this._handleMouseUpDocument);\n    }\n\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle mouse move event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseMove = function (evt) {\n    if (m_state.action) {\n      // If currently performing a navigation action, the mouse\n      // coordinates will be captured by the document handler.\n      return;\n    }\n    m_this._getMousePosition(evt);\n    m_this._getMouseButton(evt);\n    m_this._getMouseModifiers(evt);\n    m_this.map().geoTrigger(geo.event.mousemove, m_this.mouse());\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle mouse move event on the document (temporary bindings)\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseMoveDocument = function (evt) {\n    var dx, dy, selectionObj;\n    m_this._getMousePosition(evt);\n    m_this._getMouseButton(evt);\n    m_this._getMouseModifiers(evt);\n\n    if (!m_state.action) {\n      // This shouldn't happen\n      console.log('WARNING: Invalid state in mapInteractor.');\n      return;\n    }\n\n    // when throttled, do nothing\n    if (!doRespond()) {\n      return;\n    }\n\n    // calculate the delta from the origin point to avoid\n    // accumulation of floating point errors\n    dx = m_mouse.map.x - m_state.origin.map.x - m_state.delta.x;\n    dy = m_mouse.map.y - m_state.origin.map.y - m_state.delta.y;\n    m_state.delta.x += dx;\n    m_state.delta.y += dy;\n\n    if (m_state.action === 'pan') {\n      m_this.map().pan({x: dx, y: dy});\n    } else if (m_state.action === 'zoom') {\n      m_this.map().zoom(\n        m_this.map().zoom() - dy * m_options.zoomScale / 120\n      );\n    } else if (m_state.action === 'select') {\n      // Get the bounds of the current selection\n      selectionObj = m_this._getSelection();\n      m_this.map().geoTrigger(geo.event.brush, selectionObj);\n    }\n\n    // Prevent default to stop text selection in particular\n    evt.preventDefault();\n  };\n\n  /**\n   * Use interactor options to modify the mouse velocity by momentum\n   * or spring equations depending on the current map state.\n   * @private\n   * @param {object} v Current velocity in pixels / ms\n   * @param {number} deltaT The time delta\n   * @returns {object} New velocity\n   */\n  function modifyVelocity(v, deltaT) {\n    deltaT = deltaT <= 0 ? 30 : deltaT;\n    var sf = springForce();\n    var speed = calcSpeed(v);\n    var vx = v.x / speed;\n    var vy = v.y / speed;\n\n    speed = speed * Math.exp(-m_options.momentum.drag * deltaT);\n\n    // |force| + |velocity| < c <- stopping condition\n    if (calcSpeed(sf) * deltaT + speed < m_options.momentum.minSpeed) {\n      return null;\n    }\n\n    if (speed > 0) {\n      vx = vx * speed;\n      vy = vy * speed;\n    } else {\n      vx = 0;\n      vy = 0;\n    }\n\n    return {\n      x: vx - sf.x * deltaT,\n      y: vy - sf.y * deltaT\n    };\n  }\n\n  /**\n   * Get the spring force for the current map bounds\n   * (This method might need to move elsewhere to deal\n   * with different projections)\n   * @private\n   * @returns {object} The spring force\n   */\n  function springForce() {\n    var xplus,  // force to the right\n        xminus, // force to the left\n        yplus,  // force to the top\n        yminus; // force to the bottom\n\n    if (!m_options.spring.enabled) {\n      return {x: 0, y: 0};\n    }\n    // get screen coordinates of corners\n    var ul = m_this.map().gcsToDisplay({\n      x: -180,\n      y: 82\n    });\n    var lr = m_this.map().gcsToDisplay({\n      x: 180,\n      y: -82\n    });\n\n    var c = m_options.spring.springConstant;\n    // Arg... map needs to expose the canvas size\n    var width = m_this.map().node().width();\n    var height = m_this.map().node().height();\n\n    xplus = c * Math.max(0, ul.x);\n    xminus = c * Math.max(0, width - lr.x);\n    yplus = c * Math.max(0, ul.y) / 2;\n    yminus = c * Math.max(0, height - lr.y) / 2;\n\n    return {\n      x: xplus - xminus,\n      y: yplus - yminus\n    };\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle event when a mouse button is unpressed on the document.\n   * Removes temporary bindings.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseUpDocument = function (evt) {\n    var selectionObj, oldAction;\n\n    m_this._getMouseButton(evt);\n    m_this._getMouseModifiers(evt);\n\n    // unbind temporary handlers on document\n    $(document).off('.geojs');\n\n    if (m_mouse.buttons.right) {\n      evt.preventDefault();\n    }\n\n    if (m_state.action === 'select') {\n      selectionObj = m_this._getSelection();\n\n      m_selectionLayer.clear();\n      m_this.map().deleteLayer(m_selectionLayer);\n      m_selectionLayer = null;\n      m_selectionPlane = null;\n\n      m_this.map().geoTrigger(geo.event.brushend, selectionObj);\n    }\n\n    // reset the interactor state\n    oldAction = m_state.action;\n    m_state = {};\n\n    // if momentum is enabled, start the action here\n    if (m_options.momentum.enabled && oldAction === 'pan') {\n      m_this.springBack(true);\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle event when a mouse button is unpressed\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseUp = function (evt) {\n    m_this._getMouseButton(evt);\n    m_this._getMouseModifiers(evt);\n\n    // fire a click event here\n    m_this.map().geoTrigger(geo.event.mouseclick, m_this.mouse());\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle mouse wheel event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseWheel = function (evt) {\n    var zoomFactor, direction;\n\n    // In case jquery-mousewheel isn't loaded for some reason\n    evt.deltaFactor = evt.deltaFactor || 1;\n\n    m_this._getMouseModifiers(evt);\n    evt.deltaX = evt.deltaX * m_options.wheelScaleX * evt.deltaFactor / 120;\n    evt.deltaY = evt.deltaY * m_options.wheelScaleY * evt.deltaFactor / 120;\n\n    evt.preventDefault();\n    if (!doRespond()) {\n      m_wheelQueue.x += evt.deltaX;\n      m_wheelQueue.y += evt.deltaY;\n      return;\n    }\n\n    evt.deltaX += m_wheelQueue.x;\n    evt.deltaY += m_wheelQueue.y;\n\n    m_wheelQueue = {\n      x: 0,\n      y: 0\n    };\n\n    if (m_options.panWheelEnabled &&\n        eventMatch('wheel', m_options.panWheelModifiers)) {\n\n      m_this.map().pan({\n        x: evt.deltaX,\n        y: evt.deltaY\n      });\n\n    } else if (m_options.zoomWheelEnabled &&\n               eventMatch('wheel', m_options.zoomWheelModifiers)) {\n\n      zoomFactor = evt.deltaY;\n      direction = m_mouse.map;\n\n      m_this.map().zoom(\n        m_this.map().zoom() + zoomFactor,\n        direction\n      );\n    }\n  };\n\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Start up a spring back action when the map bounds are out of range.\n   * Not to be user callable.\n   * @todo Move this and momentum handling to the map class\n   * @protected\n   *\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.springBack = function (initialVelocity) {\n    if (m_state.action === 'momentum') {\n      return;\n    }\n    if (!initialVelocity) {\n      m_mouse.velocity = {\n        x: 0,\n        y: 0\n      };\n    }\n    m_state.action = 'momentum';\n    m_state.origin = m_this.mouse();\n    m_state.start = new Date();\n    m_state.handler = function () {\n      var v, s, last, dt;\n\n      // Not sure the correct way to do this.  We need the delta t for the\n      // next time step...  Maybe use a better interpolator and the time\n      // parameter from requestAnimationFrame.\n      dt = Math.min(m_mouse.deltaTime, 30);\n      if (m_state.action !== 'momentum' ||\n          !m_this.map() ||\n          m_this.map().transition()) {\n        // cancel if a new action was performed\n        return;\n      }\n\n      last = m_state.start.valueOf();\n      m_state.start = new Date();\n\n      v = modifyVelocity(m_mouse.velocity, m_state.start - last);\n\n      // stop panning when the speed is below the threshold\n      if (!v) {\n        m_state = {};\n        return;\n      }\n\n      s = calcSpeed(v);\n      if (s > m_options.momentum.maxSpeed) {\n        s = m_options.momentum.maxSpeed / s;\n        v.x = v.x * s;\n        v.y = v.y * s;\n      }\n\n      if (!isFinite(v.x) || !isFinite(v.y)) {\n        v.x = 0;\n        v.y = 0;\n      }\n      m_mouse.velocity.x = v.x;\n      m_mouse.velocity.y = v.y;\n\n      m_this.map().pan({\n        x: m_mouse.velocity.x * dt,\n        y: m_mouse.velocity.y * dt\n      });\n\n      if (m_state.handler) {\n        window.requestAnimationFrame(m_state.handler);\n      }\n    };\n    if (m_state.handler) {\n      window.requestAnimationFrame(m_state.handler);\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle double click event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleDoubleClick = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Public method that unbinds all events\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.destroy = function () {\n    m_this._disconnectEvents();\n    m_this.map(null);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get current mouse information\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.mouse = function () {\n    return $.extend(true, {}, m_mouse);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get current keyboard information\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.keyboard = function () {\n    return $.extend(true, {}, m_keyboard);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the current interactor state\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.state = function () {\n    return $.extend(true, {}, m_state);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Simulate a DOM mouse event on connected map.\n   *\n   * The options for creating the events are as follows, not all\n   * options are required for every event type. ::\n   *\n   *   options = {\n   *     page: {x, y} // position on the page\n   *     map: {x, y}  // position on the map (overrides page)\n   *     button: 'left' | 'right' | 'middle'\n   *     modifiers: [ 'alt' | 'ctrl' | 'meta' | 'shift' ]\n   *     wheelDelta: {x, y}\n   *   }\n   *\n   * @param {string} type Event type 'mousemove', 'mousedown', 'mouseup', ...\n   * @param {object} options\n   * @returns {mapInteractor}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.simulateEvent = function (type, options) {\n    var evt, page, offset, which;\n\n    if (!m_this.map()) {\n      return m_this;\n    }\n\n    page = options.page || {};\n\n    if (options.map) {\n      offset = $node.offset();\n      page.x = options.map.x + offset.left;\n      page.y = options.map.y + offset.top;\n    }\n\n    if (options.button === 'left') {\n      which = 1;\n    } else if (options.button === 'right') {\n      which = 3;\n    } else if (options.button === 'middle') {\n      which = 2;\n    }\n\n    options.modifiers = options.modifiers || [];\n    options.wheelDelta = options.wheelDelta || {};\n\n    evt = $.Event(\n      type,\n      {\n        pageX: page.x,\n        pageY: page.y,\n        which: which,\n        altKey: options.modifiers.indexOf('alt') >= 0,\n        ctrlKey: options.modifiers.indexOf('ctrl') >= 0,\n        metaKey: options.modifiers.indexOf('meta') >= 0,\n        shiftKey: options.modifiers.indexOf('shift') >= 0,\n        deltaX: options.wheelDelta.x,\n        deltaY: options.wheelDelta.y,\n        deltaFactor: 1\n      }\n    );\n    $node.trigger(evt);\n  };\n  this._connectEvents();\n  return this;\n};\n\ninherit(geo.mapInteractor, geo.object);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Stores the current time for a map, triggers time keeping events, and\n * handles the animation state and interaction.\n *\n * @class geo.clock\n * @extends geo.object\n * @returns {geo.clock}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.clock = function (opts) {\n  'use strict';\n\n  if (!(this instanceof geo.clock)) {\n    return new geo.clock(opts);\n  }\n  opts = opts || {};\n  geo.object.call(this, opts);\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      m_now = new Date(0),\n      m_start = null,\n      m_end = null,\n      m_step = null,\n      m_rate = null,\n      m_loop = Number.POSITIVE_INFINITY,\n      m_currentLoop = 0,\n      m_state = 'stop',\n      m_currentAnimation = null,\n      m_object = null;\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the geo.object to trigger events on.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.object = function (arg) {\n    if (arg === undefined) {\n      return m_object;\n    }\n    m_object = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns true if attached to a valid geo.object.\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._attached = function () {\n    return (m_object instanceof geo.object);\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the current time.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.now = function (arg) {\n    var previous = m_now;\n    if (arg === undefined) {\n      return m_now;\n    }\n    m_now = arg;\n\n    if (m_now !== previous &&\n        m_this._attached()) {\n      m_this.object().geoTrigger(geo.event.clock.change, {\n        previous: previous,\n        current: m_now,\n        clock: m_this\n      });\n    }\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the animation start time.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.start = function (arg) {\n    if (arg === undefined) {\n      return m_start;\n    }\n    m_start = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the animation end time.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.end = function (arg) {\n    if (arg === undefined) {\n      return m_end;\n    }\n    m_end = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the animation time step.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.step = function (arg) {\n    if (arg === undefined) {\n      return m_step;\n    }\n    m_step = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set looping control of the clock.  This controls how many times the\n   * animation will repeat before stopping.  Default\n   * ``Number.POSITIVE_INFINITY``, the animation repeats forever.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.loop = function (arg) {\n    if (arg === undefined) {\n      return m_loop;\n    }\n    m_loop = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the animation state.  Valid values are:\n   *\n   *   * 'stop'\n   *   * 'play'\n   *   * 'pause'\n   *\n   * This will also trigger relevant events, but they may be fired\n   * asynchronously.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.state = function (arg, step) {\n\n    if (arg === undefined) {\n      return m_state;\n    }\n    if (['stop', 'play', 'pause'].indexOf(arg) < 0) {\n      console.log('WARNING: Ignored invalid state: ' + arg);\n      return m_this;\n    }\n\n    if (arg === 'play' && m_state === 'stop') {\n      // reset animation parameters\n      m_currentLoop = 0;\n      m_this.now(m_this.start());\n    }\n\n    if (arg === 'play' && m_state !== 'play') {\n      // Start a new animation.\n      m_state = arg;\n      m_this._animate(step || 1);\n    }\n\n    m_state = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the animation frame rate.  This is approximately the number\n   * of frames displayed per second.  A null value will use the browser's\n   * native requestAnimationFrame to draw new frames.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.framerate = function (arg) {\n    if (arg === undefined) {\n      return m_rate;\n    }\n    m_rate = arg;\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Step to the next frame in the animation.  Pauses the animation if it is\n   * playing.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.stepForward = function () {\n    m_this.state('pause');\n    m_this._setNextFrame(1);\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Step to the previous frame in the animation.  Pauses the animation if it is\n   * playing.\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.stepBackward = function () {\n    m_this.state('pause');\n    m_this._setNextFrame(-1);\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Step to the next frame in the animation.  Will set the state to stop\n   * if the animation has reached the end and there are no more loops.\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._setNextFrame = function (step) {\n    var next = new Date(m_this.now().valueOf() + step * m_this.step());\n\n    if (next >= m_this.end() || next <= m_this.start()) {\n      if (m_this.loop() <= m_currentLoop) {\n        m_this.state('stop');\n        return;\n      }\n      m_currentLoop += 1;\n      if (step >= 0) {\n        m_this.now(m_this.start());\n      } else {\n        m_this.now(m_this.end());\n      }\n      return;\n    }\n    m_this.now(next);\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Start an animation.\n   * @param {integer} step The animation frame step (+1 for forward -1 for\n   *                       reverse, etc).\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._animate = function (step) {\n    var myAnimation = {};\n    m_currentAnimation = myAnimation;\n\n    function frame() {\n      if (myAnimation !== m_currentAnimation) {\n        // A new animation has started, so kill this one.\n        return;\n      }\n      m_this._setNextFrame(step);\n      if (m_this.state() === 'play') {\n\n        // Queue the next frame\n        if (!m_this.framerate()) {\n          window.requestAnimationFrame(frame);\n        } else {\n          window.setTimeout(frame, 1000 / m_this.framerate());\n        }\n      } else if (m_this._attached()) {\n        m_this.object().geoTrigger(geo.event.clock[m_this.state()], {\n          current: m_this.now(),\n          clock: m_this\n        });\n      }\n    }\n\n    // trigger the play event\n    if (m_this._attached()) {\n      m_this.object().geoTrigger(geo.event.clock.play, {\n        current: m_this.now(),\n        clock: m_this\n      });\n    }\n\n    // Queue the first frame\n    if (!m_this.framerate()) {\n      window.requestAnimationFrame(frame);\n    } else {\n      window.setTimeout(frame, 1000 / m_this.framerate());\n    }\n  };\n};\ninherit(geo.clock, geo.object);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class fileReader\n *\n * @class\n * @extends geo.object\n * @returns {geo.fileReader}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.fileReader = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.fileReader)) {\n    return new geo.fileReader(arg);\n  }\n  geo.object.call(this);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  arg = arg || {};\n\n  if (!(arg.layer instanceof geo.featureLayer)) {\n    throw \"fileReader must be given a feature layer\";\n  }\n\n  var m_layer = arg.layer;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the feature layer attached to the reader\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.layer = function () {\n    return m_layer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Tells the caller if it can handle the given file by returning a boolean.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.canRead = function () {\n    return false;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Reads the file object and calls the done function when finished.  As an\n   * argument to done, provides a boolean that reports if the read was a\n   * success.  Possibly, it can call done with an object containing details\n   * of the read operation.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.read = function (file, done) {\n    done(false);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return a FileReader with handlers attached.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function newFileReader(done, progress) {\n    var reader = new FileReader();\n    if (progress) {\n      reader.onprogress = progress;\n    }\n    reader.onloadend = function () {\n      if (!reader.result) {\n        done(reader.error);\n      }\n      done(reader.result);\n    };\n    return reader;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private method for reading a file object as a string.  Calls done with\n   * the string content when finished or an error object if unsuccessful.\n   * Optionally, the caller can provide a progress method that is called\n   * after reading each slice.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._getString = function (file, done, progress) {\n    var reader = newFileReader(done, progress);\n    reader.readAsText(file);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Like _getString, but returns an ArrayBuffer object.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._getArrayBuffer = function (file, done, progress) {\n    var reader = newFileReader(done, progress);\n    reader.readAsText(file);\n  };\n\n  return this;\n};\n\ninherit(geo.fileReader, geo.object);\n","/*global File*/\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class jsonReader\n *\n * @class\n * @extends geo.fileReader\n * @returns {geo.jsonReader}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.jsonReader = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.jsonReader)) {\n    return new geo.jsonReader(arg);\n  }\n\n  var m_this = this, m_style = arg.style || {};\n  m_style = $.extend({\n      'strokeWidth': 2,\n      'strokeColor': {r: 0, g: 0, b: 0},\n      'strokeOpacity': 1,\n      'fillColor': {r: 1, g: 0, b: 0},\n      'fillOpacity': 1\n    }, m_style);\n\n  geo.fileReader.call(this, arg);\n\n  this.canRead = function (file) {\n    if (file instanceof File) {\n      return (file.type === 'application/json' || file.name.match(/\\.json$/));\n    } else if (typeof file === 'string') {\n      try {\n        JSON.parse(file);\n      } catch (e) {\n        return false;\n      }\n      return true;\n    }\n    try {\n      if (Array.isArray(m_this._featureArray(file))) {\n        return true;\n      }\n    } catch (e) {}\n    return false;\n  };\n\n  this._readObject = function (file, done, progress) {\n    var object;\n    function onDone(fileString) {\n      if (typeof fileString !== 'string') {\n        done(false);\n      }\n\n      // We have two possibilities here:\n      // 1) fileString is a JSON string or is\n      // a URL.\n      try {\n        object = JSON.parse(fileString);\n        done(object);\n      } catch (e) {\n        if (!object) {\n          $.ajax({\n            type: 'GET',\n            url: fileString,\n            dataType: 'text'\n          }).done(function (data) {\n            object = JSON.parse(data);\n            done(object);\n          }).fail(function () {\n            done(false);\n          });\n        }\n      }\n    }\n\n    if (file instanceof File) {\n      m_this._getString(file, onDone, progress);\n    } else if (typeof file === 'string') {\n      onDone(file);\n    } else {\n      done(file);\n    }\n  };\n\n  this._featureArray = function (spec) {\n    if (spec.type === 'FeatureCollection') {\n      return spec.features || [];\n    }\n    if (spec.type === 'GeometryCollection') {\n      throw 'GeometryCollection not yet implemented.';\n    }\n    if (Array.isArray(spec.coordinates)) {\n      return spec;\n    }\n    throw 'Unsupported collection type: ' + spec.type;\n  };\n\n  this._featureType = function (spec) {\n    var geometry = spec.geometry || {};\n    if (geometry.type === 'Point' || geometry.type === 'MultiPoint') {\n      return 'point';\n    }\n    if (geometry.type === 'LineString') {\n      return 'line';\n    }\n    if (geometry.type === 'Polygon') {\n      return 'polygon';\n    }\n    return null;\n  };\n\n  this._getCoordinates = function (spec) {\n    var geometry = spec.geometry || {},\n        coordinates = geometry.coordinates || [], elv;\n\n    if ((coordinates.length === 2 || coordinates.length === 3) &&\n        (isFinite(coordinates[0]) && isFinite(coordinates[1]))) {\n\n      // Do we have a elevation component\n      if (isFinite(coordinates[2])) {\n        elv = coordinates[2];\n      }\n\n      // special handling for single point coordinates\n      return [{x: coordinates[0], y: coordinates[1], z: elv}];\n    }\n\n    // need better handling here, but we can plot simple polygons\n    // by taking just the outer linearring\n    if (Array.isArray(coordinates[0][0])) {\n      coordinates = coordinates[0];\n    }\n\n    // return an array of latlng's for LineString, MultiPoint, etc...\n    return coordinates.map(function (c) {\n      return {\n        x: c[0],\n        y: c[1],\n        z: c[2]\n      };\n    });\n  };\n\n  this._getStyle = function (spec) {\n    return spec.properties;\n  };\n\n  this.read = function (file, done, progress) {\n\n    function _done(object) {\n      var features, allFeatures = [];\n\n      features = m_this._featureArray(object);\n\n      features.forEach(function (feature) {\n        var type = m_this._featureType(feature),\n            coordinates = m_this._getCoordinates(feature),\n            style = m_this._getStyle(feature);\n        if (type) {\n          if (type === 'line') {\n            style.fill = style.fill || false;\n            allFeatures.push(m_this._addFeature(\n              type,\n              [coordinates],\n              style,\n              feature.properties\n            ));\n          } else if (type === 'point') {\n            style.stroke = style.stroke || false;\n            allFeatures.push(m_this._addFeature(\n              type,\n              coordinates,\n              style,\n              feature.properties\n            ));\n          } else if (type === 'polygon') {\n            style.fill = style.fill === undefined ? true : style.fill;\n            style.fillOpacity = (\n              style.fillOpacity === undefined ? 0.25 : style.fillOpacity\n            );\n            // polygons not yet supported\n            allFeatures.push(m_this._addFeature(\n              'line',\n              [coordinates],\n              style,\n              feature.properties\n            ));\n          }\n        } else {\n          console.log('unsupported feature type: ' + feature.geometry.type);\n        }\n      });\n\n      if (done) {\n        done(allFeatures);\n      }\n    }\n\n    m_this._readObject(file, _done, progress);\n  };\n\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build the data array for a feature given the coordinates and properties\n   * from the geojson.\n   *\n   * @private\n   * @param {Object[]} coordinates Coordinate data array\n   * @param {Object} properties Geojson properties object\n   * @param {Object} style Global style defaults\n   * @returns {Object[]}\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._buildData = function (coordinates, properties, style) {\n    return coordinates.map(function (coord) {\n      return {\n        coordinates: coord,\n        properties: properties,\n        style: style\n      };\n    });\n  };\n\n  this._addFeature = function (type, coordinates, style, properties) {\n    var _style = $.extend({}, m_style, style);\n    var feature = m_this.layer().createFeature(type)\n      .data(m_this._buildData(coordinates, properties, style))\n      .style(_style);\n\n    if (type === 'line') {\n      feature.line(function (d) { return d.coordinates; });\n    } else {\n      feature.position(function (d) { return d.coordinates; });\n    }\n    return feature;\n  };\n\n};\n\ninherit(geo.jsonReader, geo.fileReader);\n\ngeo.registerFileReader('jsonReader', geo.jsonReader);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class map\n *\n * Creates a new map inside of the given HTML layer (Typically DIV)\n * @class\n * @extends geo.sceneObject\n * @returns {geo.map}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.map = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.map)) {\n    return new geo.map(arg);\n  }\n  arg = arg || {};\n  geo.sceneObject.call(this, arg);\n  arg.layers = arg.layers === undefined ? [] : arg.layers;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private member variables\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_exit = this._exit,\n      m_x = 0,\n      m_y = 0,\n      m_node = $(arg.node),\n      m_width = arg.width || m_node.width(),\n      m_height = arg.height || m_node.height(),\n      m_gcs = arg.gcs === undefined ? \"EPSG:4326\" : arg.gcs,\n      m_uigcs = arg.uigcs === undefined ? \"EPSG:4326\" : arg.uigcs,\n      m_center = { x: 0, y: 0 },\n      m_zoom = arg.zoom === undefined ? 1 : arg.zoom,\n      m_baseLayer = null,\n      m_fileReader = null,\n      m_interactor = null,\n      m_validZoomRange = { min: 0, max: 16 },\n      m_transition = null,\n      m_queuedTransition = null,\n      m_clock = null,\n      m_bounds = {};\n\n  arg.center = geo.util.normalizeCoordinates(arg.center);\n  arg.autoResize = arg.autoResize === undefined ? true : arg.autoResize;\n  arg.clampBounds = arg.clampBounds === undefined ? true : arg.clampBounds;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get map gcs\n   *\n   * @returns {string}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.gcs = function (arg) {\n    if (arg === undefined) {\n      return m_gcs;\n    }\n    m_gcs = arg;\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get map user interface GCS\n   *\n   * @returns {string}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.uigcs = function () {\n    return m_uigcs;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get root node of the map\n   *\n   * @returns {object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.node = function () {\n    return m_node;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set zoom level of the map\n   *\n   * @returns {Number|geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.zoom = function (val, direction) {\n    var base, evt, recenter = false;\n    if (val === undefined) {\n      return m_zoom;\n    }\n\n    val = Math.min(m_validZoomRange.max, Math.max(val, m_validZoomRange.min));\n    if (val === m_zoom) {\n      return m_this;\n    }\n\n    base = m_this.baseLayer();\n\n    evt = {\n      geo: {},\n      zoomLevel: val,\n      screenPosition: direction,\n      eventType: geo.event.zoom\n    };\n    if (base) {\n      base.renderer().geoTrigger(geo.event.zoom, evt, true);\n    }\n\n    recenter = evt.center;\n    if (!evt.geo.preventDefault) {\n\n      m_zoom = val;\n      m_this._updateBounds();\n\n      m_this.children().forEach(function (child) {\n        child.geoTrigger(geo.event.zoom, evt, true);\n      });\n\n      m_this.modified();\n    }\n\n    if (evt.center) {\n      m_this.center(recenter);\n    } else {\n      m_this.pan({x: 0, y: 0});\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Pan the map by (x: dx, y: dy) pixels.\n   *\n   * @param {Object} delta\n   * @param {bool?} force Disable bounds clamping\n   * @returns {geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.pan = function (delta, force) {\n    var base = m_this.baseLayer(),\n        evt, pt, corner1, corner2;\n\n    if (arg.clampBounds && !force && m_width && m_height) {\n      pt = m_this.displayToGcs({\n        x: delta.x,\n        y: delta.y\n      });\n\n      corner1 = m_this.gcsToDisplay({\n        x: -180,\n        y: 82\n      });\n      corner2 = m_this.gcsToDisplay({\n        x: 180,\n        y: -82\n      });\n\n      if (corner1.x > 0 && corner2.x < m_width) {\n        // if the map is too small horizontally\n        delta.x = (-corner1.x + m_width - corner2.x) / 2;\n      } else {\n        delta.x = Math.max(Math.min(delta.x, -corner1.x), m_width - corner2.x);\n      }\n      if (corner1.y > 0 && corner2.y < m_height) {\n        // if the map is too small horizontally\n        delta.y = (-corner1.y + m_height - corner2.y) / 2;\n      } else {\n        delta.y = Math.max(Math.min(delta.y, -corner1.y), m_height - corner2.y);\n      }\n    }\n\n    evt = {\n      geo: {},\n      screenDelta: delta,\n      eventType: geo.event.pan\n    };\n    // first pan the base layer\n    if (base) {\n      base.renderer().geoTrigger(geo.event.pan, evt, true);\n    }\n\n    // If the base renderer says the pan is invalid, then cancel the action.\n    if (evt.geo.preventDefault) {\n      return;\n    }\n    m_center = m_this.displayToGcs({\n      x: m_width / 2,\n      y: m_height / 2\n    });\n    m_this._updateBounds();\n\n    m_this.children().forEach(function (child) {\n      child.geoTrigger(geo.event.pan, evt, true);\n    });\n\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Set center of the map to the given geographic coordinates, or get the\n   * current center.  Uses bare objects {x: 0, y: 0}.\n   *\n   * @param {Object} coordinates\n   * @returns {Object|geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.center = function (coordinates, force) {\n    var newCenter, currentCenter;\n\n    if (coordinates === undefined) {\n      return m_center;\n    }\n\n    // get the screen coordinates of the new center\n    coordinates = geo.util.normalizeCoordinates(coordinates);\n    newCenter = m_this.gcsToDisplay(coordinates);\n    currentCenter = m_this.gcsToDisplay(m_center);\n\n    // call the pan method\n    m_this.pan({\n      x: currentCenter.x - newCenter.x,\n      y: currentCenter.y - newCenter.y\n    }, force);\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Add layer to the map\n   *\n   * @param {geo.layer} layer to be added to the map\n   * @return {geom.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.createLayer = function (layerName, arg) {\n    var newLayer = geo.createLayer(\n      layerName, m_this, arg);\n\n    if (newLayer !== null || newLayer !== undefined) {\n      newLayer._resize(m_x, m_y, m_width, m_height);\n    } else {\n      return null;\n    }\n\n    if (newLayer.referenceLayer() || m_this.children().length === 0) {\n      m_this.baseLayer(newLayer);\n    }\n    m_this.addChild(newLayer);\n    m_this.modified();\n\n    // TODO: need a better way to set the initial coordinates of a layer\n    if (!newLayer.referenceLayer()) {\n      m_this.center(m_this.center());\n    }\n\n    m_this.geoTrigger(geo.event.layerAdd, {\n      type: geo.event.layerAdd,\n      target: m_this,\n      layer: newLayer\n    });\n\n    return newLayer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Remove layer from the map\n   *\n   * @param {geo.layer} layer that should be removed from the map\n   * @return {geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.deleteLayer = function (layer) {\n\n    if (layer !== null && layer !== undefined) {\n      layer._exit();\n\n      m_this.removeChild(layer);\n\n      m_this.modified();\n\n      m_this.geoTrigger(geo.event.layerRemove, {\n        type: geo.event.layerRemove,\n        target: m_this,\n        layer: layer\n      });\n    }\n\n    /// Return deleted layer (similar to createLayer) as in the future\n    /// we may provide extension of this method to support deletion of\n    /// layer using id or some sort.\n    return layer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Toggle visibility of a layer\n   *\n   *  @param {geo.layer} layer\n   *  @returns {Boolean}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.toggle = function (layer) {\n    if (layer !== null && layer !== undefined) {\n      layer.visible(!layer.visible());\n      m_this.modified();\n\n      m_this.geoTrigger(geo.event.layerToggle, {\n        type: geo.event.layerToggle,\n        target: m_this,\n        layer: layer\n      });\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Resize map\n   *\n   * @param {Number} x x-offset in display space\n   * @param {Number} y y-offset in display space\n   * @param {Number} w width in display space\n   * @param {Number} h height in display space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.resize = function (x, y, w, h) {\n    var i, layers = m_this.children();\n\n    m_x = x;\n    m_y  = y;\n    m_width = w;\n    m_height = h;\n\n    for (i = 0; i < layers.length; i += 1) {\n      layers[i]._resize(x, y, w, h);\n    }\n\n    m_this.geoTrigger(geo.event.resize, {\n      type: geo.event.resize,\n      target: m_this,\n      x: m_x,\n      y: m_y,\n      width: w,\n      height: h\n    });\n\n    m_this._updateBounds();\n    m_this.pan({x: 0, y: 0});\n    m_this.modified();\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert from gcs coordinates to display coordinates\n   *\n   * @param {*} input {[geo.latlng], [{x:_x, y: _y}], [x1,y1, x2, y2]}\n   * @return {object}\n   *\n   * @note Currently only lat-lon inputs are supported\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.gcsToDisplay = function (input) {\n    var world, output;\n\n    /// Now handle different data types\n    if ((input instanceof Array &&\n         input.length > 0) || input instanceof Object) {\n      world = m_baseLayer.toLocal(input);\n      output = m_baseLayer.renderer().worldToDisplay(world);\n    } else {\n      /// Everything else\n      throw \"Conversion method latLonToDisplay does not handle \" + input;\n    }\n\n    return output;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert from display to latitude longitude coordinates\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.displayToGcs = function (input) {\n    var output;\n\n    /// Now handle different data types\n    if ((input instanceof Array && input.length > 0) ||\n         input instanceof Object) {\n      output = m_baseLayer.renderer().displayToWorld(input);\n      output = m_baseLayer.fromLocal(output);\n    } else {\n      throw \"Conversion method displayToGcs does not handle \" + input;\n    }\n    return output;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Queries each layer for information at this location.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.query = function () {\n    // TODO Implement this\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Sets or gets base layer for this map\n   *\n   * @param {geo.layer} baseLayer optional\n   * @returns {geo.map|geo.layer}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.baseLayer = function (baseLayer) {\n    var save;\n    if (baseLayer !== undefined) {\n\n      // The GCS of the layer must match the map\n      if (m_gcs !== baseLayer.gcs()) {\n        m_this.gcs(baseLayer.gcs());\n      }\n\n      m_baseLayer = baseLayer;\n\n      // Set the layer as the reference layer\n      m_baseLayer.referenceLayer(true);\n\n      if (arg.center) {\n        // This assumes that the base layer is initially centered at\n        // (0, 0).  May want to add an explicit call to the base layer\n        // to set a given center.\n        m_this.center(arg.center, true);\n      }\n      save = m_zoom;\n      m_zoom = null;\n      m_this.zoom(save);\n\n      m_this._updateBounds();\n\n      // This forces the map into a state with valid bounds\n      // when clamping is on.  The original call to center\n      // is forced to initialize the camera position in the\n      // base layer so no adjustment is done there.\n      m_this.pan({x: 0, y: 0});\n      return m_this;\n    }\n    return m_baseLayer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Manually force to render map\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.draw = function () {\n    var i, layers = m_this.children();\n\n    m_this.geoTrigger(geo.event.draw, {\n        type: geo.event.draw,\n        target: m_this\n      }\n    );\n\n    m_this._update();\n\n    for (i = 0; i < layers.length; i += 1) {\n      layers[i].draw();\n    }\n\n    m_this.geoTrigger(geo.event.drawEnd, {\n        type: geo.event.drawEnd,\n        target: m_this\n      }\n    );\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Attach a file reader to a layer in the map to be used as a drop target.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.fileReader = function (readerType, opts) {\n    var layer, renderer;\n    opts = opts || {};\n    if (!readerType) {\n      return m_fileReader;\n    }\n    layer = opts.layer;\n    if (!layer) {\n      renderer = opts.renderer;\n      if (!renderer) {\n        renderer = \"d3\";\n      }\n      layer = m_this.createLayer(\"feature\", {renderer: renderer});\n    }\n    opts.layer = layer;\n    opts.renderer = renderer;\n    m_fileReader = geo.createFileReader(readerType, opts);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize the map\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    var i;\n\n    if (m_node === undefined || m_node === null) {\n      throw \"Map require DIV node\";\n    }\n\n    if (arg !== undefined && arg.layers !== undefined) {\n      for (i = 0; i < arg.layers.length; i += 1) {\n        if (i === 0) {\n          m_this.baseLayer(arg.layers[i]);\n        }\n\n        m_this.addLayer(arg.layers[i]);\n      }\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update map\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function (request) {\n    var i, layers = m_this.children();\n    for (i = 0; i < layers.length; i += 1) {\n      layers[i]._update(request);\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Exit this map\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.exit = function () {\n    var i, layers = m_this.children();\n    for (i = 0; i < layers.length; i += 1) {\n      layers[i]._exit();\n    }\n    if (m_this.interactor()) {\n      m_this.interactor().destroy();\n      m_this.interactor(null);\n    }\n    m_this.node().off(\".geo\");\n    $(window).off(\"resize\", resizeSelf);\n    s_exit();\n  };\n\n  this._init(arg);\n\n  // set up drag/drop handling\n  this.node().on(\"dragover.geo\", function (e) {\n    var evt = e.originalEvent;\n\n    if (m_this.fileReader()) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      evt.dataTransfer.dropEffect = \"copy\";\n    }\n  })\n  .on(\"drop.geo\", function (e) {\n    var evt = e.originalEvent, reader = m_this.fileReader(),\n        i, file;\n\n    function done() {\n      m_this.draw();\n    }\n\n    if (reader) {\n      evt.stopPropagation();\n      evt.preventDefault();\n\n      for (i = 0; i < evt.dataTransfer.files.length; i += 1) {\n        file = evt.dataTransfer.files[i];\n        if (reader.canRead(file)) {\n          reader.read(file, done); // to do: trigger event on done\n        }\n      }\n    }\n  });\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the map interactor\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.interactor = function (arg) {\n    if (arg === undefined) {\n      return m_interactor;\n    }\n    m_interactor = arg;\n\n    // this makes it possible to set a null interactor\n    // i.e. map.interactor(null);\n    if (m_interactor) {\n      m_interactor.map(m_this);\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the map clock\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.clock = function (arg) {\n    if (arg === undefined) {\n      return m_clock;\n    }\n    m_clock = arg;\n\n    if (m_clock) {\n      m_clock.object(m_this);\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the min/max zoom range.\n   *\n   * @param {Object} arg {min: minimumzoom, max: maximumzom}\n   * @returns {Object|geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.zoomRange = function (arg) {\n    if (arg === undefined) {\n      return $.extend({}, m_validZoomRange);\n    }\n    m_validZoomRange.min = arg.min;\n    m_validZoomRange.max = arg.max;\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Start an animated zoom/pan.\n   *\n   * Options:\n   * <pre>\n   *   opts = {\n   *     center: { x: ... , y: ... } // the new center\n   *     zoom: ... // the new zoom level\n   *     duration: ... // the duration (in ms) of the transition\n   *     ease: ... // an easing function [0, 1] -> [0, 1]\n   *   }\n   * </pre>\n   *\n   * Call with no arguments to return the current transition information.\n   *\n   * @param {object?} opts\n   * @returns {geo.map}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.transition = function (opts) {\n\n    if (opts === undefined) {\n      return m_transition;\n    }\n\n    if (m_transition) {\n      m_queuedTransition = opts;\n      return m_this;\n    }\n\n    function interp1(p0, p1, t) {\n      return p0 + (p1 - p0) * t;\n    }\n    function defaultInterp(p0, p1) {\n      return function (t) {\n        return [\n          interp1(p0[0], p1[0], t),\n          interp1(p0[1], p1[1], t),\n          interp1(p0[2], p1[2], t)\n        ];\n      };\n    }\n\n    // Transform zoom level into z-coordinate and inverse\n    function zoom2z(z) {\n      return 360 * Math.pow(2, -1 - z);\n    }\n    function z2zoom(z) {\n      return -1 - Math.log2(z / 360);\n    }\n\n    var defaultOpts = {\n      center: m_this.center(),\n      zoom: m_this.zoom(),\n      duration: 1000,\n      ease: function (t) {\n        return t;\n      },\n      interp: defaultInterp,\n      done: null,\n      zCoord: true\n    };\n\n    if (opts.center) {\n      opts.center = geo.util.normalizeCoordinates(opts.center);\n    }\n    $.extend(defaultOpts, opts);\n\n    m_transition = {\n      start: {\n        center: m_this.center(),\n        zoom: m_this.zoom()\n      },\n      end: {\n        center: defaultOpts.center,\n        zoom: defaultOpts.zoom\n      },\n      ease: defaultOpts.ease,\n      zCoord: defaultOpts.zCoord,\n      done: defaultOpts.done,\n      duration: defaultOpts.duration\n    };\n\n    if (defaultOpts.zCoord) {\n      m_transition.interp = defaultOpts.interp(\n        [\n          m_transition.start.center.x,\n          m_transition.start.center.y,\n          zoom2z(m_transition.start.zoom)\n        ],\n        [\n          m_transition.end.center.x,\n          m_transition.end.center.y,\n          zoom2z(m_transition.end.zoom)\n        ]\n      );\n    } else {\n      m_transition.interp = defaultOpts.interp(\n        [\n          m_transition.start.center.x,\n          m_transition.start.center.y,\n          m_transition.start.zoom\n        ],\n        [\n          m_transition.end.center.x,\n          m_transition.end.center.y,\n          m_transition.end.zoom\n        ]\n      );\n    }\n\n    function anim(time) {\n      var done = m_transition.done, next;\n      next = m_queuedTransition;\n\n      if (!m_transition.start.time) {\n        m_transition.start.time = time;\n        m_transition.end.time = time + defaultOpts.duration;\n      }\n      m_transition.time = time - m_transition.start.time;\n      if (time >= m_transition.end.time || next) {\n        if (!next) {\n          m_this.center(m_transition.end.center);\n          m_this.zoom(m_transition.end.zoom);\n        }\n\n        m_transition = null;\n\n        m_this.geoTrigger(geo.event.transitionend, defaultOpts);\n\n        if (done) {\n          done();\n        }\n\n        if (next) {\n          m_queuedTransition = null;\n          m_this.transition(next);\n        }\n\n        return;\n      }\n\n      var z = m_transition.ease(\n        (time - m_transition.start.time) / defaultOpts.duration\n      );\n\n      var p = m_transition.interp(z);\n      if (m_transition.zCoord) {\n        p[2] = z2zoom(p[2]);\n      }\n      m_this.center({\n        x: p[0],\n        y: p[1]\n      });\n      m_this.zoom(p[2]);\n\n      window.requestAnimationFrame(anim);\n    }\n\n    m_this.geoTrigger(geo.event.transitionstart, defaultOpts);\n\n    if (defaultOpts.cancelNavigation) {\n      m_this.geoTrigger(geo.event.transitionend, defaultOpts);\n      return m_this;\n    } else if (defaultOpts.cancelAnimation) {\n      // run the navigation synchronously\n      defaultOpts.duration = 0;\n      anim(0);\n    } else {\n      window.requestAnimationFrame(anim);\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update the internally cached map bounds.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._updateBounds = function () {\n    m_bounds.lowerLeft = m_this.displayToGcs({\n      x: 0,\n      y: m_height\n    });\n    m_bounds.lowerRight = m_this.displayToGcs({\n      x: m_width,\n      y: m_height\n    });\n    m_bounds.upperLeft = m_this.displayToGcs({\n      x: 0,\n      y: 0\n    });\n    m_bounds.upperRight = m_this.displayToGcs({\n      x: m_width,\n      y: 0\n    });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the locations of the current map corners as latitudes/longitudes.\n   * The return value of this function is an object as follows: ::\n   *\n   *    {\n   *        lowerLeft: {x: ..., y: ...},\n   *        upperLeft: {x: ..., y: ...},\n   *        lowerRight: {x: ..., y: ...},\n   *        upperRight: {x: ..., y: ...}\n   *    }\n   *\n   * @todo Provide a setter\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.bounds = function () {\n    return m_bounds;\n  };\n\n\n  this.interactor(arg.interactor || geo.mapInteractor());\n  this.clock(arg.clock || geo.clock());\n\n  function resizeSelf() {\n    m_this.resize(0, 0, m_node.width(), m_node.height());\n  }\n\n  if (arg.autoResize) {\n    $(window).resize(resizeSelf);\n  }\n\n  return this;\n};\n\n/**\n * General object specification for map types.  Any additional\n * values in the object are passed to the map constructor.\n * @typedef geo.map.spec\n * @type {object}\n * @property {object[]} [data=[]] The default data array to\n * apply to each feature if none exists\n * @property {geo.layer.spec[]} [layers=[]] Layers to create\n */\n\n/**\n * Create a map from an object.  Any errors in the creation\n * of the map will result in returning null.\n * @param {geo.map.spec} spec The object specification\n * @returns {geo.map|null}\n */\ngeo.map.create = function (spec) {\n  \"use strict\";\n\n  var map = geo.map(spec);\n\n  if (!map) {\n    console.warn(\"Could not create map.\");\n    return null;\n  }\n\n  spec.data = spec.data || [];\n  spec.layers = spec.layers || [];\n\n  spec.layers.forEach(function (l) {\n    l.data = l.data || spec.data;\n    l.layer = geo.layer.create(map, l);\n  });\n\n  return map;\n};\n\ninherit(geo.map, geo.sceneObject);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class feature\n *\n * @class\n * @extends geo.sceneObject\n * @returns {geo.feature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.feature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.feature)) {\n    return new geo.feature(arg);\n  }\n  geo.sceneObject.call(this);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  arg = arg || {};\n\n  var m_this = this,\n      s_exit = this._exit,\n      m_selectionAPI = arg.selectionAPI === undefined ? false : arg.selectionAPI,\n      m_style = {},\n      m_layer = arg.layer === undefined ? null : arg.layer,\n      m_gcs = arg.gcs === undefined ? \"EPSG:4326\" : arg.gcs,\n      m_visible = arg.visible === undefined ? true : arg.visible,\n      m_bin = arg.bin === undefined ? 0 : arg.bin,\n      m_renderer = arg.renderer === undefined ? null : arg.renderer,\n      m_dataTime = geo.timestamp(),\n      m_buildTime = geo.timestamp(),\n      m_updateTime = geo.timestamp(),\n      m_selectedFeatures = [];\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private method to bind mouse handlers on the map element.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._bindMouseHandlers = function () {\n\n    // Don't bind handlers for improved performance on features that don't\n    // require it.\n    if (!m_selectionAPI) {\n      return;\n    }\n\n    // First unbind to be sure that the handlers aren't bound twice.\n    m_this._unbindMouseHandlers();\n\n    m_this.geoOn(geo.event.mousemove, m_this._handleMousemove);\n    m_this.geoOn(geo.event.mouseclick, m_this._handleMouseclick);\n    m_this.geoOn(geo.event.brushend, m_this._handleBrushend);\n    m_this.geoOn(geo.event.brush, m_this._handleBrush);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private method to unbind mouse handlers on the map element.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._unbindMouseHandlers = function () {\n    m_this.geoOff(geo.event.mousemove, m_this._handleMousemove);\n    m_this.geoOff(geo.event.mouseclick, m_this._handleMouseclick);\n    m_this.geoOff(geo.event.brushend, m_this._handleBrushend);\n    m_this.geoOff(geo.event.brush, m_this._handleBrush);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * For binding mouse events, use functions with\n   * the following call signatures:\n   *\n   * function handler(arg) {\n   *   // arg.data - the data object of the feature\n   *   // arg.index - the index inside the data array of the featue\n   *   // arg.mouse - mouse information object (see src/core/mapInteractor.js)\n   * }\n   *\n   * i.e.\n   *\n   * feature.geoOn(geo.event.feature.mousemove, function (arg) {\n   *   // do something with the feature marker.\n   * });\n   */\n  ////////////////////////////////////////////////////////////////////////////\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Search for features containing the given point.\n   *\n   * Returns an object: ::\n   *\n   *   {\n   *     data: [...] // an array of data objects for matching features\n   *     index: [...] // an array of indices of the matching features\n   *   }\n   *\n   * @argument {Object} coordinate\n   * @returns {Object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.pointSearch = function () {\n    // base class method does nothing\n    return {\n      index: [],\n      found: []\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private mousemove handler\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMousemove = function () {\n    var mouse = m_this.layer().map().interactor().mouse(),\n        data = m_this.data(),\n        over = m_this.pointSearch(mouse.geo),\n        newFeatures = [], oldFeatures = [], lastTop = -1, top = -1;\n\n    // Get the index of the element that was previously on top\n    if (m_selectedFeatures.length) {\n      lastTop = m_selectedFeatures[m_selectedFeatures.length - 1];\n    }\n\n    // There are probably faster ways of doing this:\n    newFeatures = over.index.filter(function (i) {\n      return m_selectedFeatures.indexOf(i) < 0;\n    });\n    oldFeatures = m_selectedFeatures.filter(function (i) {\n      return over.index.indexOf(i) < 0;\n    });\n\n    geo.feature.eventID += 1;\n    // Fire events for mouse in first.\n    newFeatures.forEach(function (i, idx) {\n      m_this.geoTrigger(geo.event.feature.mouseover, {\n        data: data[i],\n        index: i,\n        mouse: mouse,\n        eventID: geo.feature.eventID,\n        top: idx === newFeatures.length - 1\n      }, true);\n    });\n\n    geo.feature.eventID += 1;\n    // Fire events for mouse out next\n    oldFeatures.forEach(function (i, idx) {\n      m_this.geoTrigger(geo.event.feature.mouseout, {\n        data: data[i],\n        index: i,\n        mouse: mouse,\n        eventID: geo.feature.eventID,\n        top: idx === oldFeatures.length - 1\n      }, true);\n    });\n\n    geo.feature.eventID += 1;\n    // Fire events for mouse move last\n    over.index.forEach(function (i, idx) {\n      m_this.geoTrigger(geo.event.feature.mousemove, {\n        data: data[i],\n        index: i,\n        mouse: mouse,\n        eventID: geo.feature.eventID,\n        top: idx === over.index.length - 1\n      }, true);\n    });\n\n    // Replace the selected features array\n    m_selectedFeatures = over.index;\n\n    // Get the index of the element that is now on top\n    if (m_selectedFeatures.length) {\n      top = m_selectedFeatures[m_selectedFeatures.length - 1];\n    }\n\n    if (lastTop !== top) {\n      // The element on top changed so we need to fire mouseon/mouseoff\n      if (lastTop !== -1) {\n        m_this.geoTrigger(geo.event.feature.mouseoff, {\n          data: data[lastTop],\n          index: lastTop,\n          mouse: mouse\n        }, true);\n      }\n\n      if (top !== -1) {\n        m_this.geoTrigger(geo.event.feature.mouseon, {\n          data: data[top],\n          index: top,\n          mouse: mouse\n        }, true);\n      }\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private mouseclick handler\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleMouseclick = function () {\n    var mouse = m_this.layer().map().interactor().mouse(),\n        data = m_this.data(),\n        over = m_this.pointSearch(mouse.geo);\n\n    geo.feature.eventID += 1;\n    over.index.forEach(function (i, idx) {\n      m_this.geoTrigger(geo.event.feature.mouseclick, {\n        data: data[i],\n        index: i,\n        mouse: mouse,\n        eventID: geo.feature.eventID,\n        top: idx === over.index.length - 1\n      }, true);\n    });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private brush handler.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleBrush = function (brush) {\n    var idx = m_this.boxSearch(brush.gcs.lowerLeft, brush.gcs.upperRight),\n        data = m_this.data();\n\n    geo.feature.eventID += 1;\n    idx.forEach(function (i, idx) {\n      m_this.geoTrigger(geo.event.feature.brush, {\n        data: data[i],\n        index: i,\n        mouse: brush.mouse,\n        brush: brush,\n        eventID: geo.feature.eventID,\n        top: idx === idx.length - 1\n      }, true);\n    });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private brushend handler.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._handleBrushend = function (brush) {\n    var idx = m_this.boxSearch(brush.gcs.lowerLeft, brush.gcs.upperRight),\n        data = m_this.data();\n\n    geo.feature.eventID += 1;\n    idx.forEach(function (i, idx) {\n      m_this.geoTrigger(geo.event.feature.brushend, {\n        data: data[i],\n        index: i,\n        mouse: brush.mouse,\n        brush: brush,\n        eventID: geo.feature.eventID,\n        top: idx === idx.length - 1\n      }, true);\n    });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set style used by the feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.style = function (arg1, arg2) {\n    if (arg1 === undefined) {\n      return m_style;\n    } else if (typeof arg1 === \"string\" && arg2 === undefined) {\n      return m_style[arg1];\n    } else if (arg2 === undefined) {\n      m_style = $.extend({}, m_style, arg1);\n      m_this.modified();\n      return m_this;\n    } else {\n      m_style[arg1] = arg2;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * A uniform getter that always returns a function even for constant styles.\n   * Maybe extend later to support accessor-like objects.  If undefined input,\n   * return all the styles as an object.\n   *\n   * @param {string|undefined} key\n   * @return {function}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.style.get = function (key) {\n    var tmp, out;\n    if (key === undefined) {\n      var all = {}, k;\n      for (k in m_style) {\n        if (m_style.hasOwnProperty(k)) {\n          all[k] = m_this.style.get(k);\n        }\n      }\n      return all;\n    }\n    if (key.toLowerCase().match(/color$/)) {\n      if (geo.util.isFunction(m_style[key])) {\n        tmp = geo.util.ensureFunction(m_style[key]);\n        out = function () {\n          return geo.util.convertColor(\n            tmp.apply(this, arguments)\n          );\n        };\n      } else {\n        // if the color is not a function, only convert it once\n        out = geo.util.ensureFunction(geo.util.convertColor(m_style[key]));\n      }\n    } else {\n      out = geo.util.ensureFunction(m_style[key]);\n    }\n    return out;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get layer referenced by the feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.layer = function () {\n    return m_layer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get renderer used by the feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.renderer = function () {\n    return m_renderer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get list of drawables or nodes that are context/api specific.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.drawables = function () {\n    return m_this._drawables();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set projection of the feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.gcs = function (val) {\n    if (val === undefined) {\n      return m_gcs;\n    } else {\n      m_gcs = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set visibility of the feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.visible = function (val) {\n    if (val === undefined) {\n      return m_visible;\n    } else {\n      m_visible = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set bin of the feature\n   *\n   * Bin number is typically used for sorting the order of rendering\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.bin = function (val) {\n    if (val === undefined) {\n      return m_bin;\n    } else {\n      m_bin = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set timestamp of data change\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.dataTime = function (val) {\n    if (val === undefined) {\n      return m_dataTime;\n    } else {\n      m_dataTime = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set timestamp of last time build happened\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.buildTime = function (val) {\n    if (val === undefined) {\n      return m_buildTime;\n    } else {\n      m_buildTime = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set timestamp of last time update happened\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.updateTime = function (val) {\n    if (val === undefined) {\n      return m_updateTime;\n    } else {\n      m_updateTime = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set data\n   *\n   * @returns {Array}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.data = function (data) {\n    if (data === undefined) {\n      return m_this.style(\"data\") || [];\n    } else {\n      m_this.style(\"data\", data);\n      m_this.dataTime().modified();\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Query if the selection API is enabled for this feature.\n   * @returns {bool}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.selectionAPI = function () {\n    return m_selectionAPI;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   *\n   * Derived class should implement this\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    if (!m_layer) {\n      throw \"Feature requires a valid layer\";\n    }\n    m_style = $.extend({},\n                {\"opacity\": 1.0}, arg.style === undefined ? {} :\n                arg.style);\n    m_this._bindMouseHandlers();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * Derived class should implement this\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get context specific drawables\n   *\n   * Derived class should implement this\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._drawables = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * Derived class should implement this\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Destroy\n   *\n   * Derived class should implement this\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this._unbindMouseHandlers();\n    m_selectedFeatures = [];\n    m_style = {};\n    arg = {};\n    s_exit();\n  };\n\n  this._init(arg);\n  return this;\n};\n\n/**\n * The most recent feature event triggered.\n * @type {number}\n */\ngeo.feature.eventID = 0;\n\n/**\n * General object specification for feature types.\n * @typedef geo.feature.spec\n * @type {object}\n * @property {string} type A supported feature type.\n * @property {object[]} [data=[]] An array of arbitrary objects used to\n * construct the feature.  These objects (and their associated\n * indices in the array) will be passed back to style and attribute\n * accessors provided by the user.  In general the number of\n * \"markers\" drawn will be equal to the length of this array.\n */\n\n/**\n * Create a feature from an object.  The implementation here is\n * meant to define the general interface of creating features\n * from a javascript object.  See documentation from individual\n * feature types for specific details.  In case of an error in\n * the arguments this method will return null;\n * @param {geo.layer} layer The layer to add the feature to\n * @param {geo.feature.spec} [spec={}] The object specification\n * @returns {geo.feature|null}\n */\ngeo.feature.create = function (layer, spec) {\n  \"use strict\";\n\n  var type = spec.type;\n\n  // Check arguments\n  if (!layer instanceof geo.layer) {\n    console.warn(\"Invalid layer\");\n    return null;\n  }\n  if (typeof spec !== \"object\") {\n    console.warn(\"Invalid spec\");\n    return null;\n  }\n  var feature = layer.createFeature(type);\n  if (!feature) {\n    console.warn(\"Could not create feature type '\" + type + \"'\");\n    return null;\n  }\n\n  spec = spec || {};\n  spec.data = spec.data || [];\n  return feature.style(spec);\n};\n\ninherit(geo.feature, geo.sceneObject);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class pointFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.pointFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.pointFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.pointFeature)) {\n    return new geo.pointFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init,\n      m_rangeTree = null,\n      s_data = this.data,\n      s_style = this.style,\n      m_maxRadius = 0;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set position\n   *\n   * @returns {geo.pointFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.position = function (val) {\n    if (val === undefined) {\n      return m_this.style(\"position\");\n    } else {\n      m_this.style(\"position\", val);\n      m_this.dataTime().modified();\n      m_this.modified();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update the current range tree object.  Should be called whenever the\n   * data changes.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._updateRangeTree = function () {\n    var pts, position,\n        radius = m_this.style.get(\"radius\"),\n        stroke = m_this.style.get(\"stroke\"),\n        strokeWidth = m_this.style.get(\"strokeWidth\");\n\n    position = m_this.position();\n\n    m_maxRadius = 0;\n\n    // create an array of positions in geo coordinates\n    pts = m_this.data().map(function (d, i) {\n      var pt = position(d);\n      pt.idx = i;\n\n      // store the maximum point radius\n      m_maxRadius = Math.max(\n        m_maxRadius,\n        radius(d, i) + (stroke(d, i) ? strokeWidth(d, i) : 0)\n      );\n\n      return pt;\n    });\n\n    m_rangeTree = new geo.util.RangeTree(pts);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns an array of datum indices that contain the given point.\n   * Largely adapted from wigglemaps pointQuerier:\n   *\n   * https://github.com/dotskapes/wigglemaps/blob/cf5bed3fbfe2c3e48d31799462a80c564be1fb60/src/query/PointQuerier.js\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.pointSearch = function (p) {\n    var min, max, data, idx = [], box, found = [], ifound = [], map, pt,\n        stroke = m_this.style.get(\"stroke\"),\n        strokeWidth = m_this.style.get(\"strokeWidth\"),\n        radius = m_this.style.get(\"radius\");\n\n    if (!m_this.selectionAPI()) {\n      return [];\n    }\n\n    data = m_this.data();\n    if (!data || !data.length) {\n      return {\n        found: [],\n        index: []\n      };\n    }\n\n    map = m_this.layer().map();\n    pt = map.gcsToDisplay(p);\n\n    // Get the upper right corner in geo coordinates\n    min = map.displayToGcs({\n      x: pt.x - m_maxRadius,\n      y: pt.y + m_maxRadius   // GCS coordinates are bottom to top\n    });\n\n    // Get the lower left corner in geo coordinates\n    max = map.displayToGcs({\n      x: pt.x + m_maxRadius,\n      y: pt.y - m_maxRadius\n    });\n\n    // Find points inside the bounding box\n    box = new geo.util.Box(geo.util.vect(min.x, min.y), geo.util.vect(max.x, max.y));\n    m_rangeTree.search(box).forEach(function (q) {\n      idx.push(q.idx);\n    });\n\n    // Filter by circular region\n    idx.forEach(function (i) {\n      var d = data[i],\n          p = m_this.position()(d, i),\n          dx, dy, rad;\n\n      rad = radius(data[i], i);\n      rad += stroke(data[i], i) ? strokeWidth(data[i], i) : 0;\n      p = map.gcsToDisplay(p);\n      dx = p.x - pt.x;\n      dy = p.y - pt.y;\n      if (Math.sqrt(dx * dx + dy * dy) <= rad) {\n        found.push(d);\n        ifound.push(i);\n      }\n    });\n\n    return {\n      data: found,\n      index: ifound\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns an array of datum indices that are contained in the given box.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.boxSearch = function (lowerLeft, upperRight) {\n    var pos = m_this.position(),\n        idx = [];\n    // TODO: use the range tree\n    m_this.data().forEach(function (d, i) {\n      var p = pos(d);\n      if (p.x >= lowerLeft.x &&\n          p.x <= upperRight.x &&\n          p.y >= lowerLeft.y &&\n          p.y <= upperRight.y\n      ) {\n        idx.push(i);\n      }\n    });\n    return idx;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Overloaded data method that updates the internal range tree on write.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.data = function (data) {\n    if (data === undefined) {\n      return s_data();\n    }\n    s_data(data);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Overloaded style method that updates the internal range tree on write.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.style = function (arg1, arg2) {\n    var val = s_style(arg1, arg2);\n    if (val === m_this && m_this.selectionAPI()) {\n      m_this._updateRangeTree();\n    }\n    return val;\n  };\n  this.style.get = s_style.get;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns the bounding box for a given datum in screen coordinates as an\n   * object: ::\n   *\n   *   {\n   *     min: {\n   *       x: value,\n   *       y: value\n   *     },\n   *     max: {\n   *       x: value,\n   *       y: value\n   *     }\n   *   }\n   *\n   * @returns {object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._boundingBox = function (d) {\n    var pt, radius;\n\n    // get the position in geo coordinates\n    pt = m_this.position()(d);\n\n    // convert to screen coordinates\n    pt = m_this.layer().map().gcsToDisplay(pt);\n\n    // get the radius of the points (should we add stroke width?)\n    radius = m_this.style().radius(d);\n\n    return {\n      min: {\n        x: pt.x - radius,\n        y: pt.y - radius\n      },\n      max: {\n        x: pt.x + radius,\n        y: pt.y + radius\n      }\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n\n    var defaultStyle = $.extend(\n      {},\n      {\n        radius: 10.0,\n        stroke: true,\n        strokeColor: { r: 0.0, g: 1.0, b: 0.0 },\n        strokeWidth: 2.0,\n        strokeOpacity: 1.0,\n        fillColor: { r: 1.0, g: 0.0, b: 0.0 },\n        fill: true,\n        fillOpacity: 1.0,\n        sprites: false,\n        sprites_image: null,\n        position: function (d) { return d; }\n      },\n      arg.style === undefined ? {} : arg.style\n    );\n\n    if (arg.position !== undefined) {\n      defaultStyle.position = arg.position;\n    }\n\n    m_this.style(defaultStyle);\n    m_this.dataTime().modified();\n  };\n\n  return m_this;\n};\n\ngeo.event.pointFeature = $.extend({}, geo.event.feature);\n\n/**\n * Object specification for a point feature.\n *\n * @extends geo.feature.spec // need to make a jsdoc plugin for this to work\n * @typedef geo.pointFeature.spec\n * @type {object}\n */\n\n/**\n * Create a pointFeature from an object.\n * @see {@link geo.feature.create}\n * @param {geo.layer} layer The layer to add the feature to\n * @param {geo.pointFeature.spec} spec The object specification\n * @returns {geo.pointFeature|null}\n */\ngeo.pointFeature.create = function (layer, renderer, spec) {\n  \"use strict\";\n\n  spec.type = \"point\";\n  return geo.feature.create(layer, spec);\n};\n\ninherit(geo.pointFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class lineFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.lineFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.lineFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.lineFeature)) {\n    return new geo.lineFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set line accessor\n   *\n   * @returns {geo.pointFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.line = function (val) {\n    if (val === undefined) {\n      return m_this.style(\"line\");\n    } else {\n      m_this.style(\"line\", val);\n      m_this.dataTime().modified();\n      m_this.modified();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set position accessor\n   *\n   * @returns {geo.pointFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.position = function (val) {\n    if (val === undefined) {\n      return m_this.style(\"position\");\n    } else {\n      m_this.style(\"position\", val);\n      m_this.dataTime().modified();\n      m_this.modified();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns an array of datum indices that contain the given point.\n   * This is a slow implementation with runtime order of the number of\n   * vertices.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.pointSearch = function (p) {\n    var data, pt, map, line, width, indices = [], found = [], pos;\n    data = m_this.data();\n    if (!data || !data.length) {\n      return {\n        found: [],\n        index: []\n      };\n    }\n\n    map = m_this.layer().map();\n    line = m_this.line();\n    width = m_this.style.get(\"strokeWidth\");\n    pos = m_this.position();\n    pt = map.gcsToDisplay(p);\n\n    // minimum l2 distance squared from\n    // q -> line(u, v)\n    function lineDist2(q, u, v) {\n      var t, l2 = dist2(u, v);\n\n      if (l2 < 1) {\n        // u, v are within 1 pixel\n        return dist2(q, u);\n      }\n\n      t = ((q.x - u.x) * (v.x - u.x) + (q.y - u.y) * (v.y - u.y)) / l2;\n      if (t < 0) { return dist2(q, u); }\n      if (t > 1) { return dist2(q, v); }\n      return dist2(\n        q,\n        {\n          x: u.x + t * (v.x - u.x),\n          y: u.y + t * (v.y - u.y)\n        }\n      );\n    }\n\n    // l2 distance squared from u to v\n    function dist2(u, v) {\n      var dx = u.x - v.x,\n          dy = u.y - v.y;\n      return dx * dx + dy * dy;\n    }\n\n    // for each line\n    data.forEach(function (d, index) {\n      var last = null;\n\n      try {\n        line(d, index).forEach(function (current, j) {\n\n          // get the screen coordinates of the current point\n          var p = pos(current, j, d, index);\n          var s = map.gcsToDisplay(p);\n          var r = Math.ceil(width(p, j, d, index) / 2) + 2;\n          r = r * r;\n\n          if (last) {\n            // test the line segment s -> last\n            if (lineDist2(pt, s, last) <= r) {\n\n              // short circuit the loop here\n              throw \"found\";\n            }\n          }\n\n          last = s;\n        });\n      } catch (err) {\n        if (err !== \"found\") {\n          throw err;\n        }\n        found.push(d);\n        indices.push(index);\n      }\n    });\n\n    return {\n      data: found,\n      index: indices\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns an array of line indices that are contained in the given box.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.boxSearch = function (lowerLeft, upperRight, opts) {\n    var pos = m_this.position(),\n        idx = [],\n        line = m_this.line();\n\n    opts = opts || {};\n    opts.partial = opts.partial || false;\n    if (opts.partial) {\n      throw \"Unimplemented query method.\";\n    }\n\n    m_this.data().forEach(function (d, i) {\n      var inside = true;\n      line(d, i).forEach(function (e, j) {\n        if (!inside) { return; }\n        var p = pos(e, j, d, i);\n        if (!(p.x >= lowerLeft.x  &&\n              p.x <= upperRight.x &&\n              p.y >= lowerLeft.y  &&\n              p.y <= upperRight.y)\n        ) {\n          inside = false;\n        }\n      });\n      if (inside) {\n        idx.push(i);\n      }\n    });\n    return idx;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n\n    var defaultStyle = $.extend(\n      {},\n      {\n        \"strokeWidth\": 1.0,\n        // Default to gold color for lines\n        \"strokeColor\": { r: 1.0, g: 0.8431372549, b: 0.0 },\n        \"strokeStyle\": \"solid\",\n        \"strokeOpacity\": 1.0,\n        \"line\": function (d) { return d; },\n        \"position\": function (d) { return d; }\n      },\n      arg.style === undefined ? {} : arg.style\n    );\n\n    if (arg.line !== undefined) {\n      defaultStyle.line = arg.line;\n    }\n\n    if (arg.position !== undefined) {\n      defaultStyle.position = arg.position;\n    }\n\n\n    m_this.style(defaultStyle);\n\n    m_this.dataTime().modified();\n  };\n\n  this._init(arg);\n  return this;\n};\n\n/**\n * Create a lineFeature from an object.\n * @see {@link geo.feature.create}\n * @param {geo.layer} layer The layer to add the feature to\n * @param {geo.lineFeature.spec} spec The object specification\n * @returns {geo.lineFeature|null}\n */\ngeo.lineFeature.create = function (layer, spec) {\n  \"use strict\";\n\n  spec.type = \"line\";\n  return geo.feature.create(layer, spec);\n};\n\ninherit(geo.lineFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class pathFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.pathFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.pathFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.pathFeature)) {\n    return new geo.pathFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      m_position = arg.position === undefined ? [] : arg.position,\n      s_init = this._init;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set positions\n   *\n   * @returns {geo.pathFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.position = function (val) {\n    if (val === undefined) {\n      return m_position;\n    }\n    // Copy incoming array of positions\n    m_position = val;\n    m_this.dataTime().modified();\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n\n    var defaultStyle = $.extend(\n      {},\n      {\n        \"strokeWidth\": function () { return 1; },\n        \"strokeColor\": function () { return { r: 1.0, g: 1.0, b: 1.0 }; }\n      },\n      arg.style === undefined ? {} : arg.style\n    );\n\n    m_this.style(defaultStyle);\n\n    if (m_position) {\n      m_this.dataTime().modified();\n    }\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.pathFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class polygonFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.polygonFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.polygonFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.polygonFeature)) {\n    return new geo.polygonFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      m_position,\n      m_polygon,\n      s_init = this._init,\n      s_data = this.data,\n      m_coordinates = {outer: [], inner: []};\n\n  if (arg.line === undefined) {\n    m_polygon = function (d) {\n      return d;\n    };\n  } else {\n    m_polygon = arg.polygon;\n  }\n\n  if (arg.position === undefined) {\n    m_position = function (d) {\n      return d;\n    };\n  } else {\n    m_position = arg.position;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Override the parent data method to keep track of changes to the\n   * internal coordinates.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.data = function (arg) {\n    var ret = s_data(arg);\n    if (arg !== undefined) {\n      getCoordinates();\n    }\n    return ret;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the internal coordinates whenever the data changes.  For now, we do\n   * the computation in world coordinates, but we will need to work in GCS\n   * for other projections.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function getCoordinates() {\n    var posFunc = m_this.position(),\n        polyFunc = m_this.polygon();\n    m_coordinates = m_this.data().map(function (d, i) {\n      var poly = polyFunc(d);\n      var outer, inner;\n\n      outer = (poly.outer || []).map(function (d0, j) {\n        return posFunc.call(m_this, d0, j, d, i);\n      });\n\n      inner = (poly.inner || []).map(function (hole) {\n        return (hole || []).map(function (d0, k) {\n          return posFunc.call(m_this, d0, k, d, i);\n        });\n      });\n      return {\n        outer: outer,\n        inner: inner\n      };\n    });\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set line accessor\n   *\n   * @returns {geo.pointFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.polygon = function (val) {\n    if (val === undefined) {\n      return m_polygon;\n    } else {\n      m_polygon = val;\n      m_this.dataTime().modified();\n      m_this.modified();\n      getCoordinates();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set position accessor\n   *\n   * @returns {geo.pointFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.position = function (val) {\n    if (val === undefined) {\n      return m_position;\n    } else {\n      m_position = val;\n      m_this.dataTime().modified();\n      m_this.modified();\n      getCoordinates();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Point searce method for selection api.  Returns markers containing the\n   * given point.\n   * @argument {Object} coordinate\n   * @returns {Object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.pointSearch = function (coordinate) {\n    var found = [], indices = [], data = m_this.data();\n    m_coordinates.forEach(function (coord, i) {\n      var inside = geo.util.pointInPolygon(\n        coordinate,\n        coord.outer,\n        coord.inner\n      );\n      if (inside) {\n        indices.push(i);\n        found.push(data[i]);\n      }\n    });\n    return {\n      index: indices,\n      found: found\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n\n    var defaultStyle = $.extend(\n      {},\n      {\n        \"fillColor\": { r: 0.0,  g: 0.5, b: 0.5 },\n        \"fillOpacity\": 1.0\n      },\n      arg.style === undefined ? {} : arg.style\n    );\n\n    m_this.style(defaultStyle);\n\n    if (m_position) {\n      m_this.dataTime().modified();\n    }\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.polygonFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class planeFeature\n *\n * @class\n * @extends geo.polygonFeature\n * @returns {geo.planeFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.planeFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.planeFeature)) {\n    return new geo.planeFeature(arg);\n  }\n  arg = arg || {};\n\n  // Defaults\n  arg.ul = arg.ul === undefined ? [0.0, 1.0, 0.0] : arg.ul;\n  arg.lr = arg.lr === undefined ? [1.0, 0.0, 0.0] : arg.lr;\n  arg.depth = arg.depth === undefined ? 0.0 : arg.depth;\n\n  geo.polygonFeature.call(this, arg);\n\n  var m_this = this,\n      m_origin = [arg.ul.x, arg.lr.y, arg.depth],\n      m_upperLeft = [arg.ul.x, arg.ul.y, arg.depth],\n      m_lowerRight = [arg.lr.x, arg.lr.y, arg.depth],\n      m_defaultDepth = arg.depth,\n      m_drawOnAsyncResourceLoad = arg.drawOnAsyncResourceLoad === undefined ?\n                                    true : false,\n      s_init = this._init;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set origin\n   *\n   * @returns {geo.planeFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.origin = function (val) {\n    if (val === undefined) {\n      return m_origin;\n    } else if (val instanceof Array) {\n      if (val.length > 3 || val.length < 2) {\n        throw \"Upper left point requires point in 2 or 3 dimension\";\n      }\n      m_origin = val.slice(0);\n      if (m_origin.length === 2) {\n        m_origin[2] = m_defaultDepth;\n      }\n    } else if (val instanceof geo.latlng) {\n      m_origin = [val.x(), val.y(), m_defaultDepth];\n    }\n    m_this.dataTime().modified();\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set pt1\n   *\n   * @returns {geo.planeFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.upperLeft = function (val) {\n    if (val === undefined) {\n      return m_upperLeft;\n    } else if (val instanceof Array) {\n      if (val.length > 3 || val.length < 2) {\n        throw \"Upper left point requires point in 2 or 3 dimension\";\n      }\n      m_upperLeft = val.slice(0);\n      if (m_upperLeft.length === 2) {\n        m_upperLeft[2] = m_defaultDepth;\n      }\n    } else if (val instanceof geo.latlng) {\n      m_upperLeft = [val.x(), val.y(), m_defaultDepth];\n    }\n    m_this.dataTime().modified();\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set origin\n   *\n   * @returns {geo.planeFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.lowerRight = function (val) {\n    if (val === undefined) {\n      return m_lowerRight;\n    } else if (val instanceof Array) {\n      if (val.length > 3 || val.length < 2) {\n        throw \"Upper left point requires point in 2 or 3 dimension\";\n      }\n      m_lowerRight = val.slice(0);\n      if (m_lowerRight.length === 2) {\n        m_lowerRight[2] = m_defaultDepth;\n      }\n      m_this.dataTime().modified();\n    } else if (val instanceof geo.latlng) {\n      m_lowerRight = [val.x(), val.y(), m_defaultDepth];\n    }\n    m_this.dataTime().modified();\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set if draw should happen as soon as a async resource is loaded\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.drawOnAsyncResourceLoad = function (val) {\n    if (val === undefined) {\n      return m_drawOnAsyncResourceLoad;\n    } else {\n      m_drawOnAsyncResourceLoad = val;\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    var style = null;\n    s_init.call(m_this, arg);\n    style = m_this.style();\n    if (style.image === undefined) {\n      style.image = null;\n    }\n    m_this.style(style);\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.planeFeature, geo.polygonFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class vectorFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.vectorFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.vectorFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.vectorFeature)) {\n    return new geo.vectorFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init,\n      s_style = this.style;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the accessor for the origin of the vector.  This is the point\n   * that the vector base resides at.  Defaults to (0, 0, 0).\n   * @param {geo.accessor|geo.geoPosition} [accessor] The origin accessor\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.origin = function (val) {\n    if (val === undefined) {\n      return s_style('origin');\n    } else {\n      s_style('origin', val);\n      m_this.dataTime().modified();\n      m_this.modified();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the accessor for the displacement (coordinates) of the vector.\n   * @param {geo.accessor|geo.geoPosition} [accessor] The accessor\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.delta = function (val) {\n    if (val === undefined) {\n      return s_style('delta');\n    } else {\n      s_style('delta', val);\n      m_this.dataTime().modified();\n      m_this.modified();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   * @protected\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n\n    var defaultStyle = $.extend(\n      {},\n      {\n        strokeColor: 'black',\n        strokeWidth: 2.0,\n        strokeOpacity: 1.0,\n        // TODO: define styles for the end markers\n        // originStyle: 'none',\n        // endStyle: 'arrow',\n        origin: {x: 0, y: 0, z: 0},\n        delta: function (d) { return d; },\n        scale: null // size scaling factor (null -> renderer decides)\n      },\n      arg.style === undefined ? {} : arg.style\n    );\n\n    if (arg.origin !== undefined) {\n      defaultStyle.origin = arg.origin;\n    }\n\n    m_this.style(defaultStyle);\n    m_this.dataTime().modified();\n  };\n};\n\ninherit(geo.vectorFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class geomFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.geomFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.geomFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.geomFeature)) {\n    return new geo.geomFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  arg.style = arg.style === undefined ? $.extend({}, {\n    \"color\": [1.0, 1.0, 1.0],\n    \"point_sprites\": false,\n    \"point_sprites_image\": null\n  }, arg.style) : arg.style;\n\n  // Update style\n  this.style(arg.style);\n\n  return this;\n};\n\ninherit(geo.geomFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class graphFeature\n *\n * @class\n * @extends geo.feature\n * @returns {geo.graphFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.graphFeature = function (arg) {\n  \"use strict\";\n\n  if (!(this instanceof geo.graphFeature)) {\n    return new geo.graphFeature(arg);\n  }\n  arg = arg || {};\n  geo.feature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_draw = this.draw,\n      s_style = this.style,\n      m_nodes = null,\n      m_points = null,\n      m_children = function (d) { return d.children; },\n      m_links = [],\n      s_init = this._init,\n      s_exit = this._exit;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n\n    var defaultStyle = $.extend(true, {},\n      {\n        nodes: {\n          radius: 5.0,\n          fill: true,\n          fillColor: { r: 1.0, g: 0.0, b: 0.0 },\n          strokeColor: { r: 0, g: 0, b: 0 }\n        },\n        links: {\n          strokeColor: { r: 0.0, g: 0.0, b: 0.0 }\n        },\n        linkType: \"path\" /* 'path' || 'line' */\n      },\n      arg.style === undefined ? {} : arg.style\n    );\n\n    m_this.style(defaultStyle);\n    m_this.nodes(function (d) { return d; });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Call child _build methods\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    m_this.children().forEach(function (child) {\n      child._build();\n    });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Call child _update methods\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    m_this.children().forEach(function (child) {\n      child._update();\n    });\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Custom _exit method to remove all sub-features\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.data([]);\n    m_links.forEach(function (link) {\n      link._exit();\n      m_this.removeChild(link);\n    });\n    m_links = [];\n    m_points._exit();\n    m_this.removeChild(m_points);\n    s_exit();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set style\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.style = function (arg, arg2) {\n    var out = s_style.call(m_this, arg, arg2);\n    if (out !== m_this) {\n      return out;\n    }\n    // set styles for sub-features\n    m_points.style(arg.nodes);\n    m_links.forEach(function (l) {\n      l.style(arg.links);\n    });\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set links accessor.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.links = function (arg) {\n    if (arg === undefined) {\n      return m_children;\n    }\n\n    m_children = geo.util.ensureFunction(arg);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set nodes\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.nodes = function (val) {\n    if (val === undefined) {\n      return m_nodes;\n    }\n    m_nodes = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get internal node feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.nodeFeature = function () {\n    return m_points;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get internal link features\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.linkFeatures = function () {\n    return m_links;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build the feature for drawing\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.draw = function () {\n\n    var layer = m_this.layer(),\n        data = m_this.data(),\n        nLinks = 0,\n        style;\n\n    // get the feature style object\n    style = m_this.style();\n\n    // Bind data to the point nodes\n    m_points.data(data);\n    m_points.style(style.nodes);\n\n    // get links from node connections\n    data.forEach(function (source) {\n      (source.children || []).forEach(function (target) {\n        var link;\n        nLinks += 1;\n        if (m_links.length < nLinks) {\n          link = geo.createFeature(\n            style.linkType, layer, layer.renderer()\n          ).style(style.links);\n          m_this.addChild(link);\n          m_links.push(link);\n        }\n        m_links[nLinks - 1].data([source, target]);\n      });\n    });\n\n    m_links.splice(nLinks, m_links.length - nLinks).forEach(function (l) {\n      l._exit();\n      m_this.removeChild(l);\n    });\n\n    s_draw();\n    return m_this;\n  };\n\n  m_points = geo.createFeature(\n    \"point\",\n    this.layer(),\n    this.layer().renderer()\n  );\n  m_this.addChild(m_points);\n\n  if (arg.nodes) {\n    this.nodes(arg.nodes);\n  }\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.graphFeature, geo.feature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Transform geometric data of a feature from source projection to destination\n * projection.\n *\n * @namespace\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.transform = {};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Custom transform for a feature used for OpenStreetMap\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.transform.osmTransformFeature = function (destGcs, feature, inplace) {\n  /// TODO\n  /// Currently we make assumption that incoming feature is in 4326\n  /// which may not be true.\n\n  \"use strict\";\n\n  if (!feature) {\n    console.log(\"[warning] Invalid (null) feature\");\n    return;\n  }\n\n  if (feature.gcs() === destGcs) {\n    return;\n  }\n\n  if (!(feature instanceof geo.pointFeature ||\n        feature instanceof geo.lineFeature)) {\n    throw \"Supports only point or line feature\";\n  }\n\n  var noOfComponents = null,\n      pointOffset = 0,\n      count = null,\n      inPos = null,\n      outPos = null,\n      srcGcs = feature.gcs(),\n      i,\n      yCoord;\n\n  inplace = !!inplace;\n  if (feature instanceof geo.pointFeature ||\n      feature instanceof geo.lineFeature) {\n\n    ///  If source GCS is not in 4326, transform it first into 4326\n    /// before we transform it for OSM.\n    if (srcGcs !== \"EPSG:4326\") {\n      geo.transform.transformFeature(\"EPSG:4326\", feature, true);\n    }\n\n    inPos = feature.positions();\n    count = inPos.length;\n\n    if (!(inPos instanceof Array)) {\n      throw \"Supports Array of 2D and 3D points\";\n    }\n\n    if (inPos.length > 0 && inPos[0] instanceof geo.latlng) {\n      noOfComponents = 2;\n      pointOffset = 1;\n    } else {\n      noOfComponents = (count % 2 === 0 ? 2 :\n                       (count % 3 === 0 ? 3 : null));\n      pointOffset = noOfComponents;\n    }\n\n    if (noOfComponents !== 2 && noOfComponents !== 3) {\n      throw \"Transform points require points in 2D or 3D\";\n    }\n\n    if (inplace) {\n      outPos = inPos;\n    } else {\n      outPos = inPos.slice(0);\n    }\n\n    for (i = 0; i < count; i += pointOffset) {\n\n      /// Y goes from 0 (top edge is 85.0511 N) to 2zoom  1\n      /// (bottom edge is 85.0511 S) in a Mercator projection.\n      if (inPos[i] instanceof geo.latlng) {\n        yCoord = inPos[i].lat();\n      } else {\n        yCoord = inPos[i + 1];\n      }\n\n      if (yCoord > 85.0511) {\n        yCoord = 85.0511;\n      }\n      if (yCoord < -85.0511) {\n        yCoord = -85.0511;\n      }\n      if (inPos[i] instanceof geo.latlng) {\n        outPos[i] = geo.latlng(geo.mercator.lat2y(yCoord), outPos[i].lng());\n      } else {\n        outPos[i + 1] = geo.mercator.lat2y(yCoord);\n      }\n    }\n\n    if (inplace) {\n      feature.positions(outPos);\n      feature.gcs(destGcs);\n    }\n    return outPos;\n  }\n\n  return null;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Transform a feature to destination GCS\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.transform.transformFeature = function (destGcs, feature, inplace) {\n  \"use strict\";\n\n  if (!feature) {\n    throw \"Invalid (null) feature\";\n  }\n\n  if (!(feature instanceof geo.pointFeature ||\n        feature instanceof geo.lineFeature)) {\n    throw \"Supports only point or line feature\";\n  }\n\n  if (feature.gcs() === destGcs) {\n    return feature.positions();\n  }\n\n  if (destGcs === \"EPSG:3857\") {\n    return geo.transform.osmTransformFeature(destGcs, feature, inplace);\n  }\n\n  var noOfComponents = null,\n      pointOffset = 0,\n      count = null,\n      inPos = null,\n      outPos = null,\n      projPoint = null,\n      srcGcs = feature.gcs(),\n      i,\n      projSrcGcs = new proj4.Proj(srcGcs),\n      projDestGcs = new proj4.Proj(destGcs);\n\n  inplace = !!inplace;\n  if (feature instanceof geo.pointFeature ||\n      feature instanceof geo.lineFeature) {\n    inPos = feature.positions();\n    count = inPos.length;\n\n    if (!(inPos instanceof Array)) {\n      throw \"Supports Array of 2D and 3D points\";\n    }\n\n    if (inPos.length > 0 && inPos[0] instanceof geo.latlng) {\n      noOfComponents = 2;\n      pointOffset = 1;\n    } else {\n      noOfComponents = (count % 2 === 0 ? 2 :\n                       (count % 3 === 0 ? 3 : null));\n      pointOffset = noOfComponents;\n    }\n\n    if (noOfComponents !== 2 && noOfComponents !== 3) {\n      throw \"Transform points require points in 2D or 3D\";\n    }\n\n    if (inplace) {\n      outPos = inPos;\n    } else {\n      outPos = [];\n      outPos.length = inPos.length;\n    }\n\n    for (i = 0; i < count; i += pointOffset) {\n      if (noOfComponents === 2) {\n        projPoint = new proj4.Point(inPos[i], inPos[i + 1], 0.0);\n      } else {\n        projPoint = new proj4.Point(inPos[i], inPos[i + 1], inPos[i + 2]);\n      }\n\n      proj4.transform(projSrcGcs, projDestGcs, projPoint);\n\n      if (noOfComponents === 2) {\n        outPos[i] =  projPoint.x;\n        outPos[i + 1] = projPoint.y;\n      } else {\n        outPos[i] = projPoint.x;\n        outPos[i + 1] = projPoint.y;\n        outPos[i + 2] = projPoint.z;\n      }\n    }\n\n    if (inplace) {\n      feature.positions(outPos);\n      feature.gcs(destGcs);\n    }\n\n    return outPos;\n  }\n\n  return null;\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Transform geometric data of a layer from source projection to destination\n * projection.\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.transform.transformLayer = function (destGcs, layer, baseLayer) {\n  \"use strict\";\n\n  var features, count, i;\n\n  if (!layer) {\n    throw \"Requires valid layer for tranformation\";\n  }\n\n  if (!baseLayer) {\n    throw \"Requires baseLayer used by the map\";\n  }\n\n  if (layer === baseLayer) {\n    return;\n  }\n\n  if (layer instanceof geo.featureLayer) {\n    features = layer.features();\n    count = features.length;\n    i = 0;\n\n    for (i = 0; i < count; i += 1) {\n      if (destGcs === \"EPSG:3857\" && baseLayer instanceof geo.osmLayer) {\n        geo.transform.osmTransformFeature(\n          destGcs, features[i], true);\n      } else {\n        geo.transform.transformFeature(\n          destGcs, features[i], true);\n      }\n    }\n\n    layer.gcs(destGcs);\n  } else {\n    throw \"Only feature layer transformation is supported\";\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Transform position coordinates from source projection to destination\n * projection.\n *\n * @param {string} srcGcs GCS of the coordinates\n * @param {string} destGcs Desired GCS of the transformed coordinates\n * @param {object} coordinates\n * @return {geo.latlng|geo.latlng[]} Transformed coordinates\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.transform.transformCoordinates = function (srcGcs, destGcs, coordinates,\n                                               numberOfComponents) {\n  \"use strict\";\n\n  var i, count, offset, xCoord, yCoord, zCoord, xAcc,\n      yAcc, zAcc, writer, output, projPoint,\n      projSrcGcs = new proj4.Proj(srcGcs),\n      projDestGcs = new proj4.Proj(destGcs);\n\n  /// Default Z accessor\n  zAcc = function () {\n    return 0.0;\n  };\n\n  if (destGcs === srcGcs) {\n    return coordinates;\n  }\n\n  /// TODO: Can we check for EPSG code?\n  if (!destGcs || !srcGcs) {\n    throw \"Invalid source or destination GCS\";\n  }\n\n  /// Helper methods\n  function handleLatLngCoordinates() {\n    if (coordinates[0] && coordinates[0] instanceof geo.latlng) {\n      xAcc = function (index) {\n        return coordinates[index].x();\n      };\n      yAcc = function (index) {\n        return coordinates[index].y();\n      };\n      writer = function (index, x, y) {\n        output[index] = geo.latlng(y, x);\n      };\n    } else {\n      xAcc = function () {\n        return coordinates.x();\n      };\n      yAcc = function () {\n        return coordinates.y();\n      };\n      writer = function (index, x, y) {\n        output = geo.latlng(y, x);\n      };\n    }\n  }\n\n  /// Helper methods\n  function handleArrayCoordinates() {\n    if (coordinates[0] instanceof Array) {\n      if (coordinates[0].length === 2) {\n        xAcc = function (index) {\n          return coordinates[index][0];\n        };\n        yAcc = function (index) {\n          return coordinates[index][1];\n        };\n        writer = function (index, x, y) {\n          output[index] = [x, y];\n        };\n      } else if (coordinates[0].length === 3) {\n        xAcc = function (index) {\n          return coordinates[index][0];\n        };\n        yAcc = function (index) {\n          return coordinates[index][1];\n        };\n        zAcc = function (index) {\n          return coordinates[index][2];\n        };\n        writer = function (index, x, y, z) {\n          output[index] = [x, y, z];\n        };\n      } else {\n        throw \"Invalid coordinates. Requires two or three components per array\";\n      }\n    } else {\n      if (coordinates.length === 2) {\n        offset = 2;\n\n        xAcc = function (index) {\n          return coordinates[index * offset];\n        };\n        yAcc = function (index) {\n          return coordinates[index * offset + 1];\n        };\n        writer = function (index, x, y) {\n          output[index] = x;\n          output[index + 1] = y;\n        };\n      } else if (coordinates.length === 3) {\n        offset = 3;\n\n        xAcc = function (index) {\n          return coordinates[index * offset];\n        };\n        yAcc = function (index) {\n          return coordinates[index * offset + 1];\n        };\n        zAcc = function (index) {\n          return coordinates[index * offset + 2];\n        };\n        writer = function (index, x, y, z) {\n          output[index] = x;\n          output[index + 1] = y;\n          output[index + 2] = z;\n        };\n      } else if (numberOfComponents) {\n        if (numberOfComponents === 2 || numberOfComponents || 3) {\n          offset = numberOfComponents;\n\n          xAcc = function (index) {\n            return coordinates[index];\n          };\n          yAcc = function (index) {\n            return coordinates[index + 1];\n          };\n          if (numberOfComponents === 2) {\n            writer = function (index, x, y) {\n              output[index] = x;\n              output[index + 1] = y;\n            };\n          } else {\n            zAcc = function (index) {\n              return coordinates[index + 2];\n            };\n            writer = function (index, x, y, z) {\n              output[index] = x;\n              output[index + 1] = y;\n              output[index + 2] = z;\n            };\n          }\n        } else {\n          throw \"Number of components should be two or three\";\n        }\n      } else {\n        throw \"Invalid coordinates\";\n      }\n    }\n  }\n\n  /// Helper methods\n  function handleObjectCoordinates() {\n    if (coordinates[0] &&\n        \"x\" in coordinates[0] &&\n        \"y\" in coordinates[0]) {\n      xAcc = function (index) {\n        return coordinates[index].x;\n      };\n      yAcc = function (index) {\n        return coordinates[index].y;\n      };\n\n      if (\"z\" in coordinates[0]) {\n        zAcc = function (index) {\n          return coordinates[index].z;\n        };\n        writer = function (index, x, y, z) {\n          output[i] = {x: x, y: y, z: z};\n        };\n      } else {\n        writer = function (index, x, y) {\n          output[index] = {x: x, y: y};\n        };\n      }\n    } else if (coordinates &&\n        \"x\" in coordinates && \"y\" in coordinates) {\n      xAcc = function () {\n        return coordinates.x;\n      };\n      yAcc = function () {\n        return coordinates.y;\n      };\n\n      if (\"z\" in coordinates) {\n        zAcc = function () {\n          return coordinates.z;\n        };\n        writer = function (index, x, y, z) {\n          output = {x: x, y: y, z: z};\n        };\n      } else {\n        writer = function (index, x, y) {\n          output = {x: x, y: y};\n        };\n      }\n    } else {\n      throw \"Invalid coordinates\";\n    }\n  }\n\n  if (coordinates instanceof Array) {\n    output = [];\n    output.length = coordinates.length;\n    count = coordinates.length;\n\n    if (coordinates[0] instanceof Array ||\n        coordinates[0] instanceof geo.latlng ||\n        coordinates[0] instanceof Object) {\n      offset = 1;\n\n      if (coordinates[0] instanceof Array) {\n        handleArrayCoordinates();\n      } else if (coordinates[0] instanceof geo.latlng) {\n        handleLatLngCoordinates();\n      } else if (coordinates[0] instanceof Object) {\n        handleObjectCoordinates();\n      }\n    } else {\n      handleArrayCoordinates();\n    }\n  } else if (coordinates && coordinates instanceof Object) {\n    count = 1;\n    offset = 1;\n    if (coordinates instanceof geo.latlng) {\n      handleLatLngCoordinates();\n    } else if (coordinates && \"x\" in coordinates && \"y\" in coordinates) {\n      handleObjectCoordinates();\n    } else {\n      throw \"Coordinates are not valid\";\n    }\n  }\n\n  if (destGcs === \"EPSG:3857\" && srcGcs === \"EPSG:4326\") {\n    for (i = 0; i < count; i += offset) {\n      /// Y goes from 0 (top edge is 85.0511 N) to 2zoom  1\n      /// (bottom edge is 85.0511 S) in a Mercator projection.\n      xCoord = xAcc(i);\n      yCoord = yAcc(i);\n      zCoord = zAcc(i);\n\n      if (yCoord > 85.0511) {\n        yCoord = 85.0511;\n      }\n      if (yCoord < -85.0511) {\n        yCoord = -85.0511;\n      }\n\n      writer(i, xCoord, geo.mercator.lat2y(yCoord), zCoord);\n    }\n\n    return output;\n  } else {\n    for (i = 0; i < count; i += offset) {\n      projPoint = new proj4.Point(xAcc(i), yAcc(i), zAcc(i));\n      proj4.transform(projSrcGcs, projDestGcs, projPoint);\n      writer(i, projPoint.x, projPoint.y, projPoint.z);\n      return output;\n    }\n  }\n};\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class renderer\n *\n * @class\n * @extends geo.object\n * @returns {geo.renderer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.renderer = function (arg) {\n  \"use strict\";\n\n  if (!(this instanceof geo.renderer)) {\n    return new geo.renderer(arg);\n  }\n  geo.object.call(this);\n\n  arg = arg || {};\n  var m_this = this,\n      m_layer = arg.layer === undefined ? null : arg.layer,\n      m_canvas = arg.canvas === undefined ? null : arg.canvas,\n      m_initialized = false;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get layer of the renderer\n   *\n   * @returns {*}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.layer = function () {\n    return m_layer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get canvas for the renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.canvas = function (val) {\n    if (val === undefined) {\n      return m_canvas;\n    } else {\n      m_canvas = val;\n      m_this.modified();\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get map that this renderer belongs to\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.map = function () {\n    if (m_layer) {\n      return m_layer.map();\n    } else {\n      return null;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get base layer that belongs to this renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.baseLayer = function () {\n    if (m_this.map()) {\n      return m_this.map().baseLayer();\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set if renderer has been initialized\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.initialized = function (val) {\n    if (val === undefined) {\n      return m_initialized;\n    } else {\n      m_initialized = val;\n      return m_this;\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get render API used by the renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.api = function () {\n    throw \"Should be implemented by derivied classes\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Reset to default\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.reset = function () {\n    return true;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert array of points from world to GCS coordinate space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.worldToGcs = function () {\n    throw \"Should be implemented by derivied classes\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert array of points from display to GCS space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.displayToGcs = function () {\n    throw \"Should be implemented by derivied classes\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert array of points from display to GCS space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.gcsToDisplay = function () {\n    throw \"Should be implemented by derivied classes\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert array of points from world to display space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.worldToDisplay = function () {\n    throw \"Should be implemented by derivied classes\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert array of points from display to world space\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.displayToWorld = function () {\n    throw \"Should be implemented by derivied classes\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get mouse coodinates related to canvas\n   *\n   * @param {object} event\n   * @returns {object}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.relMouseCoords = function (event) {\n    var totalOffsetX = 0,\n        totalOffsetY = 0,\n        canvasX = 0,\n        canvasY = 0,\n        currentElement = m_this.canvas();\n\n    do {\n      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;\n      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;\n      currentElement = currentElement.offsetParent;\n    } while (currentElement);\n\n    canvasX = event.pageX - totalOffsetX;\n    canvasY = event.pageY - totalOffsetY;\n\n    return {\n      x: canvasX,\n      y: canvasY\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle resize event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._resize = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Render\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._render = function () {\n  };\n\n  return this;\n};\n\ninherit(geo.renderer, geo.object);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of osmLayer\n *\n * @class\n * @extends geo.featureLayer\n *\n * @param {Object} arg - arg can contain following keys: baseUrl,\n *        imageFormat (such as png or jpeg), and displayLast\n *        (to decide whether or not render tiles from last zoom level).\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.osmLayer = function (arg) {\n  \"use strict\";\n\n  if (!(this instanceof geo.osmLayer)) {\n    return new geo.osmLayer(arg);\n  }\n  geo.featureLayer.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private member variables\n   *\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n    s_exit = this._exit,\n    m_tiles = {},\n    m_hiddenBinNumber = -1,\n    m_lastVisibleBinNumber = -1,\n    m_visibleBinNumber = 1000,\n    m_pendingNewTiles = [],\n    m_pendingInactiveTiles = [],\n    m_numberOfCachedTiles = 0,\n    m_tileCacheSize = 100,\n    m_baseUrl = \"http://tile.openstreetmap.org/\",\n    m_mapOpacity = 1.0,\n    m_imageFormat = \"png\",\n    m_updateTimerId = null,\n    m_lastVisibleZoom = null,\n    m_visibleTilesRange = {},\n    s_init = this._init,\n    m_pendingNewTilesStat = {},\n    s_update = this._update,\n    m_updateDefer = null,\n    m_zoom = null,\n    m_tileUrl;\n\n  if (arg && arg.baseUrl !== undefined) {\n    m_baseUrl = arg.baseUrl;\n  }\n\n  if (m_baseUrl.charAt(m_baseUrl.length - 1) !== \"/\") {\n    m_baseUrl += \"/\";\n  }\n\n  if (arg && arg.mapOpacity !== undefined) {\n    m_mapOpacity = arg.mapOpacity;\n  }\n  if (arg && arg.imageFormat !== undefined) {\n    m_imageFormat = arg.imageFormat;\n  }\n\n  if (arg && arg.displayLast !== undefined && arg.displayLast) {\n    m_lastVisibleBinNumber = 999;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Returns a url string containing the requested tile.  This default\n   * version uses the open street map standard, but the user can\n   * change the default behavior.\n   *\n   * @param {integer} zoom The zoom level\n   * @param {integer} x The tile from the xth row\n   * @param {integer} y The tile from the yth column\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  m_tileUrl = function (zoom, x, y) {\n    return m_baseUrl + zoom + \"/\" + x +\n      \"/\" + y + \".\" + m_imageFormat;\n  };\n\n  if (arg && arg.tileUrl !== undefined) {\n    m_tileUrl = arg.tileUrl;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Check if a tile is visible in current view\n   *\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function isTileVisible(tile) {\n    if (tile.zoom in m_visibleTilesRange) {\n      if (tile.index_x >= m_visibleTilesRange[tile.zoom].startX &&\n          tile.index_x <= m_visibleTilesRange[tile.zoom].endX &&\n          tile.index_y >= m_visibleTilesRange[tile.zoom].startY &&\n          tile.index_y <= m_visibleTilesRange[tile.zoom].endY) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Draw new tiles and remove the old ones\n   *\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function drawTiles() {\n    m_this._removeTiles();\n    m_this.draw();\n    delete m_pendingNewTilesStat[m_updateTimerId];\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set tile cache size\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.tileCacheSize = function (val) {\n    if (val === undefined) {\n      return m_tileCacheSize;\n    }\n    m_tileCacheSize = val;\n    m_this.modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set the tile url formatting function.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.tileUrl = function (val) {\n    if (val === undefined) {\n      return m_tileUrl;\n    }\n    m_tileUrl = val;\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Transform a point or array of points in latitude-longitude-altitude\n   * space to local space of the layer\n   *\n   * @param {*} input\n   * Input can be of following types:\n   *\n   *   1. geo.latlng\n   *   2. [geo.latlng]\n   *   3. [x1,y1, x2, y2]\n   *   4. [[x,y]]\n   *   5. {x:val: y:val, z:val},\n   *   6. [{x:val: y:val}]\n   *\n   * returns geo.latlng, [geo.latlng], or {x:lon, y:lat}, [{x:lon, y:lat}]\n   * [x1,y1, x2, y2], [[x,y]]\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.toLocal = function (input) {\n    var i, output, delta;\n\n    /// Now handle different data types\n    if (input instanceof Array && input.length > 0) {\n      output = [];\n      output.length = input.length;\n\n      /// Input is array of geo.latlng\n      if (input[0] instanceof geo.latlng) {\n        for (i = 0; i < input.length; i += 1) {\n          output[i] = geo.latlng(input[i]);\n          output[i].lat(geo.mercator.lat2y(output[i].lat()));\n        }\n      } else if (input[0] instanceof Array) {\n        delta = input % 3 === 0 ? 3 : 2;\n\n        if (delta === 2) {\n          for (i = 0; i < input.length; i += delta) {\n            output[i] = input[i];\n            output[i + 1] = geo.mercator.lat2y(input[i + 1]);\n          }\n        } else {\n          for (i = 0; i < input.length; i += delta) {\n            output[i] = input[i];\n            output[i + 1] = geo.mercator.lat2y(input[i + 1]);\n            output[i + 2] = input[i + 2];\n          }\n        }\n      } else if (input[0] instanceof Object &&\n                 \"x\" in input[0] && \"y\" in input[0] && \"z\" in input[0]) {\n        /// Input is array of object\n        output[i] = { x: input[i].x, y: geo.mercator.lat2y(input[i].y),\n                      z: input[i].z };\n      } else if (input[0] instanceof Object &&\n                 \"x\" in input[0] && \"y\" in input[0] && \"z\" in input[0]) {\n        /// Input is array of object\n        output[i] = { x: input[i].x, y: geo.mercator.lat2y(input[i].y)};\n      } else if (input.length >= 2) {\n        output = input.slice(0);\n        output[1] = geo.mercator.lat2y(input[1]);\n      }\n    } else if (input instanceof geo.latlng) {\n      output = {};\n      output.x = input.x();\n      output.y = geo.mercator.lat2y(input.y());\n    } else {\n      output = {};\n      output.x = input.x;\n      output.y = geo.mercator.lat2y(input.y);\n    }\n\n    return output;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Transform a point or array of points in local space to\n   * latitude-longitude space\n   *\n   * @input Input An object, array, of array of objects/array representing 2D\n   * point in space. [x,y], [[x,y]], [{x:val: y:val}], {x:val, y:val}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.fromLocal = function (input) {\n    var i, output;\n\n    if (input instanceof Array && input.length > 0) {\n      output = [];\n      output.length = input.length;\n\n      if (input[0] instanceof Object) {\n        for (i = 0; i < input.length; i += 1) {\n          output[i] = {};\n          output[i].x = input[i].x;\n          output[i].y = geo.mercator.y2lat(input[i].y);\n        }\n      } else if (input[0] instanceof Array) {\n        for (i = 0; i < input.length; i += 1) {\n          output[i] = input[i];\n          output[i][1] = geo.mercator.y2lat(input[i][1]);\n        }\n      } else {\n        for (i = 0; i < input.length; i += 1) {\n          output[i] = input[i];\n          output[i + 1] = geo.mercator.y2lat(input[i + 1]);\n        }\n      }\n    } else {\n      output = {};\n      output.x = input.x;\n      output.y = geo.mercator.y2lat(input.y);\n    }\n\n    return output;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Check if a tile exists in the cache\n   *\n   * @param {number} zoom The zoom value for the map [1-17]\n   * @param {number} x X axis tile index\n   * @param {number} y Y axis tile index\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._hasTile = function (zoom, x, y) {\n    if (!m_tiles[zoom]) {\n      return false;\n    }\n    if (!m_tiles[zoom][x]) {\n      return false;\n    }\n    if (!m_tiles[zoom][x][y]) {\n      return false;\n    }\n    return true;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create a new tile\n   * @param {number} x X axis tile index\n   * @param {number} y Y axis tile index\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._addTile = function (request, zoom, x, y) {\n    if (!m_tiles[zoom]) {\n      m_tiles[zoom] = {};\n    }\n    if (!m_tiles[zoom][x]) {\n      m_tiles[zoom][x] = {};\n    }\n    if (m_tiles[zoom][x][y]) {\n      return;\n    }\n\n    /// Compute corner points\n    var noOfTilesX = Math.max(1, Math.pow(2, zoom)),\n        noOfTilesY = Math.max(1, Math.pow(2, zoom)),\n        /// Convert into mercator\n        totalLatDegrees = 360.0,\n        lonPerTile = 360.0 / noOfTilesX,\n        latPerTile = totalLatDegrees / noOfTilesY,\n        llx = -180.0 + x * lonPerTile,\n        lly = -totalLatDegrees * 0.5 + y * latPerTile,\n        urx = -180.0 + (x + 1) * lonPerTile,\n        ury = -totalLatDegrees * 0.5 + (y + 1) * latPerTile,\n        tile = new Image();\n\n    tile.LOADING = true;\n    tile.LOADED = false;\n    tile.REMOVED = false;\n    tile.REMOVING = false;\n    tile.INVALID = false;\n\n    tile.crossOrigin = \"anonymous\";\n    tile.zoom = zoom;\n    tile.index_x = x;\n    tile.index_y = y;\n    tile.llx = llx;\n    tile.lly = lly;\n    tile.urx = urx;\n    tile.ury = ury;\n    tile.lastused = new Date();\n\n    tile.src = m_tileUrl(zoom, x, Math.pow(2, zoom) - 1 - y);\n\n    m_tiles[zoom][x][y] = tile;\n    m_pendingNewTiles.push(tile);\n    m_numberOfCachedTiles += 1;\n    return tile;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Clear tiles that are no longer required\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  /* jshint -W089 */\n  this._removeTiles = function () {\n    var i, x, y, tile, zoom, currZoom = m_zoom,\n        lastZoom = m_lastVisibleZoom;\n\n    if (!m_tiles) {\n      return m_this;\n    }\n\n    for (zoom in m_tiles) {\n      for (x in m_tiles[zoom]) {\n        for (y in m_tiles[zoom][x]) {\n          tile = m_tiles[zoom][x][y];\n          if (tile) {\n            tile.REMOVING = true;\n            m_pendingInactiveTiles.push(tile);\n          }\n        }\n      }\n    }\n\n    /// First remove the tiles if we have cached more than max cached limit\n    m_pendingInactiveTiles.sort(function (a, b) {\n      return a.lastused - b.lastused;\n    });\n\n    i = 0;\n\n    /// Get rid of tiles if we have reached our threshold. However,\n    /// If the tile is required for current zoom, then do nothing.\n    /// Also do not delete the tile if it is from the previous zoom\n    while (m_numberOfCachedTiles > m_tileCacheSize &&\n      i < m_pendingInactiveTiles.length) {\n      tile = m_pendingInactiveTiles[i];\n\n      if (isTileVisible(tile)) {\n        i += 1;\n      } else {\n        m_this.deleteFeature(tile.feature);\n        delete m_tiles[tile.zoom][tile.index_x][tile.index_y];\n        m_pendingInactiveTiles.splice(i, 1);\n        m_numberOfCachedTiles -= 1;\n      }\n    }\n\n    for (i = 0; i < m_pendingInactiveTiles.length; i += 1) {\n      tile = m_pendingInactiveTiles[i];\n      tile.REMOVING = false;\n      tile.REMOVED = false;\n      if (tile.zoom !== currZoom && tile.zoom === lastZoom) {\n        tile.feature.bin(m_lastVisibleBinNumber);\n      } else if (tile.zoom !== currZoom) {\n        tile.feature.bin(m_hiddenBinNumber);\n      } else {\n        tile.lastused = new Date();\n        tile.feature.bin(m_visibleBinNumber);\n      }\n      tile.feature._update();\n    }\n    m_pendingInactiveTiles = [];\n\n    return m_this;\n  };\n  /* jshint +W089 */\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create / delete tiles as necessary\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._addTiles = function (request) {\n    var feature, ren = m_this.renderer(),\n        /// First get corner points\n        /// In display coordinates the origin is on top left corner (0, 0)\n        llx = 0.0, lly = m_this.height(), urx = m_this.width(), ury = 0.0,\n        temp = null, tile = null, tile1x = null, tile1y = null, tile2x = null,\n        tile2y = null, invJ = null, i = 0, j = 0, lastStartX, lastStartY,\n        lastEndX, lastEndY, currStartX, currStartY, currEndX, currEndY,\n        worldPt1 = ren.displayToWorld([llx, lly]),\n        worldPt2 = ren.displayToWorld([urx, ury]),\n        worldDeltaY = null, displayDeltaY = null,\n        worldDelta = null, displayDelta = null,\n        noOfTilesRequired = null, worldDeltaPerTile = null,\n        minDistWorldDeltaPerTile = null, distWorldDeltaPerTile;\n\n    worldPt1[0] = Math.max(worldPt1[0], -180.0);\n    worldPt1[0] = Math.min(worldPt1[0], 180.0);\n    worldPt1[1] = Math.max(worldPt1[1], -180.0);\n    worldPt1[1] = Math.min(worldPt1[1], 180.0);\n\n    worldPt2[0] = Math.max(worldPt2[0], -180.0);\n    worldPt2[0] = Math.min(worldPt2[0], 180.0);\n    worldPt2[1] = Math.max(worldPt2[1], -180.0);\n    worldPt2[1] = Math.min(worldPt2[1], 180.0);\n\n    /// Compute tile zoom\n    worldDelta = Math.abs(worldPt2[0] - worldPt1[0]);\n    worldDeltaY = Math.abs(worldPt2[1] - worldPt1[1]);\n\n    displayDelta = urx - llx;\n    displayDeltaY = lly - ury;\n\n    /// Reuse variables\n    if (displayDeltaY > displayDelta) {\n      displayDelta = displayDeltaY;\n      worldDelta = worldDeltaY;\n    }\n\n    noOfTilesRequired = Math.round(displayDelta / 256.0);\n    worldDeltaPerTile = worldDelta / noOfTilesRequired;\n\n    /// Minimize per pixel distortion\n    minDistWorldDeltaPerTile = Number.POSITIVE_INFINITY;\n    for (i = 20; i >= 2; i = i - 1) {\n      distWorldDeltaPerTile = Math.abs(360.0 / Math.pow(2, i) - worldDeltaPerTile);\n      if (distWorldDeltaPerTile < minDistWorldDeltaPerTile) {\n        minDistWorldDeltaPerTile = distWorldDeltaPerTile;\n        m_zoom = i;\n      }\n    }\n\n    /// Compute tilex and tiley\n    tile1x = geo.mercator.long2tilex(worldPt1[0], m_zoom);\n    tile1y = geo.mercator.lat2tiley(worldPt1[1], m_zoom);\n\n    tile2x = geo.mercator.long2tilex(worldPt2[0], m_zoom);\n    tile2y = geo.mercator.lat2tiley(worldPt2[1], m_zoom);\n\n    /// Clamp tilex and tiley\n    tile1x = Math.max(tile1x, 0);\n    tile1x = Math.min(Math.pow(2, m_zoom) - 1, tile1x);\n    tile1y = Math.max(tile1y, 0);\n    tile1y = Math.min(Math.pow(2, m_zoom) - 1, tile1y);\n\n    tile2x = Math.max(tile2x, 0);\n    tile2x = Math.min(Math.pow(2, m_zoom) - 1, tile2x);\n    tile2y = Math.max(tile2y, 0);\n    tile2y = Math.min(Math.pow(2, m_zoom) - 1, tile2y);\n\n    /// Check and update variables appropriately if view\n    /// direction is flipped. This should not happen but\n    /// just in case.\n    if (tile1x > tile2x) {\n      temp = tile1x;\n      tile1x = tile2x;\n      tile2x = temp;\n    }\n    if (tile2y > tile1y) {\n      temp = tile1y;\n      tile1y = tile2y;\n      tile2y = temp;\n    }\n\n    /// Compute current tile indices\n    currStartX = tile1x;\n    currEndX = tile2x;\n    currStartY = (Math.pow(2, m_zoom) - 1 - tile1y);\n    currEndY = (Math.pow(2, m_zoom) - 1 - tile2y);\n    if (currEndY < currStartY) {\n      temp = currStartY;\n      currStartY = currEndY;\n      currEndY = temp;\n    }\n\n    /// Compute last tile indices\n    lastStartX = geo.mercator.long2tilex(worldPt1[0],\n                   m_lastVisibleZoom);\n    lastStartY = geo.mercator.lat2tiley(worldPt1[1],\n                   m_lastVisibleZoom);\n    lastEndX = geo.mercator.long2tilex(worldPt2[0],\n                   m_lastVisibleZoom);\n    lastEndY = geo.mercator.lat2tiley(worldPt2[1],\n                   m_lastVisibleZoom);\n    lastStartY = Math.pow(2, m_lastVisibleZoom) - 1 - lastStartY;\n    lastEndY   = Math.pow(2, m_lastVisibleZoom) - 1 - lastEndY;\n\n    if (lastEndY < lastStartY) {\n      temp = lastStartY;\n      lastStartY = lastEndY;\n      lastEndY = temp;\n    }\n\n    m_visibleTilesRange = {};\n    m_visibleTilesRange[m_zoom] = { startX: currStartX, endX: currEndX,\n                                    startY: currStartY, endY: currEndY };\n\n    m_visibleTilesRange[m_lastVisibleZoom] =\n                                { startX: lastStartX, endX: lastEndX,\n                                  startY: lastStartY, endY: lastEndY };\n    m_pendingNewTilesStat[m_updateTimerId] = { total:\n      ((tile2x - tile1x + 1) * (tile1y - tile2y + 1)), count: 0 };\n\n    for (i = tile1x; i <= tile2x; i += 1) {\n      for (j = tile2y; j <= tile1y; j += 1) {\n        invJ = (Math.pow(2, m_zoom) - 1 - j);\n        if (!m_this._hasTile(m_zoom, i, invJ)) {\n          tile = m_this._addTile(request, m_zoom, i, invJ);\n        } else {\n          tile = m_tiles[m_zoom][i][invJ];\n          tile.feature.bin(m_visibleBinNumber);\n          if (tile.LOADED && m_updateTimerId in m_pendingNewTilesStat) {\n            m_pendingNewTilesStat[m_updateTimerId].count += 1;\n          }\n          tile.lastused = new Date();\n          tile.feature._update();\n        }\n        tile.updateTimerId = m_updateTimerId;\n      }\n    }\n\n    // define a function here to set tile properties after it is loaded\n    function tileOnLoad(tile) {\n      var defer = $.Deferred();\n      m_this.addDeferred(defer);\n\n      return function () {\n        if (tile.INVALID) {\n          return;\n        }\n        tile.LOADING = false;\n        tile.LOADED = true;\n        if ((tile.REMOVING || tile.REMOVED) &&\n          tile.feature &&\n          tile.zoom !== m_zoom) {\n          tile.feature.bin(m_hiddenBinNumber);\n          tile.REMOVING = false;\n          tile.REMOVED = true;\n        } else {\n          tile.REMOVED = false;\n          tile.lastused = new Date();\n          tile.feature.bin(m_visibleBinNumber);\n        }\n\n        if (tile.updateTimerId === m_updateTimerId &&\n            m_updateTimerId in m_pendingNewTilesStat) {\n          tile.feature.bin(m_visibleBinNumber);\n          m_pendingNewTilesStat[m_updateTimerId].count += 1;\n        } else {\n          tile.REMOVED = true;\n          tile.feature.bin(m_hiddenBinNumber);\n        }\n        tile.feature._update();\n\n        if (m_updateTimerId in m_pendingNewTilesStat &&\n            m_pendingNewTilesStat[m_updateTimerId].count >=\n            m_pendingNewTilesStat[m_updateTimerId].total) {\n          drawTiles();\n        }\n        defer.resolve();\n      };\n    }\n\n    /// And now finally add them\n    for (i = 0; i < m_pendingNewTiles.length; i += 1) {\n      tile = m_pendingNewTiles[i];\n      feature = m_this.createFeature(\n        \"plane\", {drawOnAsyncResourceLoad: false, onload: tileOnLoad(tile)})\n        .origin([tile.llx, tile.lly])\n        .upperLeft([tile.llx, tile.ury])\n        .lowerRight([tile.urx, tile.lly])\n        .gcs(\"EPSG:3857\")\n        .style({image: tile, opacity: m_mapOpacity});\n      tile.feature = feature;\n      tile.feature._update();\n    }\n    m_pendingNewTiles = [];\n\n    if (m_updateTimerId in m_pendingNewTilesStat &&\n        m_pendingNewTilesStat[m_updateTimerId].count >=\n        m_pendingNewTilesStat[m_updateTimerId].total) {\n      drawTiles();\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update OSM tiles as needed\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function updateOSMTiles(request) {\n    if (request === undefined) {\n      request = {};\n    }\n\n    if (!m_zoom) {\n      m_zoom = m_this.map().zoom();\n    }\n\n    if (!m_lastVisibleZoom) {\n      m_lastVisibleZoom = m_zoom;\n    }\n\n    /// Add tiles that are currently visible\n    m_this._addTiles(request);\n\n    /// Update the zoom\n    if (m_lastVisibleZoom !== m_zoom) {\n      m_lastVisibleZoom = m_zoom;\n    }\n\n    m_this.updateTime().modified();\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create / delete tiles as necessary\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._updateTiles = function (request) {\n    var defer = $.Deferred();\n    m_this.addDeferred(defer);\n\n    if (m_updateTimerId !== null) {\n      clearTimeout(m_updateTimerId);\n      m_updateDefer.resolve();\n      m_updateDefer = defer;\n      if (m_updateTimerId in m_pendingNewTilesStat) {\n        delete m_pendingNewTilesStat[m_updateTimerId];\n      }\n      /// Set timeout for 60 ms. 60 ms seems to playing well\n      /// with the events. Also, 60ms corresponds to 15 FPS.\n      m_updateTimerId = setTimeout(function () {\n        updateOSMTiles(request);\n        m_updateDefer.resolve();\n      }, 100);\n    } else {\n      m_updateDefer = defer;\n      m_updateTimerId = setTimeout(function () {\n        updateOSMTiles(request);\n        m_updateDefer.resolve();\n      }, 0);\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   *\n   * Do not call parent _init method as its already been executed\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    s_init.call(m_this);\n    m_this.gcs(\"EPSG:3857\");\n    m_this.map().zoomRange({\n      min: 0,\n      max: 18\n    });\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update layer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function (request) {\n    /// Update tiles (create new / delete old etc...)\n    m_this._updateTiles(request);\n\n    /// Now call base class update\n    s_update.call(m_this, request);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update baseUrl for map tiles.  Map all tiles as needing to be refreshed.\n   *\n   * @param baseUrl: the new baseUrl for the map.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  /* jshint -W089 */\n  this.updateBaseUrl = function (baseUrl) {\n    if (baseUrl.charAt(m_baseUrl.length - 1) !== \"/\") {\n      baseUrl += \"/\";\n    }\n    if (baseUrl !== m_baseUrl) {\n      m_baseUrl = baseUrl;\n\n      var tile, x, y, zoom;\n      for (zoom in m_tiles) {\n        for (x in m_tiles[zoom]) {\n          for (y in m_tiles[zoom][x]) {\n            tile = m_tiles[zoom][x][y];\n            tile.INVALID = true;\n            m_this.deleteFeature(tile.feature);\n          }\n        }\n      }\n      m_tiles = {};\n      m_pendingNewTiles = [];\n      m_pendingInactiveTiles = [];\n      m_numberOfCachedTiles = 0;\n      m_visibleTilesRange = {};\n      m_pendingNewTilesStat = {};\n\n      if (m_updateTimerId !== null) {\n        clearTimeout(m_updateTimerId);\n        m_updateTimerId = null;\n      }\n      this._update();\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set map opacity\n   *\n   * @returns {geo.osmLayer}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.mapOpacity = function (val) {\n    if (val === undefined) {\n      return m_mapOpacity;\n    } else if (val !== m_mapOpacity) {\n      m_mapOpacity = val;\n      var zoom, x, y, tile;\n      for (zoom in m_tiles) {\n        for (x in m_tiles[zoom]) {\n          for (y in m_tiles[zoom][x]) {\n            tile = m_tiles[zoom][x][y];\n            tile.feature.style().opacity = val;\n            tile.feature._update();\n          }\n        }\n      }\n      m_this.modified();\n    }\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Exit\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_tiles = {};\n    m_pendingNewTiles = [];\n    m_pendingInactiveTiles = [];\n    m_numberOfCachedTiles = 0;\n    m_visibleTilesRange = {};\n    m_pendingNewTilesStat = {};\n    s_exit();\n  };\n\n  return this;\n};\n\ninherit(geo.osmLayer, geo.featureLayer);\n\ngeo.registerLayer(\"osm\", geo.osmLayer);\n","/**\n * @namespace\n */\ngeo.gl = {};\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class vglRenderer\n *\n * @class\n * @extends geo.renderer\n * @param canvas\n * @returns {geo.gl.renderer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.renderer = function (arg) {\n  'use strict';\n\n  if (!(this instanceof geo.gl.renderer)) {\n    return new geo.gl.renderer(arg);\n  }\n  geo.renderer.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get context specific renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.contextRenderer = function () {\n    throw 'Should be implemented by derived classes';\n  };\n\n  return this;\n};\n\ninherit(geo.gl.renderer, geo.renderer);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of lineFeature\n *\n * @class\n * @extends geo.lineFeature\n * @returns {geo.gl.lineFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.lineFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.gl.lineFeature)) {\n    return new geo.gl.lineFeature(arg);\n  }\n  arg = arg || {};\n  geo.lineFeature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_exit = this._exit,\n      m_actor = null,\n      m_mapper = null,\n      m_material = null,\n      m_pixelWidthUnif = null,\n      m_aspectUniform = null,\n      m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,\n      s_init = this._init,\n      s_update = this._update;\n\n  function createVertexShader() {\n    var vertexShaderSource = [\n      '#ifdef GL_ES',\n      '  precision highp float;',\n      '#endif',\n      'attribute vec3 pos;',\n      'attribute vec3 prev;',\n      'attribute vec3 next;',\n      'attribute float offset;',\n\n      'attribute vec3 strokeColor;',\n      'attribute float strokeOpacity;',\n      'attribute float strokeWidth;',\n\n      'uniform mat4 modelViewMatrix;',\n      'uniform mat4 projectionMatrix;',\n      'uniform float pixelWidth;',\n      'uniform float aspect;',\n\n      'varying vec3 strokeColorVar;',\n      'varying float strokeWidthVar;',\n      'varying float strokeOpacityVar;',\n\n      'void main(void)',\n      '{',\n      /* If any vertex has been deliberately set to a negative opacity,\n       * skip doing computations on it. */\n      '  if (strokeOpacity < 0.0) {',\n      '    gl_Position = vec4(2, 2, 0, 1);',\n      '    return;',\n      '  }',\n      '  const float PI = 3.14159265358979323846264;',\n      '  vec4 worldPos = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1);',\n      '  if (worldPos.w != 0.0) {',\n      '    worldPos = worldPos/worldPos.w;',\n      '  }',\n      '  vec4 worldNext = projectionMatrix * modelViewMatrix * vec4(next.xyz, 1);',\n      '  if (worldNext.w != 0.0) {',\n      '    worldNext = worldNext/worldNext.w;',\n      '  }',\n      '  vec4 worldPrev = projectionMatrix* modelViewMatrix * vec4(prev.xyz, 1);',\n      '  if (worldPrev.w != 0.0) {',\n      '    worldPrev = worldPrev/worldPrev.w;',\n      '  }',\n      '  strokeColorVar = strokeColor;',\n      '  strokeWidthVar = strokeWidth;',\n      '  strokeOpacityVar = strokeOpacity;',\n      '  vec2 deltaNext = worldNext.xy - worldPos.xy;',\n      '  vec2 deltaPrev = worldPos.xy - worldPrev.xy;',\n      '  float angleNext = 0.0, anglePrev = 0.0;',\n      '  if (deltaNext.xy != vec2(0.0, 0.0))',\n      '    angleNext = atan(deltaNext.y / aspect, deltaNext.x);',\n      '  if (deltaPrev.xy == vec2(0.0, 0.0)) anglePrev = angleNext;',\n      '  else  anglePrev = atan(deltaPrev.y / aspect, deltaPrev.x);',\n      '  if (deltaNext.xy == vec2(0.0, 0.0)) angleNext = anglePrev;',\n      '  float angle = (anglePrev + angleNext) / 2.0;',\n      '  float cosAngle = cos(anglePrev - angle);',\n      '  if (cosAngle < 0.1) { cosAngle = sign(cosAngle) * 1.0; angle = 0.0; }',\n      '  float distance = (offset * strokeWidth * pixelWidth) /',\n      '                    cosAngle;',\n      '  worldPos.x += distance * sin(angle);',\n      '  worldPos.y -= distance * cos(angle) * aspect;',\n      '  gl_Position = worldPos;',\n      '}'\n    ].join('\\n'),\n    shader = new vgl.shader(gl.VERTEX_SHADER);\n    shader.setShaderSource(vertexShaderSource);\n    return shader;\n  }\n\n  function createFragmentShader() {\n    var fragmentShaderSource = [\n      '#ifdef GL_ES',\n      '  precision highp float;',\n      '#endif',\n      'varying vec3 strokeColorVar;',\n      'varying float strokeWidthVar;',\n      'varying float strokeOpacityVar;',\n      'void main () {',\n      '  gl_FragColor = vec4 (strokeColorVar, strokeOpacityVar);',\n      '}'\n    ].join('\\n'),\n    shader = new vgl.shader(gl.FRAGMENT_SHADER);\n    shader.setShaderSource(fragmentShaderSource);\n    return shader;\n  }\n\n  function createGLLines() {\n    var data = m_this.data(),\n        i, j, k, v,\n        numSegments = 0, len,\n        lineItem, lineItemData,\n        vert = [{}, {}], vertTemp,\n        pos, posIdx3,\n        position = [],\n        posFunc = m_this.position(),\n        strkWidthFunc = m_this.style.get('strokeWidth'),\n        strkColorFunc = m_this.style.get('strokeColor'),\n        strkOpacityFunc = m_this.style.get('strokeOpacity'),\n        order = m_this.featureVertices(),\n        posBuf, nextBuf, prevBuf, offsetBuf, indicesBuf,\n        strokeWidthBuf, strokeColorBuf, strokeOpacityBuf,\n        dest, dest3,\n        geom = m_mapper.geometryData();\n\n    for (i = 0; i < data.length; i += 1) {\n      lineItem = m_this.line()(data[i], i);\n      numSegments += lineItem.length - 1;\n      for (j = 0; j < lineItem.length; j += 1) {\n        pos = posFunc(lineItem[j], j, lineItem, i);\n        if (pos instanceof geo.latlng) {\n          position.push(pos.x());\n          position.push(pos.y());\n          position.push(0.0);\n        } else {\n          position.push(pos.x);\n          position.push(pos.y);\n          position.push(pos.z || 0.0);\n        }\n      }\n    }\n\n    position = geo.transform.transformCoordinates(\n                 m_this.gcs(), m_this.layer().map().gcs(),\n                 position, 3);\n\n    len = numSegments * order.length;\n    posBuf           = getBuffer(geom, 'pos', len * 3);\n    nextBuf          = getBuffer(geom, 'next', len * 3);\n    prevBuf          = getBuffer(geom, 'prev', len * 3);\n    offsetBuf        = getBuffer(geom, 'offset', len * 1);\n    strokeWidthBuf   = getBuffer(geom, 'strokeWidth', len * 1);\n    strokeColorBuf   = getBuffer(geom, 'strokeColor', len * 3);\n    strokeOpacityBuf = getBuffer(geom, 'strokeOpacity', len * 1);\n    indicesBuf = geom.primitive(0).indices();\n    if (!(indicesBuf instanceof Uint16Array) || indicesBuf.length !== len) {\n      indicesBuf = new Uint16Array(len);\n      geom.primitive(0).setIndices(indicesBuf);\n    }\n\n    for (i = posIdx3 = dest = dest3 = 0; i < data.length; i += 1) {\n      lineItem = m_this.line()(data[i], i);\n      for (j = 0; j < lineItem.length; j += 1, posIdx3 += 3) {\n        lineItemData = lineItem[j];\n        /* swap entries in vert so that vert[0] is the first vertex, and\n         * vert[1] will be reused for the second vertex */\n        if (j) {\n          vertTemp = vert[0];\n          vert[0] = vert[1];\n          vert[1] = vertTemp;\n        }\n        vert[1].pos = posIdx3;\n        vert[1].prev = posIdx3 - (j ? 3 : 0);\n        vert[1].next = posIdx3 + (j + 1 < lineItem.length ? 3 : 0);\n        vert[1].strokeWidth = strkWidthFunc(lineItemData, j, lineItem, i);\n        vert[1].strokeColor = strkColorFunc(lineItemData, j, lineItem, i);\n        vert[1].strokeOpacity = strkOpacityFunc(lineItemData, j, lineItem, i);\n        if (j) {\n          for (k = 0; k < order.length; k += 1, dest += 1, dest3 += 3) {\n            v = vert[order[k][0]];\n            posBuf[dest3]     = position[v.pos];\n            posBuf[dest3 + 1] = position[v.pos + 1];\n            posBuf[dest3 + 2] = position[v.pos + 2];\n            prevBuf[dest3]     = position[v.prev];\n            prevBuf[dest3 + 1] = position[v.prev + 1];\n            prevBuf[dest3 + 2] = position[v.prev + 2];\n            nextBuf[dest3]     = position[v.next];\n            nextBuf[dest3 + 1] = position[v.next + 1];\n            nextBuf[dest3 + 2] = position[v.next + 2];\n            offsetBuf[dest] = order[k][1];\n            /* We can ignore the indicies (they will all be zero) */\n            strokeWidthBuf[dest] = v.strokeWidth;\n            strokeColorBuf[dest3]     = v.strokeColor.r;\n            strokeColorBuf[dest3 + 1] = v.strokeColor.g;\n            strokeColorBuf[dest3 + 2] = v.strokeColor.b;\n            strokeOpacityBuf[dest] = v.strokeOpacity;\n          }\n        }\n      }\n    }\n\n    geom.boundsDirty(true);\n    m_mapper.modified();\n    m_mapper.boundsDirtyTimestamp().modified();\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get a buffer for a geometry source.  If a buffer already exists and is\n   * the correct size, return it.  Otherwise, allocate a new buffer; any data\n   * in an old buffer is discarded.\n   *\n   * @param geom: the geometry to reference and modify.\n   * @param srcName: the name of the source.\n   * @param len: the number of elements for the array.\n   * @returns {Float32Array}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function getBuffer(geom, srcName, len) {\n    var src = geom.sourceByName(srcName), data;\n\n    data = src.data();\n    if (data instanceof Float32Array && data.length === len) {\n      return data;\n    }\n    data = new Float32Array(len);\n    src.setData(data);\n    return data;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the arrangement of vertices used for each line segment.\n   *\n   * @returns {Number}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.featureVertices = function () {\n    return [[0, 1], [1, -1], [0, -1], [0, 1], [1, 1], [1, -1]];\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the number of vertices used for each line segment.\n   *\n   * @returns {Number}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.verticesPerFeature = function () {\n    return this.featureVertices().length;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    var prog = vgl.shaderProgram(),\n        vs = createVertexShader(),\n        fs = createFragmentShader(),\n        // Vertex attributes\n        posAttr = vgl.vertexAttribute('pos'),\n        prvAttr = vgl.vertexAttribute('prev'),\n        nxtAttr = vgl.vertexAttribute('next'),\n        offAttr = vgl.vertexAttribute('offset'),\n        strkWidthAttr = vgl.vertexAttribute('strokeWidth'),\n        strkColorAttr = vgl.vertexAttribute('strokeColor'),\n        strkOpacityAttr = vgl.vertexAttribute('strokeOpacity'),\n        // Shader uniforms\n        mviUnif = new vgl.modelViewUniform('modelViewMatrix'),\n        prjUnif = new vgl.projectionUniform('projectionMatrix'),\n        geom = vgl.geometryData(),\n        // Sources\n        posData = vgl.sourceDataP3fv({'name': 'pos'}),\n        prvPosData = vgl.sourceDataAnyfv(\n            3, vgl.vertexAttributeKeysIndexed.Four, {'name': 'prev'}),\n        nxtPosData = vgl.sourceDataAnyfv(\n            3, vgl.vertexAttributeKeysIndexed.Five, {'name': 'next'}),\n        offPosData = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Six, {'name': 'offset'}),\n        strkWidthData = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.One, {'name': 'strokeWidth'}),\n        strkColorData = vgl.sourceDataAnyfv(\n            3, vgl.vertexAttributeKeysIndexed.Two, {'name': 'strokeColor'}),\n        strkOpacityData = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Three,\n            {'name': 'strokeOpacity'}),\n        // Primitive indices\n        triangles = vgl.triangles();\n\n    m_pixelWidthUnif =  new vgl.floatUniform('pixelWidth',\n                          1.0 / m_this.renderer().width());\n    m_aspectUniform = new vgl.floatUniform('aspect',\n        m_this.renderer().width() / m_this.renderer().height());\n\n    s_init.call(m_this, arg);\n    m_material = vgl.material();\n    m_mapper = vgl.mapper({dynamicDraw: m_dynamicDraw});\n\n    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);\n    prog.addVertexAttribute(strkWidthAttr, vgl.vertexAttributeKeysIndexed.One);\n    prog.addVertexAttribute(strkColorAttr, vgl.vertexAttributeKeysIndexed.Two);\n    prog.addVertexAttribute(strkOpacityAttr, vgl.vertexAttributeKeysIndexed.Three);\n    prog.addVertexAttribute(prvAttr, vgl.vertexAttributeKeysIndexed.Four);\n    prog.addVertexAttribute(nxtAttr, vgl.vertexAttributeKeysIndexed.Five);\n    prog.addVertexAttribute(offAttr, vgl.vertexAttributeKeysIndexed.Six);\n\n    prog.addUniform(mviUnif);\n    prog.addUniform(prjUnif);\n    prog.addUniform(m_pixelWidthUnif);\n    prog.addUniform(m_aspectUniform);\n\n    prog.addShader(fs);\n    prog.addShader(vs);\n\n    m_material.addAttribute(prog);\n    m_material.addAttribute(vgl.blend());\n\n    m_actor = vgl.actor();\n    m_actor.setMaterial(m_material);\n    m_actor.setMapper(m_mapper);\n\n    geom.addSource(posData);\n    geom.addSource(prvPosData);\n    geom.addSource(nxtPosData);\n    geom.addSource(strkWidthData);\n    geom.addSource(strkColorData);\n    geom.addSource(strkOpacityData);\n    geom.addSource(offPosData);\n    geom.addPrimitive(triangles);\n    m_mapper.setGeometryData(geom);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return list of actors\n   *\n   * @returns {vgl.actor[]}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.actors = function () {\n    if (!m_actor) {\n      return [];\n    }\n    return [m_actor];\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    if (m_actor) {\n      m_this.renderer().contextRenderer().removeActor(m_actor);\n    }\n\n    createGLLines();\n\n    m_this.renderer().contextRenderer().addActor(m_actor);\n    m_this.buildTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||\n        m_this.updateTime().getMTime() <= m_this.getMTime()) {\n      m_this._build();\n    }\n\n    m_pixelWidthUnif.set(1.0 / m_this.renderer().width());\n    m_aspectUniform.set(m_this.renderer().width() /\n                        m_this.renderer().height());\n    m_actor.setVisible(m_this.visible());\n    m_actor.material().setBinNumber(m_this.bin());\n    m_this.updateTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Destroy\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.renderer().contextRenderer().removeActor(m_actor);\n    s_exit();\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.gl.lineFeature, geo.lineFeature);\n\n// Now register it\ngeo.registerFeature('vgl', 'line', geo.gl.lineFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of pointFeature\n *\n * @class\n * @extends geo.pointFeature\n * @returns {geo.gl.pointFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.pointFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.gl.pointFeature)) {\n    return new geo.gl.pointFeature(arg);\n  }\n  arg = arg || {};\n  geo.pointFeature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_exit = this._exit,\n      m_actor = null,\n      m_mapper = null,\n      m_pixelWidthUniform = null,\n      m_aspectUniform = null,\n      m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,\n      m_primitiveShape = \"sprite\", // arg can change this, below\n      s_init = this._init,\n      s_update = this._update,\n      vertexShaderSource = null,\n      fragmentShaderSource = null;\n\n  if (arg.primitiveShape === \"triangle\" ||\n      arg.primitiveShape === \"square\" ||\n      arg.primitiveShape === \"sprite\") {\n    m_primitiveShape = arg.primitiveShape;\n  }\n\n  vertexShaderSource = [\n    \"#ifdef GL_ES\",\n    \"  precision highp float;\",\n    \"#endif\",\n    \"attribute vec3 pos;\",\n    \"attribute float rad;\",\n    \"attribute vec3 fillColor;\",\n    \"attribute vec3 strokeColor;\",\n    \"attribute float fillOpacity;\",\n    \"attribute float strokeWidth;\",\n    \"attribute float strokeOpacity;\",\n    \"attribute float fill;\",\n    \"attribute float stroke;\",\n    \"uniform float pixelWidth;\",\n    \"uniform float aspect;\",\n    \"uniform mat4 modelViewMatrix;\",\n    \"uniform mat4 projectionMatrix;\",\n    \"varying vec4 fillColorVar;\",\n    \"varying vec4 strokeColorVar;\",\n    \"varying float radiusVar;\",\n    \"varying float strokeWidthVar;\",\n    \"varying float fillVar;\",\n    \"varying float strokeVar;\"\n  ];\n\n  if (m_primitiveShape !== \"sprite\") {\n    vertexShaderSource = vertexShaderSource.concat([\n      \"attribute vec2 unit;\",\n      \"varying vec3 unitVar;\"\n    ]);\n  }\n\n  vertexShaderSource.push.apply(vertexShaderSource, [\n    \"void main(void)\",\n    \"{\",\n    \"  strokeWidthVar = strokeWidth;\",\n    \"  // No stroke or fill implies nothing to draw\",\n    \"  if (stroke < 1.0 || strokeWidth <= 0.0 || strokeOpacity <= 0.0) {\",\n    \"    strokeVar = 0.0;\",\n    \"    strokeWidthVar = 0.0;\",\n    \"  }\",\n    \"  else\",\n    \"    strokeVar = 1.0;\",\n    \"  if (fill < 1.0 || rad <= 0.0 || fillOpacity <= 0.0)\",\n    \"    fillVar = 0.0;\",\n    \"  else\",\n    \"    fillVar = 1.0;\",\n    /* If the point has no visible pixels, skip doing computations on it. */\n    \"  if (fillVar == 0.0 && strokeVar == 0.0) {\",\n    \"    gl_Position = vec4(2, 2, 0, 1);\",\n    \"    return;\",\n    \"  }\",\n    \"  fillColorVar = vec4 (fillColor, fillOpacity);\",\n    \"  strokeColorVar = vec4 (strokeColor, strokeOpacity);\",\n    \"  radiusVar = rad;\"\n  ]);\n\n  if (m_primitiveShape === \"sprite\") {\n    vertexShaderSource.push.apply(vertexShaderSource, [\n      \"  gl_Position = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;\",\n      \"  gl_PointSize = 2.0 * (rad + strokeWidthVar); \",\n      \"}\"\n    ]);\n  } else {\n    vertexShaderSource.push.apply(vertexShaderSource, [\n        \"  unitVar = vec3 (unit, 1.0);\",\n        \"  vec4 p = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;\",\n        \"  if (p.w != 0.0) {\",\n        \"    p = p / p.w;\",\n        \"  }\",\n        \"  p += (rad + strokeWidthVar) * \",\n        \"       vec4 (unit.x * pixelWidth, unit.y * pixelWidth * aspect, 0.0, 1.0);\",\n        \"  gl_Position = vec4(p.xyz, 1.0);\",\n        \"}\"\n      ]);\n  }\n  vertexShaderSource = vertexShaderSource.join(\"\\n\");\n\n  fragmentShaderSource = [\n    \"#ifdef GL_ES\",\n    \"  precision highp float;\",\n    \"#endif\",\n    \"uniform float aspect;\",\n    \"varying vec4 fillColorVar;\",\n    \"varying vec4 strokeColorVar;\",\n    \"varying float radiusVar;\",\n    \"varying float strokeWidthVar;\",\n    \"varying float fillVar;\",\n    \"varying float strokeVar;\"\n  ];\n\n  if (m_primitiveShape !== \"sprite\") {\n    fragmentShaderSource.push(\"varying vec3 unitVar;\");\n  }\n\n  fragmentShaderSource.push.apply(fragmentShaderSource, [\n    \"void main () {\",\n    \"  vec4 strokeColor, fillColor;\",\n    \"  float endStep;\",\n    \"  // No stroke or fill implies nothing to draw\",\n    \"  if (fillVar == 0.0 && strokeVar == 0.0)\",\n    \"    discard;\"\n  ]);\n\n  if (m_primitiveShape === \"sprite\") {\n    fragmentShaderSource.push(\n      \"  float rad = 2.0 * length (gl_PointCoord - vec2(0.5));\");\n  } else {\n    fragmentShaderSource.push(\n      \"  float rad = length (unitVar.xy);\");\n  }\n\n  fragmentShaderSource.push.apply(fragmentShaderSource, [\n    \"  if (rad > 1.0)\",\n    \"    discard;\",\n    \"  // If there is no stroke, the fill region should transition to nothing\",\n    \"  if (strokeVar == 0.0) {\",\n    \"    strokeColor = vec4 (fillColorVar.rgb, 0.0);\",\n    \"    endStep = 1.0;\",\n    \"  } else {\",\n    \"    strokeColor = strokeColorVar;\",\n    \"    endStep = radiusVar / (radiusVar + strokeWidthVar);\",\n    \"  }\",\n    \"  // Likewise, if there is no fill, the stroke should transition to nothing\",\n    \"  if (fillVar == 0.0)\",\n    \"    fillColor = vec4 (strokeColor.rgb, 0.0);\",\n    \"  else\",\n    \"    fillColor = fillColorVar;\",\n    \"  // Distance to antialias over\",\n    \"  float antialiasDist = 3.0 / (2.0 * radiusVar);\",\n    \"  if (rad < endStep) {\",\n    \"    float step = smoothstep (endStep - antialiasDist, endStep, rad);\",\n    \"    gl_FragColor = mix (fillColor, strokeColor, step);\",\n    \"  } else {\",\n    \"    float step = smoothstep (1.0 - antialiasDist, 1.0, rad);\",\n    \"    gl_FragColor = mix (strokeColor, vec4 (strokeColor.rgb, 0.0), step);\",\n    \"  }\",\n    \"}\"\n  ]);\n\n  fragmentShaderSource = fragmentShaderSource.join(\"\\n\");\n\n  function createVertexShader() {\n    var shader = new vgl.shader(gl.VERTEX_SHADER);\n    shader.setShaderSource(vertexShaderSource);\n    return shader;\n  }\n\n  function createFragmentShader() {\n    var shader = new vgl.shader(gl.FRAGMENT_SHADER);\n    shader.setShaderSource(fragmentShaderSource);\n    return shader;\n  }\n\n  function pointPolygon(x, y, w, h) {\n    var verts;\n    switch (m_primitiveShape) {\n      case \"triangle\":\n        /* Use an equilateral triangle.  While this has 30% more area than a\n         * square, the reduction in vertices should help more than the\n         * processing the additional fragments. */\n        verts = [\n          x, y - h * 2,\n          x - w * Math.sqrt(3.0), y + h,\n          x + w * Math.sqrt(3.0), y + h\n        ];\n        break;\n      case \"sprite\":\n        /* Point sprite uses only one vertex per point. */\n        verts = [x, y];\n        break;\n      default: // \"square\"\n        /* Use a surrounding square split diagonally into two triangles. */\n        verts = [\n          x - w, y + h,\n          x - w, y - h,\n          x + w, y + h,\n          x - w, y - h,\n          x + w, y - h,\n          x + w, y + h\n        ];\n        break;\n    }\n    return verts;\n  }\n\n  function createGLPoints() {\n    // unit and associated data is not used when drawing sprite\n    var i, j, numPts = m_this.data().length,\n        unit = pointPolygon(0, 0, 1, 1),\n        position = new Array(numPts * 3), posBuf, posVal, posFunc,\n        unitBuf, indices,\n        radius, radiusVal, radFunc,\n        stroke, strokeVal, strokeFunc,\n        strokeWidth, strokeWidthVal, strokeWidthFunc,\n        strokeOpacity, strokeOpacityVal, strokeOpactityFunc,\n        strokeColor, strokeColorVal, strokeColorFunc,\n        fill, fillVal, fillFunc,\n        fillOpacity, fillOpacityVal, fillOpacityFunc,\n        fillColor, fillColorVal, fillColorFunc,\n        vpf = m_this.verticesPerFeature(),\n        data = m_this.data(),\n        item, ivpf, ivpf3, iunit, i3,\n        geom = m_mapper.geometryData();\n\n    posFunc = m_this.position();\n    radFunc = m_this.style.get(\"radius\");\n    strokeFunc = m_this.style.get(\"stroke\");\n    strokeWidthFunc = m_this.style.get(\"strokeWidth\");\n    strokeOpactityFunc = m_this.style.get(\"strokeOpacity\");\n    strokeColorFunc = m_this.style.get(\"strokeColor\");\n    fillFunc = m_this.style.get(\"fill\");\n    fillOpacityFunc = m_this.style.get(\"fillOpacity\");\n    fillColorFunc = m_this.style.get(\"fillColor\");\n\n    /* It is more efficient to do a transform on a single array rather than on\n     * an array of arrays or an array of objects. */\n    for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {\n      posVal = posFunc(data[i]);\n      position[i3]     = posVal.x;\n      position[i3 + 1] = posVal.y;\n      position[i3 + 2] = posVal.z || 0;\n    }\n    position = geo.transform.transformCoordinates(\n                  m_this.gcs(), m_this.layer().map().gcs(),\n                  position, 3);\n\n    posBuf        = getBuffer(geom, \"pos\", vpf * numPts * 3);\n\n    if (m_primitiveShape !== \"sprite\") {\n      unitBuf       = getBuffer(geom, \"unit\", vpf * numPts * 2);\n    }\n\n    radius        = getBuffer(geom, \"rad\", vpf * numPts * 1);\n    stroke        = getBuffer(geom, \"stroke\", vpf * numPts * 1);\n    strokeWidth   = getBuffer(geom, \"strokeWidth\", vpf * numPts * 1);\n    strokeOpacity = getBuffer(geom, \"strokeOpacity\", vpf * numPts * 1);\n    strokeColor   = getBuffer(geom, \"strokeColor\", vpf * numPts * 3);\n    fill          = getBuffer(geom, \"fill\", vpf * numPts * 1);\n    fillOpacity   = getBuffer(geom, \"fillOpacity\", vpf * numPts * 1);\n    fillColor     = getBuffer(geom, \"fillColor\", vpf * numPts * 3);\n    indices = geom.primitive(0).indices();\n    if (!(indices instanceof Uint16Array) || indices.length !== vpf * numPts) {\n      indices = new Uint16Array(vpf * numPts);\n      geom.primitive(0).setIndices(indices);\n    }\n\n    for (i = ivpf = ivpf3 = iunit = i3 = 0; i < numPts; i += 1, i3 += 3) {\n      item = data[i];\n      if (m_primitiveShape !== \"sprite\") {\n        for (j = 0; j < unit.length; j += 1, iunit += 1) {\n          unitBuf[iunit] = unit[j];\n        }\n      }\n      /* We can ignore the indicies (they will all be zero) */\n      radiusVal = radFunc(item);\n      strokeVal = strokeFunc(item) ? 1.0 : 0.0;\n      strokeWidthVal = strokeWidthFunc(item);\n      strokeOpacityVal = strokeOpactityFunc(item);\n      strokeColorVal = strokeColorFunc(item);\n      fillVal = fillFunc(item) ? 1.0 : 0.0;\n      fillOpacityVal = fillOpacityFunc(item);\n      fillColorVal = fillColorFunc(item);\n      for (j = 0; j < vpf; j += 1, ivpf += 1, ivpf3 += 3) {\n        posBuf[ivpf3]     = position[i3];\n        posBuf[ivpf3 + 1] = position[i3 + 1];\n        posBuf[ivpf3 + 2] = position[i3 + 2];\n        radius[ivpf] = radiusVal;\n        stroke[ivpf] = strokeVal;\n        strokeWidth[ivpf] = strokeWidthVal;\n        strokeOpacity[ivpf] = strokeOpacityVal;\n        strokeColor[ivpf3]     = strokeColorVal.r;\n        strokeColor[ivpf3 + 1] = strokeColorVal.g;\n        strokeColor[ivpf3 + 2] = strokeColorVal.b;\n        fill[ivpf] = fillVal;\n        fillOpacity[ivpf] = fillOpacityVal;\n        fillColor[ivpf3]     = fillColorVal.r;\n        fillColor[ivpf3 + 1] = fillColorVal.g;\n        fillColor[ivpf3 + 2] = fillColorVal.b;\n      }\n    }\n\n    geom.boundsDirty(true);\n    m_mapper.modified();\n    m_mapper.boundsDirtyTimestamp().modified();\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get a buffer for a geometry source.  If a buffer already exists and is\n   * the correct size, return it.  Otherwise, allocate a new buffer; any data\n   * in an old buffer is discarded.\n   *\n   * @param geom: the geometry to reference and modify.\n   * @param srcName: the name of the source.\n   * @param len: the number of elements for the array.\n   * @returns {Float32Array}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function getBuffer(geom, srcName, len) {\n    var src = geom.sourceByName(srcName), data;\n\n    data = src.data();\n    if (data instanceof Float32Array && data.length === len) {\n      return data;\n    }\n    data = new Float32Array(len);\n    src.setData(data);\n    return data;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return list of actors\n   *\n   * @returns {vgl.actor[]}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.actors = function () {\n    if (!m_actor) {\n      return [];\n    }\n    return [m_actor];\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the number of vertices used for each point.\n   *\n   * @returns {Number}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.verticesPerFeature = function () {\n    var unit = pointPolygon(0, 0, 1, 1);\n    return unit.length / 2;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    var prog = vgl.shaderProgram(),\n        vertexShader = createVertexShader(),\n        fragmentShader = createFragmentShader(),\n        posAttr = vgl.vertexAttribute(\"pos\"),\n        unitAttr = vgl.vertexAttribute(\"unit\"),\n        radAttr = vgl.vertexAttribute(\"rad\"),\n        strokeWidthAttr = vgl.vertexAttribute(\"strokeWidth\"),\n        fillColorAttr = vgl.vertexAttribute(\"fillColor\"),\n        fillAttr = vgl.vertexAttribute(\"fill\"),\n        strokeColorAttr = vgl.vertexAttribute(\"strokeColor\"),\n        strokeAttr = vgl.vertexAttribute(\"stroke\"),\n        fillOpacityAttr = vgl.vertexAttribute(\"fillOpacity\"),\n        strokeOpacityAttr = vgl.vertexAttribute(\"strokeOpacity\"),\n        modelViewUniform = new vgl.modelViewUniform(\"modelViewMatrix\"),\n        projectionUniform = new vgl.projectionUniform(\"projectionMatrix\"),\n        mat = vgl.material(),\n        blend = vgl.blend(),\n        geom = vgl.geometryData(),\n        sourcePositions = vgl.sourceDataP3fv({\"name\": \"pos\"}),\n        sourceUnits = vgl.sourceDataAnyfv(\n            2, vgl.vertexAttributeKeysIndexed.One, {\"name\": \"unit\"}),\n        sourceRadius = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Two, {\"name\": \"rad\"}),\n        sourceStrokeWidth = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Three, {\"name\": \"strokeWidth\"}),\n        sourceFillColor = vgl.sourceDataAnyfv(\n            3, vgl.vertexAttributeKeysIndexed.Four, {\"name\": \"fillColor\"}),\n        sourceFill = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Five, {\"name\": \"fill\"}),\n        sourceStrokeColor = vgl.sourceDataAnyfv(\n            3, vgl.vertexAttributeKeysIndexed.Six, {\"name\": \"strokeColor\"}),\n        sourceStroke = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Seven, {\"name\": \"stroke\"}),\n        sourceAlpha = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Eight, {\"name\": \"fillOpacity\"}),\n        sourceStrokeOpacity = vgl.sourceDataAnyfv(\n            1, vgl.vertexAttributeKeysIndexed.Nine, {\"name\": \"strokeOpacity\"}),\n        primitive = new vgl.triangles();\n\n    if (m_primitiveShape === \"sprite\") {\n      primitive = new vgl.points();\n    }\n\n    m_pixelWidthUniform = new vgl.floatUniform(\"pixelWidth\",\n                            2.0 / m_this.renderer().width());\n    m_aspectUniform = new vgl.floatUniform(\"aspect\",\n                        m_this.renderer().width() / m_this.renderer().height());\n\n    s_init.call(m_this, arg);\n    m_mapper = vgl.mapper({dynamicDraw: m_dynamicDraw});\n\n    // TODO: Right now this is ugly but we will fix it.\n    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);\n    if (m_primitiveShape !== \"sprite\") {\n      prog.addVertexAttribute(unitAttr, vgl.vertexAttributeKeysIndexed.One);\n    }\n\n    prog.addVertexAttribute(radAttr, vgl.vertexAttributeKeysIndexed.Two);\n    prog.addVertexAttribute(strokeWidthAttr, vgl.vertexAttributeKeysIndexed.Three);\n    prog.addVertexAttribute(fillColorAttr, vgl.vertexAttributeKeysIndexed.Four);\n    prog.addVertexAttribute(fillAttr, vgl.vertexAttributeKeysIndexed.Five);\n    prog.addVertexAttribute(strokeColorAttr, vgl.vertexAttributeKeysIndexed.Six);\n    prog.addVertexAttribute(strokeAttr, vgl.vertexAttributeKeysIndexed.Seven);\n    prog.addVertexAttribute(fillOpacityAttr, vgl.vertexAttributeKeysIndexed.Eight);\n    prog.addVertexAttribute(strokeOpacityAttr, vgl.vertexAttributeKeysIndexed.Nine);\n\n    prog.addUniform(m_pixelWidthUniform);\n    prog.addUniform(m_aspectUniform);\n    prog.addUniform(modelViewUniform);\n    prog.addUniform(projectionUniform);\n\n    prog.addShader(fragmentShader);\n    prog.addShader(vertexShader);\n\n    mat.addAttribute(prog);\n    mat.addAttribute(blend);\n\n    m_actor = vgl.actor();\n    m_actor.setMaterial(mat);\n    m_actor.setMapper(m_mapper);\n\n    geom.addSource(sourcePositions);\n    geom.addSource(sourceUnits);\n    geom.addSource(sourceRadius);\n    geom.addSource(sourceStrokeWidth);\n    geom.addSource(sourceFillColor);\n    geom.addSource(sourceFill);\n    geom.addSource(sourceStrokeColor);\n    geom.addSource(sourceStroke);\n    geom.addSource(sourceAlpha);\n    geom.addSource(sourceStrokeOpacity);\n    geom.addPrimitive(primitive);\n    m_mapper.setGeometryData(geom);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n\n    if (m_actor) {\n      m_this.renderer().contextRenderer().removeActor(m_actor);\n    }\n\n    createGLPoints();\n\n    m_this.renderer().contextRenderer().addActor(m_actor);\n    m_this.renderer().contextRenderer().render();\n    m_this.buildTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n\n    s_update.call(m_this);\n\n    // For now build if the data or style changes. In the future we may\n    // we able to partially update the data using dynamic gl buffers.\n    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||\n        m_this.updateTime().getMTime() < m_this.getMTime()) {\n      m_this._build();\n    }\n\n    // Update uniforms\n    m_pixelWidthUniform.set(2.0 / m_this.renderer().width());\n    m_aspectUniform.set(m_this.renderer().width() /\n                        m_this.renderer().height());\n\n    m_actor.setVisible(m_this.visible());\n    m_actor.material().setBinNumber(m_this.bin());\n\n    m_this.updateTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Destroy\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.renderer().contextRenderer().removeActor(m_actor);\n    s_exit();\n  };\n\n  m_this._init();\n  return this;\n};\n\ninherit(geo.gl.pointFeature, geo.pointFeature);\n\n// Now register it\ngeo.registerFeature(\"vgl\", \"point\", geo.gl.pointFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of geomFeature\n *\n * @class\n * @extends geo.geomFeature\n * @param {vgl.geometryData} arg\n * @returns {geo.gl.geomFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.geomFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.gl.geomFeature)) {\n    return new geo.gl.geomFeature(arg);\n  }\n  arg = arg || {};\n  geo.geomFeature.call(this, arg);\n\n  // Initialize\n  var m_this = this,\n      m_geom = arg.geom || null,\n      m_actor = vgl.actor(),\n      m_mapper = vgl.mapper(),\n      m_material = null,\n      m_scalar = null,\n      m_color = arg.color || [1.0, 1.0, 1.0],\n      m_buildTime = null,\n      m_noOfPrimitives = 0;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var style = m_this.style();\n\n    // Vertex color gets the preference\n    if (m_geom !== null) {\n      m_scalar = m_geom.sourceData(vgl.vertexAttributeKeys.Scalar);\n      m_color = m_geom.sourceData(vgl.vertexAttributeKeys.Color);\n      m_mapper.setGeometryData(m_geom);\n    }\n\n    this.setMapper(m_mapper);\n\n    if (style.point_sprites !== undefined && style.point_sprites &&\n        style.point_sprites_image !== undefined &&\n        style.point_sprites_image !== null &&\n        m_noOfPrimitives === 1 &&\n        m_geom.primitive(0).primitiveType() === gl.POINTS) {\n      m_material = vgl.utils.createPointSpritesMaterial(\n                     style.point_sprites_image);\n    } else if (m_scalar) {\n      if (m_color instanceof vgl.lookupTable) {\n        m_color.updateRange(m_scalar.scalarRange());\n        m_material = vgl.utils.createColorMappedMaterial(m_color);\n      } else {\n        m_color = vgl.lookupTable();\n        m_color.updateRange(m_scalar.scalarRange());\n        m_material = vgl.utils.createColorMappedMaterial(m_color);\n      }\n    } else if (m_color) {\n      m_material = vgl.utils.createColorMaterial();\n    } else {\n      m_material = vgl.utils.createSolidColorMaterial();\n    }\n    m_actor.setMaterial(m_material);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @private\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    if (m_buildTime &&\n        m_buildTime.getMTime() < m_this.getMTime()) {\n      if (m_color instanceof vgl.lookupTable) {\n        vgl.utils.updateColorMappedMaterial(m_this.material(),\n          m_this.style.color);\n      }/* else {\n        // TODO\n      }*/\n    } else {\n      m_buildTime = vgl.timestamp();\n      m_buildTime.modified();\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get/Set geometry\n   *\n   * @returns {geo.gl.geomFeature}\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.geometry = function (val) {\n    if (val === undefined) {\n      return m_geom;\n    } else {\n      m_geom = val;\n      m_this.modified();\n      return m_this;\n    }\n  };\n\n  return this;\n};\n\ninherit(geo.gl.geomFeature, geo.geomFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a plane feature given a lower left corner point geo.latlng\n * and and upper right corner point geo.latlng\n * @class\n * @extends geo.planeFeature\n * @param lowerleft\n * @param upperright\n * @returns {geo.planeFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.planeFeature = function (arg) {\n  \"use strict\";\n  if (!(this instanceof geo.gl.planeFeature)) {\n    return new geo.gl.planeFeature(arg);\n  }\n  geo.planeFeature.call(this, arg);\n\n  var m_this = this,\n      s_exit = this._exit,\n      m_actor = null,\n      m_onloadCallback = arg.onload === undefined ? null : arg.onload;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Gets the coordinates for this plane\n   *\n   * @returns {Array} [[origin], [upper left] [lower right]]\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.coords = function () {\n    return [m_this.origin(), m_this.upperLeft(), m_this.lowerRight()];\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build this feature\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var or = m_this.origin(),\n        ul = m_this.upperLeft(),\n        lr = m_this.lowerRight(),\n        /// img could be a source or an Image\n        img = m_this.style().image,\n        image = null,\n        texture = null;\n\n    /// TODO If for some reason base layer changes its gcs at run time\n    /// then we need to trigger an event to rebuild every feature\n    or = geo.transform.transformCoordinates(m_this.gcs(),\n                                            m_this.layer().map().gcs(),\n                                            or);\n    ul = geo.transform.transformCoordinates(m_this.gcs(),\n                                            m_this.layer().map().gcs(),\n                                            ul);\n    lr = geo.transform.transformCoordinates(m_this.gcs(),\n                                            m_this.layer().map().gcs(),\n                                            lr);\n\n    m_this.buildTime().modified();\n\n    if (m_actor) {\n      m_this.renderer().contextRenderer().removeActor(m_actor);\n    }\n\n    if (img && img instanceof Image) {\n      image = img;\n    } else if (img) {\n      image = new Image();\n      image.src = img;\n    }\n\n    if (!image) {\n      m_actor = vgl.utils.createPlane(or[0], or[1], or[2],\n        ul[0], ul[1], ul[2],\n        lr[0], lr[1], lr[2]);\n\n      m_actor.material().shaderProgram().uniform(\"opacity\").set(\n        m_this.style().opacity !== undefined ? m_this.style().opacity : 1);\n\n      m_this.renderer().contextRenderer().addActor(m_actor);\n\n    } else {\n      m_actor = vgl.utils.createTexturePlane(or[0], or[1], or[2],\n        lr[0], lr[1], lr[2],\n        ul[0], ul[1], ul[2], true);\n\n      m_actor.material().shaderProgram().uniform(\"opacity\").set(\n        m_this.style().opacity !== undefined ? m_this.style().opacity : 1);\n\n      texture = vgl.texture();\n      m_this.visible(false);\n\n      /// TODO: Is there a reliable way to make sure that image is loaded already?\n      m_this.renderer().contextRenderer().addActor(m_actor);\n\n      if (image.complete) {\n        texture.setImage(image);\n        m_actor.material().addAttribute(texture);\n        /// NOTE Currently we assume that we want to show the feature as\n        /// soon as the image gets loaded. However, there might be a case\n        /// where we want to lock down the visibility. We will deal with that\n        /// later.\n        m_this.visible(true);\n\n        if (m_onloadCallback) {\n          m_onloadCallback.call(m_this);\n        }\n        //}\n      } else {\n        image.onload = function () {\n          texture.setImage(image);\n          m_actor.material().addAttribute(texture);\n          /// NOTE Currently we assume that we want to show the feature as\n          /// soon as the image gets loaded. However, there might be a case\n          /// where we want to lock down the visibility. We will deal with that\n          /// later.\n          m_this.visible(true);\n\n          if (m_onloadCallback) {\n            m_onloadCallback.call(m_this);\n          }\n\n          if (m_this.drawOnAsyncResourceLoad()) {\n            m_this._update();\n            m_this.layer().draw();\n          }\n        };\n      }\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    if (m_this.buildTime().getMTime() <= m_this.dataTime().getMTime()) {\n      m_this._build();\n    }\n\n    if (m_this.updateTime().getMTime() <= m_this.getMTime()) {\n      m_actor.setVisible(m_this.visible());\n      m_actor.material().setBinNumber(m_this.bin());\n      m_actor.material().shaderProgram().uniform(\"opacity\").set(\n        m_this.style().opacity !== undefined ? m_this.style().opacity : 1);\n    }\n\n    m_this.updateTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Destroy\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.renderer().contextRenderer().removeActor(m_actor);\n    s_exit();\n  };\n\n  return this;\n};\n\ninherit(geo.gl.planeFeature, geo.planeFeature);\n\n// Now register it\ngeo.registerFeature(\"vgl\", \"plane\", geo.gl.planeFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of polygonFeature\n *\n * @class\n * @extends geo.polygonFeature\n * @returns {geo.gl.polygonFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.polygonFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.gl.polygonFeature)) {\n    return new geo.gl.polygonFeature(arg);\n  }\n  arg = arg || {};\n  geo.polygonFeature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_exit = this._exit,\n      m_actor = vgl.actor(),\n      m_mapper = vgl.mapper(),\n      m_material = vgl.material(),\n      s_init = this._init,\n      s_update = this._update;\n\n  function createVertexShader() {\n    var vertexShaderSource = [\n      'attribute vec3 pos;',\n      'attribute vec3 fillColor;',\n      'attribute float fillOpacity;',\n      'uniform mat4 modelViewMatrix;',\n      'uniform mat4 projectionMatrix;',\n      'uniform float pixelWidth;',\n      'varying vec3 fillColorVar;',\n      'varying float fillOpacityVar;',\n\n      'void main(void)',\n      '{',\n      '  vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1);',\n      '  if (clipPos.w != 0.0) {',\n      '    clipPos = clipPos/clipPos.w;',\n      '  }',\n      '  fillColorVar = fillColor;',\n      '  fillOpacityVar = fillOpacity;',\n      '  gl_Position = clipPos;',\n      '}'\n    ].join('\\n'),\n    shader = new vgl.shader(gl.VERTEX_SHADER);\n    shader.setShaderSource(vertexShaderSource);\n    return shader;\n  }\n\n  function createFragmentShader() {\n    var fragmentShaderSource = [\n      '#ifdef GL_ES',\n      '  precision highp float;',\n      '#endif',\n      'varying vec3 fillColorVar;',\n      'varying float fillOpacityVar;',\n      'void main () {',\n      '  gl_FragColor = vec4 (fillColorVar, fillOpacityVar);',\n      '}'\n    ].join('\\n'),\n    shader = new vgl.shader(gl.FRAGMENT_SHADER);\n    shader.setShaderSource(fragmentShaderSource);\n    return shader;\n  }\n\n  function createGLPolygons() {\n    var i = null,\n        numPts = null,\n        start = null,\n        itemIndex = 0,\n        polygonItemCoordIndex = 0,\n        position = [],\n        fillColor = [],\n        fillOpacity = [],\n        fillColorNew = [],\n        fillOpacityNew = [],\n        posFunc = null,\n        fillColorFunc = null,\n        polygonItem = null,\n        fillOpacityFunc = null,\n        buffers = vgl.DataBuffers(1024),\n        sourcePositions = vgl.sourceDataP3fv(),\n        sourceFillColor =\n          vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Two),\n        sourceFillOpacity =\n          vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Three),\n        trianglePrimitive = vgl.triangles(),\n        geom = vgl.geometryData(),\n        polygon = null,\n        holes = null,\n        extRing = null,\n        extIndex = 0,\n        extLength = null,\n        intIndex = 0,\n        posInstance = null,\n        triangulator = new PNLTRI.Triangulator(),\n        triangList = null,\n        newTriangList = null,\n        fillColorInstance = null,\n        currentIndex = null;\n\n    posFunc = m_this.position();\n    fillColorFunc = m_this.style.get('fillColor');\n    fillOpacityFunc = m_this.style.get('fillOpacity');\n\n    m_this.data().forEach(function (item) {\n      polygon = m_this.polygon()(item, itemIndex);\n      polygonItem = polygon.outer || [];\n      holes = polygon.inner || [];\n      polygonItemCoordIndex = 0;\n      extRing = [];\n      extIndex = 0;\n      extLength = polygonItem.length - 1;\n      extRing[0] = [];\n      intIndex = 0;\n\n      polygonItem.forEach(function (extRingCoords) {\n        if (extIndex !== extLength) {\n          //extRing = extRing.concat(extRingCoords);\n          posInstance = posFunc(extRingCoords,\n                                polygonItemCoordIndex,\n                                item, itemIndex);\n          if (posInstance instanceof geo.latlng) {\n            extRing[0].push({\n              x: posInstance.x(), y: posInstance.y(), i: fillColor.length\n            });\n          } else {\n            extRing[0].push({\n              x: posInstance.x, y: posInstance.y, i: fillColor.length\n            });\n          }\n\n          fillColorInstance = fillColorFunc(extRingCoords,\n                                            polygonItemCoordIndex,\n                                            item, itemIndex);\n          fillColor.push([fillColorInstance.r,\n                          fillColorInstance.g,\n                          fillColorInstance.b]);\n          fillOpacity.push(fillOpacityFunc(extRingCoords,\n                                           polygonItemCoordIndex,\n                                           item,\n                                           itemIndex));\n          polygonItemCoordIndex += 1;\n        }\n        extIndex += 1;\n      });\n\n      polygonItemCoordIndex = 0;\n      holes.forEach(function (hole) {\n        extRing[intIndex + 1] = [];\n        hole.forEach(function (intRingCoords) {\n          posInstance = posFunc(intRingCoords, polygonItemCoordIndex,\n                                item, itemIndex);\n          if (posInstance instanceof geo.latlng) {\n            extRing[intIndex + 1].push({\n              x: posInstance.x(), y: posInstance.y(), i: fillColor.length\n            });\n          } else {\n            extRing[intIndex + 1].push({\n              x: posInstance.x, y: posInstance.y, i: fillColor.length\n            });\n          }\n          fillColorInstance = fillColorFunc(intRingCoords,\n                                            polygonItemCoordIndex,\n                                            item, itemIndex);\n          fillColor.push([fillColorInstance.r,\n                          fillColorInstance.g,\n                          fillColorInstance.b]);\n          fillOpacity.push(fillOpacityFunc(intRingCoords,\n                                           polygonItemCoordIndex,\n                                           item, itemIndex));\n          polygonItemCoordIndex += 1;\n        });\n        intIndex += 1;\n      });\n\n      //console.log(\"extRing \", extRing);\n      //console.log(\"result\", PolyK.Triangulate(extRing));\n      triangList = triangulator.triangulate_polygon(extRing);\n      newTriangList = [];\n\n      triangList.forEach(function (newIndices) {\n        Array.prototype.push.apply(newTriangList, newIndices);\n      });\n\n      for (i = 1; i < extRing.length; i += 1) {\n        extRing[0] = extRing[0].concat(extRing[i]);\n      }\n\n      newTriangList.forEach(function (polygonIndex) {\n        var polygonItemCoords = extRing[0][polygonIndex];\n        position.push([polygonItemCoords.x,\n                       polygonItemCoords.y,\n                       polygonItemCoords.z || 0.0]);\n        fillColorNew.push(fillColor[polygonItemCoords.i]);\n        fillOpacityNew.push(fillOpacity[polygonItemCoords.i]);\n      });\n\n      itemIndex += 1;\n    });\n\n    position = geo.transform.transformCoordinates(\n                 m_this.gcs(), m_this.layer().map().gcs(),\n                 position, 3);\n\n    buffers.create('pos', 3);\n    buffers.create('indices', 1);\n    buffers.create('fillColor', 3);\n    buffers.create('fillOpacity', 1);\n\n    numPts = position.length;\n\n    start = buffers.alloc(numPts);\n    currentIndex = start;\n\n    //console.log(\"numPts \", numPts);\n    for (i = 0; i < numPts; i += 1) {\n      buffers.write('pos', position[i], start + i, 1);\n      buffers.write('indices', [i], start + i, 1);\n      buffers.write('fillColor', fillColorNew[i], start + i, 1);\n      buffers.write('fillOpacity', [fillOpacityNew[i]], start + i, 1);\n    }\n\n    //console.log(buffers.get('fillColor'));\n    sourcePositions.pushBack(buffers.get('pos'));\n    geom.addSource(sourcePositions);\n\n    sourceFillColor.pushBack(buffers.get('fillColor'));\n    geom.addSource(sourceFillColor);\n\n    sourceFillOpacity.pushBack(buffers.get('fillOpacity'));\n    geom.addSource(sourceFillOpacity);\n\n    //console.log(buffers.get('indices'));\n    trianglePrimitive.setIndices(buffers.get('indices'));\n    geom.addPrimitive(trianglePrimitive);\n\n    m_mapper.setGeometryData(geom);\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    var blend = vgl.blend(),\n        prog = vgl.shaderProgram(),\n        posAttr = vgl.vertexAttribute('pos'),\n        fillColorAttr = vgl.vertexAttribute('fillColor'),\n        fillOpacityAttr = vgl.vertexAttribute('fillOpacity'),\n        modelViewUniform = new vgl.modelViewUniform('modelViewMatrix'),\n        projectionUniform = new vgl.projectionUniform('projectionMatrix'),\n        vertexShader = createVertexShader(),\n        fragmentShader = createFragmentShader();\n\n    s_init.call(m_this, arg);\n\n    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);\n    prog.addVertexAttribute(fillColorAttr, vgl.vertexAttributeKeysIndexed.Two);\n    prog.addVertexAttribute(fillOpacityAttr, vgl.vertexAttributeKeysIndexed.Three);\n\n    prog.addUniform(modelViewUniform);\n    prog.addUniform(projectionUniform);\n\n    prog.addShader(fragmentShader);\n    prog.addShader(vertexShader);\n\n    m_material.addAttribute(prog);\n    m_material.addAttribute(blend);\n\n    m_actor.setMapper(m_mapper);\n    m_actor.setMaterial(m_material);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    if (m_actor) {\n      m_this.renderer().contextRenderer().removeActor(m_actor);\n    }\n\n    createGLPolygons();\n\n    m_this.renderer().contextRenderer().addActor(m_actor);\n    m_this.buildTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() ||\n        m_this.updateTime().getMTime() <= m_this.getMTime()) {\n      m_this._build();\n    }\n\n    m_actor.setVisible(m_this.visible());\n    m_actor.material().setBinNumber(m_this.bin());\n    m_this.updateTime().modified();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Destroy\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.renderer().contextRenderer().removeActor(m_actor);\n    s_exit();\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.gl.polygonFeature, geo.polygonFeature);\n\n// Now register it\ngeo.registerFeature('vgl', 'polygon', geo.gl.polygonFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Single VGL viewer\n *\n * This singleton instance is used to share a single GL context across multiple\n * vlgRenderer and therefore layers.\n * @private\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl._vglViewerInstances = {\n  viewers: [],\n  maps: []\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Retrives the singleton, lazily constructs as necessary.\n *\n * @return {vgl.viewer} the single viewer instance.\n */\n//////////////////////////////////////////////////////////////////////////////\n\ngeo.gl.vglViewerInstance = function (map) {\n  \"use strict\";\n\n  var mapIdx,\n      maps = geo.gl._vglViewerInstances.maps,\n      viewers = geo.gl._vglViewerInstances.viewers,\n      canvas;\n\n  function makeViewer() {\n    canvas = $(document.createElement(\"canvas\"));\n    canvas.attr(\"class\", \"webgl-canvas\");\n    var viewer = vgl.viewer(canvas.get(0));\n    viewer.renderWindow().removeRenderer(\n    viewer.renderWindow().activeRenderer());\n    viewer.init();\n    return viewer;\n  }\n\n  for (mapIdx = 0; mapIdx < maps.length; mapIdx += 1) {\n    if (map === maps[mapIdx]) {\n      break;\n    }\n  }\n\n  if (map !== maps[mapIdx]) {\n    maps[mapIdx] = map;\n    viewers[mapIdx] = makeViewer();\n  }\n\n  viewers[mapIdx]._exit = function () {\n    if (canvas) {\n      canvas.off();\n      canvas.remove();\n    }\n  };\n\n  return viewers[mapIdx];\n};\n\ngeo.gl.vglViewerInstance.deleteCache = function (viewer) {\n  \"use strict\";\n\n  var mapIdx,\n      maps = geo.gl._vglViewerInstances.maps,\n      viewers = geo.gl._vglViewerInstances.viewers;\n\n  for (mapIdx = 0; mapIdx < viewers.length; mapIdx += 1) {\n    if (viewer === undefined || viewer === viewers[mapIdx]) {\n      viewer._exit();\n      maps.splice(mapIdx, 1);\n      viewers.splice(mapIdx, 1);\n    }\n  }\n};\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class vglRenderer\n *\n * @class\n * @extends geo.gl.renderer\n * @param canvas\n * @returns {geo.gl.vglRenderer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gl.vglRenderer = function (arg) {\n  \"use strict\";\n\n  if (!(this instanceof geo.gl.vglRenderer)) {\n    return new geo.gl.vglRenderer(arg);\n  }\n  geo.gl.renderer.call(this, arg);\n\n  var m_this = this,\n      s_exit = this._exit,\n      m_viewer = geo.gl.vglViewerInstance(this.layer().map()),\n      m_contextRenderer = vgl.renderer(),\n      m_width = 0,\n      m_height = 0,\n      s_init = this._init;\n\n  m_contextRenderer.setResetScene(false);\n\n  /// TODO: Move this API to the base class\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return width of the renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.width = function () {\n    return m_width;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return height of the renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.height = function () {\n    return m_height;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert input data in display space to world space\n   *\n   * @param {object} input {x:val, y:val}, [{x:val, y:val}],\n   * [{x:val, y:val}], [x1,y1], [[x,y]]\n   *\n   * @returns {object} {x:val, y:val, z:val, w:val}, [{x:val, y:val, z:val, w:val}],\n              [[x, y, z, w]], [x1,y1,z1,w]\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.displayToWorld = function (input) {\n    var i,\n        delta,\n        ren = m_this.contextRenderer(),\n        cam = ren.camera(),\n        fdp = ren.focusDisplayPoint(),\n        output,\n        temp,\n        point;\n\n    /// Handle if the input is an array [...]\n    if (input instanceof Array && input.length > 0) {\n      output = [];\n    /// Input is array of object {x:val, y:val}\n      if (input[0] instanceof Object) {\n        delta = 1;\n        for (i = 0; i < input.length; i += delta) {\n          point = input[i];\n          temp = ren.displayToWorld(vec4.fromValues(\n                   point.x, point.y, fdp[2], 1.0),\n                   cam.viewMatrix(), cam.projectionMatrix(),\n                   m_width, m_height);\n          output.push({x: temp[0], y: temp[1], z: temp[2], w: temp[3]});\n        }\n    /// Input is array of 2d array [[x,y], [x,y]]\n      } else if (input[0] instanceof Array) {\n        delta = 1;\n        for (i = 0; i < input.length; i += delta) {\n          point = input[i];\n          temp = ren.displayToWorld(vec4.fromValues(\n                   point[0], point[1], fdp[2], 1.0),\n                   cam.viewMatrix(), cam.projectionMatrix(),\n                   m_width, m_height);\n          output.push(temp);\n        }\n    /// Input is flat array [x1,y1,x2,y2]\n      } else {\n        delta = input.length % 3 === 0 ? 3 : 2;\n        for (i = 0; i < input.length; i += delta) {\n          temp = ren.displayToWorld(vec4.fromValues(\n            input[i],\n            input[i + 1],\n            fdp[2],\n            1.0), cam.viewMatrix(), cam.projectionMatrix(),\n            m_width, m_height);\n          output.push(temp[0]);\n          output.push(temp[1]);\n          output.push(temp[2]);\n          output.push(temp[3]);\n        }\n      }\n    /// Input is object {x:val, y:val}\n    } else if (input instanceof Object) {\n      output = {};\n      temp = ren.displayToWorld(vec4.fromValues(\n               input.x, input.y, fdp[2], 1.0),\n               cam.viewMatrix(), cam.projectionMatrix(),\n               m_width, m_height);\n      output = {x: temp[0], y: temp[1], z: temp[2], w: temp[3]};\n    } else {\n      throw \"Display to world conversion requires array of 2D/3D points\";\n    }\n    return output;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert input data in world space to display space\n   *\n   * @param {object} input {x:val, y:val} or {x:val, y:val, z:val} or [{x:val, y:val}]\n   * [{x:val, y:val, z:val}] or [[x,y]] or  [[x,y,z]] or [x1,y1,z1, x2, y2, z2]\n   *\n   * @returns {object} {x:val, y:val} or [{x:val, y:val}] or [[x,y]] or\n   * [x1,y1, x2, y2]\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.worldToDisplay = function (input) {\n    var i, temp, delta,\n        ren = m_this.contextRenderer(), cam = ren.camera(),\n        fp = cam.focalPoint(), output = [];\n\n    /// Input is an array\n    if (input instanceof Array && input.length > 0) {\n      output = [];\n\n      /// Input is an array of objects\n      if (input[0] instanceof Object) {\n        delta = 1;\n        for (i = 0; i < input.length; i += delta) {\n          temp = ren.worldToDisplay(vec4.fromValues(\n                   input[i].x, input[i].y, fp[2], 1.0), cam.viewMatrix(),\n                   cam.projectionMatrix(),\n                   m_width, m_height);\n          output[i] = { x: temp[0], y: temp[1], z: temp[2] };\n        }\n      } else if (input[0] instanceof Array) {\n        /// Input is an array of array\n        delta = 1;\n        for (i = 0; i < input.length; i += delta) {\n          temp = ren.worldToDisplay(\n                   vec4.fromValues(input[i][0], input[i][1], fp[2], 1.0),\n                   cam.viewMatrix(), cam.projectionMatrix(), m_width, m_height);\n          output[i].push(temp);\n        }\n      } else {\n        /// Input is a flat array of 2 or 3 dimension\n        delta = input.length % 3 === 0 ? 3 : 2;\n        if (delta === 2) {\n          for (i = 0; i < input.length; i += delta) {\n            temp = ren.worldToDisplay(vec4.fromValues(\n                     input[i], input[i + 1], fp[2], 1.0), cam.viewMatrix(),\n                     cam.projectionMatrix(),\n                     m_width, m_height);\n            output.push(temp[0]);\n            output.push(temp[1]);\n            output.push(temp[2]);\n          }\n        } else {\n          for (i = 0; i < input.length; i += delta) {\n            temp = ren.worldToDisplay(vec4.fromValues(\n                         input[i], input[i + 1], input[i + 2], 1.0), cam.viewMatrix(),\n                         cam.projectionMatrix(),\n                         m_width, m_height);\n            output.push(temp[0]);\n            output.push(temp[1]);\n            output.push(temp[2]);\n          }\n        }\n      }\n    } else if (input instanceof Object) {\n      temp = ren.worldToDisplay(vec4.fromValues(\n               input.x, input.y, fp[2], 1.0), cam.viewMatrix(),\n               cam.projectionMatrix(),\n               m_width, m_height);\n\n      output = {x: temp[0], y: temp[1], z: temp[2]};\n    } else {\n      throw \"World to display conversion requires array of 2D/3D points\";\n    }\n\n    return output;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get context specific renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.contextRenderer = function () {\n    return m_contextRenderer;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get API used by the renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.api = function () {\n    return \"vgl\";\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    if (m_this.initialized()) {\n      return m_this;\n    }\n\n    s_init.call(m_this);\n\n    m_this.canvas($(m_viewer.canvas()));\n    if (m_viewer.renderWindow().renderers().length > 0) {\n      m_contextRenderer.setLayer(m_viewer.renderWindow().renderers().length);\n      m_contextRenderer.setResetScene(false);\n    }\n    m_viewer.renderWindow().addRenderer(m_contextRenderer);\n\n    m_this.layer().node().append(m_this.canvas());\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle resize event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._resize = function (x, y, w, h) {\n    m_width = w;\n    m_height = h;\n    m_this.canvas().attr(\"width\", w);\n    m_this.canvas().attr(\"height\", h);\n    m_viewer.renderWindow().positionAndResize(x, y, w, h);\n    m_this._render();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Render\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._render = function () {\n    m_viewer.render();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Exit\n   * @todo remove all vgl objects\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    geo.gl.vglViewerInstance.deleteCache(m_viewer);\n    s_exit();\n  };\n\n  this._updateRendererCamera = function () {\n    var vglRenderer = m_this.contextRenderer(),\n        renderWindow = m_viewer.renderWindow(),\n        camera = vglRenderer.camera(),\n        pos, fp, cr;\n\n    vglRenderer.resetCameraClippingRange();\n    pos = camera.position();\n    fp = camera.focalPoint();\n    cr = camera.clippingRange();\n    renderWindow.renderers().forEach(function (renderer) {\n      var cam = renderer.camera();\n\n      if (cam !== camera) {\n        cam.setPosition(pos[0], pos[1], pos[2]);\n        cam.setFocalPoint(fp[0], fp[1], fp[2]);\n        cam.setClippingRange(cr[0], cr[1]);\n        renderer.render();\n      }\n    });\n  };\n\n  // connect to interactor events\n  this.geoOn(geo.event.pan, function (evt) {\n    var vglRenderer = m_this.contextRenderer(),\n        camera,\n        focusPoint,\n        centerDisplay,\n        centerGeo,\n        newCenterDisplay,\n        newCenterGeo,\n        renderWindow,\n        layer = m_this.layer();\n\n    // only the base layer needs to respond\n    if (layer.map().baseLayer() !== layer) {\n      return;\n    }\n\n    // skip handling if the renderer is unconnected\n    if (!vglRenderer || !vglRenderer.camera()) {\n      console.log(\"Pan event triggered on unconnected vgl renderer.\");\n    }\n\n    renderWindow = m_viewer.renderWindow();\n    camera = vglRenderer.camera();\n    focusPoint = renderWindow.focusDisplayPoint();\n\n    // Calculate the center in display coordinates\n    centerDisplay = [m_width / 2, m_height / 2, 0];\n\n    // Calculate the center in world coordinates\n    centerGeo = renderWindow.displayToWorld(\n      centerDisplay[0],\n      centerDisplay[1],\n      focusPoint,\n      vglRenderer\n    );\n\n    newCenterDisplay = [\n      centerDisplay[0] + evt.screenDelta.x,\n      centerDisplay[1] + evt.screenDelta.y\n    ];\n\n    newCenterGeo = renderWindow.displayToWorld(\n      newCenterDisplay[0],\n      newCenterDisplay[1],\n      focusPoint,\n      vglRenderer\n    );\n\n    camera.pan(\n      centerGeo[0] - newCenterGeo[0],\n      centerGeo[1] - newCenterGeo[1],\n      centerGeo[2] - newCenterGeo[2]\n    );\n\n    evt.center = {\n      x: newCenterGeo[0],\n      y: newCenterGeo[1],\n      z: newCenterGeo[2]\n    };\n\n    m_this._updateRendererCamera();\n  });\n\n  this.geoOn(geo.event.zoom, function (evt) {\n    var vglRenderer = m_this.contextRenderer(),\n        camera,\n        renderWindow,\n        layer = m_this.layer(),\n        center,\n        dir,\n        focusPoint,\n        position,\n        newZ;\n\n    // only the base layer needs to respond\n    if (layer.map().baseLayer() !== layer) {\n      return;\n    }\n\n    // skip handling if the renderer is unconnected\n    if (!vglRenderer || !vglRenderer.camera()) {\n      console.log(\"Zoom event triggered on unconnected vgl renderer.\");\n    }\n\n    renderWindow = m_viewer.renderWindow();\n    camera = vglRenderer.camera();\n    focusPoint = camera.focalPoint();\n    position = camera.position();\n    newZ = 360 * Math.pow(2, -evt.zoomLevel);\n\n    evt.pan = null;\n    if (evt.screenPosition) {\n      center = renderWindow.displayToWorld(\n        evt.screenPosition.x,\n        evt.screenPosition.y,\n        focusPoint,\n        vglRenderer\n      );\n      dir = [center[0] - position[0], center[1] - position[1], center[2] - position[2]];\n      evt.center = layer.fromLocal({\n        x: position[0] + dir[0] * (1 - newZ / position[2]),\n        y: position[1] + dir[1] * (1 - newZ / position[2])\n      });\n    }\n\n    camera.setPosition(position[0], position[1], 360 * Math.pow(2, -evt.zoomLevel));\n\n    m_this._updateRendererCamera();\n  });\n\n  return this;\n};\n\ninherit(geo.gl.vglRenderer, geo.gl.renderer);\n\ngeo.registerRenderer(\"vgl\", geo.gl.vglRenderer);\n","/** @namespace */\ngeo.d3 = {};\n\n(function () {\n  'use strict';\n\n  var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz',\n    strLength = 8;\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get a random string to use as a div ID\n   * @returns {string}\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  geo.d3.uniqueID = function () {\n    var strArray = [],\n        i;\n    strArray.length = strLength;\n    for (i = 0; i < strLength; i += 1) {\n      strArray[i] = chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return strArray.join('');\n  };\n\n  // event propagated when the d3 renderer rescales its group element\n  geo.event.d3Rescale = 'geo_d3_rescale';\n}());\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * D3 specific subclass of object which adds an id property for d3 selections\n * on groups of objects by class id.\n * @class\n * @extends geo.sceneObject\n */\n//////////////////////////////////////////////////////////////////////////////\n\ngeo.d3.object = function (arg) {\n  'use strict';\n  // this is used to extend other geojs classes, so only generate\n  // a new object when that is not the case... like if this === window\n  if (!(this instanceof geo.object)) {\n    return new geo.d3.object(arg);\n  }\n  geo.sceneObject.call(this);\n\n  var m_id = 'd3-' + geo.d3.uniqueID(),\n      s_exit = this._exit,\n      m_this = this,\n      s_draw = this.draw;\n\n  this._d3id = function () {\n    return m_id;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Returns a d3 selection for the feature elements\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this.select = function () {\n    return m_this.renderer().select(m_this._d3id());\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Redraw the object.\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this.draw = function () {\n    m_this._update();\n    s_draw();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Removes the element from the svg and the renderer\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.renderer()._removeFeature(m_this._d3id());\n    s_exit();\n  };\n\n  return this;\n};\n\ninherit(geo.d3.object, geo.sceneObject);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of pointFeature\n *\n * @class\n * @extends geo.pointFeature\n * @extends geo.d3.object\n * @returns {geo.d3.pointFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.d3.pointFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.d3.pointFeature)) {\n    return new geo.d3.pointFeature(arg);\n  }\n  arg = arg || {};\n  geo.pointFeature.call(this, arg);\n  geo.d3.object.call(this);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init,\n      s_update = this._update,\n      m_buildTime = geo.timestamp(),\n      m_style = {},\n      m_sticky;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n    m_sticky = m_this.layer().sticky();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var data = m_this.data(),\n        s_style = m_this.style.get(),\n        m_renderer = m_this.renderer(),\n        pos_func = m_this.position();\n\n    // call super-method\n    s_update.call(m_this);\n\n    // default to empty data array\n    if (!data) { data = []; }\n\n    // fill in d3 renderer style object defaults\n    m_style.id = m_this._d3id();\n    m_style.data = data;\n    m_style.append = 'circle';\n    m_style.attributes = {\n      r: m_renderer._convertScale(s_style.radius),\n      cx: function (d) {\n        return m_renderer.worldToDisplay(pos_func(d)).x;\n      },\n      cy: function (d) {\n        return m_renderer.worldToDisplay(pos_func(d)).y;\n      }\n    };\n    m_style.style = s_style;\n    m_style.classes = ['d3PointFeature'];\n\n    // pass to renderer to draw\n    m_this.renderer()._drawFeatures(m_style);\n\n    // update time stamps\n    m_buildTime.modified();\n    m_this.updateTime().modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.getMTime() >= m_buildTime.getMTime()) {\n      m_this._build();\n    }\n\n    return m_this;\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.d3.pointFeature, geo.pointFeature);\n\n// Now register it\ngeo.registerFeature('d3', 'point', geo.d3.pointFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class lineFeature\n *\n * @class\n * @extends geo.lineFeature\n * @extends geo.d3.object\n * @returns {geo.d3.lineFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.d3.lineFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.d3.lineFeature)) {\n    return new geo.d3.lineFeature(arg);\n  }\n  arg = arg || {};\n  geo.lineFeature.call(this, arg);\n  geo.d3.object.call(this);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init,\n      m_buildTime = geo.timestamp(),\n      s_update = this._update;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var data = m_this.data() || [],\n        s_style = m_this.style(),\n        m_renderer = m_this.renderer(),\n        pos_func = m_this.position(),\n        line = d3.svg.line()\n                .x(function (d) { return m_renderer.worldToDisplay(d).x; })\n                .y(function (d) { return m_renderer.worldToDisplay(d).y; });\n\n    s_update.call(m_this);\n    s_style.fill = function () { return false; };\n\n    data.forEach(function (item, idx) {\n      var m_style;\n      var ln = m_this.line()(item, idx);\n\n      var style = {}, key;\n      function wrapStyle(func) {\n        if (geo.util.isFunction(func)) {\n          return function () {\n            return func(ln[0], 0, item, idx);\n          };\n        } else {\n          return func;\n        }\n      }\n      for (key in s_style) {\n        if (s_style.hasOwnProperty(key)) {\n          style[key] = wrapStyle(s_style[key]);\n        }\n      }\n\n      // item is an object representing a single line\n      // m_this.line()(item) is an array of coordinates\n      m_style = {\n        data: [ln.map(function (d, i) { return pos_func(d, i, item, idx);})],\n        append: 'path',\n        attributes: {\n          d: line\n        },\n        id: m_this._d3id() + idx,\n        classes: ['d3LineFeature', 'd3SubLine-' + idx],\n        style: style\n      };\n\n      m_renderer._drawFeatures(m_style);\n    });\n\n    m_buildTime.modified();\n    m_this.updateTime().modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.getMTime() >= m_buildTime.getMTime()) {\n      m_this._build();\n    }\n\n    return m_this;\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.d3.lineFeature, geo.lineFeature);\n\ngeo.registerFeature('d3', 'line', geo.d3.lineFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class pathFeature\n *\n * @class\n * @extends geo.pathFeature\n * @extends geo.d3.object\n * @returns {geo.d3.pathFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.d3.pathFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.d3.pathFeature)) {\n    return new geo.d3.pathFeature(arg);\n  }\n  arg = arg || {};\n  geo.pathFeature.call(this, arg);\n  geo.d3.object.call(this);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init,\n      m_buildTime = geo.timestamp(),\n      s_update = this._update,\n      m_style = {};\n\n  m_style.style = {};\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var data = m_this.data() || [],\n        s_style = m_this.style(),\n        m_renderer = m_this.renderer(),\n        tmp, diag;\n    s_update.call(m_this);\n\n    diag = function (d) {\n        var p = {\n          source: d.source,\n          target: d.target\n        };\n        return d3.svg.diagonal()(p);\n      };\n    tmp = [];\n    data.forEach(function (d, i) {\n      var src, trg;\n      if (i < data.length - 1) {\n        src = d;\n        trg = data[i + 1];\n        tmp.push({\n          source: m_renderer.worldToDisplay(src),\n          target: m_renderer.worldToDisplay(trg)\n        });\n      }\n    });\n    m_style.data = tmp;\n    m_style.attributes = {\n      d: diag\n    };\n\n    m_style.id = m_this._d3id();\n    m_style.append = 'path';\n    m_style.classes = ['d3PathFeature'];\n    m_style.style = $.extend({\n      'fill': function () { return false; },\n      'fillColor': function () { return { r: 0, g: 0, b: 0 }; }\n    }, s_style);\n\n    m_this.renderer()._drawFeatures(m_style);\n\n    m_buildTime.modified();\n    m_this.updateTime().modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   *\n   * @override\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.dataTime().getMTime() >= m_buildTime.getMTime()) {\n      m_this._build();\n    }\n\n    return m_this;\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.d3.pathFeature, geo.pathFeature);\n\ngeo.registerFeature('d3', 'path', geo.d3.pathFeature);\n","/**\n * @class\n * @extends geo.graphFeature\n */\ngeo.d3.graphFeature = function (arg) {\n  'use strict';\n\n  var m_this = this;\n\n  if (!(this instanceof geo.d3.graphFeature)) {\n    return new geo.d3.graphFeature(arg);\n  }\n  geo.graphFeature.call(this, arg);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Returns a d3 selection for the graph elements\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this.select = function () {\n    var renderer = m_this.renderer(),\n        selection = {},\n        node = m_this.nodeFeature(),\n        links = m_this.linkFeatures();\n    selection.nodes = renderer.select(node._d3id());\n    selection.links = links.map(function (link) {\n      return renderer.select(link._d3id());\n    });\n    return selection;\n  };\n\n  return this;\n};\n\ninherit(geo.d3.graphFeature, geo.graphFeature);\n\ngeo.registerFeature('d3', 'graph', geo.d3.graphFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a plane feature given a lower left corner point geo.latlng\n * and and upper right corner point geo.latlng\n *\n * *CURRENTLY BROKEN*\n *\n * @class\n * @extends geo.planeFeature\n * @param lowerleft\n * @param upperright\n * @returns {geo.d3.planeFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.d3.planeFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.d3.planeFeature)) {\n    return new geo.d3.planeFeature(arg);\n  }\n  geo.planeFeature.call(this, arg);\n  geo.d3.object.call(this);\n\n  var m_this = this,\n      m_style = {},\n      s_update = this._update,\n      s_init = this._init,\n      m_buildTime = geo.timestamp();\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Normalize a coordinate as an object {x: ..., y: ...}\n   *\n   * @private\n   * @returns {Object}\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  function normalize(pt) {\n    if (Array.isArray(pt)) {\n      return {\n        x: pt[0],\n        y: pt[1]\n      };\n    } else if (pt instanceof geo.latlng) {\n      return {\n        x: pt.x(),\n        y: pt.y()\n      };\n    }\n    return pt;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build the feature object and pass to the renderer for drawing.\n   *\n   * @private\n   * @returns {geo.d3.planeFeature}\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var origin = normalize(m_this.origin()),\n        ul = normalize(m_this.upperLeft()),\n        lr = normalize(m_this.lowerRight()),\n        renderer = m_this.renderer(),\n        s = m_this.style();\n\n    delete s.fill_color;\n    delete s.color;\n    delete s.opacity;\n    if (!s.screenCoordinates) {\n      origin = renderer.worldToDisplay(origin);\n      ul = renderer.worldToDisplay(ul);\n      lr = renderer.worldToDisplay(lr);\n    }\n    m_style.id = m_this._d3id();\n    m_style.style = s;\n    m_style.attributes = {\n      x: ul.x,\n      y: ul.y,\n      width: lr.x - origin.x,\n      height: origin.y - ul.y\n    };\n    m_style.append = 'rect';\n    m_style.data = [0];\n    m_style.classes = ['d3PlaneFeature'];\n\n    renderer._drawFeatures(m_style);\n    m_buildTime.modified();\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Redraw the plane feature if necessary.\n   *\n   * @private\n   * @returns {geo.d3.planeFeature}\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.dataTime().getMTime() >= m_buildTime.getMTime()) {\n      m_this._build();\n    }\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initializes the plane feature style (over-riding the parent default).\n   *\n   * @private\n   * @returns {geo.d3.planeFeature}\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg || {});\n    m_this.style({\n      stroke: function () { return false; },\n      fill: function () { return true; },\n      fillColor: function () { return {r: 0.3, g: 0.3, b: 0.3}; },\n      fillOpacity: function () { return 0.5; }\n    });\n    return m_this;\n  };\n\n  this._init();\n  return this;\n};\n\ninherit(geo.d3.planeFeature, geo.planeFeature);\n\ngeo.registerFeature('d3', 'plane', geo.d3.planeFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of vectorFeature\n *\n * @class\n * @extends geo.vectorFeature\n * @extends geo.d3.object\n * @returns {geo.d3.vectorFeature}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.d3.vectorFeature = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.d3.vectorFeature)) {\n    return new geo.d3.vectorFeature(arg);\n  }\n  arg = arg || {};\n  geo.vectorFeature.call(this, arg);\n  geo.d3.object.call(this);\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  var m_this = this,\n      s_init = this._init,\n      s_exit = this._exit,\n      s_update = this._update,\n      m_buildTime = geo.timestamp(),\n      m_style = {},\n      m_sticky;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Generate a unique ID for a marker definition\n   * @private\n   * @param {object} d Unused datum (for d3 compat)\n   * @param {number} i The marker index\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function markerID(d, i) {\n    return m_this._d3id() + '_marker_' + i;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Add marker styles for vector arrows.\n   * @private\n   * @param {object[]} data The vector data array\n   * @param {function} stroke The stroke accessor\n   * @param {function} opacity The opacity accessor\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function updateMarkers(data, stroke, opacity) {\n\n    var renderer = m_this.renderer();\n    var sel = m_this.renderer()._definitions()\n      .selectAll('marker.geo-vector')\n        .data(data);\n    sel.enter()\n      .append('marker')\n        .attr('id', markerID)\n        .attr('class', 'geo-vector')\n        .attr('viewBox', '0 0 10 10')\n        .attr('refX', '1')\n        .attr('refY', '5')\n        .attr('markerWidth', '5')\n        .attr('markerHeight', '5')\n        .attr('orient', 'auto')\n        .append('path')\n          .attr('d', 'M 0 0 L 10 5 L 0 10 z');\n\n    sel.exit().remove();\n\n    sel.style('stroke', renderer._convertColor(stroke))\n      .style('fill', renderer._convertColor(stroke))\n      .style('opacity', opacity);\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   * @protected\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function (arg) {\n    s_init.call(m_this, arg);\n    m_sticky = m_this.layer().sticky();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Build\n   * @protected\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._build = function () {\n    var data = m_this.data(),\n        s_style = m_this.style.get(),\n        m_renderer = m_this.renderer(),\n        orig_func = m_this.origin(),\n        size_func = m_this.delta(),\n        cache = [],\n        scale = m_this.style('scale'),\n        max = Number.NEGATIVE_INFINITY;\n\n    // call super-method\n    s_update.call(m_this);\n\n    // default to empty data array\n    if (!data) { data = []; }\n\n    // cache the georeferencing\n    cache = data.map(function (d, i) {\n      var origin = m_renderer.worldToDisplay(orig_func(d, i)),\n          delta = size_func(d, i);\n      max = Math.max(max, delta.x * delta.x + delta.y * delta.y);\n      return {\n        x1: origin.x,\n        y1: origin.y,\n        dx: delta.x,\n        dy: -delta.y\n      };\n    });\n\n    max = Math.sqrt(max);\n    if (!scale) {\n      scale = 75 / max;\n    }\n\n    function getScale() {\n      return scale / m_renderer.scaleFactor();\n    }\n\n    // fill in d3 renderer style object defaults\n    m_style.id = m_this._d3id();\n    m_style.data = data;\n    m_style.append = 'line';\n    m_style.attributes = {\n      x1: function (d, i) {\n        return cache[i].x1;\n      },\n      y1: function (d, i) {\n        return cache[i].y1;\n      },\n      x2: function (d, i) {\n        return cache[i].x1 + getScale() * cache[i].dx;\n      },\n      y2: function (d, i) {\n        return cache[i].y1 + getScale() * cache[i].dy;\n      },\n      'marker-end': function (d, i) {\n        return 'url(#' + markerID(d, i) + ')';\n      }\n    };\n    m_style.style = {\n      stroke: function () { return true; },\n      strokeColor: s_style.strokeColor,\n      strokeWidth: s_style.strokeWidth,\n      strokeOpacity: s_style.strokeOpacity\n    };\n    m_style.classes = ['d3VectorFeature'];\n\n    // Add markers to the defition list\n    updateMarkers(data, s_style.strokeColor, s_style.strokeOpacity);\n\n    // pass to renderer to draw\n    m_this.renderer()._drawFeatures(m_style);\n\n    // update time stamps\n    m_buildTime.modified();\n    m_this.updateTime().modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update\n   * @protected\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n    s_update.call(m_this);\n\n    if (m_this.getMTime() >= m_buildTime.getMTime()) {\n      m_this._build();\n    } else {\n      updateMarkers(\n        m_style.data,\n        m_style.style.strokeColor,\n        m_style.style.strokeOpacity\n      );\n    }\n\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Exit\n   * @protected\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    s_exit.call(m_this);\n    m_style = {};\n    updateMarkers([], null, null);\n  };\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.d3.vectorFeature, geo.vectorFeature);\n\n// Now register it\ngeo.registerFeature('d3', 'vector', geo.d3.vectorFeature);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class d3Renderer\n *\n * @class\n * @extends geo.renderer\n * @returns {geo.d3.d3Renderer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.d3.d3Renderer = function (arg) {\n  'use strict';\n\n  if (!(this instanceof geo.d3.d3Renderer)) {\n    return new geo.d3.d3Renderer(arg);\n  }\n  geo.renderer.call(this, arg);\n\n  var s_exit = this._exit;\n\n  geo.d3.object.call(this, arg);\n\n  arg = arg || {};\n\n  var m_this = this,\n      m_sticky = null,\n      m_features = {},\n      m_corners = null,\n      m_width = null,\n      m_height = null,\n      m_scale = 1,\n      m_dx = 0,\n      m_dy = 0,\n      m_svg = null,\n      m_defs = null;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Set attributes to a d3 selection.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function setAttrs(select, attrs) {\n    var key;\n    for (key in attrs) {\n      if (attrs.hasOwnProperty(key)) {\n        select.attr(key, attrs[key]);\n      }\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Meta functions for converting from geojs styles to d3.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._convertColor = function (f, g) {\n    f = geo.util.ensureFunction(f);\n    g = g || function () { return true; };\n    return function () {\n      var c = 'none';\n      if (g.apply(this, arguments)) {\n        c = f.apply(this, arguments);\n        if (c.hasOwnProperty('r') &&\n            c.hasOwnProperty('g') &&\n            c.hasOwnProperty('b')) {\n          c = d3.rgb(255 * c.r, 255 * c.g, 255 * c.b);\n        }\n      }\n      return c;\n    };\n  };\n\n  this._convertPosition = function (f) {\n    f = geo.util.ensureFunction(f);\n    return function () {\n      return m_this.worldToDisplay(f.apply(this, arguments));\n    };\n  };\n\n  this._convertScale = function (f) {\n    f = geo.util.ensureFunction(f);\n    return function () {\n      return f.apply(this, arguments) / m_scale;\n    };\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Set styles to a d3 selection. Ignores unkown style keys.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function setStyles(select, styles) {\n    /* jshint validthis:true */\n    var key, k, f;\n    function fillFunc() {\n      if (styles.fill.apply(this, arguments)) {\n        return null;\n      } else {\n        return 'none';\n      }\n    }\n    function strokeFunc() {\n      if (styles.stroke.apply(this, arguments)) {\n        return null;\n      } else {\n        return 'none';\n      }\n    }\n    for (key in styles) {\n      if (styles.hasOwnProperty(key)) {\n        f = null;\n        k = null;\n        if (key === 'strokeColor') {\n          k = 'stroke';\n          f = m_this._convertColor(styles[key], styles.stroke);\n        } else if (key === 'stroke' && styles[key]) {\n          k = 'stroke';\n          f = strokeFunc;\n        } else if (key === 'strokeWidth') {\n          k = 'stroke-width';\n          f = m_this._convertScale(styles[key]);\n        } else if (key === 'strokeOpacity') {\n          k = 'stroke-opacity';\n          f = styles[key];\n        } else if (key === 'fillColor') {\n          k = 'fill';\n          f = m_this._convertColor(styles[key], styles.fill);\n        } else if (key === 'fill' && !styles.hasOwnProperty('fillColor')) {\n          k = 'fill';\n          f = fillFunc;\n        } else if (key === 'fillOpacity') {\n          k = 'fill-opacity';\n          f = styles[key];\n        }\n        if (k) {\n          select.style(k, f);\n        }\n      }\n    }\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the map instance or return null if not connected to a map.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function getMap() {\n    var layer = m_this.layer();\n    if (!layer) {\n      return null;\n    }\n    return layer.map();\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the svg group element associated with this renderer instance.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function getGroup() {\n    return m_svg.select('.group-' + m_this._d3id());\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Set the initial lat-lon coordinates of the map view.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function initCorners() {\n    var layer = m_this.layer(),\n        map = layer.map(),\n        width = m_this.layer().width(),\n        height = m_this.layer().height();\n\n    m_width = width;\n    m_height = height;\n    if (!m_width || !m_height) {\n      throw 'Map layer has size 0';\n    }\n    m_corners = {\n      'upperLeft': map.displayToGcs({'x': 0, 'y': 0}),\n      'lowerRight': map.displayToGcs({'x': width, 'y': height})\n    };\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Set the translation, scale, and zoom for the current view.\n   * @note rotation not yet supported\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function setTransform() {\n\n    if (!m_corners) {\n      initCorners();\n    }\n\n    if (!m_sticky) {\n      return;\n    }\n\n    var layer = m_this.layer(),\n        map = layer.map(),\n        upperLeft = map.gcsToDisplay(m_corners.upperLeft),\n        lowerRight = map.gcsToDisplay(m_corners.lowerRight),\n        group = getGroup(),\n        dx, dy, scale;\n\n    // calculate the translation\n    dx = upperLeft.x;\n    dy = upperLeft.y;\n\n    // calculate the scale\n    scale = (lowerRight.y - upperLeft.y) / m_height;\n\n    // set the group transform property\n    group.attr('transform', 'matrix(' + [scale, 0, 0, scale, dx, dy].join() + ')');\n\n    // set internal variables\n    m_scale = scale;\n    m_dx = dx;\n    m_dy = dy;\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert from screen pixel coordinates to the local coordinate system\n   * in the SVG group element taking into account the transform.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function baseToLocal(pt) {\n    return {\n      x: (pt.x - m_dx) / m_scale,\n      y: (pt.y - m_dy) / m_scale\n    };\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert from the local coordinate system in the SVG group element\n   * to screen pixel coordinates.\n   * @private\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  function localToBase(pt) {\n    return {\n      x: pt.x * m_scale + m_dx,\n      y: pt.y * m_scale + m_dy\n    };\n  }\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Initialize\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    if (!m_this.canvas()) {\n      var canvas;\n      m_svg = d3.select(m_this.layer().node().get(0)).append('svg');\n\n      // create a global svg definitions element\n      m_defs = m_svg.append('defs');\n\n      var shadow = m_defs\n        .append('filter')\n          .attr('id', 'geo-highlight')\n          .attr('x', '-100%')\n          .attr('y', '-100%')\n          .attr('width', '300%')\n          .attr('height', '300%');\n      shadow\n        .append('feMorphology')\n          .attr('operator', 'dilate')\n          .attr('radius', 2)\n          .attr('in', 'SourceAlpha')\n          .attr('result', 'dilateOut');\n      shadow\n        .append('feGaussianBlur')\n          .attr('stdDeviation', 5)\n          .attr('in', 'dilateOut')\n          .attr('result', 'blurOut');\n      shadow\n        .append('feColorMatrix')\n          .attr('type', 'matrix')\n          .attr('values', '-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0')\n          .attr('in', 'blurOut')\n          .attr('result', 'invertOut');\n      shadow\n        .append('feBlend')\n          .attr('in', 'SourceGraphic')\n          .attr('in2', 'invertOut')\n          .attr('mode', 'normal');\n      canvas = m_svg.append('g');\n\n      shadow = m_defs.append('filter')\n          .attr('id', 'geo-blur')\n          .attr('x', '-100%')\n          .attr('y', '-100%')\n          .attr('width', '300%')\n          .attr('height', '300%');\n\n      shadow\n        .append('feGaussianBlur')\n          .attr('stdDeviation', 20)\n          .attr('in', 'SourceGraphic');\n\n      m_sticky = m_this.layer().sticky();\n      m_svg.attr('class', m_this._d3id());\n      m_svg.attr('width', m_this.layer().node().width());\n      m_svg.attr('height', m_this.layer().node().height());\n\n      canvas.attr('class', 'group-' + m_this._d3id());\n\n      m_this.canvas(canvas);\n    }\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert from coordinates in the svg group element to lat/lon.\n   * Supports objects or arrays of objects.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.displayToWorld = function (pt) {\n    var map = getMap();\n    if (!map) {\n      throw 'Cannot project until this layer is connected to a map.';\n    }\n    if (Array.isArray(pt)) {\n      pt = pt.map(function (x) {\n        return map.displayToGcs(localToBase(x));\n      });\n    } else {\n      pt = map.displayToGcs(localToBase(pt));\n    }\n    return pt;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Convert from lat/lon to pixel coordinates in the svg group element.\n   * Supports objects or arrays of objects.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.worldToDisplay = function (pt) {\n    var map = getMap();\n    if (!map) {\n      throw 'Cannot project until this layer is connected to a map.';\n    }\n    var v;\n    if (Array.isArray(pt)) {\n      v = pt.map(function (x) {\n        return baseToLocal(map.gcsToDisplay(x));\n      });\n    } else {\n      v = baseToLocal(map.gcsToDisplay(pt));\n    }\n    return v;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get API used by the renderer\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.api = function () {\n    return 'd3';\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the current scaling factor to build features that shouldn't\n   * change size during zooms.  For example:\n   *\n   *  selection.append('circle')\n   *    .attr('r', r0 / renderer.scaleFactor());\n   *\n   * This will create a circle element with radius r0 independent of the\n   * current zoom level.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.scaleFactor = function () {\n    return m_scale;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Handle resize event\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._resize = function (x, y, w, h) {\n    if (!m_corners) {\n      initCorners();\n    }\n    m_svg.attr('width', w);\n    m_svg.attr('height', h);\n    setTransform();\n    m_this.layer().geoTrigger(geo.event.d3Rescale, { scale: m_scale }, true);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Update noop for geo.d3.object api.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._update = function () {\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Exit\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_features = {};\n    m_this.canvas().remove();\n    s_exit();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the definitions dom element for the layer\n   * @protected\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._definitions = function () {\n    return m_defs;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create a new feature element from an object that describes the feature\n   * attributes.  To be called from feature classes only.\n   *\n   * Input:\n   *  {\n   *    id:         A unique string identifying the feature.\n   *    data:       Array of data objects used in a d3 data method.\n   *    index:      A function that returns a unique id for each data element.\n   *    style:      An object containing element CSS styles.\n   *    attributes: An object containing element attributes.\n   *    classes:    An array of classes to add to the elements.\n   *    append:     The element type as used in d3 append methods.\n   *  }\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._drawFeatures = function (arg) {\n    m_features[arg.id] = {\n      data: arg.data,\n      index: arg.dataIndex,\n      style: arg.style,\n      attributes: arg.attributes,\n      classes: arg.classes,\n      append: arg.append\n    };\n    return m_this.__render(arg.id);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Updates a feature by performing a d3 data join.  If no input id is\n  *  provided then this method will update all features.\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this.__render = function (id) {\n    var key;\n    if (id === undefined) {\n      for (key in m_features) {\n        if (m_features.hasOwnProperty(key)) {\n          m_this.__render(key);\n        }\n      }\n      return m_this;\n    }\n    var data = m_features[id].data,\n        index = m_features[id].index,\n        style = m_features[id].style,\n        attributes = m_features[id].attributes,\n        classes = m_features[id].classes,\n        append = m_features[id].append,\n        selection = m_this.select(id).data(data, index);\n    selection.enter().append(append);\n    selection.exit().remove();\n    setAttrs(selection, attributes);\n    selection.attr('class', classes.concat([id]).join(' '));\n    setStyles(selection, style);\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Returns a d3 selection for the given feature id.\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this.select = function (id) {\n    return getGroup().selectAll('.' + id);\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Removes a feature from the layer.\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this._removeFeature = function (id) {\n    m_this.select(id).remove();\n    delete m_features[id];\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n  *  Override draw method to do nothing.\n  */\n  ////////////////////////////////////////////////////////////////////////////\n  this.draw = function () {\n  };\n\n  // connect to pan event\n  this.layer().geoOn(geo.event.pan, setTransform);\n\n  // connect to zoom event\n  this.layer().geoOn(geo.event.zoom, function () {\n    setTransform();\n    m_this.__render();\n    m_this.layer().geoTrigger(geo.event.d3Rescale, { scale: m_scale }, true);\n  });\n\n  this.layer().geoOn(geo.event.resize, function (event) {\n    m_this._resize(event.x, event.y, event.width, event.height);\n  });\n\n  this._init(arg);\n  return this;\n};\n\ninherit(geo.d3.d3Renderer, geo.renderer);\n\ngeo.registerRenderer('d3', geo.d3.d3Renderer);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * @namespace\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gui = {};\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class uiLayer\n *\n * @class\n * @extends {geo.layer}\n * @returns {geo.gui.uiLayer}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gui.uiLayer = function (arg) {\n  'use strict';\n\n  // The widget stays fixed on the screen.  (only available in d3 at the moment)\n  arg.renderer = 'd3';\n  arg.sticky = false;\n\n  if (!(this instanceof geo.gui.uiLayer)) {\n    return new geo.gui.uiLayer(arg);\n  }\n  geo.layer.call(this, arg);\n\n  var m_this = this,\n      s_exit = this._exit;\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create a new ui control\n   *\n   * @returns {geo.gui.Widget} Will return a new control widget\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.createWidget = function (widgetName, arg) {\n\n    var newWidget = geo.createWidget(\n      widgetName, m_this, m_this.renderer(), arg);\n\n    m_this.addChild(newWidget);\n    newWidget._init();\n    m_this.modified();\n    return newWidget;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Delete a ui control\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.deleteWidget = function (widget) {\n    widget._exit();\n    m_this.removeChild(widget);\n    m_this.modified();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Free memory and destroy the layer.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_this.children().forEach(function (child) {\n      m_this.deleteWidget(child);\n    });\n    s_exit();\n  };\n};\n\ninherit(geo.gui.uiLayer, geo.layer);\n\ngeo.registerLayer('ui', geo.gui.uiLayer);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class widget\n *\n * @class\n * @extends {geo.sceneObject}\n * @returns {geo.gui.widget}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gui.widget = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.gui.widget)) {\n    return new geo.gui.widget(arg);\n  }\n  geo.sceneObject.call(this, arg);\n\n  var m_this = this,\n      s_exit = this._exit,\n      m_layer = arg.layer;\n\n  this._init = function () {\n    m_this.modified();\n  };\n\n  this._exit = function () {\n    m_this.children().forEach(function (child) {\n      m_this._deleteFeature(child);\n    });\n    s_exit();\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Create feature give a name\n   *\n   * @returns {geo.Feature} Will return a new feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._createFeature = function (featureName, arg) {\n\n    var newFeature = geo.createFeature(\n      featureName, m_this, m_this.renderer(), arg);\n\n    m_this.addChild(newFeature);\n    m_this.modified();\n    return newFeature;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Delete feature\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this._deleteFeature = function (feature) {\n    m_this.removeChild(feature);\n    feature._exit();\n    return m_this;\n  };\n\n  ////////////////////////////////////////////////////////////////////////////\n  /**\n   * Return the layer associated with this widget.\n   */\n  ////////////////////////////////////////////////////////////////////////////\n  this.layer = function () {\n    return m_layer;\n  };\n};\ninherit(geo.gui.widget, geo.sceneObject);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class sliderWidget\n *\n * @class\n * @extends {geo.gui.widget}\n * @returns {geo.gui.sliderWidget}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gui.sliderWidget = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.gui.sliderWidget)) {\n    return new geo.gui.sliderWidget(arg);\n  }\n  geo.gui.widget.call(this, arg);\n\n  var m_this = this,\n      s_exit = this._exit,\n      m_xscale,\n      m_yscale,\n      m_plus,\n      m_minus,\n      m_track,\n      m_nub,\n      m_width = 20, // Approximate size of the widget in pixels\n      m_height = 100,\n      m_nubSize = 10,\n      m_plusIcon,\n      m_minusIcon,\n      m_group,\n      m_lowContrast,\n      m_highlightDur = 100;\n\n  /* http://icomoon.io */\n  /* CC BY 3.0 http://creativecommons.org/licenses/by/3.0/ */\n  /* jshint -W101 */\n  m_plusIcon = 'M512 81.92c-237.568 0-430.080 192.614-430.080 430.080 0 237.568 192.563 430.080 430.080 430.080s430.080-192.563 430.080-430.080c0-237.517-192.563-430.080-430.080-430.080zM564.326 564.326v206.182h-104.653v-206.182h-206.234v-104.653h206.182v-206.234h104.704v206.182h206.182v104.704h-206.182z';\n  m_minusIcon = 'M512 81.92c-237.568 0-430.080 192.614-430.080 430.080 0 237.568 192.563 430.080 430.080 430.080s430.080-192.563 430.080-430.080c0-237.517-192.563-430.080-430.080-430.080zM770.56 459.674v104.704h-517.12v-104.704h517.12z';\n  /* jshint +W101 */\n\n  // Define off-white gray colors for low contrast ui (unselected).\n  m_lowContrast = {\n    white: '#f4f4f4',\n    black: '#505050'\n  };\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Add an icon from a path string.  Returns a d3 group element.\n *\n * @function\n * @argument {String} icon svg path string\n * @argument {Array} base where to append the element (d3 selection)\n * @argument {Number} cx Center x-coordinate\n * @argument {Number} cy Center y-coordinate\n * @argument {Number} size Icon size in pixels\n * @returns {object}\n * @private\n */\n//////////////////////////////////////////////////////////////////////////////\n  function put_icon(icon, base, cx, cy, size) {\n    var g = base.append('g');\n\n    // the scale factor\n    var s = size / 1024;\n\n    g.append('g')\n      .append('g')\n        .attr(\n          'transform',\n          'translate(' + cx + ',' + cy + ') scale(' + s + ') translate(-512,-512)'\n      )\n      .append('path')\n        .attr('d', icon)\n        .attr('class', 'geo-glyphicon');\n\n    return g;\n  }\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Initialize the slider widget in the map.\n *\n * @function\n * @returns {geo.gui.sliderWidget}\n * @private\n */\n//////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    var svg = m_this.layer().renderer().canvas(),\n        x0 = 40,\n        y0 = 40 + m_width,\n        map = m_this.layer().map();\n\n    // create d3 scales for positioning\n    // TODO: make customizable and responsive\n    m_xscale = d3.scale.linear().domain([-4, 4]).range([x0, x0 + m_width]);\n    m_yscale = d3.scale.linear().domain([0, 1]).range([y0, y0 + m_height]);\n\n    // Create the main group element\n    svg = svg.append('g').classed('geo-ui-slider', true);\n    m_group = svg;\n\n    // Create + zoom button\n    m_plus = svg.append('g');\n    m_plus.append('circle')\n      .datum({\n        fill: 'white',\n        stroke: null\n      })\n      .classed('geo-zoom-in', true)\n      .attr('cx', m_xscale(0))\n      .attr('cy', m_yscale(0.0) - m_width + 2)\n      .attr('r', m_width / 2)\n      .style({\n        'cursor': 'pointer'\n      })\n      .on('click', function () {\n        var z = map.zoom();\n        map.transition({\n          zoom: z + 1,\n          ease: d3.ease('cubic-in-out'),\n          duration: 500\n        });\n      })\n      .on('mousedown', function () {\n        d3.event.stopPropagation();\n      });\n\n    put_icon(\n      m_plusIcon,\n      m_plus,\n      m_xscale(0),\n      m_yscale(0) - m_width + 2,\n      m_width + 5\n    ).style('cursor', 'pointer')\n      .style('pointer-events', 'none')\n      .select('path')\n      .datum({\n        fill: 'black',\n        stroke: null\n      });\n\n    // Create the - zoom button\n    m_minus = svg.append('g');\n    m_minus.append('circle')\n      .datum({\n        fill: 'white',\n        stroke: null\n      })\n      .classed('geo-zoom-out', true)\n      .attr('cx', m_xscale(0))\n      .attr('cy', m_yscale(1.0) + m_width - 2)\n      .attr('r', m_width / 2)\n      .style({\n        'cursor': 'pointer'\n      })\n      .on('click', function () {\n        var z = map.zoom();\n        map.transition({\n          zoom: z - 1,\n          ease: d3.ease('cubic-in-out'),\n          duration: 500\n        });\n      })\n      .on('mousedown', function () {\n        d3.event.stopPropagation();\n      });\n\n    put_icon(\n      m_minusIcon,\n      m_minus,\n      m_xscale(0),\n      m_yscale(1) + m_width - 2,\n      m_width + 5\n    ).style('cursor', 'pointer')\n      .style('pointer-events', 'none')\n      .select('path')\n      .datum({\n        fill: 'black',\n        stroke: null\n      });\n\n    // Respond to a mouse event on the widget\n    function respond(evt, trans) {\n      var z = m_yscale.invert(d3.mouse(m_this.layer().node()[0])[1]),\n          zrange = map.zoomRange();\n      z = (1 - z) * (zrange.max - zrange.min) + zrange.min;\n      if (trans) {\n        map.transition({\n          zoom: z,\n          ease: d3.ease('cubic-in-out'),\n          duration: 500,\n          done: m_this._update()\n        });\n      } else {\n        map.zoom(z);\n        m_this._update();\n      }\n      evt.stopPropagation();\n    }\n\n    // Create the track\n    m_track = svg.append('rect')\n      .datum({\n        fill: 'white',\n        stroke: 'black'\n      })\n      .classed('geo-zoom-track', true)\n      .attr('x', m_xscale(0) - m_width / 6)\n      .attr('y', m_yscale(0))\n      .attr('rx', m_width / 10)\n      .attr('ry', m_width / 10)\n      .attr('width', m_width / 3)\n      .attr('height', m_height)\n      .style({\n        'cursor': 'pointer'\n      })\n      .on('click', function () {\n        respond(d3.event, true);\n      });\n\n    // Create the nub\n    m_nub = svg.append('rect')\n      .datum({\n        fill: 'black',\n        stroke: null\n      })\n      .classed('geo-zoom-nub', true)\n      .attr('x', m_xscale(-4))\n      .attr('y', m_yscale(0.5) - m_nubSize / 2)\n      .attr('rx', 3)\n      .attr('ry', 3)\n      .attr('width', m_width)\n      .attr('height', m_nubSize)\n      .style({\n        'cursor': 'pointer'\n      })\n      .on('mousedown', function () {\n        d3.select(document).on('mousemove.geo.slider', function () {\n          respond(d3.event);\n        });\n        d3.select(document).on('mouseup.geo.slider', function () {\n          respond(d3.event);\n          d3.select(document).on('.geo.slider', null);\n        });\n        d3.event.stopPropagation();\n      });\n\n    var mouseOver = function () {\n      d3.select(this).attr('filter', 'url(#geo-highlight)');\n      m_group.selectAll('rect,path,circle').transition()\n        .duration(m_highlightDur)\n        .style('fill', function (d) {\n          return d.fill || null;\n        })\n        .style('stroke', function (d) {\n          return d.stroke || null;\n        });\n\n    };\n\n    var mouseOut = function () {\n      d3.select(this).attr('filter', null);\n      m_group.selectAll('circle,rect,path').transition()\n        .duration(m_highlightDur)\n        .style('fill', function (d) {\n          return m_lowContrast[d.fill] || null;\n        })\n        .style('stroke', function (d) {\n          return m_lowContrast[d.stroke] || null;\n        });\n    };\n\n    m_group.selectAll('*')\n      .on('mouseover', mouseOver)\n      .on('mouseout', mouseOut);\n\n    // Update the nub position on zoom\n    m_this.layer().geoOn(geo.event.zoom, function () {\n      m_this._update();\n    });\n\n    mouseOut();\n    m_this._update();\n  };\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Removes the slider element from the map and unbinds all handlers.\n *\n * @function\n * @returns {geo.gui.sliderWidget}\n * @private\n */\n//////////////////////////////////////////////////////////////////////////////\n  this._exit = function () {\n    m_group.remove();\n    m_this.layer().geoOff(geo.event.zoom);\n    s_exit();\n  };\n\n//////////////////////////////////////////////////////////////////////////////\n/**\n * Update the slider widget state in reponse to map changes.  I.e. zoom\n * range changes.\n *\n * @function\n * @returns {geo.gui.sliderWidget}\n * @private\n */\n//////////////////////////////////////////////////////////////////////////////\n  this._update = function (obj) {\n    var map = m_this.layer().map(),\n        zoomRange = map.zoomRange(),\n        zoom = map.zoom(),\n        zoomScale = d3.scale.linear();\n\n    obj = obj || {};\n    zoom = obj.value || zoom;\n    zoomScale.domain([zoomRange.min, zoomRange.max])\n      .range([1, 0])\n      .clamp(true);\n\n    m_nub.attr('y', m_yscale(zoomScale(zoom)) - m_nubSize / 2);\n  };\n};\n\ninherit(geo.gui.sliderWidget, geo.gui.widget);\n\ngeo.registerWidget('d3', 'slider', geo.gui.sliderWidget);\n","//////////////////////////////////////////////////////////////////////////////\n/**\n * Create a new instance of class legendWidget\n *\n * @class\n * @extends geo.gui.widget\n * @returns {geo.gui.legendWidget}\n */\n//////////////////////////////////////////////////////////////////////////////\ngeo.gui.legendWidget = function (arg) {\n  'use strict';\n  if (!(this instanceof geo.gui.legendWidget)) {\n    return new geo.gui.legendWidget(arg);\n  }\n  geo.gui.widget.call(this, arg);\n\n  /** @private */\n  var m_this = this,\n      m_categories = [],\n      m_top = null,\n      m_group = null,\n      m_border = null,\n      m_spacing = 20, // distance in pixels between lines\n      m_padding = 12; // padding in pixels inside the border\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get or set the category array associated with\n   * the legend.  Each element of this array is\n   * an object: ::\n   *     {\n   *         name: string,\n   *         style: object,\n   *         type: 'point' | 'line' | ...\n   *     }\n   *\n   * The style property can contain the following feature styles:\n   *     * fill: bool\n   *     * fillColor: object | string\n   *     * fillOpacity: number\n   *     * stroke: bool\n   *     * strokeColor: object | string\n   *     * strokeWidth: number\n   *     * strokeOpacity: number\n   *\n   * The type controls how the element is displayed, point as a circle,\n   * line as a line segment.  Any other value will display as a rounded\n   * rectangle.\n   *\n   * @param {object[]?} categories The categories to display\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.categories = function (arg) {\n    if (arg === undefined) {\n      return m_categories.slice();\n    }\n    m_categories = arg.slice().map(function (d) {\n      if (d.type === 'line') {\n        d.style.fill = false;\n        d.style.stroke = true;\n      }\n      return d;\n    });\n    m_this.draw();\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get the widget's size\n   * @return {{width: number, height: number}} The size in pixels\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.size = function () {\n    var width = 1, height;\n    var test =  m_this.layer().renderer().canvas().append('text')\n      .style('opacity', 1e-6);\n\n    m_categories.forEach(function (d) {\n      test.text(d.name);\n      width = Math.max(width, test.node().getBBox().width);\n    });\n    test.remove();\n\n    height = m_spacing * (m_categories.length + 1);\n    return {\n      width: width + 50,\n      height: height\n    };\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Redraw the legend\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this.draw = function () {\n\n    m_this._init();\n    function applyColor(selection) {\n      selection.style('fill', function (d) {\n          if (d.style.fill || d.style.fill === undefined) {\n            return d.style.fillColor;\n          } else {\n            return 'none';\n          }\n        })\n        .style('fill-opacity', function (d) {\n          if (d.style.fillOpacity === undefined) {\n            return 1;\n          }\n          return d.style.fillOpacity;\n        })\n        .style('stroke', function (d) {\n          if (d.style.stroke || d.style.stroke === undefined) {\n            return d.style.strokeColor;\n          } else {\n            return 'none';\n          }\n        })\n        .style('stroke-opacity', function (d) {\n          if (d.style.strokeOpacity === undefined) {\n            return 1;\n          }\n          return d.style.strokeOpacity;\n        })\n        .style('stroke-width', function (d) {\n          if (d.style.strokeWidth === undefined) {\n            return 1.5;\n          }\n          return d.style.strokeWidth;\n        });\n    }\n\n    m_border.attr('height', m_this.size().height + 2 * m_padding)\n      .style('display', null);\n\n    var scale = m_this._scale();\n\n    var labels = m_group.selectAll('g.geo-label')\n      .data(m_categories, function (d) { return d.name; });\n\n    var g = labels.enter().append('g')\n      .attr('class', 'geo-label')\n      .attr('transform', function (d, i) {\n        return 'translate(0,' + scale.y(i) + ')';\n      });\n\n    applyColor(g.filter(function (d) {\n        return d.type !== 'point' && d.type !== 'line';\n      }).append('rect')\n        .attr('x', 0)\n        .attr('y', -6)\n        .attr('rx', 5)\n        .attr('ry', 5)\n        .attr('width', 40)\n        .attr('height', 12)\n    );\n\n    applyColor(g.filter(function (d) {\n        return d.type === 'point';\n      }).append('circle')\n        .attr('cx', 20)\n        .attr('cy', 0)\n        .attr('r', 6)\n    );\n\n    applyColor(g.filter(function (d) {\n        return d.type === 'line';\n      }).append('line')\n        .attr('x1', 0)\n        .attr('y1', 0)\n        .attr('x2', 40)\n        .attr('y2', 0)\n    );\n\n    g.append('text')\n      .attr('x', '50px')\n      .attr('y', 0)\n      .attr('dy', '0.3em')\n      .text(function (d) {\n        return d.name;\n      });\n\n    return m_this;\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Get scales for the x and y axis for the current size.\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._scale = function () {\n    return {\n      x: d3.scale.linear()\n        .domain([0, 1])\n        .range([0, m_this.size().width]),\n      y: d3.scale.linear()\n        .domain([0, m_categories.length - 1])\n        .range([m_padding / 2, m_this.size().height - m_padding / 2])\n    };\n  };\n\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Private initialization.  Creates the widget's DOM container and internal\n   * variables.\n   * @private\n   */\n  //////////////////////////////////////////////////////////////////////////////\n  this._init = function () {\n    var w = m_this.size().width + 2 * m_padding,\n        h = m_this.size().height + 2 * m_padding,\n        nw = m_this.layer().map().node().width(),\n        margin = 20;\n    if (m_top) {\n      m_top.remove();\n    }\n    m_top = m_this.layer().renderer().canvas().append('g')\n        .attr('transform', 'translate(' + (nw - w - margin) + ',' + margin + ')');\n    m_group = m_top\n      .append('g')\n        .attr('transform', 'translate(' + [m_padding - 1.5, m_padding] + ')');\n    m_border = m_group.append('rect')\n      .attr('x', -m_padding)\n      .attr('y', -m_padding)\n      .attr('width', w)\n      .attr('height', h)\n      .attr('rx', 3)\n      .attr('ry', 3)\n      .style({\n        'stroke': 'black',\n        'stroke-width': '1.5px',\n        'fill': 'white',\n        'fill-opacity': 0.75,\n        'display': 'none'\n      });\n    m_group.on('mousedown', function () {\n      d3.event.stopPropagation();\n    });\n    m_group.on('mouseover', function () {\n      m_border.transition()\n        .duration(250)\n        .style('fill-opacity', 1);\n    });\n    m_group.on('mouseout', function () {\n      m_border.transition()\n        .duration(250)\n        .style('fill-opacity', 0.75);\n    });\n  };\n\n  this.geoOn(geo.event.resize, function () {\n    this.draw();\n  });\n\n};\n\ninherit(geo.gui.legendWidget, geo.gui.widget);\n\ngeo.registerWidget('d3', 'legend', geo.gui.legendWidget);\n","/*jscs:disable validateIndentation*/\n(function ($, geo, d3) {\n  'use strict';\n\n  var load = function () {\n\n  // This requires jquery ui, which we don't want to make a\n  // hard requirement, so bail out here if the widget factory\n  // is not available and throw a helpful message when the\n  // tries to use it.\n  if (!$.widget) {\n    $.fn.geojsMap = function () {\n      throw new Error(\n        'The geojs jquery plugin requires jquery ui to be available.'\n      );\n    };\n    return;\n  }\n\n  // for multiple initialization detection\n  var initialized = false;\n\n  /**\n   * Takes an option key and returns true if it should\n   * return a color accessor.\n   * @private\n   */\n  function isColorKey(key) {\n    return key.slice(key.length - 5, key.length)\n      .toLowerCase() === 'color';\n  }\n\n  /**\n   * Take an array of data and an accessor for a color property\n   * and return a wrapped accessor mapping to actual color\n   * values.  This allows users to pass arbitrary strings\n   * or numbers as any color property and this will wrap\n   * a categorical scale or linear scale.\n   *\n   * Requires d3\n   * @private\n   * @param {Object[]} data A data array\n   * @param {(string|number|function)} acc A color accessor\n   * @return {function}\n   */\n  function makeColorScale(data, acc) {\n    if (!d3) {\n      console.warn('d3 is unavailable, cannot apply color scales.');\n      return acc;\n    }\n    var domain;\n    var cannotHandle = false;\n    var doNotHandle = true;\n    var categorical = false;\n    var min = Number.POSITIVE_INFINITY;\n    var max = Number.NEGATIVE_INFINITY;\n\n    function wrap(func) {\n      if (geo.util.isFunction(func)) {\n        return function () {\n          return func(acc.apply(this, arguments));\n        };\n      } else {\n        return func(acc);\n      }\n    }\n\n    if (geo.util.isFunction(acc)) {\n      domain = d3.set(data.map(acc)).values();\n    } else {\n      domain = [acc];\n    }\n    domain.forEach(function (v) {\n      if (!(typeof v === 'string' &&\n            typeof geo.util.convertColor(v) === 'object')) {\n        // This is to handle cases when values are css names or\n        // hex strings.  We don't want to apply a categorical\n        // scale.\n        doNotHandle = false;\n      }\n      if (typeof v === 'string') {\n        categorical = true;\n      } else if (!isFinite(v)) {\n        cannotHandle = true;\n      } else if (+v > max) {\n        max = +v;\n      } else if (+v < min) {\n        min = +v;\n      }\n    });\n    if (cannotHandle) {\n      // At least one value is not a string or a numeric value.\n      // Pass the bare accessor back to geojs to handle it.\n      return acc;\n    }\n    if (doNotHandle) {\n      return acc;\n    }\n    if (categorical) {\n      if (domain.length <= 10) {\n        return wrap(d3.scale.category10().domain(domain));\n      } else if (domain.length <= 20) {\n        return wrap(d3.scale.category20().domain(domain));\n      } else {\n        // TODO: sort domain by most used and make an \"other\" category\n        return wrap(d3.scale.category20().domain(domain));\n      }\n    }\n    // http://colorbrewer2.org/?type=diverging&scheme=RdYlBu&n=3\n    return wrap(d3.scale.linear()\n      .range([\n        'rgb(252,141,89)',\n        'rgb(255,255,191)',\n        'rgb(145,191,219)'\n      ])\n      .domain([\n        min,\n        (min + max) / 2,\n        max\n      ]));\n  }\n\n  /**\n   * @class geojsMap\n   * @memberOf jQuery.fn\n   *\n   * @description Generates a geojs map inside an element.\n   *\n   *\n   * Due to current limitations in geojs, only a single map can be instantiated\n   * on a page.  Trying to create a second map will throw an error\n   * (see issue\n   * <a href=\"https://github.com/OpenGeoscience/geojs/issues/154\">#154</a>).\n   *\n   * @example <caption>Create a map with the default options.</caption>\n   * $(\"#map\").geojsMap();\n   * @example <caption>Create a map with a given initial center and zoom</caption>\n   * $(\"#map\").geojsMap({\n   *    longitude: -125,\n   *    latitude: 35,\n   *    zoom: 5\n   * });\n   * @example <caption>Create a map with points</caption>\n   * $(\"#map\").geojsMap({\n   *   data: [...],\n   *   layers: [{\n   *     renderer: 'vgl',\n   *     features: [{\n   *       type: 'point',\n   *       size: 5,\n   *       position: function (d) { return {x: d.geometry.x, y: d.geometry.y} },\n   *       fillColor: function (d, i) { return i < 5 ? 'red' : 'blue' },\n   *       stroke: false\n   *     }]\n   *   }]\n   * };\n   * @example <caption>Create a map with points, lines and multiple layers</caption>\n   * $(\"#map\").geojsMap({\n   *   center: { x: -130, y: 40 },\n   *   zoom: 3,\n   *   layers: [{\n   *     renderer: 'vgl',\n   *     features: [{\n   *       data: [...],\n   *       type: 'point',\n   *       size: 5,\n   *       position: function (d) { return {x: d.geometry.x, y: d.geometry.y} },\n   *       fillColor: function (d, i) { return i < 5 ? 'red' : 'blue' },\n   *       stroke: false\n   *     }]\n   *   },\n   *   {\n   *      renderer: 'd3',\n   *      features[{\n   *        data: [...],\n   *        type: 'line',\n   *        position: function (d) { return { x: d[0], y: d[1] } },\n   *        line: function (d) { return d.coordinates; },\n   *        strokeWidth: 3,\n   *        strokeColor: 'black',\n   *        strokeOpacity: 0.5\n   *      }]\n   *   }]\n   * };\n   */\n  // jscs:disable requireSpaceBetweenArguments\n  $.widget('geojs.geojsMap', /** @lends jQuery.fn.geojsMap */{\n  // jscs:enable requireSpaceBetweenArguments\n    /**\n     * A coordinate object as accepted by geojs to express positions in an\n     * arbitrary coordinate system (geographic, screen, etc).  Coordinates returned by\n     * geojs methods are always expressed with \"x\" and \"y\" properties, but\n     * it will accept any of the aliased properties.\n     * @typedef coordinate\n     * @type {object}\n     * @property {number} longitude Alias: \"x\", \"lng\", or \"lon\"\n     * @property {number} latitude Alias: \"y\" or \"lat\"\n     * @property {number} [elevation=0] Alias: \"z\", \"elev\", or \"height\"\n     */\n\n    /**\n     * Colors can be expressed in multiple ways:\n     * <ul>\n     *   <li>css name (<code>\"steelblue\"</code>)</li>\n     *   <li>24 bit hex value (<code>0xff0051</code>)</li>\n     *   <li>25 bit hex string (<code>\"#ff0051\"</code>)</li>\n     *   <li>rgb object (values from 0-1, <code>{r: 1, g: 0.5, b: 0}</code>)</li>\n     * </ul>\n     * @typedef color\n     * @type {*}\n     */\n\n    /**\n     * Point feature options object.  All styles can be\n     * given as accessor functions or constants.  Accessor\n     * functions are called with the following signature:\n     * <pre>\n     *     function func(d, i) {\n     *         // d    - data object\n     *         // i    - index of d in the data array\n     *         // this - geo.pointFeature\n     *     }\n     * </pre>\n     * Pass null to remove saved options from previous calls.\n     * @typedef pointOptions\n     * @type {Object}\n     * @property {Object[]} data Data array\n     * @property {coordinate} position Location of the point center\n     * @property {number} radius\n     *  Radius of the circle in pixels (ignored when <code>size</code>\n     *  is present)\n     * @property {number} size\n     *   A numerical value mapped affinely to a radius in the range [5,20]\n     * @property {boolean} fill Presence or absence of the fill\n     * @property {color} fillColor Interior color\n     * @property {float} fillOpacity Opacity of the interior <code>[0,1]</code>\n     * @property {boolean} stroke Presence or absence of the stroke\n     * @property {color} strokeColor Stroke color\n     * @property {float} strokeOpacity Opacity of the stroke <code>[0,1]</code>\n     */\n\n    /**\n     * @instance\n     * @description\n     * Map options (not fully implemented).\n     * @example <caption>Get the current map center</caption>\n     * var center=$(\"#map\").geojsMap(\"center\");\n     * @example <caption>Pan the map to a new center</caption>\n     * $(\"#map\").geojsMap(\"center\", {lat: 10, lng: -100});\n     * @property {object[]} [data=[]] The default data array used for\n     * features/layers not already containing data.\n     * @property {coordinate} [center={lat: 0, lng: 0}] The map center\n     * @property {number} [zoom=0] The zoom level (floating point >= 0)\n     * @property {(number|null)} [width=null]\n     *   The width of the map in pixels or null for 100%\n     * @property {(number|null)} [height=null]\n     *   The height of the map in pixels or null for 100%\n     * @property {geo.layer.spec[]} [layers=[]]\n     *   Describes layers added to the map\n     * @property {boolean} [autoresize=true]\n     *   Resize the map on <code>window.resize</code> (initialization only)\n     */\n    options: {\n      center: {latitude: 0, longitude: 0},\n      zoom: 0,\n      width: null,\n      height: null,\n      layers: [],\n      data: [],\n\n      // These options are for future use, but shouldn't\n      // be changed at the moment, so they aren't documented.\n      baseLayer: 'osm',\n      baseRenderer: 'vgl'\n    },\n\n    /**\n     * Internal constructor\n     * @instance\n     * @protected\n     */\n    _create: function () {\n      if (this._map || !this.element.length) {\n        // when called multiple times on a single element, do nothing\n        return;\n      }\n      if (initialized) {\n        // warn when called multiple times on different elements\n        console.warn(\n          'Geojs already initialized in this window.'\n        );\n        // Try to clean up the old gl context, but this doesn't usually work\n        delete window.gl;\n      }\n      // set global initialization state\n      initialized = true;\n\n      // create the map\n      this._map = geo.map({\n        width: this.options.width,\n        height: this.options.height,\n        zoom: this.options.zoom,\n        center: this.options.center,\n        node: this.element.get(0)\n      });\n\n      // create the base layer\n      this._baseLayer = this._map.createLayer(\n        this.options.baseLayer,\n        {\n          renderer: this.options.baseRenderer\n        }\n      );\n\n      // Trigger a resize to a valid size before adding\n      // the feature layer to handle some of the bugs that\n      // occur when initializing onto a node of size 0.\n      this._resize({width: 800, height: 600});\n\n      this._layers = [];\n      this.update();\n    },\n\n    /**\n     * Update the layers and features using a new array of\n     * {@link geo.layer.spec} objects.  All existing layers\n     * and features are deleted.  If only the data has changed,\n     * you can usually just call {@link jQuery.fn.geojsMap#redraw redraw}.\n     * @instance\n     * @param {geo.layer.spec[]} [layers] New map layers\n     * @example <caption>Delete and recreate all existing layers</caption>\n     * $(\"#map\").geojsMap(\"update\");\n     * @example <caption>Remove all existing feature layers.</caption>\n     * $(\"#map\").geojsMap(\"update\", []);\n     */\n    update: function (layers) {\n      var m_this = this;\n      this.options.layers = layers || this.options.layers || [];\n\n      // delete existing layers\n      this._layers.forEach(function (layer) {\n        layer.clear();\n        m_this._map.deleteLayer(layer);\n      });\n\n      // create new layers\n      this._layers = this.options.layers.map(function (layer) {\n        layer.data = layer.data || m_this.options.data;\n\n        // Until auto color scaling gets moved into geojs core, we will\n        // mutate the spec and replace the color and radius options.\n        (layer.features || []).forEach(function (feature) {\n          var data = feature.data || layer.data || [];\n          var scl;\n          if (feature.type === 'point') {\n            if (feature.size) {\n              feature._size = feature.size;\n            } else if (feature.size === null) {\n              delete feature._size;\n            }\n\n            if (data.length && feature._size) {\n              scl = d3.scale.linear()\n                .domain(\n                  d3.extent(data, feature._size)\n                )\n                .range([5, 20]);\n              feature.radius = function () {\n                // TODO: wrong `this` (wait for style refactor)\n                return scl(feature._size.apply(this, arguments));\n              };\n            }\n            delete feature.size;\n          }\n\n          var key;\n          for (key in feature) {\n            if (feature.hasOwnProperty(key) &&\n                isColorKey(key)) {\n              feature[key] = makeColorScale(data, feature[key]);\n            }\n          }\n        });\n        return geo.layer.create(m_this._map, layer);\n      });\n\n      // trigger an initial draw\n      this.redraw();\n\n      return this;\n    },\n\n    /**\n     * Resize the map canvas.\n     * @instance\n     * @protected\n     * @param {object?} size Explicit size or use this.options.\n     */\n    _resize: function (size) {\n      var width = this.options.width,\n          height = this.options.height;\n      if (size) {\n        width = size.width;\n        height = size.height;\n      }\n      if (!width) {\n        width = this.element.width();\n      }\n      if (!height) {\n        height = this.element.height();\n      }\n      this._map.resize(0, 0, width, height);\n    },\n\n    /**\n     * Do a full redraw of the map.  In general, users shouldn't need to\n     * call this method, but it could be useful when accessing lower\n     * level features of the mapping api.\n     * @todo This function may need to go through each feature and call\n     * {@link geo.feature#modified} to properly update.\n     * @instance\n     */\n    redraw: function () {\n      this._resize();\n      return this;\n    }\n  });\n\n  // Some argument type definitions used only by this plugin:\n  /**\n   * A geojs renderer is one of the following:\n   * <ul>\n   *   <li><code>\"vgl\"</code>: Uses webGL</li>\n   *   <li><code>\"d3\"</code>: Uses svg</li>\n   * </ul>\n   * @typedef renderer\n   * @type {string}\n   */\n\n  };\n\n  $(load);\n})($ || window.$, geo || window.geo, d3 || window.d3);\n"]}