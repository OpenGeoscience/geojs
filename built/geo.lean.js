(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return require("hammerjs"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("d3"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("vtk.js"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["hammerjs", "d3", "vtk.js"], factory);
	else if(typeof exports === 'object')
		exports["geo"] = factory((function webpackLoadOptionalExternalModule() { try { return require("hammerjs"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("d3"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("vtk.js"); } catch(e) {} }()));
	else
		root["geo"] = factory(root["Hammer"], root["d3"], root["vtk.js"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE__7606__, __WEBPACK_EXTERNAL_MODULE__3893__, __WEBPACK_EXTERNAL_MODULE__4436__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 1845:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ Proj; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/defs.js + 1 modules
var defs = __webpack_require__(1362);
// EXTERNAL MODULE: ../node_modules/wkt-parser/index.js + 9 modules
var wkt_parser = __webpack_require__(6082);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projString.js + 2 modules
var projString = __webpack_require__(4326);
// EXTERNAL MODULE: ../node_modules/proj4/lib/match.js
var match = __webpack_require__(7575);
;// ../node_modules/proj4/lib/parseCode.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }




function testObj(code) {
  return typeof code === 'string';
}
function testDef(code) {
  return code in defs/* default */.A;
}
function testWKT(code) {
  return code.indexOf('+') !== 0 && code.indexOf('[') !== -1 || _typeof(code) === 'object' && !('srsCode' in code);
}
var codes = ['3857', '900913', '3785', '102113'];
function checkMercator(item) {
  var auth = (0,match/* default */.A)(item, 'authority');
  if (!auth) {
    return;
  }
  var code = (0,match/* default */.A)(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = (0,match/* default */.A)(item, 'extension');
  if (!ext) {
    return;
  }
  return (0,match/* default */.A)(ext, 'proj4');
}
function testProj(code) {
  return code[0] === '+';
}
/**
 * @param {string | import('./core').PROJJSONDefinition | import('./defs').ProjectionDefinition} code
 * @returns {import('./defs').ProjectionDefinition}
 */
function parse(code) {
  if (testObj(code)) {
    // check to see if this is a WKT string
    if (testDef(code)) {
      return defs/* default */.A[code];
    }
    if (testWKT(code)) {
      var out = (0,wkt_parser/* default */.A)(code);
      // test of spetial case, due to this being a very common and often malformed
      if (checkMercator(out)) {
        return defs/* default */.A['EPSG:3857'];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return (0,projString/* default */.A)(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return (0,projString/* default */.A)(code);
    }
  } else if (!('projName' in code)) {
    return (0,wkt_parser/* default */.A)(code);
  } else {
    return code;
  }
}
/* harmony default export */ var parseCode = (parse);
;// ../node_modules/proj4/lib/extend.js
/* harmony default export */ function extend(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections.js
var projections = __webpack_require__(7272);
// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
;// ../node_modules/proj4/lib/constants/Ellipsoid.js
var ellipsoids = {
  MERIT: {
    a: 6378137,
    rf: 298.257,
    ellipseName: 'MERIT 1983'
  },
  SGS85: {
    a: 6378136,
    rf: 298.257,
    ellipseName: 'Soviet Geodetic System 85'
  },
  GRS80: {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: 'GRS 1980(IUGG, 1980)'
  },
  IAU76: {
    a: 6378140,
    rf: 298.257,
    ellipseName: 'IAU 1976'
  },
  airy: {
    a: 6377563.396,
    b: 6356256.91,
    ellipseName: 'Airy 1830'
  },
  APL4: {
    a: 6378137,
    rf: 298.25,
    ellipseName: 'Appl. Physics. 1965'
  },
  NWL9D: {
    a: 6378145,
    rf: 298.25,
    ellipseName: 'Naval Weapons Lab., 1965'
  },
  mod_airy: {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: 'Modified Airy'
  },
  andrae: {
    a: 6377104.43,
    rf: 300,
    ellipseName: 'Andrae 1876 (Den., Iclnd.)'
  },
  aust_SA: {
    a: 6378160,
    rf: 298.25,
    ellipseName: 'Australian Natl & S. Amer. 1969'
  },
  GRS67: {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: 'GRS 67(IUGG 1967)'
  },
  bessel: {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: 'Bessel 1841'
  },
  bess_nam: {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: 'Bessel 1841 (Namibia)'
  },
  clrk66: {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: 'Clarke 1866'
  },
  clrk80: {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: 'Clarke 1880 mod.'
  },
  clrk80ign: {
    a: 6378249.2,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: 'Clarke 1880 (IGN)'
  },
  clrk58: {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: 'Clarke 1858'
  },
  CPM: {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: 'Comm. des Poids et Mesures 1799'
  },
  delmbr: {
    a: 6376428,
    rf: 311.5,
    ellipseName: 'Delambre 1810 (Belgium)'
  },
  engelis: {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: 'Engelis 1985'
  },
  evrst30: {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: 'Everest 1830'
  },
  evrst48: {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: 'Everest 1948'
  },
  evrst56: {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: 'Everest 1956'
  },
  evrst69: {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: 'Everest 1969'
  },
  evrstSS: {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: 'Everest (Sabah & Sarawak)'
  },
  fschr60: {
    a: 6378166,
    rf: 298.3,
    ellipseName: 'Fischer (Mercury Datum) 1960'
  },
  fschr60m: {
    a: 6378155,
    rf: 298.3,
    ellipseName: 'Fischer 1960'
  },
  fschr68: {
    a: 6378150,
    rf: 298.3,
    ellipseName: 'Fischer 1968'
  },
  helmert: {
    a: 6378200,
    rf: 298.3,
    ellipseName: 'Helmert 1906'
  },
  hough: {
    a: 6378270,
    rf: 297,
    ellipseName: 'Hough'
  },
  intl: {
    a: 6378388,
    rf: 297,
    ellipseName: 'International 1909 (Hayford)'
  },
  kaula: {
    a: 6378163,
    rf: 298.24,
    ellipseName: 'Kaula 1961'
  },
  lerch: {
    a: 6378139,
    rf: 298.257,
    ellipseName: 'Lerch 1979'
  },
  mprts: {
    a: 6397300,
    rf: 191,
    ellipseName: 'Maupertius 1738'
  },
  new_intl: {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: 'New International 1967'
  },
  plessis: {
    a: 6376523,
    rf: 6355863,
    ellipseName: 'Plessis 1817 (France)'
  },
  krass: {
    a: 6378245,
    rf: 298.3,
    ellipseName: 'Krassovsky, 1942'
  },
  SEasia: {
    a: 6378155,
    b: 6356773.3205,
    ellipseName: 'Southeast Asia'
  },
  walbeck: {
    a: 6376896,
    b: 6355834.8467,
    ellipseName: 'Walbeck'
  },
  WGS60: {
    a: 6378165,
    rf: 298.3,
    ellipseName: 'WGS 60'
  },
  WGS66: {
    a: 6378145,
    rf: 298.25,
    ellipseName: 'WGS 66'
  },
  WGS7: {
    a: 6378135,
    rf: 298.26,
    ellipseName: 'WGS 72'
  },
  WGS84: {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: 'WGS 84'
  },
  sphere: {
    a: 6370997,
    b: 6370997,
    ellipseName: 'Normal Sphere (r=6370997)'
  }
};
/* harmony default export */ var Ellipsoid = (ellipsoids);
;// ../node_modules/proj4/lib/deriveConstants.js



var WGS84 = Ellipsoid.WGS84; // default ellipsoid

function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (values/* SIXTH */.bA + es * (values/* RA4 */.Q1 + es * values/* RA6 */.ej));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) {
    // do we have an ellipsoid?
    var ellipse = (0,match/* default */.A)(Ellipsoid, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < values/* EPSLN */.H0) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}
;// ../node_modules/proj4/lib/constants/Datum.js
var datums = {
  wgs84: {
    towgs84: '0,0,0',
    ellipse: 'WGS84',
    datumName: 'WGS84'
  },
  ch1903: {
    towgs84: '674.374,15.056,405.346',
    ellipse: 'bessel',
    datumName: 'swiss'
  },
  ggrs87: {
    towgs84: '-199.87,74.79,246.62',
    ellipse: 'GRS80',
    datumName: 'Greek_Geodetic_Reference_System_1987'
  },
  nad83: {
    towgs84: '0,0,0',
    ellipse: 'GRS80',
    datumName: 'North_American_Datum_1983'
  },
  nad27: {
    nadgrids: '@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat',
    ellipse: 'clrk66',
    datumName: 'North_American_Datum_1927'
  },
  potsdam: {
    towgs84: '598.1,73.7,418.2,0.202,0.045,-2.455,6.7',
    ellipse: 'bessel',
    datumName: 'Potsdam Rauenberg 1950 DHDN'
  },
  carthage: {
    towgs84: '-263.0,6.0,431.0',
    ellipse: 'clark80',
    datumName: 'Carthage 1934 Tunisia'
  },
  hermannskogel: {
    towgs84: '577.326,90.129,463.919,5.137,1.474,5.297,2.4232',
    ellipse: 'bessel',
    datumName: 'Hermannskogel'
  },
  mgi: {
    towgs84: '577.326,90.129,463.919,5.137,1.474,5.297,2.4232',
    ellipse: 'bessel',
    datumName: 'Militar-Geographische Institut'
  },
  osni52: {
    towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
    ellipse: 'airy',
    datumName: 'Irish National'
  },
  ire65: {
    towgs84: '482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15',
    ellipse: 'mod_airy',
    datumName: 'Ireland 1965'
  },
  rassadiran: {
    towgs84: '-133.63,-157.5,-158.62',
    ellipse: 'intl',
    datumName: 'Rassadiran'
  },
  nzgd49: {
    towgs84: '59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993',
    ellipse: 'intl',
    datumName: 'New Zealand Geodetic Datum 1949'
  },
  osgb36: {
    towgs84: '446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894',
    ellipse: 'airy',
    datumName: 'Ordnance Survey of Great Britain 1936'
  },
  s_jtsk: {
    towgs84: '589,76,480',
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
  },
  beduaram: {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
  },
  gunung_segara: {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
  },
  rnb72: {
    towgs84: '106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1',
    ellipse: 'intl',
    datumName: 'Reseau National Belge 1972'
  },
  EPSG_5451: {
    towgs84: '6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649'
  },
  IGNF_LURESG: {
    towgs84: '-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43'
  },
  EPSG_4614: {
    towgs84: '-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065'
  },
  EPSG_4615: {
    towgs84: '-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748'
  },
  ESRI_37241: {
    towgs84: '-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031'
  },
  ESRI_37249: {
    towgs84: '-440.296,58.548,296.265,1.128,10.202,4.559,-0.438'
  },
  ESRI_37245: {
    towgs84: '-511.151,-181.269,139.609,1.05,2.703,1.798,3.071'
  },
  EPSG_4178: {
    towgs84: '24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01'
  },
  EPSG_4622: {
    towgs84: '-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984'
  },
  EPSG_4625: {
    towgs84: '126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227'
  },
  EPSG_5252: {
    towgs84: '0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439'
  },
  EPSG_4314: {
    towgs84: '597.1,71.4,412.1,0.894,0.068,-1.563,7.58'
  },
  EPSG_4282: {
    towgs84: '-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166'
  },
  EPSG_4231: {
    towgs84: '-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218'
  },
  EPSG_4274: {
    towgs84: '-230.994,102.591,25.199,0.633,-0.239,0.9,1.95'
  },
  EPSG_4134: {
    towgs84: '-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006'
  },
  EPSG_4254: {
    towgs84: '18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013'
  },
  EPSG_4159: {
    towgs84: '-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175'
  },
  EPSG_4687: {
    towgs84: '0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093'
  },
  EPSG_4227: {
    towgs84: '-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225'
  },
  EPSG_4746: {
    towgs84: '599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46'
  },
  EPSG_4745: {
    towgs84: '612.4,77,440.2,-0.054,0.057,-2.797,2.55'
  },
  EPSG_6311: {
    towgs84: '8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926'
  },
  EPSG_4289: {
    towgs84: '565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244'
  },
  EPSG_4230: {
    towgs84: '-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4'
  },
  EPSG_4154: {
    towgs84: '-123.02,-158.95,-168.47'
  },
  EPSG_4156: {
    towgs84: '570.8,85.7,462.8,4.998,1.587,5.261,3.56'
  },
  EPSG_4299: {
    towgs84: '482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15'
  },
  EPSG_4179: {
    towgs84: '33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84'
  },
  EPSG_4313: {
    towgs84: '-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747'
  },
  EPSG_4194: {
    towgs84: '163.511,127.533,-159.789'
  },
  EPSG_4195: {
    towgs84: '105,326,-102.5'
  },
  EPSG_4196: {
    towgs84: '-45,417,-3.5'
  },
  EPSG_4611: {
    towgs84: '-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246'
  },
  EPSG_4633: {
    towgs84: '137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824'
  },
  EPSG_4641: {
    towgs84: '-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993'
  },
  EPSG_4643: {
    towgs84: '-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002'
  },
  EPSG_4300: {
    towgs84: '482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15'
  },
  EPSG_4188: {
    towgs84: '482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15'
  },
  EPSG_4660: {
    towgs84: '982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805'
  },
  EPSG_4662: {
    towgs84: '97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259'
  },
  EPSG_3906: {
    towgs84: '577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664'
  },
  EPSG_4307: {
    towgs84: '-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547'
  },
  EPSG_6892: {
    towgs84: '-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686'
  },
  EPSG_4690: {
    towgs84: '221.597,152.441,176.523,2.403,1.3893,0.884,11.4648'
  },
  EPSG_4691: {
    towgs84: '218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817'
  },
  EPSG_4629: {
    towgs84: '72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653'
  },
  EPSG_4630: {
    towgs84: '165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111'
  },
  EPSG_4692: {
    towgs84: '217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093'
  },
  EPSG_9333: {
    towgs84: '0,0,0,-8.393,0.749,-10.276,0'
  },
  EPSG_9059: {
    towgs84: '0,0,0'
  },
  EPSG_4312: {
    towgs84: '601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887'
  },
  EPSG_4123: {
    towgs84: '-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496'
  },
  EPSG_4309: {
    towgs84: '-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365'
  },
  ESRI_104106: {
    towgs84: '-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058'
  },
  EPSG_4281: {
    towgs84: '-219.247,-73.802,269.529'
  },
  EPSG_4322: {
    towgs84: '0,0,4.5'
  },
  EPSG_4324: {
    towgs84: '0,0,1.9'
  },
  EPSG_4284: {
    towgs84: '43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549'
  },
  EPSG_4277: {
    towgs84: '446.448,-125.157,542.06,0.15,0.247,0.842,-20.489'
  },
  EPSG_4207: {
    towgs84: '-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46'
  },
  EPSG_4688: {
    towgs84: '347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647'
  },
  EPSG_4689: {
    towgs84: '410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218'
  },
  EPSG_4720: {
    towgs84: '0,0,4.5'
  },
  EPSG_4273: {
    towgs84: '278.3,93,474.5,7.889,0.05,-6.61,6.21'
  },
  EPSG_4240: {
    towgs84: '204.64,834.74,293.8'
  },
  EPSG_4817: {
    towgs84: '278.3,93,474.5,7.889,0.05,-6.61,6.21'
  },
  ESRI_104131: {
    towgs84: '426.62,142.62,460.09,4.98,4.49,-12.42,-17.1'
  },
  EPSG_4265: {
    towgs84: '-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68'
  },
  EPSG_4263: {
    towgs84: '-111.92,-87.85,114.5,1.875,0.202,0.219,0.032'
  },
  EPSG_4298: {
    towgs84: '-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536'
  },
  EPSG_4270: {
    towgs84: '-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424'
  },
  EPSG_4229: {
    towgs84: '-121.8,98.1,-10.7'
  },
  EPSG_4220: {
    towgs84: '-55.5,-348,-229.2'
  },
  EPSG_4214: {
    towgs84: '12.646,-155.176,-80.863'
  },
  EPSG_4232: {
    towgs84: '-345,3,223'
  },
  EPSG_4238: {
    towgs84: '-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037'
  },
  EPSG_4168: {
    towgs84: '-170,33,326'
  },
  EPSG_4131: {
    towgs84: '199,931,318.9'
  },
  EPSG_4152: {
    towgs84: '-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0'
  },
  EPSG_5228: {
    towgs84: '572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378'
  },
  EPSG_8351: {
    towgs84: '485.021,169.465,483.839,7.786342,4.397554,4.102655,0'
  },
  EPSG_4683: {
    towgs84: '-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06'
  },
  EPSG_4133: {
    towgs84: '0,0,0'
  },
  EPSG_7373: {
    towgs84: '0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693'
  },
  EPSG_9075: {
    towgs84: '-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0'
  },
  EPSG_9072: {
    towgs84: '-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0'
  },
  EPSG_9294: {
    towgs84: '1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388'
  },
  EPSG_4212: {
    towgs84: '-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492'
  },
  EPSG_4191: {
    towgs84: '-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703'
  },
  EPSG_4237: {
    towgs84: '52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191'
  },
  EPSG_4740: {
    towgs84: '-1.08,-0.27,-0.9'
  },
  EPSG_4124: {
    towgs84: '419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496'
  },
  EPSG_5681: {
    towgs84: '584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922'
  },
  EPSG_4141: {
    towgs84: '23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262'
  },
  EPSG_4204: {
    towgs84: '-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194'
  },
  EPSG_4319: {
    towgs84: '226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798'
  },
  EPSG_4200: {
    towgs84: '24.82,-131.21,-82.66'
  },
  EPSG_4130: {
    towgs84: '0,0,0'
  },
  EPSG_4127: {
    towgs84: '-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359'
  },
  EPSG_4149: {
    towgs84: '674.374,15.056,405.346'
  },
  EPSG_4617: {
    towgs84: '-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0'
  },
  EPSG_4663: {
    towgs84: '-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485'
  },
  EPSG_4664: {
    towgs84: '-211.939,137.626,58.3,-0.089,0.251,0.079,0.384'
  },
  EPSG_4665: {
    towgs84: '-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048'
  },
  EPSG_4666: {
    towgs84: '631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43'
  },
  EPSG_4756: {
    towgs84: '-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188'
  },
  EPSG_4723: {
    towgs84: '-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925'
  },
  EPSG_4726: {
    towgs84: '8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081'
  },
  EPSG_4267: {
    towgs84: '-8.0,160.0,176.0'
  },
  EPSG_5365: {
    towgs84: '-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693'
  },
  EPSG_4218: {
    towgs84: '304.5,306.5,-318.1'
  },
  EPSG_4242: {
    towgs84: '-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95'
  },
  EPSG_4216: {
    towgs84: '-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289'
  },
  ESRI_104105: {
    towgs84: '631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43'
  },
  ESRI_104129: {
    towgs84: '0,0,0'
  },
  EPSG_4673: {
    towgs84: '174.05,-25.49,112.57'
  },
  EPSG_4202: {
    towgs84: '-124,-60,154'
  },
  EPSG_4203: {
    towgs84: '-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191'
  },
  EPSG_3819: {
    towgs84: '595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408'
  },
  EPSG_8694: {
    towgs84: '-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169'
  },
  EPSG_4145: {
    towgs84: '275.57,676.78,229.6'
  },
  EPSG_4283: {
    towgs84: '61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994'
  },
  EPSG_4317: {
    towgs84: '2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266'
  },
  EPSG_4272: {
    towgs84: '59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993'
  },
  EPSG_4248: {
    towgs84: '-307.7,265.3,-363.5'
  },
  EPSG_5561: {
    towgs84: '24,-121,-76'
  },
  EPSG_5233: {
    towgs84: '-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338'
  },
  ESRI_104130: {
    towgs84: '-86,-98,-119'
  },
  ESRI_104102: {
    towgs84: '682,-203,480'
  },
  ESRI_37207: {
    towgs84: '7,-10,-26'
  },
  EPSG_4675: {
    towgs84: '59.935,118.4,-10.871'
  },
  ESRI_104109: {
    towgs84: '-89.121,-348.182,260.871'
  },
  ESRI_104112: {
    towgs84: '-185.583,-230.096,281.361'
  },
  ESRI_104113: {
    towgs84: '25.1,-275.6,222.6'
  },
  IGNF_WGS72G: {
    towgs84: '0,12,6'
  },
  IGNF_NTFG: {
    towgs84: '-168,-60,320'
  },
  IGNF_EFATE57G: {
    towgs84: '-127,-769,472'
  },
  IGNF_PGP50G: {
    towgs84: '324.8,153.6,172.1'
  },
  IGNF_REUN47G: {
    towgs84: '94,-948,-1262'
  },
  IGNF_CSG67G: {
    towgs84: '-186,230,110'
  },
  IGNF_GUAD48G: {
    towgs84: '-467,-16,-300'
  },
  IGNF_TAHI51G: {
    towgs84: '162,117,154'
  },
  IGNF_TAHAAG: {
    towgs84: '65,342,77'
  },
  IGNF_NUKU72G: {
    towgs84: '84,274,65'
  },
  IGNF_PETRELS72G: {
    towgs84: '365,194,166'
  },
  IGNF_WALL78G: {
    towgs84: '253,-133,-127'
  },
  IGNF_MAYO50G: {
    towgs84: '-382,-59,-262'
  },
  IGNF_TANNAG: {
    towgs84: '-139,-967,436'
  },
  IGNF_IGN72G: {
    towgs84: '-13,-348,292'
  },
  IGNF_ATIGG: {
    towgs84: '1118,23,66'
  },
  IGNF_FANGA84G: {
    towgs84: '150.57,158.33,118.32'
  },
  IGNF_RUSAT84G: {
    towgs84: '202.13,174.6,-15.74'
  },
  IGNF_KAUE70G: {
    towgs84: '126.74,300.1,-75.49'
  },
  IGNF_MOP90G: {
    towgs84: '-10.8,-1.8,12.77'
  },
  IGNF_MHPF67G: {
    towgs84: '338.08,212.58,-296.17'
  },
  IGNF_TAHI79G: {
    towgs84: '160.61,116.05,153.69'
  },
  IGNF_ANAA92G: {
    towgs84: '1.5,3.84,4.81'
  },
  IGNF_MARQUI72G: {
    towgs84: '330.91,-13.92,58.56'
  },
  IGNF_APAT86G: {
    towgs84: '143.6,197.82,74.05'
  },
  IGNF_TUBU69G: {
    towgs84: '237.17,171.61,-77.84'
  },
  IGNF_STPM50G: {
    towgs84: '11.363,424.148,373.13'
  },
  EPSG_4150: {
    towgs84: '674.374,15.056,405.346'
  },
  EPSG_4754: {
    towgs84: '-208.4058,-109.8777,-2.5764'
  },
  ESRI_104101: {
    towgs84: '374,150,588'
  },
  EPSG_4693: {
    towgs84: '0,-0.15,0.68'
  },
  EPSG_6207: {
    towgs84: '293.17,726.18,245.36'
  },
  EPSG_4153: {
    towgs84: '-133.63,-157.5,-158.62'
  },
  EPSG_4132: {
    towgs84: '-241.54,-163.64,396.06'
  },
  EPSG_4221: {
    towgs84: '-154.5,150.7,100.4'
  },
  EPSG_4266: {
    towgs84: '-80.7,-132.5,41.1'
  },
  EPSG_4193: {
    towgs84: '-70.9,-151.8,-41.4'
  },
  EPSG_5340: {
    towgs84: '-0.41,0.46,-0.35'
  },
  EPSG_4246: {
    towgs84: '-294.7,-200.1,525.5'
  },
  EPSG_4318: {
    towgs84: '-3.2,-5.7,2.8'
  },
  EPSG_4121: {
    towgs84: '-199.87,74.79,246.62'
  },
  EPSG_4223: {
    towgs84: '-260.1,5.5,432.2'
  },
  EPSG_4158: {
    towgs84: '-0.465,372.095,171.736'
  },
  EPSG_4285: {
    towgs84: '-128.16,-282.42,21.93'
  },
  EPSG_4613: {
    towgs84: '-404.78,685.68,45.47'
  },
  EPSG_4607: {
    towgs84: '195.671,332.517,274.607'
  },
  EPSG_4475: {
    towgs84: '-381.788,-57.501,-256.673'
  },
  EPSG_4208: {
    towgs84: '-157.84,308.54,-146.6'
  },
  EPSG_4743: {
    towgs84: '70.995,-335.916,262.898'
  },
  EPSG_4710: {
    towgs84: '-323.65,551.39,-491.22'
  },
  EPSG_7881: {
    towgs84: '-0.077,0.079,0.086'
  },
  EPSG_4682: {
    towgs84: '283.729,735.942,261.143'
  },
  EPSG_4739: {
    towgs84: '-156,-271,-189'
  },
  EPSG_4679: {
    towgs84: '-80.01,253.26,291.19'
  },
  EPSG_4750: {
    towgs84: '-56.263,16.136,-22.856'
  },
  EPSG_4644: {
    towgs84: '-10.18,-350.43,291.37'
  },
  EPSG_4695: {
    towgs84: '-103.746,-9.614,-255.95'
  },
  EPSG_4292: {
    towgs84: '-355,21,72'
  },
  EPSG_4302: {
    towgs84: '-61.702,284.488,472.052'
  },
  EPSG_4143: {
    towgs84: '-124.76,53,466.79'
  },
  EPSG_4606: {
    towgs84: '-153,153,307'
  },
  EPSG_4699: {
    towgs84: '-770.1,158.4,-498.2'
  },
  EPSG_4247: {
    towgs84: '-273.5,110.6,-357.9'
  },
  EPSG_4160: {
    towgs84: '8.88,184.86,106.69'
  },
  EPSG_4161: {
    towgs84: '-233.43,6.65,173.64'
  },
  EPSG_9251: {
    towgs84: '-9.5,122.9,138.2'
  },
  EPSG_9253: {
    towgs84: '-78.1,101.6,133.3'
  },
  EPSG_4297: {
    towgs84: '-198.383,-240.517,-107.909'
  },
  EPSG_4269: {
    towgs84: '0,0,0'
  },
  EPSG_4301: {
    towgs84: '-147,506,687'
  },
  EPSG_4618: {
    towgs84: '-59,-11,-52'
  },
  EPSG_4612: {
    towgs84: '0,0,0'
  },
  EPSG_4678: {
    towgs84: '44.585,-131.212,-39.544'
  },
  EPSG_4250: {
    towgs84: '-130,29,364'
  },
  EPSG_4144: {
    towgs84: '214,804,268'
  },
  EPSG_4147: {
    towgs84: '-17.51,-108.32,-62.39'
  },
  EPSG_4259: {
    towgs84: '-254.1,-5.36,-100.29'
  },
  EPSG_4164: {
    towgs84: '-76,-138,67'
  },
  EPSG_4211: {
    towgs84: '-378.873,676.002,-46.255'
  },
  EPSG_4182: {
    towgs84: '-422.651,-172.995,84.02'
  },
  EPSG_4224: {
    towgs84: '-143.87,243.37,-33.52'
  },
  EPSG_4225: {
    towgs84: '-205.57,168.77,-4.12'
  },
  EPSG_5527: {
    towgs84: '-67.35,3.88,-38.22'
  },
  EPSG_4752: {
    towgs84: '98,390,-22'
  },
  EPSG_4310: {
    towgs84: '-30,190,89'
  },
  EPSG_9248: {
    towgs84: '-192.26,65.72,132.08'
  },
  EPSG_4680: {
    towgs84: '124.5,-63.5,-281'
  },
  EPSG_4701: {
    towgs84: '-79.9,-158,-168.9'
  },
  EPSG_4706: {
    towgs84: '-146.21,112.63,4.05'
  },
  EPSG_4805: {
    towgs84: '682,-203,480'
  },
  EPSG_4201: {
    towgs84: '-165,-11,206'
  },
  EPSG_4210: {
    towgs84: '-157,-2,-299'
  },
  EPSG_4183: {
    towgs84: '-104,167,-38'
  },
  EPSG_4139: {
    towgs84: '11,72,-101'
  },
  EPSG_4668: {
    towgs84: '-86,-98,-119'
  },
  EPSG_4717: {
    towgs84: '-2,151,181'
  },
  EPSG_4732: {
    towgs84: '102,52,-38'
  },
  EPSG_4280: {
    towgs84: '-377,681,-50'
  },
  EPSG_4209: {
    towgs84: '-138,-105,-289'
  },
  EPSG_4261: {
    towgs84: '31,146,47'
  },
  EPSG_4658: {
    towgs84: '-73,46,-86'
  },
  EPSG_4721: {
    towgs84: '265.025,384.929,-194.046'
  },
  EPSG_4222: {
    towgs84: '-136,-108,-292'
  },
  EPSG_4601: {
    towgs84: '-255,-15,71'
  },
  EPSG_4602: {
    towgs84: '725,685,536'
  },
  EPSG_4603: {
    towgs84: '72,213.7,93'
  },
  EPSG_4605: {
    towgs84: '9,183,236'
  },
  EPSG_4621: {
    towgs84: '137,248,-430'
  },
  EPSG_4657: {
    towgs84: '-28,199,5'
  },
  EPSG_4316: {
    towgs84: '103.25,-100.4,-307.19'
  },
  EPSG_4642: {
    towgs84: '-13,-348,292'
  },
  EPSG_4698: {
    towgs84: '145,-187,103'
  },
  EPSG_4192: {
    towgs84: '-206.1,-174.7,-87.7'
  },
  EPSG_4311: {
    towgs84: '-265,120,-358'
  },
  EPSG_4135: {
    towgs84: '58,-283,-182'
  },
  ESRI_104138: {
    towgs84: '198,-226,-347'
  },
  EPSG_4245: {
    towgs84: '-11,851,5'
  },
  EPSG_4142: {
    towgs84: '-125,53,467'
  },
  EPSG_4213: {
    towgs84: '-106,-87,188'
  },
  EPSG_4253: {
    towgs84: '-133,-77,-51'
  },
  EPSG_4129: {
    towgs84: '-132,-110,-335'
  },
  EPSG_4713: {
    towgs84: '-77,-128,142'
  },
  EPSG_4239: {
    towgs84: '217,823,299'
  },
  EPSG_4146: {
    towgs84: '295,736,257'
  },
  EPSG_4155: {
    towgs84: '-83,37,124'
  },
  EPSG_4165: {
    towgs84: '-173,253,27'
  },
  EPSG_4672: {
    towgs84: '175,-38,113'
  },
  EPSG_4236: {
    towgs84: '-637,-549,-203'
  },
  EPSG_4251: {
    towgs84: '-90,40,88'
  },
  EPSG_4271: {
    towgs84: '-2,374,172'
  },
  EPSG_4175: {
    towgs84: '-88,4,101'
  },
  EPSG_4716: {
    towgs84: '298,-304,-375'
  },
  EPSG_4315: {
    towgs84: '-23,259,-9'
  },
  EPSG_4744: {
    towgs84: '-242.2,-144.9,370.3'
  },
  EPSG_4244: {
    towgs84: '-97,787,86'
  },
  EPSG_4293: {
    towgs84: '616,97,-251'
  },
  EPSG_4714: {
    towgs84: '-127,-769,472'
  },
  EPSG_4736: {
    towgs84: '260,12,-147'
  },
  EPSG_6883: {
    towgs84: '-235,-110,393'
  },
  EPSG_6894: {
    towgs84: '-63,176,185'
  },
  EPSG_4205: {
    towgs84: '-43,-163,45'
  },
  EPSG_4256: {
    towgs84: '41,-220,-134'
  },
  EPSG_4262: {
    towgs84: '639,405,60'
  },
  EPSG_4604: {
    towgs84: '174,359,365'
  },
  EPSG_4169: {
    towgs84: '-115,118,426'
  },
  EPSG_4620: {
    towgs84: '-106,-129,165'
  },
  EPSG_4184: {
    towgs84: '-203,141,53'
  },
  EPSG_4616: {
    towgs84: '-289,-124,60'
  },
  EPSG_9403: {
    towgs84: '-307,-92,127'
  },
  EPSG_4684: {
    towgs84: '-133,-321,50'
  },
  EPSG_4708: {
    towgs84: '-491,-22,435'
  },
  EPSG_4707: {
    towgs84: '114,-116,-333'
  },
  EPSG_4709: {
    towgs84: '145,75,-272'
  },
  EPSG_4712: {
    towgs84: '-205,107,53'
  },
  EPSG_4711: {
    towgs84: '124,-234,-25'
  },
  EPSG_4718: {
    towgs84: '230,-199,-752'
  },
  EPSG_4719: {
    towgs84: '211,147,111'
  },
  EPSG_4724: {
    towgs84: '208,-435,-229'
  },
  EPSG_4725: {
    towgs84: '189,-79,-202'
  },
  EPSG_4735: {
    towgs84: '647,1777,-1124'
  },
  EPSG_4722: {
    towgs84: '-794,119,-298'
  },
  EPSG_4728: {
    towgs84: '-307,-92,127'
  },
  EPSG_4734: {
    towgs84: '-632,438,-609'
  },
  EPSG_4727: {
    towgs84: '912,-58,1227'
  },
  EPSG_4729: {
    towgs84: '185,165,42'
  },
  EPSG_4730: {
    towgs84: '170,42,84'
  },
  EPSG_4733: {
    towgs84: '276,-57,149'
  },
  ESRI_37218: {
    towgs84: '230,-199,-752'
  },
  ESRI_37240: {
    towgs84: '-7,215,225'
  },
  ESRI_37221: {
    towgs84: '252,-209,-751'
  },
  ESRI_4305: {
    towgs84: '-123,-206,219'
  },
  ESRI_104139: {
    towgs84: '-73,-247,227'
  },
  EPSG_4748: {
    towgs84: '51,391,-36'
  },
  EPSG_4219: {
    towgs84: '-384,664,-48'
  },
  EPSG_4255: {
    towgs84: '-333,-222,114'
  },
  EPSG_4257: {
    towgs84: '-587.8,519.75,145.76'
  },
  EPSG_4646: {
    towgs84: '-963,510,-359'
  },
  EPSG_6881: {
    towgs84: '-24,-203,268'
  },
  EPSG_6882: {
    towgs84: '-183,-15,273'
  },
  EPSG_4715: {
    towgs84: '-104,-129,239'
  },
  IGNF_RGF93GDD: {
    towgs84: '0,0,0'
  },
  IGNF_RGM04GDD: {
    towgs84: '0,0,0'
  },
  IGNF_RGSPM06GDD: {
    towgs84: '0,0,0'
  },
  IGNF_RGTAAF07GDD: {
    towgs84: '0,0,0'
  },
  IGNF_RGFG95GDD: {
    towgs84: '0,0,0'
  },
  IGNF_RGNCG: {
    towgs84: '0,0,0'
  },
  IGNF_RGPFGDD: {
    towgs84: '0,0,0'
  },
  IGNF_ETRS89G: {
    towgs84: '0,0,0'
  },
  IGNF_RGR92GDD: {
    towgs84: '0,0,0'
  },
  EPSG_4173: {
    towgs84: '0,0,0'
  },
  EPSG_4180: {
    towgs84: '0,0,0'
  },
  EPSG_4619: {
    towgs84: '0,0,0'
  },
  EPSG_4667: {
    towgs84: '0,0,0'
  },
  EPSG_4075: {
    towgs84: '0,0,0'
  },
  EPSG_6706: {
    towgs84: '0,0,0'
  },
  EPSG_7798: {
    towgs84: '0,0,0'
  },
  EPSG_4661: {
    towgs84: '0,0,0'
  },
  EPSG_4669: {
    towgs84: '0,0,0'
  },
  EPSG_8685: {
    towgs84: '0,0,0'
  },
  EPSG_4151: {
    towgs84: '0,0,0'
  },
  EPSG_9702: {
    towgs84: '0,0,0'
  },
  EPSG_4758: {
    towgs84: '0,0,0'
  },
  EPSG_4761: {
    towgs84: '0,0,0'
  },
  EPSG_4765: {
    towgs84: '0,0,0'
  },
  EPSG_8997: {
    towgs84: '0,0,0'
  },
  EPSG_4023: {
    towgs84: '0,0,0'
  },
  EPSG_4670: {
    towgs84: '0,0,0'
  },
  EPSG_4694: {
    towgs84: '0,0,0'
  },
  EPSG_4148: {
    towgs84: '0,0,0'
  },
  EPSG_4163: {
    towgs84: '0,0,0'
  },
  EPSG_4167: {
    towgs84: '0,0,0'
  },
  EPSG_4189: {
    towgs84: '0,0,0'
  },
  EPSG_4190: {
    towgs84: '0,0,0'
  },
  EPSG_4176: {
    towgs84: '0,0,0'
  },
  EPSG_4659: {
    towgs84: '0,0,0'
  },
  EPSG_3824: {
    towgs84: '0,0,0'
  },
  EPSG_3889: {
    towgs84: '0,0,0'
  },
  EPSG_4046: {
    towgs84: '0,0,0'
  },
  EPSG_4081: {
    towgs84: '0,0,0'
  },
  EPSG_4558: {
    towgs84: '0,0,0'
  },
  EPSG_4483: {
    towgs84: '0,0,0'
  },
  EPSG_5013: {
    towgs84: '0,0,0'
  },
  EPSG_5264: {
    towgs84: '0,0,0'
  },
  EPSG_5324: {
    towgs84: '0,0,0'
  },
  EPSG_5354: {
    towgs84: '0,0,0'
  },
  EPSG_5371: {
    towgs84: '0,0,0'
  },
  EPSG_5373: {
    towgs84: '0,0,0'
  },
  EPSG_5381: {
    towgs84: '0,0,0'
  },
  EPSG_5393: {
    towgs84: '0,0,0'
  },
  EPSG_5489: {
    towgs84: '0,0,0'
  },
  EPSG_5593: {
    towgs84: '0,0,0'
  },
  EPSG_6135: {
    towgs84: '0,0,0'
  },
  EPSG_6365: {
    towgs84: '0,0,0'
  },
  EPSG_5246: {
    towgs84: '0,0,0'
  },
  EPSG_7886: {
    towgs84: '0,0,0'
  },
  EPSG_8431: {
    towgs84: '0,0,0'
  },
  EPSG_8427: {
    towgs84: '0,0,0'
  },
  EPSG_8699: {
    towgs84: '0,0,0'
  },
  EPSG_8818: {
    towgs84: '0,0,0'
  },
  EPSG_4757: {
    towgs84: '0,0,0'
  },
  EPSG_9140: {
    towgs84: '0,0,0'
  },
  EPSG_8086: {
    towgs84: '0,0,0'
  },
  EPSG_4686: {
    towgs84: '0,0,0'
  },
  EPSG_4737: {
    towgs84: '0,0,0'
  },
  EPSG_4702: {
    towgs84: '0,0,0'
  },
  EPSG_4747: {
    towgs84: '0,0,0'
  },
  EPSG_4749: {
    towgs84: '0,0,0'
  },
  EPSG_4674: {
    towgs84: '0,0,0'
  },
  EPSG_4755: {
    towgs84: '0,0,0'
  },
  EPSG_4759: {
    towgs84: '0,0,0'
  },
  EPSG_4762: {
    towgs84: '0,0,0'
  },
  EPSG_4763: {
    towgs84: '0,0,0'
  },
  EPSG_4764: {
    towgs84: '0,0,0'
  },
  EPSG_4166: {
    towgs84: '0,0,0'
  },
  EPSG_4170: {
    towgs84: '0,0,0'
  },
  EPSG_5546: {
    towgs84: '0,0,0'
  },
  EPSG_7844: {
    towgs84: '0,0,0'
  },
  EPSG_4818: {
    towgs84: '589,76,480'
  }
};
for (var key in datums) {
  var datum = datums[key];
  if (!datum.datumName) {
    continue;
  }
  datums[datum.datumName] = datum;
}
/* harmony default export */ var Datum = (datums);
;// ../node_modules/proj4/lib/datum.js

function datum_datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = values/* PJD_NODATUM */.A1;
  } else {
    out.datum_type = values/* PJD_WGS84 */.xK;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = values/* PJD_3PARAM */.a8;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = values/* PJD_7PARAM */.Y$;
        out.datum_params[3] *= values/* SEC_TO_RAD */._3;
        out.datum_params[4] *= values/* SEC_TO_RAD */._3;
        out.datum_params[5] *= values/* SEC_TO_RAD */._3;
        out.datum_params[6] = out.datum_params[6] / 1000000.0 + 1.0;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = values/* PJD_GRIDSHIFT */.G9;
    out.grids = nadgrids;
  }
  out.a = a; // datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
/* harmony default export */ var lib_datum = (datum_datum);
// EXTERNAL MODULE: ../node_modules/proj4/lib/nadgrid.js
var nadgrid = __webpack_require__(8201);
;// ../node_modules/proj4/lib/Proj.js
function Proj_typeof(o) { "@babel/helpers - typeof"; return Proj_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Proj_typeof(o); }









/**
 * @typedef {Object} DatumDefinition
 * @property {number} datum_type - The type of datum.
 * @property {number} a - Semi-major axis of the ellipsoid.
 * @property {number} b - Semi-minor axis of the ellipsoid.
 * @property {number} es - Eccentricity squared of the ellipsoid.
 * @property {number} ep2 - Second eccentricity squared of the ellipsoid.
 */

/**
 * @param {string | import('./core').PROJJSONDefinition | import('./defs').ProjectionDefinition} srsCode
 * @param {(errorMessage?: string, instance?: Projection) => void} [callback]
 */
function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  /** @type {<T extends import('./core').TemplateCoordinates>(coordinates: T, enforceAxis?: boolean) => T} */
  this.forward = null;
  /** @type {<T extends import('./core').TemplateCoordinates>(coordinates: T, enforceAxis?: boolean) => T} */
  this.inverse = null;
  /** @type {function(): void} */
  this.init = null;
  /** @type {string} */
  this.name;
  /** @type {Array<string>} */
  this.names = null;
  /** @type {string} */
  this.title;
  callback = callback || function (error) {
    if (error) {
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if (Proj_typeof(json) !== 'object') {
    callback('Could not parse to valid json: ' + srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if (!ourProj) {
    callback('Could not get projection name from: ' + srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = (0,match/* default */.A)(Datum, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = (0,nadgrid/* getNadgrids */.f)(json.nadgrids);
  /** @type {DatumDefinition} */
  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
  extend(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calculated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  if ('init' in this && typeof this.init === 'function') {
    this.init();
  }

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);
}
Projection.projections = projections/* default */.Ay;
Projection.projections.start();
/* harmony default export */ var Proj = (Projection);

/***/ }),

/***/ 6165:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9393);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK ? x : x - (0,_sign__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(x) * Math.PI;
}

/***/ }),

/***/ 6269:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
/* harmony import */ var _sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9393);


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, skipAdjust) {
  if (skipAdjust) {
    return x;
  }
  return Math.abs(x) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF ? x : x - (0,_sign__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(x) * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .TWO_PI */ .JM;
}

/***/ }),

/***/ 8597:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }
  return Math.asin(x);
}

/***/ }),

/***/ 6449:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}

/***/ }),

/***/ 1341:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}

/***/ }),

/***/ 7954:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}

/***/ }),

/***/ 3611:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}

/***/ }),

/***/ 4280:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x * x * x * (35 / 3072);
}

/***/ }),

/***/ 2889:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}

/***/ }),

/***/ 4424:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}

/***/ }),

/***/ 364:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  // ..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
}

/***/ }),

/***/ 1417:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}

/***/ }),

/***/ 7072:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}

/***/ }),

/***/ 6157:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  // console.log("phi2z has NoConvergence");
  return -9999;
}

/***/ }),

/***/ 6194:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}

/***/ }),

/***/ 112:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _pj_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3712);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7000);


var MAX_ITER = 20;
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) {
    /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    // t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    // phi -= t * (t * Math.sqrt(t)) * k;
    t = ((0,_pj_mlfn__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      return phi;
    }
  }
  // ..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
}

/***/ }),

/***/ 3712:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}

/***/ }),

/***/ 5964:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}

/***/ }),

/***/ 9393:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x < 0 ? -1 : 1;
}

/***/ }),

/***/ 7897:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}

/***/ }),

/***/ 851:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - phi)) / con;
}

/***/ }),

/***/ 7000:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A1: function() { return /* binding */ PJD_NODATUM; },
/* harmony export */   DF: function() { return /* binding */ SPI; },
/* harmony export */   G9: function() { return /* binding */ PJD_GRIDSHIFT; },
/* harmony export */   H0: function() { return /* binding */ EPSLN; },
/* harmony export */   JM: function() { return /* binding */ TWO_PI; },
/* harmony export */   Q1: function() { return /* binding */ RA4; },
/* harmony export */   Vj: function() { return /* binding */ FORTPI; },
/* harmony export */   Y$: function() { return /* binding */ PJD_7PARAM; },
/* harmony export */   _3: function() { return /* binding */ SEC_TO_RAD; },
/* harmony export */   a8: function() { return /* binding */ PJD_3PARAM; },
/* harmony export */   bA: function() { return /* binding */ SIXTH; },
/* harmony export */   bv: function() { return /* binding */ SRS_WGS84_SEMIMAJOR; },
/* harmony export */   dX: function() { return /* binding */ R2D; },
/* harmony export */   ej: function() { return /* binding */ RA6; },
/* harmony export */   gS: function() { return /* binding */ SRS_WGS84_ESQUARED; },
/* harmony export */   sK: function() { return /* binding */ HALF_PI; },
/* harmony export */   xK: function() { return /* binding */ PJD_WGS84; },
/* harmony export */   zp: function() { return /* binding */ SRS_WGS84_SEMIMINOR; },
/* harmony export */   zq: function() { return /* binding */ D2R; }
/* harmony export */ });
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137.0; // only used in grid shift transforms
var SRS_WGS84_SEMIMINOR = 6356752.314; // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI / 2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10;
// you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI / 4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;

/***/ }),

/***/ 3356:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fs: function() { return /* binding */ geocentricFromWgs84; },
/* harmony export */   OI: function() { return /* binding */ compareDatums; },
/* harmony export */   Rw: function() { return /* binding */ geocentricToGeodetic; },
/* harmony export */   jX: function() { return /* binding */ geodeticToGeocentric; },
/* harmony export */   mj: function() { return /* binding */ geocentricToWgs84; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);



function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .PJD_3PARAM */ .a8) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .PJD_7PARAM */ .Y$) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; // Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK && Latitude > -1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK) {
    Latitude = -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK && Latitude < 1.001 * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK) {
    Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
  } else if (Latitude < -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK) {
    /* Latitude out of range */
    // ..reportError('geocent:lat out of range:' + Latitude);
    return {
      x: -Infinity,
      y: -Infinity,
      z: p.z
    };
  } else if (Latitude > _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK) {
    /* Latitude out of range */
    return {
      x: Infinity,
      y: Infinity,
      z: p.z
    };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1.0e0 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; // Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {
    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .PJD_3PARAM */ .a8) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .PJD_7PARAM */ .Y$) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .PJD_3PARAM */ .a8) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .PJD_7PARAM */ .Y$) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    // if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } // cs_geocentric_from_wgs84()
}

/***/ }),

/***/ 1362:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ lib_defs; }
});

;// ../node_modules/proj4/lib/global.js
/* harmony default export */ function global(defs) {
  defs('EPSG:4326', '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees');
  defs('EPSG:4269', '+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees');
  defs('EPSG:3857', '+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs');
  // UTM WGS84
  for (var i = 1; i <= 60; ++i) {
    defs('EPSG:' + (32600 + i), '+proj=utm +zone=' + i + ' +datum=WGS84 +units=m');
    defs('EPSG:' + (32700 + i), '+proj=utm +zone=' + i + ' +south +datum=WGS84 +units=m');
  }
  defs('EPSG:5041', '+title=WGS 84 / UPS North (E,N) +proj=stere +lat_0=90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +datum=WGS84 +units=m');
  defs('EPSG:5042', '+title=WGS 84 / UPS South (E,N) +proj=stere +lat_0=-90 +lon_0=0 +k=0.994 +x_0=2000000 +y_0=2000000 +datum=WGS84 +units=m');
  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/projString.js + 2 modules
var projString = __webpack_require__(4326);
// EXTERNAL MODULE: ../node_modules/wkt-parser/index.js + 9 modules
var wkt_parser = __webpack_require__(6082);
;// ../node_modules/proj4/lib/defs.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }




/**
 * @typedef {Object} ProjectionDefinition
 * @property {string} title
 * @property {string} [projName]
 * @property {string} [ellps]
 * @property {import('./Proj.js').DatumDefinition} [datum]
 * @property {string} [datumName]
 * @property {number} [rf]
 * @property {number} [lat0]
 * @property {number} [lat1]
 * @property {number} [lat2]
 * @property {number} [lat_ts]
 * @property {number} [long0]
 * @property {number} [long1]
 * @property {number} [long2]
 * @property {number} [alpha]
 * @property {number} [longc]
 * @property {number} [x0]
 * @property {number} [y0]
 * @property {number} [k0]
 * @property {number} [a]
 * @property {number} [b]
 * @property {true} [R_A]
 * @property {number} [zone]
 * @property {true} [utmSouth]
 * @property {string|Array<number>} [datum_params]
 * @property {number} [to_meter]
 * @property {string} [units]
 * @property {number} [from_greenwich]
 * @property {string} [datumCode]
 * @property {string} [nadgrids]
 * @property {string} [axis]
 * @property {boolean} [sphere]
 * @property {number} [rectified_grid_angle]
 * @property {boolean} [approx]
 * @property {boolean} [over]
 * @property {string} [projStr]
 * @property {<T extends import('./core').TemplateCoordinates>(coordinates: T, enforceAxis?: boolean) => T} inverse
 * @property {<T extends import('./core').TemplateCoordinates>(coordinates: T, enforceAxis?: boolean) => T} forward
 */

/**
 * @overload
 * @param {string} name
 * @param {string|ProjectionDefinition|import('./core.js').PROJJSONDefinition} projection
 * @returns {void}
 */
/**
 * @overload
 * @param {Array<[string, string]>} name
 * @returns {Array<ProjectionDefinition|undefined>}
 */
/**
 * @overload
 * @param {string} name
 * @returns {ProjectionDefinition}
 */

/**
 * @param {string | Array<Array<string>> | Partial<Record<'EPSG'|'ESRI'|'IAU2000', ProjectionDefinition>>} name
 * @returns {ProjectionDefinition | Array<ProjectionDefinition|undefined> | void}
 */
function defs(name) {
  /* global console */
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[(/** @type {string} */name)] = (0,projString/* default */.A)(arguments[1]);
      } else {
        defs[(/** @type {string} */name)] = (0,wkt_parser/* default */.A)(arguments[1]);
      }
    } else if (def && _typeof(def) === 'object' && !('projName' in def)) {
      // PROJJSON
      defs[(/** @type {string} */name)] = (0,wkt_parser/* default */.A)(arguments[1]);
    } else {
      defs[(/** @type {string} */name)] = def;
      if (!def) {
        delete defs[(/** @type {string} */name)];
      }
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function (v) {
        if (Array.isArray(v)) {
          return defs.apply(that, v);
        } else {
          return defs(v);
        }
      });
    } else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    } else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    } else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    } else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
global(defs);
/* harmony default export */ var lib_defs = (defs);

/***/ }),

/***/ 9677:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ lib; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/Proj.js + 6 modules
var Proj = __webpack_require__(1845);
// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
// EXTERNAL MODULE: ../node_modules/proj4/lib/datumUtils.js
var datumUtils = __webpack_require__(3356);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/adjust_lon.js
var adjust_lon = __webpack_require__(6269);
;// ../node_modules/proj4/lib/datum_transform.js



function checkParams(type) {
  return type === values/* PJD_3PARAM */.a8 || type === values/* PJD_7PARAM */.Y$;
}
/* harmony default export */ function datum_transform(source, dest, point) {
  // Short cut if the datums are identical.
  if ((0,datumUtils/* compareDatums */.OI)(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === values/* PJD_NODATUM */.A1 || dest.datum_type === values/* PJD_NODATUM */.A1) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === values/* PJD_GRIDSHIFT */.G9) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return undefined;
    }
    source_a = values/* SRS_WGS84_SEMIMAJOR */.bv;
    source_es = values/* SRS_WGS84_ESQUARED */.gS;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === values/* PJD_GRIDSHIFT */.G9) {
    dest_a = values/* SRS_WGS84_SEMIMAJOR */.bv;
    dest_b = values/* SRS_WGS84_SEMIMINOR */.zp;
    dest_es = values/* SRS_WGS84_ESQUARED */.gS;
  }

  // Do we need to go through geocentric coordinates?
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = (0,datumUtils/* geodeticToGeocentric */.jX)(point, source_es, source_a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = (0,datumUtils/* geocentricToWgs84 */.mj)(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = (0,datumUtils/* geocentricFromWgs84 */.Fs)(point, dest.datum_type, dest.datum_params);
  }
  point = (0,datumUtils/* geocentricToGeodetic */.Rw)(point, dest_es, dest_a, dest_b);
  if (dest.datum_type === values/* PJD_GRIDSHIFT */.G9) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return undefined;
    }
  }
  return point;
}
function applyGridShift(source, inverse, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log('Grid shift grids not found');
    return -1;
  }
  var input = {
    x: -point.x,
    y: point.y
  };
  var output = {
    x: Number.NaN,
    y: Number.NaN
  };
  var attemptedGrids = [];
  outer: for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log('Unable to find mandatory grid \'' + grid.name + '\'');
        return -1;
      }
      continue;
    }
    var subgrids = grid.grid.subgrids;
    for (var j = 0, jj = subgrids.length; j < jj; j++) {
      var subgrid = subgrids[j];
      // skip tables that don't match our point at all
      var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
      var minX = subgrid.ll[0] - epsilon;
      var minY = subgrid.ll[1] - epsilon;
      var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
      var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
      if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
        continue;
      }
      output = applySubgridShift(input, inverse, subgrid);
      if (!isNaN(output.x)) {
        break outer;
      }
    }
  }
  if (isNaN(output.x)) {
    console.log('Failed to find a grid shift table for location \'' + -input.x * values/* R2D */.dX + ' ' + input.y * values/* R2D */.dX + ' tried: \'' + attemptedGrids + '\'');
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse, ct) {
  var val = {
    x: Number.NaN,
    y: Number.NaN
  };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = {
    x: pin.x,
    y: pin.y
  };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = (0,adjust_lon/* default */.A)(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9,
      tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log('Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.');
        break;
      }
      dif = {
        x: tb.x - (del.x + t.x),
        y: tb.y - (del.y + t.y)
      };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log('Inverse grid shift iterator failed to converge.');
      return val;
    }
    val.x = (0,adjust_lon/* default */.A)(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t = {
    x: pin.x / ct.del[0],
    y: pin.y / ct.del[1]
  };
  var indx = {
    x: Math.floor(t.x),
    y: Math.floor(t.y)
  };
  var frct = {
    x: t.x - 1.0 * indx.x,
    y: t.y - 1.0 * indx.y
  };
  var val = {
    x: Number.NaN,
    y: Number.NaN
  };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  inx++;
  var f10 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  inx += ct.lim[0];
  var f11 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  inx--;
  var f01 = {
    x: ct.cvs[inx][0],
    y: ct.cvs[inx][1]
  };
  var m11 = frct.x * frct.y,
    m10 = frct.x * (1.0 - frct.y),
    m00 = (1.0 - frct.x) * (1.0 - frct.y),
    m01 = (1.0 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
;// ../node_modules/proj4/lib/adjust_axis.js
/* harmony default export */ function adjust_axis(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  /** @type {import("./core").InterfaceCoordinates} */
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ('ew'.indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }
    } else if (i === 1) {
      v = yin;
      if ('ns'.indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    } else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
      case 'e':
        out[t] = v;
        break;
      case 'w':
        out[t] = -v;
        break;
      case 'n':
        out[t] = v;
        break;
      case 's':
        out[t] = -v;
        break;
      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }
        break;
      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }
        break;
      default:
        // console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
    }
  }
  return out;
}
;// ../node_modules/proj4/lib/common/toPoint.js
/**
 * @param {Array<number>} array
 * @returns {import("../core").InterfaceCoordinates}
 */
/* harmony default export */ function toPoint(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
;// ../node_modules/proj4/lib/checkSanity.js
/* harmony default export */ function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError('coordinates must be finite numbers');
  }
  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}
;// ../node_modules/proj4/lib/transform.js






function checkNotWGS(source, dest) {
  return (source.datum.datum_type === values/* PJD_3PARAM */.a8 || source.datum.datum_type === values/* PJD_7PARAM */.Y$ || source.datum.datum_type === values/* PJD_GRIDSHIFT */.G9) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === values/* PJD_3PARAM */.a8 || dest.datum.datum_type === values/* PJD_7PARAM */.Y$ || dest.datum.datum_type === values/* PJD_GRIDSHIFT */.G9) && source.datumCode !== 'WGS84';
}

/**
 * @param {import('./defs').ProjectionDefinition} source
 * @param {import('./defs').ProjectionDefinition} dest
 * @param {import('./core').TemplateCoordinates} point
 * @param {boolean} enforceAxis
 * @returns {import('./core').InterfaceCoordinates | undefined}
 */
function transform(source, dest, point, enforceAxis) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  } else {
    // Clone the point object so inputs don't get modified
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== undefined;
  checkSanity(point);
  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new Proj/* default */.A('WGS84');
    point = transform(source, wgs84, point, enforceAxis);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (enforceAxis && source.axis !== 'enu') {
    point = adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point = {
      x: point.x * values/* D2R */.zq,
      y: point.y * values/* D2R */.zq,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point); // Convert Cartesian to longlat
    if (!point) {
      return;
    }
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }
  point = /** @type {import('./core').InterfaceCoordinates} */point;

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }
  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * values/* R2D */.dX,
      y: point.y * values/* R2D */.dX,
      z: point.z || 0
    };
  } else {
    // else project
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }

  // DGR, 2010/11/12
  if (enforceAxis && dest.axis !== 'enu') {
    return adjust_axis(dest, true, point);
  }
  if (point && !hasZ) {
    delete point.z;
  }
  return point;
}
;// ../node_modules/proj4/lib/core.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }


var wgs84 = (0,Proj/* default */.A)('WGS84');

/**
 * @typedef {{x: number, y: number, z?: number, m?: number}} InterfaceCoordinates
 */

/**
 * @typedef {Array<number> | InterfaceCoordinates} TemplateCoordinates
 */

/**
 * @typedef {Object} Converter
 * @property {<T extends TemplateCoordinates>(coordinates: T, enforceAxis?: boolean) => T} forward
 * @property {<T extends TemplateCoordinates>(coordinates: T, enforceAxis?: boolean) => T} inverse
 * @property {proj} [oProj]
 */

/**
 * @typedef {Object} PROJJSONDefinition
 * @property {string} [$schema]
 * @property {string} type
 * @property {string} [name]
 * @property {{authority: string, code: number}} [id]
 * @property {string} [scope]
 * @property {string} [area]
 * @property {{south_latitude: number, west_longitude: number, north_latitude: number, east_longitude: number}} [bbox]
 * @property {PROJJSONDefinition[]} [components]
 * @property {{type: string, name: string}} [datum]
 * @property {{
 *   name: string,
 *   members: Array<{
 *     name: string,
 *     id?: {authority: string, code: number}
 *   }>,
 *   ellipsoid?: {
 *     name: string,
 *     semi_major_axis: number,
 *     inverse_flattening?: number
 *   },
 *   accuracy?: string,
 *   id?: {authority: string, code: number}
 * }} [datum_ensemble]
 * @property {{
 *   subtype: string,
 *   axis: Array<{
 *     name: string,
 *     abbreviation?: string,
 *     direction: string,
 *     unit: string
 *   }>
 * }} [coordinate_system]
 * @property {{
 *   name: string,
 *   method: {name: string},
 *   parameters: Array<{
 *     name: string,
 *     value: number,
 *     unit?: string
 *   }>
 * }} [conversion]
 * @property {{
 *   name: string,
 *   method: {name: string},
 *   parameters: Array<{
 *     name: string,
 *     value: number,
 *     unit?: string,
 *     type?: string,
 *     file_name?: string
 *   }>
 * }} [transformation]
 */

/**
 * @template {TemplateCoordinates} T
 * @param {proj} from
 * @param {proj} to
 * @param {T} coords
 * @param {boolean} [enforceAxis]
 * @returns {T}
 */
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords, enforceAxis) || {
      x: NaN,
      y: NaN
    };
    if (coords.length > 2) {
      if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
        if (typeof transformedArray.z === 'number') {
          return /** @type {T} */[transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.slice(3));
        } else {
          return /** @type {T} */[transformedArray.x, transformedArray.y, coords[2]].concat(coords.slice(3));
        }
      } else {
        return /** @type {T} */[transformedArray.x, transformedArray.y].concat(coords.slice(2));
      }
    } else {
      return /** @type {T} */[transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return /** @type {T} */out;
    }
    keys.forEach(function (key) {
      if (typeof from.name !== 'undefined' && from.name === 'geocent' || typeof to.name !== 'undefined' && to.name === 'geocent') {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }
      out[key] = coords[key];
    });
    return /** @type {T} */out;
  }
}

/**
 * @param {proj | string | PROJJSONDefinition | Converter} item
 * @returns {import('./Proj').default}
 */
function checkProj(item) {
  if (item instanceof Proj/* default */.A) {
    return item;
  }
  if (_typeof(item) === 'object' && 'oProj' in item) {
    return item.oProj;
  }
  return (0,Proj/* default */.A)(/** @type {string | PROJJSONDefinition} */item);
}

/**
 * @overload
 * @param {string | PROJJSONDefinition | proj} toProj
 * @returns {Converter}
 */
/**
 * @overload
 * @param {string | PROJJSONDefinition | proj} fromProj
 * @param {string | PROJJSONDefinition | proj} toProj
 * @returns {Converter}
 */
/**
 * @template {TemplateCoordinates} T
 * @overload
 * @param {string | PROJJSONDefinition | proj} toProj
 * @param {T} coord
 * @returns {T}
 */
/**
 * @template {TemplateCoordinates} T
 * @overload
 * @param {string | PROJJSONDefinition | proj} fromProj
 * @param {string | PROJJSONDefinition | proj} toProj
 * @param {T} coord
 * @returns {T}
 */
/**
 * @template {TemplateCoordinates} T
 * @param {string | PROJJSONDefinition | proj} fromProjOrToProj
 * @param {string | PROJJSONDefinition | proj | TemplateCoordinates} [toProjOrCoord]
 * @param {T} [coord]
 * @returns {T|Converter}
 */
function proj4(fromProjOrToProj, toProjOrCoord, coord) {
  /** @type {proj} */
  var fromProj;
  /** @type {proj} */
  var toProj;
  var single = false;
  /** @type {Converter} */
  var obj;
  if (typeof toProjOrCoord === 'undefined') {
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  } else if (typeof /** @type {?} */toProjOrCoord.x !== 'undefined' || Array.isArray(toProjOrCoord)) {
    coord = /** @type {T} */ /** @type {?} */toProjOrCoord;
    toProj = checkProj(fromProjOrToProj);
    fromProj = wgs84;
    single = true;
  }
  if (!fromProj) {
    fromProj = checkProj(fromProjOrToProj);
  }
  if (!toProj) {
    toProj = checkProj(/** @type {string | PROJJSONDefinition | proj } */toProjOrCoord);
  }
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      forward: function forward(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      /**
       * @template {TemplateCoordinates} T
       * @param {T} coords
       * @param {boolean=} enforceAxis
       * @returns {T}
       */
      inverse: function inverse(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ var core = (proj4);
;// ../node_modules/mgrs/mgrs.js



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
/* harmony default export */ var mgrs = ({
  forward: forward,
  inverse: inverse,
  toPoint: mgrs_toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function mgrs_toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}

;// ../node_modules/proj4/lib/Point.js
function Point_typeof(o) { "@babel/helpers - typeof"; return Point_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Point_typeof(o); }


/**
 * @deprecated v3.0.0 - use proj4.toPoint instead
 * @param {number | import('./core').TemplateCoordinates | string} x
 * @param {number} [y]
 * @param {number} [z]
 */
function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if (Point_typeof(x) === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0]);
    this.y = parseFloat(coords[1]);
    this.z = parseFloat(coords[2]) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}
Point.fromMGRS = function (mgrsStr) {
  return new Point(mgrs_toPoint(mgrsStr));
};
Point.prototype.toMGRS = function (accuracy) {
  return forward([this.x, this.y], accuracy);
};
/* harmony default export */ var lib_Point = (Point);
// EXTERNAL MODULE: ../node_modules/proj4/lib/defs.js + 1 modules
var defs = __webpack_require__(1362);
// EXTERNAL MODULE: ../node_modules/proj4/lib/nadgrid.js
var nadgrid = __webpack_require__(8201);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/tmerc.js
var tmerc = __webpack_require__(5518);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/etmerc.js + 5 modules
var etmerc = __webpack_require__(3426);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/utm.js + 1 modules
var utm = __webpack_require__(2924);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/sterea.js
var sterea = __webpack_require__(6789);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/stere.js
var stere = __webpack_require__(3084);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/somerc.js
var somerc = __webpack_require__(9872);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/omerc.js
var omerc = __webpack_require__(431);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/lcc.js
var lcc = __webpack_require__(993);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/krovak.js
var krovak = __webpack_require__(6167);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/cass.js
var cass = __webpack_require__(3245);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/laea.js
var laea = __webpack_require__(8506);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/aea.js
var aea = __webpack_require__(4894);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/gnom.js
var gnom = __webpack_require__(5106);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/cea.js + 1 modules
var cea = __webpack_require__(8104);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/eqc.js
var eqc = __webpack_require__(780);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/poly.js
var poly = __webpack_require__(741);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/nzmg.js
var nzmg = __webpack_require__(6731);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/mill.js
var mill = __webpack_require__(969);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/sinu.js
var sinu = __webpack_require__(1034);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/moll.js
var moll = __webpack_require__(6155);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/eqdc.js
var eqdc = __webpack_require__(7724);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/vandg.js
var vandg = __webpack_require__(6671);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/aeqd.js + 1 modules
var aeqd = __webpack_require__(6014);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/ortho.js
var ortho = __webpack_require__(6145);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/qsc.js
var qsc = __webpack_require__(2513);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/robin.js
var robin = __webpack_require__(8067);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/geocent.js
var geocent = __webpack_require__(5904);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/tpers.js
var tpers = __webpack_require__(251);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/geos.js
var geos = __webpack_require__(1017);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/eqearth.js
var eqearth = __webpack_require__(8197);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/bonne.js
var bonne = __webpack_require__(9265);
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/ob_tran.js
var ob_tran = __webpack_require__(4076);
;// ../node_modules/proj4/projs.js
































/* harmony default export */ function projs(proj4) {
  proj4.Proj.projections.add(tmerc["default"]);
  proj4.Proj.projections.add(etmerc["default"]);
  proj4.Proj.projections.add(utm["default"]);
  proj4.Proj.projections.add(sterea["default"]);
  proj4.Proj.projections.add(stere["default"]);
  proj4.Proj.projections.add(somerc["default"]);
  proj4.Proj.projections.add(omerc["default"]);
  proj4.Proj.projections.add(lcc["default"]);
  proj4.Proj.projections.add(krovak["default"]);
  proj4.Proj.projections.add(cass["default"]);
  proj4.Proj.projections.add(laea["default"]);
  proj4.Proj.projections.add(aea["default"]);
  proj4.Proj.projections.add(gnom["default"]);
  proj4.Proj.projections.add(cea["default"]);
  proj4.Proj.projections.add(eqc["default"]);
  proj4.Proj.projections.add(poly["default"]);
  proj4.Proj.projections.add(nzmg["default"]);
  proj4.Proj.projections.add(mill["default"]);
  proj4.Proj.projections.add(sinu["default"]);
  proj4.Proj.projections.add(moll["default"]);
  proj4.Proj.projections.add(eqdc["default"]);
  proj4.Proj.projections.add(vandg["default"]);
  proj4.Proj.projections.add(aeqd["default"]);
  proj4.Proj.projections.add(ortho["default"]);
  proj4.Proj.projections.add(qsc["default"]);
  proj4.Proj.projections.add(robin["default"]);
  proj4.Proj.projections.add(geocent["default"]);
  proj4.Proj.projections.add(tpers["default"]);
  proj4.Proj.projections.add(geos["default"]);
  proj4.Proj.projections.add(eqearth["default"]);
  proj4.Proj.projections.add(bonne["default"]);
  proj4.Proj.projections.add(ob_tran["default"]);
}
;// ../node_modules/proj4/lib/index.js










/**
 * @typedef {Object} Mgrs
 * @property {(lonlat: [number, number]) => string} forward
 * @property {(mgrsString: string) => [number, number, number, number]} inverse
 * @property {(mgrsString: string) => [number, number]} toPoint
 */

/**
 * @typedef {import('./defs').ProjectionDefinition} ProjectionDefinition
 * @typedef {import('./core').TemplateCoordinates} TemplateCoordinates
 * @typedef {import('./core').InterfaceCoordinates} InterfaceCoordinates
 * @typedef {import('./core').Converter} Converter
 * @typedef {import('./Proj').DatumDefinition} DatumDefinition
 */

/**
 * @template {import('./core').TemplateCoordinates} T
 * @type {core<T> & {defaultDatum: string, Proj: typeof Proj, WGS84: Proj, Point: typeof Point, toPoint: typeof common, defs: typeof defs, nadgrid: typeof nadgrid, transform: typeof transform, mgrs: Mgrs, version: string}}
 */
var lib_proj4 = Object.assign(core, {
  defaultDatum: 'WGS84',
  Proj: Proj/* default */.A,
  WGS84: new Proj/* default */.A('WGS84'),
  Point: lib_Point,
  toPoint: toPoint,
  defs: defs/* default */.A,
  nadgrid: nadgrid/* default */.A,
  transform: transform,
  mgrs: mgrs,
  version: '__VERSION__'
});
projs(lib_proj4);
/* harmony default export */ var lib = (lib_proj4);

/***/ }),

/***/ 7575:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ match; }
/* harmony export */ });
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

/***/ }),

/***/ 8201:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: function() { return /* binding */ nadgrid; },
/* harmony export */   f: function() { return /* binding */ getNadgrids; }
/* harmony export */ });
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/**
 * Resources for details of NTv2 file formats:
 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
 */

/**
 * @typedef {Object} NadgridInfo
 * @property {string} name The name of the NAD grid or 'null' if not specified.
 * @property {boolean} mandatory Indicates if the grid is mandatory (true) or optional (false).
 * @property {*} grid The loaded NAD grid object, or null if not loaded or not applicable.
 * @property {boolean} isNull True if the grid is explicitly 'null', otherwise false.
 */

/**
 * @typedef {Object} NTV2GridOptions
 * @property {boolean} [includeErrorFields=true] Whether to include error fields in the subgrids.
 */

/**
 * @typedef {Object} NadgridHeader
 * @property {number} [nFields] Number of fields in the header.
 * @property {number} [nSubgridFields] Number of fields in each subgrid header.
 * @property {number} nSubgrids Number of subgrids in the file.
 * @property {string} [shiftType] Type of shift (e.g., "SECONDS").
 * @property {number} [fromSemiMajorAxis] Source ellipsoid semi-major axis.
 * @property {number} [fromSemiMinorAxis] Source ellipsoid semi-minor axis.
 * @property {number} [toSemiMajorAxis] Target ellipsoid semi-major axis.
 * @property {number} [toSemiMinorAxis] Target ellipsoid semi-minor axis.
 */

/**
 * @typedef {Object} Subgrid
 * @property {Array<number>} ll Lower left corner of the grid in radians [longitude, latitude].
 * @property {Array<number>} del Grid spacing in radians [longitude interval, latitude interval].
 * @property {Array<number>} lim Number of columns in the grid [longitude columns, latitude columns].
 * @property {number} [count] Total number of grid nodes.
 * @property {Array} cvs Mapped node values for the grid.
 */

/** @typedef {{header: NadgridHeader, subgrids: Array<Subgrid>}} NADGrid */

/**
 * @typedef {Object} GeoTIFF
 * @property {() => Promise<number>} getImageCount - Returns the number of images in the GeoTIFF.
 * @property {(index: number) => Promise<GeoTIFFImage>} getImage - Returns a GeoTIFFImage for the given index.
 */

/**
 * @typedef {Object} GeoTIFFImage
 * @property {() => number} getWidth - Returns the width of the image.
 * @property {() => number} getHeight - Returns the height of the image.
 * @property {() => number[]} getBoundingBox - Returns the bounding box as [minX, minY, maxX, maxY] in degrees.
 * @property {() => Promise<ArrayLike<ArrayLike<number>>>} readRasters - Returns the raster data as an array of bands.
 * @property {Object} fileDirectory - The file directory object containing metadata.
 * @property {Object} fileDirectory.ModelPixelScale - The pixel scale array [scaleX, scaleY, scaleZ] in degrees.
 */

var loadedNadgrids = {};

/**
 * @overload
 * @param {string} key - The key to associate with the loaded grid.
 * @param {ArrayBuffer} data - The NTv2 grid data as an ArrayBuffer.
 * @param {NTV2GridOptions} [options] - Optional parameters for loading the grid.
 * @returns {NADGrid} - The loaded NAD grid information.
 */
/**
 * @overload
 * @param {string} key - The key to associate with the loaded grid.
 * @param {GeoTIFF} data - The GeoTIFF instance to read the grid from.
 * @returns {{ready: Promise<NADGrid>}} - A promise that resolves to the loaded grid information.
 */
/**
 * Load either a NTv2 file (.gsb) or a Geotiff (.tif) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
 * as an ArrayBuffer. Pass Geotiff as a GeoTIFF instance from the geotiff.js library.
 * @param {string} key - The key to associate with the loaded grid.
 * @param {ArrayBuffer|GeoTIFF} data The data to load, either an ArrayBuffer for NTv2 or a GeoTIFF instance.
 * @param {NTV2GridOptions} [options] Optional parameters.
 * @returns {{ready: Promise<NADGrid>}|NADGrid} - A promise that resolves to the loaded grid information.
 */
function nadgrid(key, data, options) {
  if (data instanceof ArrayBuffer) {
    return readNTV2Grid(key, data, options);
  }
  return {
    ready: readGeotiffGrid(key, data)
  };
}

/**
 * @param {string} key The key to associate with the loaded grid.
 * @param {ArrayBuffer} data The NTv2 grid data as an ArrayBuffer.
 * @param {NTV2GridOptions} [options] Optional parameters for loading the grid.
 * @returns {NADGrid} The loaded NAD grid information.
 */
function readNTV2Grid(key, data, options) {
  var includeErrorFields = true;
  if (options !== undefined && options.includeErrorFields === false) {
    includeErrorFields = false;
  }
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  var subgrids = readSubgrids(view, header, isLittleEndian, includeErrorFields);
  var nadgrid = {
    header: header,
    subgrids: subgrids
  };
  loadedNadgrids[key] = nadgrid;
  return nadgrid;
}

/**
 * @param {string} key The key to associate with the loaded grid.
 * @param {GeoTIFF} tiff The GeoTIFF instance to read the grid from.
 * @returns {Promise<NADGrid>} A promise that resolves to the loaded NAD grid information.
 */
function readGeotiffGrid(_x, _x2) {
  return _readGeotiffGrid.apply(this, arguments);
}
function _readGeotiffGrid() {
  _readGeotiffGrid = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(key, tiff) {
    var subgrids, subGridCount, subgridIndex, image, rasters, data, lim, imageBBoxRadians, del, maxX, minY, latitudeOffsetBand, longitudeOffsetBand, nodes, i, j, index, tifGrid;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          subgrids = [];
          _context.n = 1;
          return tiff.getImageCount();
        case 1:
          subGridCount = _context.v;
          subgridIndex = subGridCount - 1;
        case 2:
          if (!(subgridIndex >= 0)) {
            _context.n = 6;
            break;
          }
          _context.n = 3;
          return tiff.getImage(subgridIndex);
        case 3:
          image = _context.v;
          _context.n = 4;
          return image.readRasters();
        case 4:
          rasters = _context.v;
          data = rasters;
          lim = [image.getWidth(), image.getHeight()];
          imageBBoxRadians = image.getBoundingBox().map(degreesToRadians);
          del = [image.fileDirectory.ModelPixelScale[0], image.fileDirectory.ModelPixelScale[1]].map(degreesToRadians);
          maxX = imageBBoxRadians[0] + (lim[0] - 1) * del[0];
          minY = imageBBoxRadians[3] - (lim[1] - 1) * del[1];
          latitudeOffsetBand = data[0];
          longitudeOffsetBand = data[1];
          nodes = [];
          for (i = lim[1] - 1; i >= 0; i--) {
            for (j = lim[0] - 1; j >= 0; j--) {
              index = i * lim[0] + j;
              nodes.push([-secondsToRadians(longitudeOffsetBand[index]), secondsToRadians(latitudeOffsetBand[index])]);
            }
          }
          subgrids.push({
            del: del,
            lim: lim,
            ll: [-maxX, minY],
            cvs: nodes
          });
        case 5:
          subgridIndex--;
          _context.n = 2;
          break;
        case 6:
          tifGrid = {
            header: {
              nSubgrids: subGridCount
            },
            subgrids: subgrids
          };
          loadedNadgrids[key] = tifGrid;
          return _context.a(2, tifGrid);
      }
    }, _callee);
  }));
  return _readGeotiffGrid.apply(this, arguments);
}
;

/**
 * Given a proj4 value for nadgrids, return an array of loaded grids
 * @param {string} nadgrids A comma-separated list of grid names, optionally prefixed with '@' to indicate optional grids.
 * @returns
 */
function getNadgrids(nadgrids) {
  // Format details: http://proj.maptools.org/gen_parms.html
  if (nadgrids === undefined) {
    return null;
  }
  var grids = nadgrids.split(',');
  return grids.map(parseNadgridString);
}

/**
 * @param {string} value The nadgrid string to get information for.
 * @returns {NadgridInfo|null} An object with grid information, or null if the input is empty.
 */
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === '@';
  if (optional) {
    value = value.slice(1);
  }
  if (value === 'null') {
    return {
      name: 'null',
      mandatory: !optional,
      grid: null,
      isNull: true
    };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
}
function readSubgrids(view, header, isLittleEndian, includeErrorFields) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian, includeErrorFields);
    var lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
    // Proj4 operates on radians whereas the coordinates are in seconds in the grid
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
    var rowSize = 16;
    if (includeErrorFields === false) {
      rowSize = 8;
    }
    gridOffset += 176 + subHeader.gridNodeCount * rowSize;
  }
  return grids;
}

/**
 * @param {*} nodes
 * @returns Array<Array<number>>
 */
function mapNodes(nodes) {
  return nodes.map(function (r) {
    return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian, includeErrorFields) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  if (includeErrorFields === false) {
    gridRecordLength = 8;
  }
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian)
    };
    if (includeErrorFields !== false) {
      record.latitudeAccuracy = view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian);
      record.longitudeAccuracy = view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian);
    }
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}

/***/ }),

/***/ 4326:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ projString; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
;// ../node_modules/proj4/lib/constants/PrimeMeridian.js
var primeMeridian = {};
primeMeridian.greenwich = 0.0; // "0dE",
primeMeridian.lisbon = -9.131906111111; // "9d07'54.862\"W",
primeMeridian.paris = 2.337229166667; // "2d20'14.025\"E",
primeMeridian.bogota = -74.080916666667; // "74d04'51.3\"W",
primeMeridian.madrid = -3.687938888889; // "3d41'16.58\"W",
primeMeridian.rome = 12.452333333333; // "12d27'8.4\"E",
primeMeridian.bern = 7.439583333333; // "7d26'22.5\"E",
primeMeridian.jakarta = 106.807719444444; // "106d48'27.79\"E",
primeMeridian.ferro = -17.666666666667; // "17d40'W",
primeMeridian.brussels = 4.367975; // "4d22'4.71\"E",
primeMeridian.stockholm = 18.058277777778; // "18d3'29.8\"E",
primeMeridian.athens = 23.7163375; // "23d42'58.815\"E",
primeMeridian.oslo = 10.722916666667; // "10d43'22.5\"E"

/* harmony default export */ var PrimeMeridian = (primeMeridian);
;// ../node_modules/proj4/lib/constants/units.js
/* harmony default export */ var constants_units = ({
  mm: {
    to_meter: 0.001
  },
  cm: {
    to_meter: 0.01
  },
  ft: {
    to_meter: 0.3048
  },
  'us-ft': {
    to_meter: 1200 / 3937
  },
  fath: {
    to_meter: 1.8288
  },
  kmi: {
    to_meter: 1852
  },
  'us-ch': {
    to_meter: 20.1168402336805
  },
  'us-mi': {
    to_meter: 1609.34721869444
  },
  km: {
    to_meter: 1000
  },
  'ind-ft': {
    to_meter: 0.30479841
  },
  'ind-yd': {
    to_meter: 0.91439523
  },
  mi: {
    to_meter: 1609.344
  },
  yd: {
    to_meter: 0.9144
  },
  ch: {
    to_meter: 20.1168
  },
  link: {
    to_meter: 0.201168
  },
  dm: {
    to_meter: 0.1
  },
  in: {
    to_meter: 0.0254
  },
  'ind-ch': {
    to_meter: 20.11669506
  },
  'us-in': {
    to_meter: 0.025400050800101
  },
  'us-yd': {
    to_meter: 0.914401828803658
  }
});
// EXTERNAL MODULE: ../node_modules/proj4/lib/match.js
var match = __webpack_require__(7575);
;// ../node_modules/proj4/lib/projString.js





/**
 * @param {string} defData
 * @returns {import('./defs').ProjectionDefinition}
 */
/* harmony default export */ function projString(defData) {
  /** @type {import('./defs').ProjectionDefinition} */
  var self = {};
  var paramObj = defData.split('+').map(function (v) {
    return v.trim();
  }).filter(function (a) {
    return a;
  }).reduce(function (p, a) {
    /** @type {Array<?>} */
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function rf(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function lat_0(v) {
      self.lat0 = v * values/* D2R */.zq;
    },
    lat_1: function lat_1(v) {
      self.lat1 = v * values/* D2R */.zq;
    },
    lat_2: function lat_2(v) {
      self.lat2 = v * values/* D2R */.zq;
    },
    lat_ts: function lat_ts(v) {
      self.lat_ts = v * values/* D2R */.zq;
    },
    lon_0: function lon_0(v) {
      self.long0 = v * values/* D2R */.zq;
    },
    lon_1: function lon_1(v) {
      self.long1 = v * values/* D2R */.zq;
    },
    lon_2: function lon_2(v) {
      self.long2 = v * values/* D2R */.zq;
    },
    alpha: function alpha(v) {
      self.alpha = parseFloat(v) * values/* D2R */.zq;
    },
    gamma: function gamma(v) {
      self.rectified_grid_angle = parseFloat(v) * values/* D2R */.zq;
    },
    lonc: function lonc(v) {
      self.longc = v * values/* D2R */.zq;
    },
    x_0: function x_0(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function y_0(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function k_0(v) {
      self.k0 = parseFloat(v);
    },
    k: function k(v) {
      self.k0 = parseFloat(v);
    },
    a: function a(v) {
      self.a = parseFloat(v);
    },
    b: function b(v) {
      self.b = parseFloat(v);
    },
    r: function r(v) {
      self.a = self.b = parseFloat(v);
    },
    r_a: function r_a() {
      self.R_A = true;
    },
    zone: function zone(v) {
      self.zone = parseInt(v, 10);
    },
    south: function south() {
      self.utmSouth = true;
    },
    towgs84: function towgs84(v) {
      self.datum_params = v.split(',').map(function (a) {
        return parseFloat(a);
      });
    },
    to_meter: function to_meter(v) {
      self.to_meter = parseFloat(v);
    },
    units: function units(v) {
      self.units = v;
      var unit = (0,match/* default */.A)(constants_units, v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function from_greenwich(v) {
      self.from_greenwich = v * values/* D2R */.zq;
    },
    pm: function pm(v) {
      var pm = (0,match/* default */.A)(PrimeMeridian, v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * values/* D2R */.zq;
    },
    nadgrids: function nadgrids(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      } else {
        self.nadgrids = v;
      }
    },
    axis: function axis(v) {
      var legalAxis = 'ewnsud';
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    },
    approx: function approx() {
      self.approx = true;
    },
    over: function over() {
      self.over = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      } else {
        self[paramOutname] = paramVal;
      }
    } else {
      self[paramName] = paramVal;
    }
  }
  if (typeof self.datumCode === 'string' && self.datumCode !== 'WGS84') {
    self.datumCode = self.datumCode.toLowerCase();
  }
  self['projStr'] = defData;
  return self;
}

/***/ }),

/***/ 7272:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cx: function() { return /* binding */ getNormalizedProjName; }
/* harmony export */ });
/* unused harmony exports add, get, start */
/* harmony import */ var _projections_merc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9402);
/* harmony import */ var _projections_longlat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2308);


/** @type {Array<Partial<import('./Proj').default>>} */
var projs = [_projections_merc__WEBPACK_IMPORTED_MODULE_0__["default"], _projections_longlat__WEBPACK_IMPORTED_MODULE_1__["default"]];
var names = {};
var projStore = [];

/**
 * @param {import('./Proj').default} proj
 * @param {number} i
 */
function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function (n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}
function getNormalizedProjName(n) {
  return n.replace(/[-\(\)\s]+/g, ' ').trim().replace(/ /g, '_');
}

/**
 * Get a projection by name.
 * @param {string} name
 * @returns {import('./Proj').default|false}
 */
function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
  n = getNormalizedProjName(n);
  if (n in names && projStore[names[n]]) {
    return projStore[names[n]];
  }
}
function start() {
  projs.forEach(add);
}
/* harmony default export */ __webpack_exports__.Ay = ({
  start: start,
  add: add,
  get: get
});

/***/ }),

/***/ 4894:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; },
/* harmony export */   phi1z: function() { return /* binding */ phi1z; }
/* harmony export */ });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7072);
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5964);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6269);
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8597);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7000);






/**
 * @typedef {Object} LocalThis
 * @property {number} temp
 * @property {number} es
 * @property {number} e3
 * @property {number} sin_po
 * @property {number} cos_po
 * @property {number} t1
 * @property {number} con
 * @property {number} ms1
 * @property {number} qs1
 * @property {number} t2
 * @property {number} ms2
 * @property {number} qs2
 * @property {number} t3
 * @property {number} qs0
 * @property {number} ns0
 * @property {number} c
 * @property {number} rh
 * @property {number} sin_phi
 * @property {number} cos_phi
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e3, this.sin_po, this.cos_po);
  this.qs1 = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e3, this.sin_po, this.cos_po);
  this.qs2 = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  ------------------------------------------------------------------- */
/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(lon - this.long0, this.over);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(theta / this.ns0 + this.long0, this.over);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
------------------------------------------- */
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(0.5 * qs);
  if (eccent < _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names = ['Albers_Conic_Equal_Area', 'Albers_Equal_Area', 'Albers', 'aea'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  phi1z: phi1z
});

/***/ }),

/***/ 6014:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ aeqd; },
  forward: function() { return /* binding */ forward; },
  init: function() { return /* binding */ init; },
  inverse: function() { return /* binding */ inverse; },
  names: function() { return /* binding */ names; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/common/adjust_lon.js
var adjust_lon = __webpack_require__(6269);
// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/mlfn.js
var mlfn = __webpack_require__(1417);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/e0fn.js
var e0fn = __webpack_require__(1341);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/e1fn.js
var e1fn = __webpack_require__(7954);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/e2fn.js
var e2fn = __webpack_require__(3611);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/e3fn.js
var e3fn = __webpack_require__(4280);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/asinz.js
var asinz = __webpack_require__(8597);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/imlfn.js
var imlfn = __webpack_require__(364);
;// ../node_modules/proj4/lib/common/vincenty.js
/**
 * Calculates the inverse geodesic problem using Vincenty's formulae.
 * Computes the forward azimuth and ellipsoidal distance between two points
 * specified by latitude and longitude on the surface of an ellipsoid.
 *
 * @param {number} lat1 Latitude of the first point in radians.
 * @param {number} lon1 Longitude of the first point in radians.
 * @param {number} lat2 Latitude of the second point in radians.
 * @param {number} lon2 Longitude of the second point in radians.
 * @param {number} a Semi-major axis of the ellipsoid (meters).
 * @param {number} f Flattening of the ellipsoid.
 * @returns {{ azi1: number, s12: number }} An object containing:
 *   - azi1: Forward azimuth from the first point to the second point (radians).
 *   - s12: Ellipsoidal distance between the two points (meters).
 */
function vincentyInverse(lat1, lon1, lat2, lon2, a, f) {
  var L = lon2 - lon1;
  var U1 = Math.atan((1 - f) * Math.tan(lat1));
  var U2 = Math.atan((1 - f) * Math.tan(lat2));
  var sinU1 = Math.sin(U1),
    cosU1 = Math.cos(U1);
  var sinU2 = Math.sin(U2),
    cosU2 = Math.cos(U2);
  var lambda = L,
    lambdaP,
    iterLimit = 100;
  var sinLambda, cosLambda, sinSigma, cosSigma, sigma, sinAlpha, cos2Alpha, cos2SigmaM, C;
  var uSq, A, B, deltaSigma, s;
  do {
    sinLambda = Math.sin(lambda);
    cosLambda = Math.cos(lambda);
    sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
    if (sinSigma === 0) {
      return {
        azi1: 0,
        s12: 0
      }; // coincident points
    }
    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
    sigma = Math.atan2(sinSigma, cosSigma);
    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
    cos2Alpha = 1 - sinAlpha * sinAlpha;
    cos2SigmaM = cos2Alpha !== 0 ? cosSigma - 2 * sinU1 * sinU2 / cos2Alpha : 0;
    C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
    lambdaP = lambda;
    lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return {
      azi1: NaN,
      s12: NaN
    }; // formula failed to converge
  }
  uSq = cos2Alpha * (a * a - a * (1 - f) * (a * (1 - f))) / (a * (1 - f) * (a * (1 - f)));
  A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
  s = a * (1 - f) * A * (sigma - deltaSigma);

  // Forward azimuth
  var azi1 = Math.atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
  return {
    azi1: azi1,
    s12: s
  };
}

/**
 * Solves the direct geodetic problem using Vincenty's formulae.
 * Given a starting point, initial azimuth, and distance, computes the destination point on the ellipsoid.
 *
 * @param {number} lat1 Latitude of the starting point in radians.
 * @param {number} lon1 Longitude of the starting point in radians.
 * @param {number} azi1 Initial azimuth (forward azimuth) in radians.
 * @param {number} s12 Distance to travel from the starting point in meters.
 * @param {number} a Semi-major axis of the ellipsoid in meters.
 * @param {number} f Flattening of the ellipsoid.
 * @returns {{lat2: number, lon2: number}} The latitude and longitude (in radians) of the destination point.
 */
function vincentyDirect(lat1, lon1, azi1, s12, a, f) {
  var U1 = Math.atan((1 - f) * Math.tan(lat1));
  var sinU1 = Math.sin(U1),
    cosU1 = Math.cos(U1);
  var sinAlpha1 = Math.sin(azi1),
    cosAlpha1 = Math.cos(azi1);
  var sigma1 = Math.atan2(sinU1, cosU1 * cosAlpha1);
  var sinAlpha = cosU1 * sinAlpha1;
  var cos2Alpha = 1 - sinAlpha * sinAlpha;
  var uSq = cos2Alpha * (a * a - a * (1 - f) * (a * (1 - f))) / (a * (1 - f) * (a * (1 - f)));
  var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
  var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
  var sigma = s12 / (a * (1 - f) * A),
    sigmaP,
    iterLimit = 100;
  var cos2SigmaM, sinSigma, cosSigma, deltaSigma;
  do {
    cos2SigmaM = Math.cos(2 * sigma1 + sigma);
    sinSigma = Math.sin(sigma);
    cosSigma = Math.cos(sigma);
    deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    sigmaP = sigma;
    sigma = s12 / (a * (1 - f) * A) + deltaSigma;
  } while (Math.abs(sigma - sigmaP) > 1e-12 && --iterLimit > 0);
  if (iterLimit === 0) {
    return {
      lat2: NaN,
      lon2: NaN
    };
  }
  var tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;
  var lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));
  var lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);
  var C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
  var L = lambda - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
  var lon2 = lon1 + L;
  return {
    lat2: lat2,
    lon2: lon2
  };
}
;// ../node_modules/proj4/lib/projections/aeqd.js











/**
 * @typedef {Object} LocalThis
 * @property {number} es
 * @property {number} sin_p12
 * @property {number} cos_p12
 * @property {number} a
 * @property {number} f
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
  // flattening for ellipsoid
  this.f = this.es / (1 + Math.sqrt(1 - this.es));
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = (0,adjust_lon/* default */.A)(lon - this.long0, this.over);
  var e0, e1, e2, e3, Mlp, Ml, c, kp, cos_c, vars, azi1;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= values/* EPSLN */.H0) {
      // North Pole case
      p.x = this.x0 + this.a * (values/* HALF_PI */.sK - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (values/* HALF_PI */.sK - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= values/* EPSLN */.H0) {
      // South Pole case
      p.x = this.x0 + this.a * (values/* HALF_PI */.sK + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (values/* HALF_PI */.sK + lat) * Math.cos(dlon);
      return p;
    } else {
      // default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = (0,e0fn/* default */.A)(this.es);
    e1 = (0,e1fn/* default */.A)(this.es);
    e2 = (0,e2fn/* default */.A)(this.es);
    e3 = (0,e3fn/* default */.A)(this.es);
    if (Math.abs(this.sin_p12 - 1) <= values/* EPSLN */.H0) {
      // North Pole case
      Mlp = this.a * (0,mlfn/* default */.A)(e0, e1, e2, e3, values/* HALF_PI */.sK);
      Ml = this.a * (0,mlfn/* default */.A)(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= values/* EPSLN */.H0) {
      // South Pole case
      Mlp = this.a * (0,mlfn/* default */.A)(e0, e1, e2, e3, values/* HALF_PI */.sK);
      Ml = this.a * (0,mlfn/* default */.A)(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      // Default case
      if (Math.abs(lon) < values/* EPSLN */.H0 && Math.abs(lat - this.lat0) < values/* EPSLN */.H0) {
        p.x = p.y = 0;
        return p;
      }
      vars = vincentyInverse(this.lat0, this.long0, lat, lon, this.a, this.f);
      azi1 = vars.azi1;
      p.x = vars.s12 * Math.sin(azi1);
      p.y = vars.s12 * Math.cos(azi1);
      return p;
    }
  }
}
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, azi1, s12, vars;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > 2 * values/* HALF_PI */.sK * this.a) {
      return;
    }
    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= values/* EPSLN */.H0) {
      lat = this.lat0;
    } else {
      lat = (0,asinz/* default */.A)(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - values/* HALF_PI */.sK;
      if (Math.abs(con) <= values/* EPSLN */.H0) {
        if (this.lat0 >= 0) {
          lon = (0,adjust_lon/* default */.A)(this.long0 + Math.atan2(p.x, -p.y), this.over);
        } else {
          lon = (0,adjust_lon/* default */.A)(this.long0 - Math.atan2(-p.x, p.y), this.over);
        }
      } else {
        lon = (0,adjust_lon/* default */.A)(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz), this.over);
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = (0,e0fn/* default */.A)(this.es);
    e1 = (0,e1fn/* default */.A)(this.es);
    e2 = (0,e2fn/* default */.A)(this.es);
    e3 = (0,e3fn/* default */.A)(this.es);
    if (Math.abs(this.sin_p12 - 1) <= values/* EPSLN */.H0) {
      // North pole case
      Mlp = this.a * (0,mlfn/* default */.A)(e0, e1, e2, e3, values/* HALF_PI */.sK);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = (0,imlfn/* default */.A)(M / this.a, e0, e1, e2, e3);
      lon = (0,adjust_lon/* default */.A)(this.long0 + Math.atan2(p.x, -1 * p.y), this.over);
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= values/* EPSLN */.H0) {
      // South pole case
      Mlp = this.a * (0,mlfn/* default */.A)(e0, e1, e2, e3, values/* HALF_PI */.sK);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;
      lat = (0,imlfn/* default */.A)(M / this.a, e0, e1, e2, e3);
      lon = (0,adjust_lon/* default */.A)(this.long0 + Math.atan2(p.x, p.y), this.over);
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      // default case
      azi1 = Math.atan2(p.x, p.y);
      s12 = Math.sqrt(p.x * p.x + p.y * p.y);
      vars = vincentyDirect(this.lat0, this.long0, azi1, s12, this.a, this.f);
      p.x = vars.lon2;
      p.y = vars.lat2;
      return p;
    }
  }
}
var names = ['Azimuthal_Equidistant', 'aeqd'];
/* harmony default export */ var aeqd = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 9265:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6165);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6269);
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4424);
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6194);
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3712);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7000);








/**
 * @typedef {Object} LocalThis
 * @property {number} phi1
 * @property {number} cphi1
 * @property {number} es
 * @property {Array<number>} en
 * @property {number} m1
 * @property {number} am1
 */

var EPS10 = 1e-10;

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  var c;
  this.phi1 = this.lat1;
  if (Math.abs(this.phi1) < EPS10) {
    throw new Error();
  }
  if (this.es) {
    this.en = (0,_common_pj_enfn__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.es);
    this.m1 = (0,_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.phi1, this.am1 = Math.sin(this.phi1), c = Math.cos(this.phi1), this.en);
    this.am1 = c / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1);
    this.inverse = e_inv;
    this.forward = e_fwd;
  } else {
    if (Math.abs(this.phi1) + EPS10 >= _constants_values__WEBPACK_IMPORTED_MODULE_6__/* .HALF_PI */ .sK) {
      this.cphi1 = 0;
    } else {
      this.cphi1 = 1 / Math.tan(this.phi1);
    }
    this.inverse = s_inv;
    this.forward = s_fwd;
  }
}
function e_fwd(p) {
  var lam = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(p.x - (this.long0 || 0), this.over);
  var phi = p.y;
  var rh, E, c;
  rh = this.am1 + this.m1 - (0,_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(phi, E = Math.sin(phi), c = Math.cos(phi), this.en);
  E = c * lam / (rh * Math.sqrt(1 - this.es * E * E));
  p.x = rh * Math.sin(E);
  p.y = this.am1 - rh * Math.cos(E);
  p.x = this.a * p.x + (this.x0 || 0);
  p.y = this.a * p.y + (this.y0 || 0);
  return p;
}
function e_inv(p) {
  p.x = (p.x - (this.x0 || 0)) / this.a;
  p.y = (p.y - (this.y0 || 0)) / this.a;
  var s, rh, lam, phi;
  rh = (0,_common_hypot__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(p.x, p.y = this.am1 - p.y);
  phi = (0,_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.am1 + this.m1 - rh, this.es, this.en);
  if ((s = Math.abs(phi)) < _constants_values__WEBPACK_IMPORTED_MODULE_6__/* .HALF_PI */ .sK) {
    s = Math.sin(phi);
    lam = rh * Math.atan2(p.x, p.y) * Math.sqrt(1 - this.es * s * s) / Math.cos(phi);
  } else if (Math.abs(s - _constants_values__WEBPACK_IMPORTED_MODULE_6__/* .HALF_PI */ .sK) <= EPS10) {
    lam = 0;
  } else {
    throw new Error();
  }
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lam + (this.long0 || 0), this.over);
  p.y = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(phi);
  return p;
}
function s_fwd(p) {
  var lam = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(p.x - (this.long0 || 0), this.over);
  var phi = p.y;
  var E, rh;
  rh = this.cphi1 + this.phi1 - phi;
  if (Math.abs(rh) > EPS10) {
    p.x = rh * Math.sin(E = lam * Math.cos(phi) / rh);
    p.y = this.cphi1 - rh * Math.cos(E);
  } else {
    p.x = p.y = 0;
  }
  p.x = this.a * p.x + (this.x0 || 0);
  p.y = this.a * p.y + (this.y0 || 0);
  return p;
}
function s_inv(p) {
  p.x = (p.x - (this.x0 || 0)) / this.a;
  p.y = (p.y - (this.y0 || 0)) / this.a;
  var lam, phi;
  var rh = (0,_common_hypot__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(p.x, p.y = this.cphi1 - p.y);
  phi = this.cphi1 + this.phi1 - rh;
  if (Math.abs(phi) > _constants_values__WEBPACK_IMPORTED_MODULE_6__/* .HALF_PI */ .sK) {
    throw new Error();
  }
  if (Math.abs(Math.abs(phi) - _constants_values__WEBPACK_IMPORTED_MODULE_6__/* .HALF_PI */ .sK) <= EPS10) {
    lam = 0;
  } else {
    lam = rh * Math.atan2(p.x, p.y) / Math.cos(phi);
  }
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lam + (this.long0 || 0), this.over);
  p.y = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(phi);
  return p;
}
var names = ['bonne', 'Bonne (Werner lat_1=90)'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  names: names
});

/***/ }),

/***/ 3245:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1417);
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1341);
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7954);
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3611);
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4280);
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2889);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6269);
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6165);
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(364);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7000);











/**
 * @typedef {Object} LocalThis
 * @property {number} es
 * @property {number} e0
 * @property {number} e1
 * @property {number} e2
 * @property {number} e3
 * @property {number} ml0
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  if (!this.sphere) {
    this.e0 = (0,_common_e0fn__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.es);
    this.e1 = (0,_common_e1fn__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.es);
    this.e2 = (0,_common_e2fn__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.es);
    this.e3 = (0,_common_e3fn__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.es);
    this.ml0 = this.a * (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  ----------------------------------------------------------------------- */
function forward(p) {
  /* Forward equations
      ----------------- */
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(lam - this.long0, this.over);
  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    // ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = (0,_common_gN__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  ----------------- */
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = (0,_common_imlfn__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - _constants_values__WEBPACK_IMPORTED_MODULE_9__/* .HALF_PI */ .sK) <= _constants_values__WEBPACK_IMPORTED_MODULE_9__/* .EPSLN */ .H0) {
      p.x = this.long0;
      p.y = _constants_values__WEBPACK_IMPORTED_MODULE_9__/* .HALF_PI */ .sK;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = (0,_common_gN__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(lam + this.long0, this.over);
  p.y = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(phi);
  return p;
}
var names = ['Cassini', 'Cassini_Soldner', 'cass'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 8104:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ cea; },
  forward: function() { return /* binding */ forward; },
  init: function() { return /* binding */ init; },
  inverse: function() { return /* binding */ inverse; },
  names: function() { return /* binding */ names; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/common/adjust_lon.js
var adjust_lon = __webpack_require__(6269);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/qsfnz.js
var qsfnz = __webpack_require__(5964);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/msfnz.js
var msfnz = __webpack_require__(7072);
// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
;// ../node_modules/proj4/lib/common/iqsfnz.js

/* harmony default export */ function iqsfnz(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return -1 * values/* HALF_PI */.sK;
    } else {
      return values/* HALF_PI */.sK;
    }
  }
  // var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  // console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
}
;// ../node_modules/proj4/lib/projections/cea.js





/**
 * @typedef {Object} LocalThis
 * @property {number} e
 */

/**
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
  @this {import('../defs.js').ProjectionDefinition & LocalThis}
*/
function init() {
  // no-op
  if (!this.sphere) {
    this.k0 = (0,msfnz/* default */.A)(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------ */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      ----------------- */
  var dlon = (0,adjust_lon/* default */.A)(lon - this.long0, this.over);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = (0,qsfnz/* default */.A)(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------ */
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = (0,adjust_lon/* default */.A)(this.long0 + p.x / this.a / Math.cos(this.lat_ts), this.over);
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = (0,adjust_lon/* default */.A)(this.long0 + p.x / (this.a * this.k0), this.over);
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['cea'];
/* harmony default export */ var cea = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 780:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6165);


function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || 'Equidistant Cylindrical (Plate Carre)';
  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  var dlat = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var x = p.x;
  var y = p.y;
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + (x - this.x0) / (this.a * this.rc), this.over);
  p.y = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var names = ['Equirectangular', 'Equidistant_Cylindrical', 'Equidistant_Cylindrical_Spherical', 'eqc'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 7724:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1341);
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7954);
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3611);
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4280);
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7072);
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1417);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6269);
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6165);
/* harmony import */ var _common_imlfn__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(364);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(7000);











/**
 * @typedef {Object} LocalThis
 * @property {number} temp
 * @property {number} es
 * @property {number} e
 * @property {number} e0
 * @property {number} e1
 * @property {number} e2
 * @property {number} e3
 * @property {number} sin_phi
 * @property {number} cos_phi
 * @property {number} ms1
 * @property {number} ml1
 * @property {number} ms2
 * @property {number} ml2
 * @property {number} ns
 * @property {number} g
 * @property {number} ml0
 * @property {number} rh
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  /* Place parameters in static storage for common use
      ------------------------------------------------- */
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__/* .EPSLN */ .H0) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = (0,_common_e0fn__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.es);
  this.e1 = (0,_common_e1fn__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.es);
  this.e2 = (0,_common_e2fn__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.es);
  this.e3 = (0,_common_e3fn__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.es);
  this.sin_phi = Math.sin(this.lat1);
  this.cos_phi = Math.cos(this.lat1);
  this.ms1 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.e, this.sin_phi, this.cos_phi);
  this.ml1 = (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_9__/* .EPSLN */ .H0) {
    this.ns = this.sin_phi;
  } else {
    this.sin_phi = Math.sin(this.lat2);
    this.cos_phi = Math.cos(this.lat2);
    this.ms2 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.e, this.sin_phi, this.cos_phi);
    this.ml2 = (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  ----------------------------------------------------------- */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      ----------------- */
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(lon - this.long0, this.over);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  ----------------- */
function inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  if (this.sphere) {
    lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(this.long0 + theta / this.ns, this.over);
    lat = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A)(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = (0,_common_imlfn__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(ml, this.e0, this.e1, this.e2, this.e3);
    lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(this.long0 + theta / this.ns, this.over);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var names = ['Equidistant_Conic', 'eqdc'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 8197:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/**
 * Copyright 2018 Bernie Jenny, Monash University, Melbourne, Australia.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Equal Earth is a projection inspired by the Robinson projection, but unlike
 * the Robinson projection retains the relative size of areas. The projection
 * was designed in 2018 by Bojan Savric, Tom Patterson and Bernhard Jenny.
 *
 * Publication:
 * Bojan Savric, Tom Patterson & Bernhard Jenny (2018). The Equal Earth map
 * projection, International Journal of Geographical Information Science,
 * DOI: 10.1080/13658816.2018.1504949
 *
 * Code released August 2018
 * Ported to JavaScript and adapted for mapshaper-proj by Matthew Bloch August 2018
 * Modified for proj4js by Andreas Hocevar by Andreas Hocevar March 2024
 */


var A1 = 1.340264,
  A2 = -0.081106,
  A3 = 0.000893,
  A4 = 0.003796,
  M = Math.sqrt(3) / 2.0;
function init() {
  this.es = 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
}
function forward(p) {
  var lam = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(p.x - this.long0, this.over);
  var phi = p.y;
  var paramLat = Math.asin(M * Math.sin(phi)),
    paramLatSq = paramLat * paramLat,
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p.x = lam * Math.cos(paramLat) / (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)));
  p.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq));
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse(p) {
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  var EPS = 1e-9,
    NITER = 12,
    paramLat = p.y,
    paramLatSq,
    paramLatPow6,
    fy,
    fpy,
    dlat,
    i;
  for (i = 0; i < NITER; ++i) {
    paramLatSq = paramLat * paramLat;
    paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
    fy = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)) - p.y;
    fpy = A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq);
    paramLat -= dlat = fy / fpy;
    if (Math.abs(dlat) < EPS) {
      break;
    }
  }
  paramLatSq = paramLat * paramLat;
  paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
  p.x = M * p.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat);
  p.y = Math.asin(Math.sin(paramLat) / M);
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(p.x + this.long0, this.over);
  return p;
}
var names = ['eqearth', 'Equal Earth', 'Equal_Earth'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 63:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);


/**
 * @typedef {Object} LocalThis
 * @property {number} t1
 * @property {number} t2
 */

/** @this {import('../defs.js').ProjectionDefinition} */
function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  /// this.t2;
}

/**
 * Equirectangular forward equations--mapping lat,long to x,y
 * @this {import('../defs.js').ProjectionDefinition & LocalThis}
 */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  var x = this.x0 + this.a * dlon * Math.cos(this.lat0);
  var y = this.y0 + this.a * lat;
  this.t1 = x;
  this.t2 = Math.cos(this.lat0);
  p.x = x;
  p.y = y;
  return p;
}

/* Equirectangular inverse equations--mapping x,y to lat/long
  --------------------------------------------------------- */
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lat = p.y / this.a;
  var lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + p.x / (this.a * Math.cos(this.lat0)), this.over);
  p.x = lon;
  p.y = lat;
}
var names = ['equi'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 3426:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ etmerc; },
  forward: function() { return /* binding */ forward; },
  init: function() { return /* binding */ init; },
  inverse: function() { return /* binding */ inverse; },
  names: function() { return /* binding */ names; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/tmerc.js
var tmerc = __webpack_require__(5518);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/sinh.js
var sinh = __webpack_require__(7897);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/hypot.js
var hypot = __webpack_require__(4424);
;// ../node_modules/proj4/lib/common/log1py.js
/* harmony default export */ function log1py(x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
}
;// ../node_modules/proj4/lib/common/asinhy.js


/* harmony default export */ function asinhy(x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / ((0,hypot/* default */.A)(1, y) + 1)));
  return x < 0 ? -y : y;
}
;// ../node_modules/proj4/lib/common/gatg.js
/* harmony default export */ function gatg(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;
  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }
  return B + h * Math.sin(2 * B);
}
;// ../node_modules/proj4/lib/common/clens.js
/* harmony default export */ function clens(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/cosh.js
var cosh = __webpack_require__(6449);
;// ../node_modules/proj4/lib/common/clens_cmplx.js


/* harmony default export */ function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = (0,sinh/* default */.A)(arg_i);
  var cosh_arg_i = (0,cosh/* default */.A)(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }
  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/adjust_lon.js
var adjust_lon = __webpack_require__(6269);
;// ../node_modules/proj4/lib/projections/etmerc.js
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js










/**
 * @typedef {Object} LocalThis
 * @property {number} es
 * @property {Array<number>} cbg
 * @property {Array<number>} cgb
 * @property {Array<number>} utg
 * @property {Array<number>} gtu
 * @property {number} Qn
 * @property {number} Zb
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    // When '+approx' is set, use tmerc instead
    tmerc["default"].init.apply(this);
    this.forward = tmerc["default"].forward;
    this.inverse = tmerc["default"].inverse;
  }
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
}
function forward(p) {
  var Ce = (0,adjust_lon/* default */.A)(p.x - this.long0, this.over);
  var Cn = p.y;
  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, (0,hypot/* default */.A)(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));
  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;
  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan((0,sinh/* default */.A)(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, (0,hypot/* default */.A)(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = (0,adjust_lon/* default */.A)(Ce + this.long0, this.over);
    lat = gatg(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Extended_Transverse_Mercator', 'Extended Transverse Mercator', 'etmerc', 'Transverse_Mercator', 'Transverse Mercator', 'Gauss Kruger', 'Gauss_Kruger', 'tmerc'];
/* harmony default export */ var etmerc = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 4025:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ gauss; },
  forward: function() { return /* binding */ forward; },
  init: function() { return /* binding */ init; },
  inverse: function() { return /* binding */ inverse; },
  names: function() { return /* binding */ names; }
});

;// ../node_modules/proj4/lib/common/srat.js
/* harmony default export */ function srat(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
;// ../node_modules/proj4/lib/projections/gauss.js

var MAX_ITER = 20;


/**
 * @typedef {Object} LocalThis
 * @property {number} rc
 * @property {number} C
 * @property {number} phic0
 * @property {number} ratexp
 * @property {number} K
 * @property {number} e
 * @property {number} es
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + values/* FORTPI */.Vj) / (Math.pow(Math.tan(0.5 * this.lat0 + values/* FORTPI */.Vj), this.C) * srat(this.e * sphi, this.ratexp));
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + values/* FORTPI */.Vj), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - values/* HALF_PI */.sK;
  p.x = this.C * lon;
  return p;
}
function inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + values/* FORTPI */.Vj) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -0.5 * this.e)) - values/* HALF_PI */.sK;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['gauss'];
/* harmony default export */ var gauss = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 5904:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _datumUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3356);

function init() {
  this.name = 'geocent';
}
function forward(p) {
  var point = (0,_datumUtils__WEBPACK_IMPORTED_MODULE_0__/* .geodeticToGeocentric */ .jX)(p, this.es, this.a);
  return point;
}
function inverse(p) {
  var point = (0,_datumUtils__WEBPACK_IMPORTED_MODULE_0__/* .geocentricToGeodetic */ .Rw)(p, this.es, this.a, this.b);
  return point;
}
var names = ['Geocentric', 'geocentric', 'geocent', 'Geocent'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 1017:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4424);


/**
 * @typedef {Object} LocalThis
 * @property {1 | 0} flip_axis
 * @property {number} h
 * @property {number} radius_g_1
 * @property {number} radius_g
 * @property {number} radius_p
 * @property {number} radius_p2
 * @property {number} radius_p_inv2
 * @property {'ellipse'|'sphere'} shape
 * @property {number} C
 * @property {string} sweep
 * @property {number} es
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  this.flip_axis = this.sweep === 'x' ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1.0 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1.0;
  if (this.es !== 0.0) {
    var one_es = 1.0 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
  } else {
    this.radius_p = 1.0;
    this.radius_p2 = 1.0;
    this.radius_p_inv2 = 1.0;
    this.shape = 'sphere'; // Use as a condition in the forward and inverse functions.
  }
  if (!this.title) {
    this.title = 'Geostationary Satellite View';
  }
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === 'ellipse') {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r = this.radius_p / (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r * Math.cos(lon) * Math.cos(lat);
    v_y = r * Math.sin(lon) * Math.cos(lat);
    v_z = r * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0.0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(v_y, tmp));
    }
  } else if (this.shape === 'sphere') {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(v_y, tmp));
    }
  }
  p.x = p.x * this.a;
  p.y = p.y * this.a;
  return p;
}
function inverse(p) {
  var v_x = -1.0;
  var v_y = 0.0;
  var v_z = 0.0;
  var a, b, det, k;
  p.x = p.x / this.a;
  p.y = p.y / this.a;
  if (this.shape === 'ellipse') {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(1.0, v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * (0,_common_hypot__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(1.0, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0.0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2.0 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
  } else if (this.shape === 'sphere') {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
    }
    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0.0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2.0 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
  }
  p.x = p.x + this.long0;
  return p;
}
var names = ['Geostationary Satellite View', 'Geostationary_Satellite', 'geos'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 5106:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8597);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7000);




/**
 * @typedef {Object} LocalThis
 * @property {number} sin_p14
 * @property {number} cos_p14
 * @property {number} infinity_dist
 * @property {number} rc
 */

/**
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
   @this {import('../defs.js').ProjectionDefinition & LocalThis}
 */
function init() {
  /* Place parameters in static storage for common use
      ------------------------------------------------- */
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    --------------------------------------------------- */
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      ----------------- */
  dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__/* .EPSLN */ .H0) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      ----------------- */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + lon, this.over);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['gnom'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 6500:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ gstmerc; },
  forward: function() { return /* binding */ forward; },
  init: function() { return /* binding */ init; },
  inverse: function() { return /* binding */ inverse; },
  names: function() { return /* binding */ names; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
;// ../node_modules/proj4/lib/common/latiso.js

/* harmony default export */ function latiso(eccent, phi, sinphi) {
  if (Math.abs(phi) > values/* HALF_PI */.sK) {
    return Number.NaN;
  }
  if (phi === values/* HALF_PI */.sK) {
    return Number.POSITIVE_INFINITY;
  }
  if (phi === -1 * values/* HALF_PI */.sK) {
    return Number.NEGATIVE_INFINITY;
  }
  var con = eccent * sinphi;
  return Math.log(Math.tan((values/* HALF_PI */.sK + phi) / 2)) + eccent * Math.log((1 - con) / (1 + con)) / 2;
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/sinh.js
var sinh = __webpack_require__(7897);
// EXTERNAL MODULE: ../node_modules/proj4/lib/common/cosh.js
var cosh = __webpack_require__(6449);
;// ../node_modules/proj4/lib/common/fL.js

/* harmony default export */ function fL(x, L) {
  return 2 * Math.atan(x * Math.exp(L)) - values/* HALF_PI */.sK;
}
;// ../node_modules/proj4/lib/common/invlatiso.js

/* harmony default export */ function invlatiso(eccent, ts) {
  var phi = fL(1, ts);
  var Iphi = 0;
  var con = 0;
  do {
    Iphi = phi;
    con = eccent * Math.sin(Iphi);
    phi = fL(Math.exp(eccent * Math.log((1 + con) / (1 - con)) / 2), ts);
  } while (Math.abs(phi - Iphi) > 1.0e-12);
  return phi;
}
;// ../node_modules/proj4/lib/projections/gstmerc.js





/**
 * @typedef {Object} LocalThis
 * @property {number} e
 * @property {number} lc
 * @property {number} rs
 * @property {number} cp
 * @property {number} n2
 * @property {number} xs
 * @property {number} ys
*/

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  // array of:  a, b, lon0, lat0, k0, x0, y0
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  this.lc = this.long0;
  this.rs = Math.sqrt(1 + this.e * this.e * Math.pow(Math.cos(this.lat0), 4) / (1 - this.e * this.e));
  var sinz = Math.sin(this.lat0);
  var pc = Math.asin(sinz / this.rs);
  var sinzpc = Math.sin(pc);
  this.cp = latiso(0, pc, sinzpc) - this.rs * latiso(this.e, this.lat0, sinz);
  this.n2 = this.k0 * this.a * Math.sqrt(1 - this.e * this.e) / (1 - this.e * this.e * sinz * sinz);
  this.xs = this.x0;
  this.ys = this.y0 - this.n2 * pc;
  if (!this.title) {
    this.title = 'Gauss Schreiber transverse mercator';
  }
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var L = this.rs * (lon - this.lc);
  var Ls = this.cp + this.rs * latiso(this.e, lat, Math.sin(lat));
  var lat1 = Math.asin(Math.sin(L) / (0,cosh/* default */.A)(Ls));
  var Ls1 = latiso(0, lat1, Math.sin(lat1));
  p.x = this.xs + this.n2 * Ls1;
  p.y = this.ys + this.n2 * Math.atan((0,sinh/* default */.A)(Ls) / Math.cos(L));
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var x = p.x;
  var y = p.y;
  var L = Math.atan((0,sinh/* default */.A)((x - this.xs) / this.n2) / Math.cos((y - this.ys) / this.n2));
  var lat1 = Math.asin(Math.sin((y - this.ys) / this.n2) / (0,cosh/* default */.A)((x - this.xs) / this.n2));
  var LC = latiso(0, lat1, Math.sin(lat1));
  p.x = this.lc + L / this.rs;
  p.y = invlatiso(this.e, (LC - this.cp) / this.rs);
  return p;
}
var names = ['gstmerg', 'gstmerc'];
/* harmony default export */ var gstmerc = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 6167:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);

function init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  /* Transformation */
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return p;
}

/* calculate lat/lon from xy */
function inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x */
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p;
}
var names = ['Krovak', 'krovak'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 8506:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EQUIT: function() { return /* binding */ EQUIT; },
/* harmony export */   N_POLE: function() { return /* binding */ N_POLE; },
/* harmony export */   OBLIQ: function() { return /* binding */ OBLIQ; },
/* harmony export */   S_POLE: function() { return /* binding */ S_POLE; },
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
/* harmony import */ var _common_qsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5964);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6269);




/**
 * @typedef {Object} LocalThis
 * @property {number} mode
 * @property {Array<number>} apa
 * @property {number} dd
 * @property {number} e
 * @property {number} es
 * @property {number} mmf
 * @property {number} rq
 * @property {number} qp
 * @property {number} sinb1
 * @property {number} cosb1
 * @property {number} ymf
 * @property {number} xmf
 * @property {number} sinph0
 * @property {number} cosph0
 */

/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;
var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/**
 * Initialize the Lambert Azimuthal Equal Area projection
 * @this {import('../defs.js').ProjectionDefinition & LocalThis}
 */
function init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    this.mode = this.lat0 < 0 ? S_POLE : N_POLE;
  } else if (Math.abs(t) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    this.mode = EQUIT;
  } else {
    this.mode = OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case N_POLE:
        this.dd = 1;
        break;
      case S_POLE:
        this.dd = 1;
        break;
      case EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  ----------------------------------------------------------------------- */
function forward(p) {
  /* Forward equations
      ----------------- */
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(lam - this.long0, this.over);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
        return null;
      }
      y = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = (0,_common_qsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
        q = this.qp + q;
        break;
    }
    if (Math.abs(b) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }
        break;
    }
  }
  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  ----------------- */
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh,
      sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0 ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0 ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - phi;
        break;
      case this.S_POLE:
        phi -= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
        break;
    }
    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = x * x + y * y;
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.long0 + lam, this.over);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;
var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;
function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}
function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}
var names = ['Lambert Azimuthal Equal Area', 'Lambert_Azimuthal_Equal_Area', 'laea'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});

/***/ }),

/***/ 993:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7072);
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(851);
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9393);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6269);
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6157);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7000);







/**
 * @typedef {Object} LocalThis
 * @property {number} e
 * @property {number} ns
 * @property {number} f0
 * @property {number} rh
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  // double lat0;                    /* the reference latitude               */
  // double long0;                   /* the reference longitude              */
  // double lat1;                    /* first standard parallel              */
  // double lat2;                    /* second standard parallel             */
  // double r_maj;                   /* major axis                           */
  // double r_min;                   /* minor axis                           */
  // double false_east;              /* x offset in meters                   */
  // double false_north;             /* y offset in meters                   */

  // the above value can be set with proj4.defs
  // example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } // if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, sin1, cos1);
  var ts1 = (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, sin2, cos2);
  var ts2 = (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, this.lat2, sin2);
  var ts0 = Math.abs(Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .HALF_PI */ .sK) < _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0 ? 0 // Handle poles by setting ts0 to 0
  : (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = 'Lambert Conformal Conic';
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0) {
    lat = (0,_common_sign__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(lat) * (_constants_values__WEBPACK_IMPORTED_MODULE_5__/* .HALF_PI */ .sK - 2 * _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0);
  }
  var con = Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .HALF_PI */ .sK);
  var ts, rh1;
  if (con > _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0) {
    ts = (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(lon - this.long0, this.over);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = (0,_common_phi2z__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -_constants_values__WEBPACK_IMPORTED_MODULE_5__/* .HALF_PI */ .sK;
  }
  lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(theta / this.ns + this.long0, this.over);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Lambert Tangential Conformal Conic Projection', 'Lambert_Conformal_Conic', 'Lambert_Conformal_Conic_1SP', 'Lambert_Conformal_Conic_2SP', 'lcc', 'Lambert Conic Conformal (1SP)', 'Lambert Conic Conformal (2SP)'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 2308:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ identity; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ identity; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
function init() {
  // no-op for longlat
}
function identity(pt) {
  return pt;
}


var names = ['longlat', 'identity'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: identity,
  inverse: identity,
  names: names
});

/***/ }),

/***/ 9402:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7072);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6269);
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(851);
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6157);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7000);






/**
 * @typedef {Object} LocalThis
 * @property {number} es
 * @property {number} e
 * @property {number} k
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!('x0' in this)) {
    this.x0 = 0;
  }
  if (!('y0' in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  -------------------------------------------------- */

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .R2D */ .dX > 90 && lat * _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .R2D */ .dX < -90 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .R2D */ .dX > 180 && lon * _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .R2D */ .dX < -180) {
    return null;
  }
  var x, y;
  if (Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .HALF_PI */ .sK) <= _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lon - this.long0, this.over);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_4__/* .FORTPI */ .Vj + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lon - this.long0, this.over);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  -------------------------------------------------- */
function inverse(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .HALF_PI */ .sK - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = (0,_common_phi2z__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.long0 + x / (this.a * this.k0), this.over);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Mercator', 'Popular Visualisation Pseudo Mercator', 'Mercator_1SP', 'Mercator_Auxiliary_Sphere', 'Mercator_Variant_A', 'merc'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 969:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

/* Initialize the Miller Cylindrical projection
  ------------------------------------------- */
function init() {
  // no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------ */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      ----------------- */
  var dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------ */
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + p.x / this.a, this.over);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Miller_Cylindrical', 'mill'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 6155:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7000);



/** @this {import('../defs.js').ProjectionDefinition} */
function init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
}

/* Mollweide forward equations--mapping lat,long to x,y
    ---------------------------------------------------- */
function forward(p) {
  /* Forward equations
      ----------------- */
  var lon = p.x;
  var lat = p.y;
  var delta_lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      ----------------------------------------------------- */
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       -------------------------------------------------------------------------- */
  if (Math.PI / 2 - Math.abs(lat) < _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      ----------------- */
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       ------------------------------------------------------------------- */
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)), this.over);
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Mollweide', 'moll'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 6731:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   iterations: function() { return /* binding */ iterations; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;
function init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SEC_TO_RAD */ ._3 * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + d_phi * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SEC_TO_RAD */ ._3 * 1E5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['New_Zealand_Map_Grid', 'nzmg'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 4076:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7000);
/* harmony import */ var _Proj__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1845);
/* harmony import */ var _longlat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2308);
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }





/**
    Original projection implementation:
        https://github.com/OSGeo/PROJ/blob/46c47e9adf6376ae06afabe5d24a0016a05ced82/src/projections/ob_tran.cpp

    Documentation:
        https://proj.org/operations/projections/ob_tran.html

    References/Formulas:
        https://pubs.usgs.gov/pp/1395/report.pdf

    Examples:
        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90
        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90 +lon_0=60
        +proj=ob_tran +o_proj=moll +o_lat_p=45 +o_lon_p=-90 +lon_0=-90
*/

var projectionType = {
  OBLIQUE: {
    forward: forwardOblique,
    inverse: inverseOblique
  },
  TRANSVERSE: {
    forward: forwardTransverse,
    inverse: inverseTransverse
  }
};

/**
 * @typedef {Object} LocalThis
 * @property {number} lamp
 * @property {number} cphip
 * @property {number} sphip
 * @property {Object} projectionType
 * @property {string | undefined} o_proj
 * @property {string | undefined} o_lon_p
 * @property {string | undefined} o_lat_p
 * @property {string | undefined} o_alpha
 * @property {string | undefined} o_lon_c
 * @property {string | undefined} o_lat_c
 * @property {string | undefined} o_lon_1
 * @property {string | undefined} o_lat_1
 * @property {string | undefined} o_lon_2
 * @property {string | undefined} o_lat_2
 * @property {number | undefined} oLongP
 * @property {number | undefined} oLatP
 * @property {number | undefined} oAlpha
 * @property {number | undefined} oLongC
 * @property {number | undefined} oLatC
 * @property {number | undefined} oLong1
 * @property {number | undefined} oLat1
 * @property {number | undefined} oLong2
 * @property {number | undefined} oLat2
 * @property {boolean} isIdentity
 * @property {import('..').Converter} obliqueProjection
 *
 */

/**
 *    Parameters can be from the following sets:
 *       New pole --> o_lat_p, o_lon_p
 *       Rotate about point --> o_alpha, o_lon_c, o_lat_c
 *       New equator points --> lon_1, lat_1, lon_2, lat_2
 *
 *    Per the original source code, the parameter sets are
 *    checked in the order of the object below.
 */
var paramSets = {
  ROTATE: {
    o_alpha: 'oAlpha',
    o_lon_c: 'oLongC',
    o_lat_c: 'oLatC'
  },
  NEW_POLE: {
    o_lat_p: 'oLatP',
    o_lon_p: 'oLongP'
  },
  NEW_EQUATOR: {
    o_lon_1: 'oLong1',
    o_lat_1: 'oLat1',
    o_lon_2: 'oLong2',
    o_lat_2: 'oLat2'
  }
};

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  var _this = this;
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.title = this.title || 'General Oblique Transformation';
  this.isIdentity = _longlat__WEBPACK_IMPORTED_MODULE_3__.names.includes(this.o_proj);

  /** Verify required parameters exist */
  if (!this.o_proj) {
    throw new Error('Missing parameter: o_proj');
  }
  if (this.o_proj === "ob_tran") {
    throw new Error('Invalid value for o_proj: ' + this.o_proj);
  }
  var newProjStr = this.projStr.replace('+proj=ob_tran', '').replace('+o_proj=', '+proj=').trim();

  /** @type {import('../defs.js').ProjectionDefinition} */
  var oProj = (0,_Proj__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(newProjStr);
  if (!oProj) {
    throw new Error('Invalid parameter: o_proj. Unknown projection ' + this.o_proj);
  }
  oProj.long0 = 0; // we handle long0 before/after forward/inverse
  this.obliqueProjection = oProj;
  var matchedSet;
  var paramSetsKeys = Object.keys(paramSets);

  /**
   * parse strings, convert to radians, throw on NaN
   * @param {string} name
   * @returns {number | undefined}
   */
  var parseParam = function parseParam(name) {
    if (_typeof(_this[name]) === "undefined") {
      return undefined;
    }
    var val = parseFloat(_this[name]) * _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .D2R */ .zq;
    if (isNaN(val)) {
      throw new Error('Invalid value for ' + name + ': ' + _this[name]);
    }
    return val;
  };
  for (var i = 0; i < paramSetsKeys.length; i++) {
    var setKey = paramSetsKeys[i];
    var set = paramSets[setKey];
    var params = Object.entries(set);
    var setHasParams = params.some(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 1),
        p = _ref2[0];
      return typeof _this[p] !== 'undefined';
    });
    if (!setHasParams) {
      continue;
    }
    matchedSet = set;
    for (var ii = 0; ii < params.length; ii++) {
      var _params$ii = _slicedToArray(params[ii], 2),
        inputParam = _params$ii[0],
        param = _params$ii[1];
      var val = parseParam(inputParam);
      if (typeof val === 'undefined') {
        throw new Error('Missing parameter: ' + inputParam + '.');
      }
      this[param] = val;
    }
    break;
  }
  if (!matchedSet) {
    throw new Error('No valid parameters provided for ob_tran projection.');
  }
  var _createRotation = createRotation(this, matchedSet),
    lamp = _createRotation.lamp,
    phip = _createRotation.phip;
  this.lamp = lamp;
  if (Math.abs(phip) > _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
    this.cphip = Math.cos(phip);
    this.sphip = Math.sin(phip);
    this.projectionType = projectionType.OBLIQUE;
  } else {
    this.projectionType = projectionType.TRANSVERSE;
  }
}

// ob_tran forward equations--mapping (lat,long) to (x,y)
// transverse (90 degrees from normal orientation) - forwardTransverse
// or oblique (arbitrary angle) used based on parameters - forwardOblique
// -----------------------------------------------------------------
/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function forward(p) {
  return this.projectionType.forward(this, p);
}

// inverse equations--mapping (x,y) to (lat,long)
// transverse: inverseTransverse
// oblique: inverseOblique
// -----------------------------------------------------------------
/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function inverse(p) {
  return this.projectionType.inverse(this, p);
}

/**
 * @param {import('../defs.js').ProjectionDefinition & LocalThis} params - Initialized projection definition
 * @param {Object} how - Transformation method
 * @returns {{phip: number, lamp: number}}
 */
function createRotation(params, how) {
  var phip, lamp;
  if (how === paramSets.ROTATE) {
    var lamc = params.oLongC;
    var phic = params.oLatC;
    var alpha = params.oAlpha;
    if (Math.abs(Math.abs(phic) - _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .HALF_PI */ .sK) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      throw new Error('Invalid value for o_lat_c: ' + params.o_lat_c + ' should be < 90');
    }
    lamp = lamc + Math.atan2(-1 * Math.cos(alpha), -1 * Math.sin(alpha) * Math.sin(phic));
    phip = Math.asin(Math.cos(phic) * Math.sin(alpha));
  } else if (how === paramSets.NEW_POLE) {
    lamp = params.oLongP;
    phip = params.oLatP;
  } else {
    var lam1 = params.oLong1;
    var phi1 = params.oLat1;
    var lam2 = params.oLong2;
    var phi2 = params.oLat2;
    var con = Math.abs(phi1);
    if (Math.abs(phi1) > _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .HALF_PI */ .sK - _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      throw new Error('Invalid value for o_lat_1: ' + params.o_lat_1 + ' should be < 90');
    }
    if (Math.abs(phi2) > _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .HALF_PI */ .sK - _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      throw new Error('Invalid value for o_lat_2: ' + params.o_lat_2 + ' should be < 90');
    }
    if (Math.abs(phi1 - phi2) < _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      throw new Error('Invalid value for o_lat_1 and o_lat_2: o_lat_1 should be different from o_lat_2');
    }
    if (con < _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
      throw new Error('Invalid value for o_lat_1: o_lat_1 should be different from zero');
    }
    lamp = Math.atan2(Math.cos(phi1) * Math.sin(phi2) * Math.cos(lam1) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(lam2), Math.sin(phi1) * Math.cos(phi2) * Math.sin(lam2) - Math.cos(phi1) * Math.sin(phi2) * Math.sin(lam1));
    phip = Math.atan(-1 * Math.cos(lamp - lam1) / Math.tan(phi1));
  }
  return {
    lamp: lamp,
    phip: phip
  };
}

/**
 * Forward (lng, lat) to (x, y) for oblique case
 * @param {import('../defs.js').ProjectionDefinition & LocalThis} self
 * @param {{x: number, y: number}} lp - lambda, phi
 */
function forwardOblique(self, lp) {
  var lam = lp.x,
    phi = lp.y;
  lam += self.long0;
  var coslam = Math.cos(lam);
  var sinphi = Math.sin(phi);
  var cosphi = Math.cos(phi);
  lp.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(Math.atan2(cosphi * Math.sin(lam), self.sphip * cosphi * coslam + self.cphip * sinphi) + self.lamp);
  lp.y = Math.asin(self.sphip * sinphi - self.cphip * cosphi * coslam);
  var result = self.obliqueProjection.forward(lp);
  if (self.isIdentity) {
    result.x *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .R2D */ .dX;
    result.y *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .R2D */ .dX;
  }
  return result;
}

/**
 * Forward (lng, lat) to (x, y) for transverse case
 * @param {import('../defs.js').ProjectionDefinition & LocalThis} self
 * @param {{x: number, y: number}} lp - lambda, phi
 */
function forwardTransverse(self, lp) {
  var lam = lp.x,
    phi = lp.y;
  lam += self.long0;
  var cosphi = Math.cos(phi);
  var coslam = Math.cos(lam);
  lp.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(Math.atan2(cosphi * Math.sin(lam), Math.sin(phi)) + self.lamp);
  lp.y = Math.asin(-1 * cosphi * coslam);
  var result = self.obliqueProjection.forward(lp);
  if (self.isIdentity) {
    result.x *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .R2D */ .dX;
    result.y *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .R2D */ .dX;
  }
  return result;
}

/**
 * Inverse (x, y) to (lng, lat) for oblique case
 * @param {import('../defs.js').ProjectionDefinition & LocalThis} self
 * @param {{x: number, y: number}} lp - lambda, phi
 */
function inverseOblique(self, lp) {
  if (self.isIdentity) {
    lp.x *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .D2R */ .zq;
    lp.y *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .D2R */ .zq;
  }
  var innerLp = self.obliqueProjection.inverse(lp);
  var lam = innerLp.x,
    phi = innerLp.y;
  if (lam < Number.MAX_VALUE) {
    lam -= self.lamp;
    var coslam = Math.cos(lam);
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    lp.x = Math.atan2(cosphi * Math.sin(lam), self.sphip * cosphi * coslam - self.cphip * sinphi);
    lp.y = Math.asin(self.sphip * sinphi + self.cphip * cosphi * coslam);
  }
  lp.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lp.x + self.long0);
  return lp;
}

/**
 * Inverse (x, y) to (lng, lat) for transverse case
 * @param {import('../defs.js').ProjectionDefinition & LocalThis} self
 * @param {{x: number, y: number}} lp - lambda, phi
 */
function inverseTransverse(self, lp) {
  if (self.isIdentity) {
    lp.x *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .D2R */ .zq;
    lp.y *= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .D2R */ .zq;
  }
  var innerLp = self.obliqueProjection.inverse(lp);
  var lam = innerLp.x,
    phi = innerLp.y;
  if (lam < Number.MAX_VALUE) {
    var cosphi = Math.cos(phi);
    lam -= self.lamp;
    lp.x = Math.atan2(cosphi * Math.sin(lam), -1 * Math.sin(phi));
    lp.y = Math.asin(cosphi * Math.cos(lam));
  }
  lp.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lp.x + self.long0);
  return lp;
}
var names = ['General Oblique Transformation', 'General_Oblique_Transformation', 'ob_tran'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 431:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(851);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6269);
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6157);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7000);
/* harmony import */ var _projections__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7272);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }






/**
 * @typedef {Object} LocalThis
 * @property {boolean} no_off
 * @property {boolean} no_rot
 * @property {number} rectified_grid_angle
 * @property {number} es
 * @property {number} A
 * @property {number} B
 * @property {number} E
 * @property {number} e
 * @property {number} lam0
 * @property {number} singam
 * @property {number} cosgam
 * @property {number} sinrot
 * @property {number} cosrot
 * @property {number} rB
 * @property {number} ArB
 * @property {number} BrA
 * @property {number} u_0
 * @property {number} v_pole_n
 * @property {number} v_pole_s
 */

var TOL = 1e-7;
function isTypeA(P) {
  var typeAProjections = ['Hotine_Oblique_Mercator', 'Hotine_Oblique_Mercator_variant_A', 'Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
  var projectionName = _typeof(P.projName) === 'object' ? Object.keys(P.projName)[0] : P.projName;
  return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1 || typeAProjections.indexOf((0,_projections__WEBPACK_IMPORTED_MODULE_4__/* .getNormalizedProjName */ .Cx)(projectionName)) !== -1;
}

/**
 * Initialize the Oblique Mercator  projection
 * @this {import('../defs.js').ProjectionDefinition & LocalThis}
 */
function init() {
  var con,
    com,
    cosph0,
    D,
    F,
    H,
    L,
    sinph0,
    p,
    J,
    gamma = 0,
    gamma0,
    lamc = 0,
    lam1 = 0,
    lam2 = 0,
    phi1 = 0,
    phi2 = 0,
    alpha_c = 0;

  // only Type A uses the no_off or no_uoff property
  // https://github.com/OSGeo/proj.4/issues/104
  this.no_off = isTypeA(this);
  this.no_rot = 'no_rot' in this;
  var alp = false;
  if ('alpha' in this) {
    alp = true;
  }
  var gam = false;
  if ('rectified_grid_angle' in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .HALF_PI */ .sK) <= TOL || Math.abs(Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .HALF_PI */ .sK) <= TOL || Math.abs(Math.abs(phi2) - _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .HALF_PI */ .sK) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1.0 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .EPSLN */ .H0) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D - 1;
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    this.E = F += D;
    this.E *= Math.pow((0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow((0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow((0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    if (con < -Math.PI) {
      lam2 -= _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .TWO_PI */ .JM;
    } else if (con > Math.PI) {
      lam2 += _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .TWO_PI */ .JM;
    }
    this.lam0 = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B, this.over);
    gamma0 = Math.atan(2 * Math.sin(this.B * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lam1 - this.lam0, this.over)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_3__/* .FORTPI */ .Vj - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(_constants_values__WEBPACK_IMPORTED_MODULE_3__/* .FORTPI */ .Vj + F));
}

/* Oblique Mercator forward equations--mapping lat,long to x,y
    ---------------------------------------------------------- */
function forward(p) {
  var coords = {};
  var S, T, U, V, W, temp, u, v;
  p.x = p.x - this.lam0;
  if (Math.abs(Math.abs(p.y) - _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .HALF_PI */ .sK) > _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .EPSLN */ .H0) {
    W = this.E / Math.pow((0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.e, p.y, Math.sin(p.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V = Math.sin(this.B * p.x);
    U = (S * this.singam - V * this.cosgam) / T;
    if (Math.abs(Math.abs(U) - 1.0) < _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .EPSLN */ .H0) {
      throw new Error();
    }
    v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p.x);
    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2(S * this.cosgam + V * this.singam, temp);
    }
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }
  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p.x = (p.x - this.x0) * (1.0 / this.a);
  p.y = (p.y - this.y0) * (1.0 / this.a);
  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .EPSLN */ .H0) {
    coords.x = 0;
    coords.y = Up < 0 ? -_constants_values__WEBPACK_IMPORTED_MODULE_3__/* .HALF_PI */ .sK : _constants_values__WEBPACK_IMPORTED_MODULE_3__/* .HALF_PI */ .sK;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = (0,_common_phi2z__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
  }
  coords.x += this.lam0;
  return coords;
}
var names = ['Hotine_Oblique_Mercator', 'Hotine Oblique Mercator', 'Hotine_Oblique_Mercator_variant_A', 'Hotine_Oblique_Mercator_Variant_B', 'Hotine_Oblique_Mercator_Azimuth_Natural_Origin', 'Hotine_Oblique_Mercator_Two_Point_Natural_Origin', 'Hotine_Oblique_Mercator_Azimuth_Center', 'Oblique_Mercator', 'omerc'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 6145:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8597);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7000);




/**
 * @typedef {Object} LocalThis
 * @property {number} sin_p14
 * @property {number} cos_p14
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  // double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      ------------------------------------------------- */
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    --------------------------------------------------- */
function forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      ----------------- */
  dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__/* .EPSLN */ .H0) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      ----------------- */
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;
  if (Math.abs(rh) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__/* .EPSLN */ .H0) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_2__/* .HALF_PI */ .sK;
  if (Math.abs(con) <= _constants_values__WEBPACK_IMPORTED_MODULE_2__/* .EPSLN */ .H0) {
    if (this.lat0 >= 0) {
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + Math.atan2(p.x, -p.y), this.over);
    } else {
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 - Math.atan2(-p.x, p.y), this.over);
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz), this.over);
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['ortho'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 741:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_e0fn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1341);
/* harmony import */ var _common_e1fn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7954);
/* harmony import */ var _common_e2fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3611);
/* harmony import */ var _common_e3fn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4280);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6269);
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6165);
/* harmony import */ var _common_mlfn__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1417);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7000);
/* harmony import */ var _common_gN__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(2889);










/**
 * @typedef {Object} LocalThis
 * @property {number} temp
 * @property {number} es
 * @property {number} e
 * @property {number} e0
 * @property {number} e1
 * @property {number} e2
 * @property {number} e3
 * @property {number} ml0
 */

var MAX_ITER = 20;

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  /* Place parameters in static storage for common use
      ------------------------------------------------- */
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = (0,_common_e0fn__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.es);
  this.e1 = (0,_common_e1fn__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.es);
  this.e2 = (0,_common_e2fn__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.es);
  this.e3 = (0,_common_e3fn__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.es);
  this.ml0 = this.a * (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, this.lat0); // si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    --------------------------------------------------- */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(lon - this.long0, this.over);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__/* .EPSLN */ .H0) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * ((0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__/* .EPSLN */ .H0) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = (0,_common_gN__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  ----------------- */
function inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__/* .EPSLN */ .H0) {
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(x / this.a + this.long0, this.over);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__/* .EPSLN */ .H0) {
          lat = phi;
          break;
        }
      }
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat), this.over);
    }
  } else {
    if (Math.abs(y + this.ml0) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__/* .EPSLN */ .H0) {
      lat = 0;
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.long0 + x / this.a, this.over);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * (0,_common_mlfn__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= _constants_values__WEBPACK_IMPORTED_MODULE_7__/* .EPSLN */ .H0) {
          lat = phi;
          break;
        }
      }

      // lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat), this.over);
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Polyconic', 'American_Polyconic', 'poly'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 2513:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/**
 * @typedef {Object} LocalThis
 * @property {number} face
 * @property {number} x0
 * @property {number} y0
 * @property {number} es
 * @property {number} one_minus_f
 * @property {number} one_minus_f_squared
 */

/* constants */
var FACE_ENUM = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
};
var AREA_ENUM = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || 'Quadrilateralized Spherical Cube';

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function forward(p) {
  var xy = {
    x: 0,
    y: 0
  };
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {
    value: 0
  };

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {
    // if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; // lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - lat;
    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else if (lon > _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj || lon <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0.0 ? lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF : lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
    } else if (lon > -(_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) && lon <= -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + lat;
    if (lon >= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj && lon <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else if (lon < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj && lon >= -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj && lon >= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0.0 ? -lon + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF : -lon - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan(12 / _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF * (theta + Math.acos(Math.sin(theta) * Math.cos(_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function inverse(p) {
  var lp = {
    lam: 0,
    phi: 0
  };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {
    value: 0
  };

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0.0 ? mu + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF : mu - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0.0 ? theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF : theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else /* area.value == AREA_ENUM.AREA_3 */{
        lp.lam = theta;
      }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else /* area.value == AREA_ENUM.AREA_3 */{
        lp.lam = theta < 0.0 ? -theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF : -theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
      }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj && theta <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj) {
      area.value = AREA_ENUM.AREA_1;
      theta -= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    } else if (theta > _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj || theta <= -(_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .FORTPI */ .Vj)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0.0 ? theta - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF : theta + _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF) {
    slon += _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .TWO_PI */ .JM;
  } else if (slon > +_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .SPI */ .DF) {
    slon -= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .TWO_PI */ .JM;
  }
  return slon;
}
var names = ['Quadrilateralized Spherical Cube', 'Quadrilateralized_Spherical_Cube', 'qsc'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 8067:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6269);
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039



var COEFS_X = [[1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06], [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06], [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07], [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06], [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06], [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08], [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06], [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06], [0.9216, -0.00467746, -0.00010457, 4.81243e-06], [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06], [0.8679, -0.00609363, -0.000113898, 3.32484e-06], [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07], [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07], [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06], [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06], [0.6732, -0.00986209, -0.000199569, 1.91974e-05], [0.6213, -0.010418, 8.83923e-05, 6.24051e-06], [0.5722, -0.00906601, 0.000182, 6.24051e-06], [0.5322, -0.00677797, 0.000275608, 6.24051e-06]];
var COEFS_Y = [[-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11], [0.0620, 0.0124, -1.26793e-09, 4.22642e-10], [0.1240, 0.0124, 5.07171e-09, -1.60604e-09], [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09], [0.2480, 0.0124002, 7.10039e-08, -2.24e-08], [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08], [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07], [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07], [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07], [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07], [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07], [0.6769, 0.011713, -3.20223e-05, -5.16405e-07], [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07], [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06], [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09], [0.8936, 0.00969686, -6.4636e-05, -8.547e-06], [0.9394, 0.00840947, -0.000192841, -4.2106e-06], [0.9761, 0.00616527, -0.000256, -4.2106e-06], [1.0000, 0.00328947, -0.000319159, -4.2106e-06]];
var FXC = 0.8487;
var FYC = 1.3523;
var C1 = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .R2D */ .dX / 5; // rad to 5-degree interval
var RC1 = 1 / C1;
var NODES = 18;
var poly3_val = function poly3_val(coefs, x) {
  return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};
var poly3_der = function poly3_der(coefs, x) {
  return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};
function newton_rapshon(f_df, start, max_err, iters) {
  var x = start;
  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x;
}
function init() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || 'Robinson';
}
function forward(ll) {
  var lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(ll.x - this.long0, this.over);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .R2D */ .dX * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    // pathologic case
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK : _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
  } else {
    // find table interval
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (;;) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    // linear interpolation in 5 degree interval
    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    // find t so that poly3_val(coefs, t) = ll.y
    t = newton_rapshon(function (x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .D2R */ .zq;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(ll.x + this.long0, this.over);
  return ll;
}
var names = ['Robinson', 'robin'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 1034:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6165);
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6194);
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3712);
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7000);
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8597);



var MAX_ITER = 20;





/**
 * @typedef {Object} LocalThis
 * @property {Array<number>} en
 * @property {number} n
 * @property {number} m
 * @property {number} C_y
 * @property {number} C_x
 * @property {number} es
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  /* Place parameters in static storage for common use
    ------------------------------------------------- */

  if (!this.sphere) {
    this.en = (0,_common_pj_enfn__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}

/* Sinusoidal forward equations--mapping lat,long to x,y
  ----------------------------------------------------- */
function forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    ----------------- */
  lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * (0,_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A)(Math.sin(lat) / this.n);
    }
    lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon + this.long0, this.over);
    lat = (0,_common_adjust_lat__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lat);
  } else {
    lat = (0,_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .HALF_PI */ .sK) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      // temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(temp, this.over);
    } else if (s - _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .EPSLN */ .H0 < _constants_values__WEBPACK_IMPORTED_MODULE_5__/* .HALF_PI */ .sK) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Sinusoidal', 'sinu'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 9872:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme  axe oblique et pour la transformation entre
    des systmes de rfrence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

/**
 * @typedef {Object} LocalThis
 * @property {number} lambda0
 * @property {number} e
 * @property {number} R
 * @property {number} b0
 * @property {number} K
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      // ...reportError("omercFwdInfinity");
      return;
    }
    // S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }
  p.x = lambda;
  p.y = phy;
  return p;
}
var names = ['somerc'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 3084:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; },
/* harmony export */   ssfn_: function() { return /* binding */ ssfn_; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9393);
/* harmony import */ var _common_msfnz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7072);
/* harmony import */ var _common_tsfnz__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(851);
/* harmony import */ var _common_phi2z__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6157);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6269);







/**
 * @typedef {Object} LocalThis
 * @property {number} coslat0
 * @property {number} sinlat0
 * @property {number} ms1
 * @property {number} X0
 * @property {number} cosX0
 * @property {number} sinX0
 * @property {number} con
 * @property {number} cons
 * @property {number} e
 */

function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  // setting default parameters
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      this.k0 = 0.5 * (1 + (0,_common_sign__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      if (this.lat0 > 0) {
        // North pole
        // trace('stere:north pole');
        this.con = 1;
      } else {
        // South pole
        // trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0 && Math.abs(Math.cos(this.lat_ts)) > _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      // When k0 is 1 (default value) and lat_ts is a vaild number and lat0 is at a pole and lat_ts is not at a pole
      // Recalculate k0 using formula 21-35 from p161 of Snyder, 1987
      this.k0 = 0.5 * this.cons * (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = (0,_common_msfnz__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(ssfn_(this.lat0, this.sinlat0, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(lon - this.long0, this.over);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0 && Math.abs(lat + this.lat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    // case of the origine point
    // trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    // trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(ssfn_(lat, sinlat, this.e)) - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      ts = (0,_common_tsfnz__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      // trace(p.toString());
      return p;
    } else if (Math.abs(this.sinlat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      // Eq
      // trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    } else {
      // other case
      // trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  // trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      if (this.lat0 > 0) {
        lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.long0 + Math.atan2(p.x, -1 * p.y), this.over);
      } else {
        lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.long0 + Math.atan2(p.x, p.y), this.over);
      }
    } else {
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)), this.over);
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        // trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * (0,_common_phi2z__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.e, ts);
      lon = this.con * (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.con * this.long0 + Math.atan2(p.x, -1 * p.y), this.over);
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)), this.over);
      }
      lat = -1 * (0,_common_phi2z__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A)(this.e, Math.tan(0.5 * (_constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  // trace(p.toString());
  return p;
}
var names = ['stere', 'Stereographic_South_Pole', 'Polar_Stereographic_variant_A', 'Polar_Stereographic_variant_B', 'Polar_Stereographic'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names,
  ssfn_: ssfn_
});

/***/ }),

/***/ 6789:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _gauss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4025);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6269);
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4424);




/**
 * @typedef {Object} LocalThis
 * @property {number} sinc0
 * @property {number} cosc0
 * @property {number} R2
 * @property {number} rc
 * @property {number} phic0
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = 'Oblique Stereographic Alternative';
  }
}
function forward(p) {
  var sinc, cosc, cosl, k;
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(p.x - this.long0, this.over);
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rho = (0,_common_hypot__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(p.x, p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  _gauss__WEBPACK_IMPORTED_MODULE_0__["default"].inverse.apply(this, [p]);
  p.x = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(p.x + this.long0, this.over);
  return p;
}
var names = ['Stereographic_North_Pole', 'Oblique_Stereographic', 'sterea', 'Oblique Stereographic Alternative', 'Double_Stereographic'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 5518:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6194);
/* harmony import */ var _common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3712);
/* harmony import */ var _common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(112);
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6269);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7000);
/* harmony import */ var _common_sign__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9393);
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js








/**
 * @typedef {Object} LocalThis
 * @property {number} es
 * @property {Array<number>} en
 * @property {number} ml0
 */

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
  if (this.es) {
    this.en = (0,_common_pj_enfn__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.es);
    this.ml0 = (0,_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(lon - this.long0, this.over);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b) - 1) < _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);
      if (b >= 1) {
        if (b - 1 > _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }
      if (lat < 0) {
        y = -y;
      }
      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0 ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = (0,_common_pj_mlfn__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }
  p.x = x;
  p.y = y;
  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y < 0) {
      lat = -lat;
    }
    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(Math.atan2(g, h) + this.long0, this.over);
    }
  } else {
    // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = (0,_common_pj_inv_mlfn__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(con, this.es, this.en);
    if (Math.abs(phi) < _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .HALF_PI */ .sK) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .EPSLN */ .H0 ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A)(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi, this.over);
    } else {
      lat = _constants_values__WEBPACK_IMPORTED_MODULE_4__/* .HALF_PI */ .sK * (0,_common_sign__WEBPACK_IMPORTED_MODULE_5__/* ["default"] */ .A)(y);
      lon = 0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Fast_Transverse_Mercator', 'Fast Transverse Mercator'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 251:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7000);
/* harmony import */ var _common_hypot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4424);



/**
 * @typedef {Object} LocalThis
 * @property {number} mode
 * @property {number} sinph0
 * @property {number} cosph0
 * @property {number} pn1
 * @property {number} h
 * @property {number} rp
 * @property {number} p
 * @property {number} h1
 * @property {number} pfact
 * @property {number} es
 * @property {number} tilt
 * @property {number} azi
 * @property {number} cg
 * @property {number} sg
 * @property {number} cw
 * @property {number} sw
 */

var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};
var params = {
  h: {
    def: 100000,
    num: true
  },
  // default is Karman line, no default in PROJ.7
  azi: {
    def: 0,
    num: true,
    degrees: true
  },
  // default is North
  tilt: {
    def: 0,
    num: true,
    degrees: true
  },
  // default is Nadir
  long0: {
    def: 0,
    num: true
  },
  // default is Greenwich, conversion to rad is automatic
  lat0: {
    def: 0,
    num: true
  } // default is Equator, conversion to rad is automatic
};

/** @this {import('../defs.js').ProjectionDefinition & LocalThis} */
function init() {
  Object.keys(params).forEach(function (p) {
    if (typeof this[p] === 'undefined') {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error('Invalid parameter value, must be numeric ' + p + ' = ' + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (params[p].degrees) {
      this[p] = this[p] * _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .D2R */ .zq;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .HALF_PI */ .sK) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a; // Normalize relative to the Earth's radius

  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error('Invalid height');
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }

  // Tilt
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function inverse(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = {
    x: p.x,
    y: p.y
  };

  // Un-Tilt
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = (0,_common_hypot__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(p.x, p.y);
  if (Math.abs(rh) < _constants_values__WEBPACK_IMPORTED_MODULE_0__/* .EPSLN */ .H0) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }
  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}
var names = ['Tilted_Perspective', 'tpers'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 2924:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": function() { return /* binding */ utm; },
  dependsOn: function() { return /* binding */ dependsOn; },
  init: function() { return /* binding */ init; },
  names: function() { return /* binding */ names; }
});

// EXTERNAL MODULE: ../node_modules/proj4/lib/common/adjust_lon.js
var adjust_lon = __webpack_require__(6269);
;// ../node_modules/proj4/lib/common/adjust_zone.js

/* harmony default export */ function adjust_zone(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor(((0,adjust_lon/* default */.A)(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
// EXTERNAL MODULE: ../node_modules/proj4/lib/projections/etmerc.js + 5 modules
var etmerc = __webpack_require__(3426);
// EXTERNAL MODULE: ../node_modules/proj4/lib/constants/values.js
var values = __webpack_require__(7000);
;// ../node_modules/proj4/lib/projections/utm.js


var dependsOn = 'etmerc';


/** @this {import('../defs.js').ProjectionDefinition} */
function init() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * values/* D2R */.zq;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;
  etmerc["default"].init.apply(this);
  this.forward = etmerc["default"].forward;
  this.inverse = etmerc["default"].inverse;
}
var names = ['Universal Transverse Mercator System', 'utm'];
/* harmony default export */ var utm = ({
  init: init,
  names: names,
  dependsOn: dependsOn
});

/***/ }),

/***/ 6671:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forward: function() { return /* binding */ forward; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   inverse: function() { return /* binding */ inverse; },
/* harmony export */   names: function() { return /* binding */ names; }
/* harmony export */ });
/* harmony import */ var _common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6269);
/* harmony import */ var _constants_values__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7000);
/* harmony import */ var _common_asinz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8597);




/**
 * @typedef {Object} LocalThis
 * @property {number} R - Radius of the Earth
 */

/**
 * Initialize the Van Der Grinten projection
 * @this {import('../defs.js').ProjectionDefinition & LocalThis}
 */
function init() {
  // this.R = 6370997; //Radius of earth
  this.R = this.a;
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    ----------------- */
  var dlon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(lon - this.long0, this.over);
  var x, y;
  if (Math.abs(lat) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = (0,_common_asinz__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0 || Math.abs(Math.abs(lat) - _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .HALF_PI */ .sK) <= _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  // con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    // y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  } else {
    // y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  --------------------------------------------------------- */
function inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    ----------------- */
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < _constants_values__WEBPACK_IMPORTED_MODULE_1__/* .EPSLN */ .H0) {
    lon = this.long0;
  } else {
    lon = (0,_common_adjust_lon__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx, this.over);
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names = ['Van_der_Grinten_I', 'VanDerGrinten', 'Van_der_Grinten', 'vandg'];
/* harmony default export */ __webpack_exports__["default"] = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

/***/ }),

/***/ 8695:
/***/ (function(module) {

/**
 * Common object containing all action types that are provided by the GeoJS
 * API.
 *
 * @namespace
 * @alias geo.action
 * @enum {string}
 */
var geo_action = {
  momentum: 'geo_action_momentum',
  pan: 'geo_action_pan',
  rotate: 'geo_action_rotate',
  select: 'geo_action_select',
  unzoomselect: 'geo_action_unzoomselect',
  zoom: 'geo_action_zoom',
  zoomrotate: 'geo_action_zoom_rotate',
  zoomselect: 'geo_action_zoomselect',
  // annotation actions -- some are also added by the registry
  annotation_edit_handle: 'geo_annotation_edit_handle',
  annotation_cursor: 'geo_annotation_cursor'
};
module.exports = geo_action;

/***/ }),

/***/ 6978:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var geo_event = __webpack_require__(6409);
var geo_action = __webpack_require__(8695);
var transform = __webpack_require__(5325);
var util = __webpack_require__(642);
var textFeature = __webpack_require__(6546);
var annotationId = 0;

/**
 * @alias geo.annotation.state
 * @enum {string}
 */
var annotationState = {
  create: 'create',
  done: 'done',
  highlight: 'highlight',
  edit: 'edit',
  cursor: 'cursor'
};
var annotationActionOwner = 'annotationAction';

/**
 * These styles are applied to edit handles, and can be overridden by
 * individual annotations.
 *
 * @alias geo.annotation.defaultEditHandleStyle
 * @type {object}
 * @default
 */
var defaultEditHandleStyle = {
  fill: true,
  fillColor: function fillColor(d) {
    return d.selected ? {
      r: 0,
      g: 1,
      b: 1
    } : {
      r: 0.3,
      g: 0.3,
      b: 0.3
    };
  },
  fillOpacity: function fillOpacity(d) {
    return d.selected ? 0.5 : 0.25;
  },
  radius: function radius(d) {
    return d.type === 'edge' || d.type === 'rotate' ? 8 : 10;
  },
  scaled: false,
  stroke: true,
  strokeColor: {
    r: 0,
    g: 0,
    b: 1
  },
  strokeOpacity: 1,
  strokeWidth: function strokeWidth(d) {
    return d.type === 'edge' || d.type === 'rotate' ? 2 : 3;
  },
  rotateHandleOffset: 24,
  // should be roughly twice radius + strokeWidth
  rotateHandleRotation: -Math.PI / 4,
  resizeHandleOffset: 48,
  // should be roughly twice radius + strokeWidth + rotateHandleOffset
  resizeHandleRotation: -Math.PI / 4,
  // handles may be a function to dynamically generate the results
  handles: {
    // if `false`, the handle won't be created for editing
    vertex: true,
    edge: true,
    center: true,
    rotate: true,
    resize: true
  }
};
var editHandleFeatureLevel = 3;

/**
 * General annotation specification.
 *
 * @typedef {object} geo.annotation.spec
 * @property {string} [name] A name for the annotation.  This defaults to the
 *    type with a unique ID suffixed to it.
 * @property {geo.annotationLayer} [layer] A reference to the controlling
 *    layer.  This is used for coordinate transforms.
 * @property {string} [state] Initial annotation state.  One of the
 *    {@link geo.annotation.state} values.
 * @property {boolean|string[]} [showLabel=true] `true` to show the annotation
 *    label on annotations in done or edit states.  Alternately, a list of
 *    states in which to show the label.  Falsy to not show the label.
 * @property {boolean} [allowBooleanOperations] This defaults to `true` for
 *    annotations that have area and `false` for those without area (e.g.,
 *    false for lines and points).  If it is truthy, then, when the annotation
 *    is being created, it checks the metakeys on the first click that defines
 *    a coordinate to determine what boolean polygon operation should be
 *    performaned on the completion of the annotation.
 */

/**
 * Base annotation class.
 *
 * @class
 * @alias geo.annotation
 * @param {string} type The type of annotation.  These should be registered
 *    with {@link geo.registerAnnotation} and can be listed with
 *    {@link geo.listAnnotations}.
 * @param {geo.annotation.spec?} [args] Options for the annotation.
 * @returns {geo.annotation}
 */
var _annotation = function annotation(type, args) {
  'use strict';

  if (!(this instanceof _annotation)) {
    return new _annotation(type, args);
  }
  var m_this = this,
    m_options = util.deepMerge({}, this.constructor.defaults, args || {}),
    m_id = m_options.annotationId;
  delete m_options.annotationId;
  if (m_id === undefined || m_options.layer && m_options.layer.annotationById(m_id)) {
    annotationId += 1;
    if (m_id !== undefined) {
      console.warn('Annotation id ' + m_id + ' is in use; using ' + annotationId + ' instead.'); // eslint-disable-line no-console
    }
    m_id = annotationId;
  } else {
    if (m_id > annotationId) {
      annotationId = m_id;
    }
  }
  var m_name = m_options.name || type.charAt(0).toUpperCase() + type.substr(1) + ' ' + m_id,
    m_label = m_options.label || null,
    m_description = m_options.description || undefined,
    m_type = type,
    m_layer = m_options.layer,
    /* one of annotationState.* */
    m_state = m_options.state || annotationState.done;
  delete m_options.state;
  delete m_options.layer;
  delete m_options.name;
  delete m_options.label;
  delete m_options.description;
  if (m_options.constraint) {
    if (util.isFunction(m_options.constraint)) {
      this._selectionConstraint = m_options.constraint;
    } else {
      this._selectionConstraint = constrainAspectRatio(m_options.constraint);
    }
  }

  /**
   * Clean up any resources that the annotation is using.
   */
  this._exit = function () {
    if (m_this.layer()) {
      m_this.layer().geoOff(geo_event.mousemove, m_this._cursorHandleMousemove);
    }
  };

  /**
   * Get a unique annotation id.
   *
   * @returns {number} The annotation id.
   */
  this.id = function () {
    return m_id;
  };

  /**
   * Assign a new id to this annotation.
   *
   * @returns {this}
   */
  this.newId = function () {
    annotationId += 1;
    m_id = annotationId;
    return m_this;
  };

  /**
   * Get or set the name of this annotation.
   *
   * @param {string|undefined} [arg] If `undefined`, return the name, otherwise
   *    change it.  When setting the name, the value is trimmed of
   *    whitespace.  The name will not be changed to an empty string.
   * @returns {this|string} The current name or this annotation.
   */
  this.name = function (arg) {
    if (arg === undefined) {
      return m_name;
    }
    if (arg !== null && ('' + arg).trim()) {
      arg = ('' + arg).trim();
      if (arg !== m_name) {
        m_name = arg;
        m_this.modified();
      }
    }
    return m_this;
  };

  /**
   * Get or set the label of this annotation.
   *
   * @param {string|null|undefined} [arg] If `undefined`, return the label,
   *    otherwise change it.  `null` to clear the label.
   * @param {boolean} [noFallback] If not truthy and the label is `null`,
   *    return the name, otherwise return the actual value for label.
   * @returns {this|string} The current label or this annotation.
   */
  this.label = function (arg, noFallback) {
    if (arg === undefined) {
      return m_label === null && !noFallback ? m_name : m_label;
    }
    if (arg !== m_label) {
      m_label = arg;
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Return the coordinate associated with the label.
   *
   * @returns {geo.geoPosition|undefined} The map gcs position for the label,
   *    or `undefined` if no such position exists.
   */
  this._labelPosition = function () {
    return util.centerFromPerimeter(m_this._coordinates());
  };

  /**
   * Return the coordinate associated with the rotation handle for the
   * annotation.
   *
   * @param {number} [offset] An additional offset from cetner to apply to the
   *    handle.
   * @param {number} [rotation] An additional rotation to apply to the handle.
   * @returns {geo.geoPosition|undefined} The map gcs position for the handle,
   *    or `undefined` if no such position exists.
   */
  this._rotateHandlePosition = function (offset, rotation) {
    var map = m_this.layer().map(),
      coord = m_this._coordinates(),
      center = util.centerFromPerimeter(m_this._coordinates()),
      dispCenter = center ? map.gcsToDisplay(center, null) : undefined,
      i,
      pos,
      maxr2 = 0,
      r;
    if (!center) {
      return;
    }
    offset = offset || 0;
    rotation = rotation || 0;
    coord = coord.outer ? coord.outer : coord;
    for (i = 0; i < coord.length; i += 1) {
      pos = map.gcsToDisplay(coord[i], null);
      maxr2 = Math.max(maxr2, Math.pow(pos.x - dispCenter.x, 2) + Math.pow(pos.y - dispCenter.y, 2));
    }
    r = Math.sqrt(maxr2) + offset;
    pos = map.displayToGcs({
      x: dispCenter.x + r * Math.cos(rotation),
      y: dispCenter.y - r * Math.sin(rotation)
    }, null);
    return pos;
  };

  /**
   * If the label should be shown, get a record of the label that can be used
   * in a {@link geo.textFeature}.
   *
   * @returns {geo.annotationLayer.labelRecord|undefined} A label record, or
   *    `undefined` if it should not be shown.
   */
  this.labelRecord = function () {
    var show = m_this.options('showLabel');
    if (!show) {
      return;
    }
    var state = m_this.state();
    if (show === true && state === annotationState.create || show !== true && show.indexOf(state) < 0) {
      return;
    }
    var style = m_this.labelStyle();
    var labelRecord = {
      text: m_this.label(),
      position: m_this._labelPosition()
    };
    if (!labelRecord.position) {
      return;
    }
    if (style) {
      labelRecord.style = style;
    }
    return labelRecord;
  };

  /**
   * Get or set the description of this annotation.
   *
   * @param {string|undefined} arg If `undefined`, return the description,
   *    otherwise change it.
   * @returns {this|string} The current description or this annotation.
   */
  this.description = function (arg) {
    if (arg === undefined) {
      return m_description;
    }
    if (arg !== m_description) {
      m_description = arg;
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get or set the annotation layer associated with this annotation.
   *
   * @param {geo.annotationLayer|undefined} arg if undefined, return the layer,
   *    otherwise change it.
   * @returns {this|geo.annotationLayer} the current layer or this annotation.
   */
  this.layer = function (arg) {
    if (arg === undefined) {
      return m_layer;
    }
    m_layer = arg;
    return m_this;
  };
  this._cursorHandleMousemove = function (evt) {
    m_this.layer()._handleMouseMoveModifiers(evt);
    var center = m_this._cursorCenter;
    var delta = {
      x: evt.mapgcs.x - center.x,
      y: evt.mapgcs.y - center.y
    };
    if (delta.x || delta.y) {
      var curPts = m_this._coordinates();
      var pts = m_this._coordinatesMapFunc(curPts, function (elem) {
        return {
          x: elem.x + delta.x,
          y: elem.y + delta.y
        };
      });
      m_this._coordinates(pts);
      m_this._cursorCenter = evt.mapgcs;
      m_this.modified();
      m_this.draw();
      return true;
    }
    return false;
  };

  /**
   * Get or set the state of this annotation.
   *
   * @param {string|undefined} [arg] If `undefined`, return the state,
   *    otherwise change it.  This should be one of the
   *    {@link geo.annotation.state} values.
   * @returns {this|string} The current state or this annotation.
   * @fires geo.event.annotation.state
   */
  this.state = function (arg) {
    if (arg === undefined) {
      return m_state;
    }
    if (m_state !== arg) {
      m_state = arg;
      if (m_this.layer()) {
        m_this.layer().geoTrigger(geo_event.annotation.state, {
          annotation: m_this
        });
      }
      if (m_this.layer()) {
        m_this.layer().geoOff(geo_event.mousemove, m_this._cursorHandleMousemove);
      }
      switch (m_state) {
        case annotationState.cursor:
          m_this._cursorCenter = util.centerFromPerimeter(m_this._coordinates());
          if (m_this.layer()) {
            m_this.layer().geoOn(geo_event.mousemove, m_this._cursorHandleMousemove);
          }
          break;
      }
    }
    return m_this;
  };

  /**
   * Return actions needed for the specified state of this annotation.
   *
   * @param {string} [state] The state to return actions for.  Defaults to
   *    the current state.
   * @returns {geo.actionRecord[]} A list of actions.
   */
  this.actions = function (state) {
    if (!state) {
      state = m_this.state();
    }
    switch (state) {
      case annotationState.edit:
        return [{
          action: geo_action.annotation_edit_handle,
          name: 'annotation edit',
          owner: annotationActionOwner,
          input: 'left'
        }, {
          action: geo_action.annotation_edit_handle,
          name: 'annotation edit',
          owner: annotationActionOwner,
          input: 'pan'
        }];
      case annotationState.cursor:
        return [{
          action: geo_action.annotation_cursor,
          name: 'annotation cursor',
          owner: annotationActionOwner,
          input: 'pan'
        }, {
          action: geo_action.annotation_cursor,
          name: 'annotation cursor',
          owner: annotationActionOwner,
          input: 'left'
        }];
      default:
        return [];
    }
  };

  /**
   * Process any non-edit actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, `'done'` if the
   *    annotation was completed (changed from create to done state),
   *    `'remove'` if the annotation should be removed, falsy to not update
   *    anything.
   */
  this.processAction = function (evt) {
    return undefined;
  };

  /**
   * Process any edit actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean?} `true` to update the annotation, falsy to not update
   *    anything.
   */
  this.processEditAction = function (evt) {
    if (!evt || !m_this._editHandle || !m_this._editHandle.handle) {
      return undefined;
    }
    switch (m_this._editHandle.handle.type) {
      case 'vertex':
        return m_this._processEditActionVertex(evt);
      case 'edge':
        return m_this._processEditActionEdge(evt);
      case 'center':
        return m_this._processEditActionCenter(evt);
      case 'rotate':
        return m_this._processEditActionRotate(evt);
      case 'resize':
        return m_this._processEditActionResize(evt);
    }
    return undefined;
  };

  /**
   * Return a copy of the _coordinates or a geo.polygon record so that it
   * doesn't share memory with the original.
   *
   * @param {geo.polygon} [coord] if specified, return a copy of this object.
   *   Otherwise, return a copy of this._coordinates.
   * @returns {geo.polygon}
   */
  this._copyOfCoordinates = function (coord) {
    coord = coord || m_this._coordinates();
    if (!coord.outer) {
      return coord.slice();
    }
    return {
      outer: coord.outer.slice(),
      inner: (coord.inner || []).map(function (h) {
        return h.slice();
      })
    };
  };

  /**
   * When an edit handle is selected or deselected (for instance, by moving the
   * mouse on or off of it), mark if it is selected and record the current
   * coordinates.
   *
   * @param {object} handle The data for the edit handle.
   * @param {boolean} enable True to enable the handle, false to disable.
   * @returns {this}
   * @fires geo.event.annotation.select_edit_handle
   */
  this.selectEditHandle = function (handle, enable) {
    if (enable && m_this._editHandle && m_this._editHandle.handle && m_this._editHandle.handle.selected) {
      m_this._editHandle.handle.selected = false;
    }
    handle.selected = enable;
    var amountRotated = (m_this._editHandle || {}).amountRotated || 0;
    m_this._editHandle = {
      handle: handle,
      startCoordinates: m_this._copyOfCoordinates(),
      center: util.centerFromPerimeter(m_this._coordinates()),
      rotatePosition: m_this._rotateHandlePosition(handle.style.rotateHandleOffset, handle.style.rotateHandleRotation + amountRotated),
      startAmountRotated: amountRotated,
      amountRotated: amountRotated,
      resizePosition: m_this._rotateHandlePosition(handle.style.resizeHandleOffset, handle.style.resizeHandleRotation)
    };
    if (m_this.layer()) {
      m_this.layer().geoTrigger(geo_event.annotation.select_edit_handle, {
        annotation: m_this,
        handle: m_this._editHandle,
        enable: enable
      });
    }
    return m_this;
  };

  /**
   * Get or set options.
   *
   * @param {string|object} [arg1] If `undefined`, return the options object.
   *    If a string, either set or return the option of that name.  If an
   *    object, update the options with the object's values.
   * @param {object} [arg2] If `arg1` is a string and this is defined, set
   *    the option to this value.
   * @returns {object|this} If options are set, return the annotation,
   *    otherwise return the requested option or the set of options.
   * @fires geo.event.annotation.coordinates
   */
  this.options = function (arg1, arg2) {
    if (arg1 === undefined) {
      return m_options;
    }
    if (typeof arg1 === 'string' && arg2 === undefined) {
      return m_options[arg1];
    }
    var coordinatesSet;
    if (arg2 === undefined) {
      coordinatesSet = arg1[m_this._coordinateOption] !== undefined;
      m_options = util.deepMerge(m_options, arg1);
      /* For style objects, re-extend them without recursion.  This allows
       * setting colors without an opacity field, for instance. */
      ['style', 'createStyle', 'editStyle', 'editHandleStyle', 'labelStyle', 'highlightStyle', 'cursorStyle'].forEach(function (key) {
        if (arg1[key] !== undefined) {
          Object.assign(m_options[key], arg1[key]);
        }
      });
    } else {
      coordinatesSet = arg1 === m_this._coordinateOption;
      m_options[arg1] = arg2;
    }
    if (m_options.coordinates) {
      var coord = m_options.coordinates;
      delete m_options.coordinates;
      m_this._coordinates(coord);
    }
    if (m_options.name !== undefined) {
      var name = m_options.name;
      delete m_options.name;
      m_this.name(name);
    }
    if (m_options.label !== undefined) {
      var label = m_options.label;
      delete m_options.label;
      m_this.label(label);
    }
    if (m_options.description !== undefined) {
      var description = m_options.description;
      delete m_options.description;
      m_this.description(description);
    }
    m_this.modified();
    if (coordinatesSet && m_this.layer()) {
      m_this.layer().geoTrigger(geo_event.annotation.coordinates, {
        annotation: m_this
      });
    }
    return m_this;
  };

  /**
   * Get or set style.
   *
   * @param {string|object} [arg1] If `undefined`, return the current style
   *    object.  If a string and `arg2` is undefined, return the style
   *    associated with the specified key.  If a string and `arg2` is defined,
   *    set the named style to the specified value.  Otherwise, extend the
   *    current style with the values in the specified object.
   * @param {*} [arg2] If `arg1` is a string, the new value for that style.
   * @param {string} [styleType] The name of the style type, such as
   *    `createStyle`, `editStyle`, `editHandleStyle`, `labelStyle`,
   *    `highlightStyle`, or `cursorStyle`.
   * @returns {object|this} Either the entire style object, the value of a
   *    specific style, or the current class instance.
   */
  this.style = function (arg1, arg2, styleType) {
    styleType = styleType || 'style';
    if (arg1 === undefined) {
      return m_options[styleType];
    }
    if (typeof arg1 === 'string' && arg2 === undefined) {
      return (m_options[styleType] || {})[arg1];
    }
    if (m_options[styleType] === undefined) {
      m_options[styleType] = {};
    }
    if (arg2 === undefined) {
      m_options[styleType] = util.deepMerge(m_options[styleType], arg1);
    } else {
      m_options[styleType][arg1] = arg2;
    }
    m_this.modified();
    return m_this;
  };

  /**
   * Calls {@link geo.annotation#style} with `styleType='createStyle'`.
   * @function createStyle
   * @memberof geo.annotation
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='editStyle'`.
   * @function editStyle
   * @memberof geo.annotation
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='editHandleStyle'`.
   * @function editHandleStyle
   * @memberof geo.annotation
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='labelStyle'`.
   * @function labelStyle
   * @memberof geo.annotation
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='highlightStyle'`.
   * @function highlightStyle
   * @memberof geo.annotation
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='cursorStyle'`.
   * @function cursorStyle
   * @memberof geo.annotation
   * @instance
   */
  ['createStyle', 'editStyle', 'editHandleStyle', 'labelStyle', 'highlightStyle', 'cursorStyle'].forEach(function (styleType) {
    m_this[styleType] = function (arg1, arg2) {
      return m_this.style(arg1, arg2, styleType);
    };
  });

  /**
   * Return the style dictionary for a particular state.
   * @param {string} [state] The state to return styles for.  Defaults to the
   *    current state.
   * @returns {object} The style object for the state.  If there is no such
   *    style defined, the default style is used.
   */
  this.styleForState = function (state) {
    state = state || m_this.state();
    /* for some states, fall back to the general style if they don't specify a
     * value explicitly. */
    if (state === annotationState.edit || state === annotationState.highlight) {
      return Object.assign({}, m_options.style, m_options[state + 'Style']);
    }
    if (state === annotationState.create) {
      return Object.assign({}, m_options.style, m_options.editStyle, m_options[state + 'Style']);
    }
    if (state === annotationState.cursor) {
      return Object.assign({}, m_options.style, m_options.editStyle, m_options.createStyle, m_options[state + 'Style']);
    }
    return m_options[state + 'Style'] || m_options.style || {};
  };

  /**
   * Get the type of this annotation.
   *
   * @returns {string} The annotation type.
   */
  this.type = function () {
    return m_type;
  };

  /**
   * Get a list of renderable features for this annotation.  The list index is
   * functionally a z-index for the feature.  Each entry is a dictionary with
   * the key as the feature name (such as `line`, `quad`, or `polygon`), and
   * the value a dictionary of values to pass to the feature constructor, such
   * as `style` and `coordinates`.
   *
   * @returns {array} An array of features.
   */
  this.features = function () {
    return [];
  };

  /**
   * Handle a mouse click on this annotation.  If the event is processed,
   * evt.handled should be set to `true` to prevent further processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string} `true` to update the annotation, `'done'` if
   *    the annotation was completed (changed from create to done state),
   *    `'remove'` if the annotation should be removed, falsy to not update
   *    anything.
   */
  this.mouseClick = function (evt) {
    return undefined;
  };

  /**
   * Handle a mouse click on this annotation when in edit mode.  If the event
   * is processed, evt.handled should be set to `true` to prevent further
   * processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string} `true` to update the annotation, `'done'` if
   *    the annotation was completed (changed from create to done state),
   *    `'remove'` if the annotation should be removed, falsy to not update
   *    anything.
   */
  this.mouseClickEdit = function (evt) {
    return undefined;
  };

  /**
   * Handle a mouse move on this annotation.
   *
   * @param {geo.event} evt The mouse move event.
   * @returns {boolean} Truthy to update the annotation, falsy to not
   *    update anything.
   */
  this.mouseMove = function (evt) {
    return undefined;
  };

  /**
   * Get or set coordinates associated with this annotation in the map gcs
   * coordinate system.
   *
   * @param {geo.geoPosition[]} [coordinates] An optional array of coordinates
   *  to set.
   * @returns {geo.geoPosition[]} The current array of coordinates.
   */
  this._coordinates = function (coordinates) {
    return [];
  };
  this._coordinateOption = 'vertices';

  /**
   * Get coordinates associated with this annotation.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.geoPosition[]} An array of coordinates.
   */
  this.coordinates = function (gcs) {
    var coord = m_this._coordinates() || [];
    if (!coord.length && (!coord.outer || !coord.outer.length)) {
      coord = [];
    }
    if (m_this.layer()) {
      var map = m_this.layer().map();
      gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
      if (gcs !== map.gcs()) {
        coord = m_this._convertCoordinates(map.gcs(), gcs, coord);
      }
    }
    return coord;
  };

  /**
   * Mark this annotation as modified.  This just marks the parent layer as
   * modified.
   *
   * @returns {this} The annotation.
   */
  this.modified = function () {
    if (m_this.layer()) {
      m_this.layer().modified();
    }
    return m_this;
  };

  /**
   * Draw this annotation.  This just updates and draws the parent layer.
   *
   * @returns {this} The annotation.
   */
  this.draw = function () {
    if (m_this.layer()) {
      m_this.layer()._update();
      m_this.layer().draw();
    }
    return m_this;
  };

  /**
   * Return a list of styles that should be preserved in a geojson
   * representation of the annotation.
   *
   * @returns {string[]} A list of style names to store.
   */
  this._geojsonStyles = function () {
    return ['closed', 'fill', 'fillColor', 'fillOpacity', 'lineCap', 'lineJoin', 'radius', 'stroke', 'strokeColor', 'strokeOffset', 'strokeOpacity', 'strokeWidth'];
  };

  /**
   * Return the coordinates to be stored in a geojson geometry object.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {array} An array of flattened coordinates in the interface gcs
   *    coordinate system.  `undefined` if this annotation is incomplete.
   */
  this._geojsonCoordinates = function (gcs) {
    return [];
  };

  /**
   * Return the geometry type that is used to store this annotation in geojson.
   *
   * @returns {string} A geojson geometry type.
   */
  this._geojsonGeometryType = function () {
    return '';
  };

  /**
   * Return the annotation as a geojson object.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @param {boolean} [includeCrs] If truthy, include the coordinate system.
   * @returns {object?} The annotation as a geojson object, or `undefined` if it
   *    should not be represented (for instance, while it is being created).
   */
  this.geojson = function (gcs, includeCrs) {
    var coord = m_this._geojsonCoordinates(gcs),
      geotype = m_this._geojsonGeometryType(),
      styles = m_this._geojsonStyles(),
      objStyle = m_this.options('style') || {},
      objLabelStyle = m_this.labelStyle() || {},
      i,
      key,
      value;
    if (!coord || !coord.length || !geotype) {
      return undefined;
    }
    var obj = {
      type: 'Feature',
      geometry: {
        type: geotype,
        coordinates: coord
      },
      properties: {
        annotationType: m_type,
        name: m_this.name(),
        annotationId: m_this.id()
      }
    };
    if (m_label) {
      obj.properties.label = m_label;
    }
    if (m_description) {
      obj.properties.description = m_description;
    }
    if (m_this.options('showLabel') === false) {
      obj.properties.showLabel = m_this.options('showLabel');
    }
    for (i = 0; i < styles.length; i += 1) {
      key = styles[i];
      value = util.ensureFunction(objStyle[key])();
      if (value !== undefined) {
        var defvalue = ((m_this.constructor.defaults || {}).style || {})[key];
        if (key.toLowerCase().match(/color$/)) {
          value = util.convertColorToHex(value, 'needed');
          defvalue = defvalue !== undefined ? util.convertColorToHex(defvalue, 'needed') : defvalue;
        }
        if (value !== defvalue) {
          obj.properties[key] = value;
        }
      }
    }
    for (i = 0; i < textFeature.usedStyles.length; i += 1) {
      key = textFeature.usedStyles[i];
      value = util.ensureFunction(objLabelStyle[key])();
      if (value !== undefined) {
        if (key.toLowerCase().match(/color$/)) {
          value = util.convertColorToHex(value, 'needed');
        }
        obj.properties['label' + key.charAt(0).toUpperCase() + key.slice(1)] = value;
      }
    }
    if (includeCrs) {
      var map = m_this.layer().map();
      gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
      obj.crs = {
        type: 'name',
        properties: {
          type: 'proj4',
          name: gcs
        }
      };
    }
    return obj;
  };

  /**
   * Add edit handles to the feature list.
   *
   * @param {array} features The array of features to modify.
   * @param {geo.geoPosition[]} vertices An array of vertices in map gcs
   *    coordinates.
   * @param {object} [opts] If specified, the keys are the types of the
   *    handles.  This matches the `editHandleStyle.handle` object.  Any type
   *    that is set to `false` in either `opts` or `editHandleStyle.handle`
   *    will prevent those handles from being created.
   * @param {boolean} [isOpen] If true, no edge handle will be created
   *    between the last and first vertices.
   */
  this._addEditHandles = function (features, vertices, opts, isOpen) {
    var editPoints,
      style = Object.assign({}, defaultEditHandleStyle, m_this.editHandleStyle()),
      handles = util.ensureFunction(style.handles)() || {},
      selected = m_this._editHandle && m_this._editHandle.handle && m_this._editHandle.handle.selected ? m_this._editHandle.handle : undefined;
    /* opts specify which handles are allowed.  They must be allowed by the
     * original opts object and by the editHandleStyle.handle object. */
    opts = Object.assign({}, opts);
    Object.keys(handles).forEach(function (key) {
      if (handles[key] === false) {
        opts[key] = false;
      }
    });
    if (!features[editHandleFeatureLevel]) {
      features[editHandleFeatureLevel] = {
        point: []
      };
    }
    editPoints = features[editHandleFeatureLevel].point;
    var vertexList = vertices.outer ? [vertices.outer].concat(vertices.inner || []) : [vertices];
    vertexList.forEach(function (vert, vidx) {
      vert.forEach(function (pt, idx) {
        if (opts.vertex !== false) {
          editPoints.push(Object.assign({}, pt, {
            type: 'vertex',
            index: idx,
            vindex: vidx,
            style: style,
            editHandle: true
          }));
        }
        if (opts.edge !== false && idx !== vert.length - 1 && (pt.x !== vert[idx + 1].x || pt.y !== vert[idx + 1].y)) {
          editPoints.push(Object.assign({
            x: (pt.x + vert[idx + 1].x) / 2,
            y: (pt.y + vert[idx + 1].y) / 2
          }, {
            type: 'edge',
            index: idx,
            vindex: vidx,
            style: style,
            editHandle: true
          }));
        }
        if (opts.edge !== false && !isOpen && idx === vert.length - 1 && (pt.x !== vert[0].x || pt.y !== vert[0].y)) {
          editPoints.push(Object.assign({
            x: (pt.x + vert[0].x) / 2,
            y: (pt.y + vert[0].y) / 2
          }, {
            type: 'edge',
            index: idx,
            vindex: vidx,
            style: style,
            editHandle: true
          }));
        }
      });
    });
    if (opts.center !== false) {
      editPoints.push(Object.assign({}, util.centerFromPerimeter(m_this._coordinates()), {
        type: 'center',
        style: style,
        editHandle: true
      }));
    }
    if (opts.rotate !== false) {
      editPoints.push(Object.assign(m_this._rotateHandlePosition(style.rotateHandleOffset, style.rotateHandleRotation + (selected && selected.type === 'rotate' ? m_this._editHandle.amountRotated : 0)), {
        type: 'rotate',
        style: style,
        editHandle: true
      }));
      if (m_this._editHandle && (!selected || selected.type !== 'rotate')) {
        m_this._editHandle.amountRotated = 0;
      }
    }
    if (opts.resize !== false) {
      editPoints.push(Object.assign(m_this._rotateHandlePosition(style.resizeHandleOffset, style.resizeHandleRotation), {
        type: 'resize',
        style: style,
        editHandle: true
      }));
    }
    if (selected) {
      editPoints.forEach(function (pt) {
        if (pt.type === selected.type && pt.index === selected.index && pt.vindex === selected.vindex) {
          pt.selected = true;
        }
      });
    }
  };

  /**
   * Apply a map function of a geo.polygon.
   *
   * @param {geo.polygon} coord The polygon to apply the function to.
   * @param {Function} func The function to apply.
   * @returns {array} The map results.
   */
  this._coordinatesMapFunc = function (coord, func) {
    if (!coord.outer) {
      return coord.map(func);
    }
    return {
      outer: coord.outer.map(func),
      inner: (coord.inner || []).map(function (h) {
        return h.map(func);
      })
    };
  };

  /**
   * Check if two geo.polygons differ in their first point.
   *
   * @param {geo.polygon} coord1 One polygon to compare.
   * @param {geo.polygon} coord2 A second polygon to compare.
   * @returns {boolean} true if the first point matches.
   */
  this._firstPointDifferent = function (coord1, coord2) {
    coord1 = coord1.outer ? coord1.outer : coord1;
    coord2 = coord2.outer ? coord2.outer : coord2;
    return coord1[0].x !== coord2[0].x || coord1[0].y !== coord2[0].y;
  };

  /**
   * Process the edit center action for a general annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, falsy to not
   *    update anything.
   */
  this._processEditActionCenter = function (evt) {
    var start = m_this._editHandle.startCoordinates,
      delta = {
        x: evt.mouse.mapgcs.x - evt.state.origin.mapgcs.x,
        y: evt.mouse.mapgcs.y - evt.state.origin.mapgcs.y
      },
      curPts = m_this._coordinates();
    var pts = m_this._coordinatesMapFunc(start, function (elem) {
      return {
        x: elem.x + delta.x,
        y: elem.y + delta.y
      };
    });
    if (m_this._firstPointDifferent(pts, curPts)) {
      m_this._coordinates(pts);
      return true;
    }
    return false;
  };

  /**
   * Process the edit rotate action for a general annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, falsy to not
   *    update anything.
   */
  this._processEditActionRotate = function (evt) {
    var handle = m_this._editHandle,
      start = handle.startCoordinates,
      delta = {
        x: evt.mouse.mapgcs.x - evt.state.origin.mapgcs.x,
        y: evt.mouse.mapgcs.y - evt.state.origin.mapgcs.y
      },
      ang1 = Math.atan2(handle.rotatePosition.y - handle.center.y, handle.rotatePosition.x - handle.center.x),
      ang2 = Math.atan2(handle.rotatePosition.y + delta.y - handle.center.y, handle.rotatePosition.x + delta.x - handle.center.x),
      ang = ang2 - ang1,
      curPts = m_this._coordinates();
    var pts = m_this._coordinatesMapFunc(start, function (elem) {
      var delta = {
        x: elem.x - handle.center.x,
        y: elem.y - handle.center.y
      };
      return {
        x: delta.x * Math.cos(ang) - delta.y * Math.sin(ang) + handle.center.x,
        y: delta.x * Math.sin(ang) + delta.y * Math.cos(ang) + handle.center.y
      };
    });
    if (m_this._firstPointDifferent(pts, curPts)) {
      m_this._coordinates(pts);
      handle.amountRotated = handle.startAmountRotated + ang;
      return true;
    }
    return false;
  };

  /**
   * Process the edit resize action for a general annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, falsy to not
   *    update anything.
   */
  this._processEditActionResize = function (evt) {
    var handle = m_this._editHandle,
      start = handle.startCoordinates,
      delta = {
        x: evt.mouse.mapgcs.x - evt.state.origin.mapgcs.x,
        y: evt.mouse.mapgcs.y - evt.state.origin.mapgcs.y
      },
      map = m_this.layer().map(),
      p0 = map.gcsToDisplay(handle.center, null),
      p1 = map.gcsToDisplay(handle.resizePosition, null),
      p2 = map.gcsToDisplay({
        x: handle.resizePosition.x + delta.x,
        y: handle.resizePosition.y + delta.y
      }, null),
      d01 = Math.pow(Math.pow(p1.y - p0.y, 2) + Math.pow(p1.x - p0.x, 2), 0.5) - handle.handle.style.resizeHandleOffset,
      d02 = Math.pow(Math.pow(p2.y - p0.y, 2) + Math.pow(p2.x - p0.x, 2), 0.5) - handle.handle.style.resizeHandleOffset,
      curPts = m_this._coordinates();
    if (d02 && d01) {
      var scale = d02 / d01;
      var pts = m_this._coordinatesMapFunc(start, function (elem) {
        return {
          x: (elem.x - handle.center.x) * scale + handle.center.x,
          y: (elem.y - handle.center.y) * scale + handle.center.y
        };
      });
      if (m_this._firstPointDifferent(pts, curPts)) {
        m_this._coordinates(pts);
        return true;
      }
    }
    return false;
  };

  /**
   * Process the edit edge action for a general annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, falsy to not
   *    update anything.
   */
  this._processEditActionEdge = function (evt) {
    var handle = m_this._editHandle,
      index = handle.handle.index,
      vindex = handle.handle.vindex,
      curPts = m_this._coordinates();
    if (!curPts.outer) {
      curPts.splice(index + 1, 0, {
        x: handle.handle.x,
        y: handle.handle.y
      });
    } else {
      var loop = vindex ? curPts.inner[vindex - 1] : curPts.outer;
      loop.splice(index + 1, 0, {
        x: handle.handle.x,
        y: handle.handle.y
      });
    }
    handle.handle.type = 'vertex';
    handle.handle.index += 1;
    handle.startCoordinates = m_this._copyOfCoordinates(curPts);
    m_this.modified();
    return true;
  };

  /**
   * Process the edit vertex action for a general annotation.
   *
   * @param {geo.event} evt The action event.
   * @param {boolean} [canClose] if True, this annotation has a closed style
   *    that indicates if the first and last vertices are joined.  If falsy, is
   *    allowed to be changed to true.
   * @returns {boolean|string} `true` to update the annotation, `false` to
   *    prevent closure, any other falsy to not update anything.
   */
  this._processEditActionVertex = function (evt, canClose) {
    var handle = m_this._editHandle,
      index = handle.handle.index,
      vindex = handle.handle.vindex,
      start = handle.startCoordinates,
      ptsRef = m_this._coordinates(),
      curPts = ptsRef.outer ? vindex ? ptsRef.inner[vindex - 1] : ptsRef.outer : ptsRef,
      origLen = curPts.length,
      origPt = curPts[index],
      delta = {
        x: evt.mouse.mapgcs.x - evt.state.origin.mapgcs.x,
        y: evt.mouse.mapgcs.y - evt.state.origin.mapgcs.y
      },
      layer = m_this.layer(),
      aPP = layer.options('adjacentPointProximity'),
      near,
      atEnd;
    if (start.outer) {
      start = vindex ? start.inner[vindex - 1] : start.outer;
    }
    curPts[index] = {
      x: start[index].x + delta.x,
      y: start[index].y + delta.y
    };
    if (layer.displayDistance(curPts[index], null, start[index], null) <= aPP) {
      /* if we haven't moved at least aPP from where the vertex started, don't
       * allow it to be merged into another vertex.  This prevents small scale
       * edits from collapsing immediately. */
    } else if (layer.displayDistance(curPts[index], null, curPts[(index + 1) % curPts.length], null) <= aPP) {
      near = (index + 1) % curPts.length;
    } else if (layer.displayDistance(curPts[index], null, curPts[(index + curPts.length - 1) % curPts.length], null) <= aPP) {
      near = (index + curPts.length - 1) % curPts.length;
    }
    atEnd = near === 0 && index === curPts.length - 1 || near === curPts.length - 1 && index === 0;
    if (canClose === false && atEnd) {
      near = undefined;
    }
    if (near !== undefined && curPts.length > (canClose || m_this.options('style').closed ? 3 : 2)) {
      curPts[index] = {
        x: curPts[near].x,
        y: curPts[near].y
      };
      if (evt.event === geo_event.actionup) {
        if (canClose && atEnd) {
          m_this.options('style').closed = true;
        }
        curPts.splice(index, 1);
      }
    }
    if (curPts.length === origLen && curPts[index].x === origPt.x && curPts[index].y === origPt.y) {
      return false;
    }
    m_this._coordinates(ptsRef);
    return true;
  };

  /**
   * Transform the annotations coordinates from one gcs to another.
   *
   * @param {string|geo.transform} oldgcs The current gcs.
   * @param {string|geo.transform} newgcs The new gcs.
   * @param {geo.polygon} [coord] If not specified, convert the coordinates in
   *   place.  If specified, convert these coordinates and return them (don't
   *   alter the existing values).
   * @returns {geo.polygon}
   */
  this._convertCoordinates = function (oldgcs, newgcs, coord) {
    var store = !coord;
    coord = coord || m_this._coordinates();
    if (!coord.outer) {
      coord = transform.transformCoordinates(oldgcs, newgcs, coord);
    } else {
      coord = {
        outer: transform.transformCoordinates(oldgcs, newgcs, coord.outer),
        inner: (coord.inner || []).map(function (h) {
          return transform.transformCoordinates(oldgcs, newgcs, h);
        })
      };
    }
    if (store) {
      m_this._coordinates(coord);
    }
    return coord;
  };
};

/* Functions used by multiple annotations */

/**
 * Return actions needed for the specified state of this annotation.
 *
 * @private
 * @param {object} m_this The current annotation instance.
 * @param {Function} s_actions The parent actions method.
 * @param {string|undefined} state The state to return actions for.  Defaults
 *    to the current state.
 * @param {string} name The name of this annotation.
 * @param {Array} originalArgs arguments to original call
 * @returns {geo.actionRecord[]} A list of actions.
 */
function continuousVerticesActions(m_this, s_actions, state, name, originalArgs) {
  if (!state) {
    state = m_this.state();
  }
  switch (state) {
    case annotationState.create:
      return [{
        action: geo_action['annotation_' + name],
        name: name + ' create',
        owner: annotationActionOwner,
        input: 'left'
      }, {
        action: geo_action['annotation_' + name],
        name: name + ' create',
        owner: annotationActionOwner,
        input: 'pan'
      }];
    default:
      return s_actions.apply(m_this, originalArgs);
  }
}

/**
 * Process actions to allow drawing continuous vertices for an annotation.
 *
 * @private
 * @param {object} m_this The current annotation instance.
 * @param {geo.event} evt The action event.
 * @param {string} name The name of this annotation.
 * @returns {boolean|string|undefined} `true` to update the annotation,
 *    `'done'` if the annotation was completed (changed from create to done
 *    state), `'remove'` if the annotation should be removed, falsy to not
 *    update anything.
 */
function continuousVerticesProcessAction(m_this, evt, name) {
  var layer = m_this.layer();
  if (m_this.state() !== annotationState.create || !layer || evt.state.action !== geo_action['annotation_' + name]) {
    return undefined;
  }
  var cpp = layer.options('continuousPointProximity');
  var cpc = layer.options('continuousPointCollinearity');
  var ccp = layer.options('continuousCloseProximity');
  if (cpp || cpp === 0) {
    var vertices = m_this.options('vertices');
    var update = false;
    if (!vertices.length) {
      vertices.push(evt.mouse.mapgcs);
      vertices.push(evt.mouse.mapgcs);
      return true;
    }
    var dist = layer.displayDistance(vertices[vertices.length - 2], null, evt.mouse.map, 'display');
    if (dist && dist > cpp) {
      // combine nearly collinear points
      if (vertices.length >= (m_this._lastClickVertexCount || 1) + 3) {
        var d01 = layer.displayDistance(vertices[vertices.length - 3], null, vertices[vertices.length - 2], null),
          d12 = dist,
          d02 = layer.displayDistance(vertices[vertices.length - 3], null, evt.mouse.map, 'display');
        if (d01 && d02) {
          var costheta = (d02 * d02 - d01 * d01 - d12 * d12) / (2 * d01 * d12);
          if (costheta > Math.cos(cpc)) {
            vertices.pop();
          }
        }
      }
      vertices[vertices.length - 1] = evt.mouse.mapgcs;
      vertices.push(evt.mouse.mapgcs);
      update = true;
    }
    if ((ccp || ccp === 0) && evt.event === geo_event.actionup && (ccp === true || layer.displayDistance(vertices[0], null, evt.mouse.map, 'display') <= cpp)) {
      if (vertices.length < 3 + (name === 'polygon' ? 1 : 0)) {
        return 'remove';
      }
      vertices.pop();
      m_this.state(annotationState.done);
      return 'done';
    }
    return update;
  }
  return undefined;
}

/**
 * Return a function that can be used as a selectionConstraint that requires
 * that the aspect ratio of a rectangle-like selection is a specific value or
 * range of values.
 *
 * @private
 * @param {number|number[]|geo.geoSize|geo.geoSize[]} ratio Either a single
 *   aspect ratio, a single size, or a list of allowed aspect ratios and sizes.
 *   For instance, 1 will require that the selection square, 2 would require
 *   that it is twice as wide as tall, [2, 1/2] would allow it to be twice as
 *   wide or half as wide as it is tall.  Sizes (e.g., {width: 400, height:
 *   500}) snap to that size.
 * @returns {Function} A function that can be passed to the mapIterator
 *   selectionConstraint or to an annotation constraint function.
 */
function constrainAspectRatio(ratio) {
  var ratios = Array.isArray(ratio) ? ratio : [ratio];

  /**
   * Constrain a mouse action or annotation action to a list of aspect ratios.
   *
   * @param {geo.geoPosition} pos Mouse or new location in map gcs.
   * @param {geo.geoPosition} origin Origin in map gcs when the activity
   *    started.
   * @param {geo.geoPosition} [corners] If specified, an array of corner
   *    locations in mapgcs.  This may be modified.
   * @param {string?} [mode] 'edge', 'vertex' or falsy.  A falsy value implies
   *    this is just the most recent point in the annotation, otherwise it is
   *    the portion of the annotation being modified.
   * @param {number} [ang] A list of angles of each side of the polygon
   *    represented by corners or the original annotation.
   * @param {integer} [index] The specific vertex or edge that is being
   *    modified.
   * @returns {object} An object with the ``origin`` (this is what is passed
   *    in), a new position as ``pos``, and the updated corners as ``corners``.
   */
  function constraintFunction(pos, origin, corners, mode, ang, index) {
    var newpos = pos;
    var best;
    if (!corners) {
      corners = [{
        x: origin.x,
        y: origin.y
      }, {
        x: pos.x,
        y: origin.y
      }, {
        x: pos.x,
        y: pos.y
      }, {
        x: origin.x,
        y: pos.y
      }];
    }
    if (mode) {
      /* Edit a vertex or edge */
      var i1 = (index + 1) % 4;
      var i2 = (index + 2) % 4;
      var i3 = (index + 3) % 4;
      var dist1 = Math.pow(Math.pow(corners[index].x - corners[i1].x, 2) + Math.pow(corners[index].y - corners[i1].y, 2), 0.5);
      var dist3 = Math.pow(Math.pow(corners[index].x - corners[i3].x, 2) + Math.pow(corners[index].y - corners[i3].y, 2), 0.5);
      var area = Math.abs(dist1 * dist3);
      var shape, edge;
      ratios.forEach(function (ratio) {
        var width, height;
        if (ratio.width) {
          width = ratio.width;
          height = ratio.height;
        } else {
          width = Math.pow(area * ratio, 0.5);
          height = width / ratio;
        }
        if (width !== height && !(index % 2)) {
          var _ref = [height, width];
          width = _ref[0];
          height = _ref[1];
        }
        var score = Math.pow(width - dist3, 2) + Math.pow(height - dist1, 2);
        if (best === undefined || score < best) {
          best = score;
          shape = {
            w: width,
            h: height
          };
        }
      });
      var ang1 = ang[i1];
      var delta1 = {
        x: -shape.w * Math.cos(ang1),
        y: -shape.w * Math.sin(ang1)
      };
      var ang2 = ang[index];
      var delta2 = {
        x: -shape.h * Math.cos(ang2),
        y: -shape.h * Math.sin(ang2)
      };
      switch (mode) {
        case 'vertex':
          corners[index].x = corners[i2].x + delta1.x + delta2.x;
          corners[index].y = corners[i2].y + delta1.y + delta2.y;
          corners[i1].x = corners[i2].x + delta1.x;
          corners[i1].y = corners[i2].y + delta1.y;
          corners[i3].x = corners[i2].x + delta2.x;
          corners[i3].y = corners[i2].y + delta2.y;
          break;
        case 'edge':
          edge = {
            x: (corners[i2].x + corners[i3].x) * 0.5,
            y: (corners[i2].y + corners[i3].y) * 0.5
          };
          corners[i2].x = edge.x + delta2.x / 2;
          corners[i2].y = edge.y + delta2.y / 2;
          corners[index].x = edge.x + delta1.x - delta2.x / 2;
          corners[index].y = edge.y + delta1.y - delta2.y / 2;
          corners[i1].x = edge.x + delta1.x + delta2.x / 2;
          corners[i1].y = edge.y + delta1.y + delta2.y / 2;
          corners[i3].x = edge.x - delta2.x / 2;
          corners[i3].y = edge.y - delta2.y / 2;
          break;
      }
    } else {
      /* Not in edit vertex or edge mode */
      var _area = Math.abs((pos.x - origin.x) * (pos.y - origin.y));
      ratios.forEach(function (ratio) {
        var width, height;
        if (ratio.width) {
          width = ratio.width;
          height = ratio.height;
        } else {
          width = Math.pow(_area * ratio, 0.5);
          height = width / ratio;
        }
        var adjusted = {
          x: origin.x + Math.sign(pos.x - origin.x) * width,
          y: origin.y + Math.sign(pos.y - origin.y) * height
        };
        var score = Math.pow(adjusted.x - pos.x, 2) + Math.pow(adjusted.y - pos.y, 2);
        if (best === undefined || score < best) {
          best = score;
          newpos = adjusted;
        }
      });
      corners[0].y = corners[1].y = origin.y;
      corners[0].x = corners[3].x = origin.x;
      corners[1].x = corners[2].x = newpos.x;
      corners[2].y = corners[3].y = newpos.y;
    }
    return {
      corners: corners,
      origin: origin,
      pos: newpos
    };
  }
  return constraintFunction;
}

/**
 * This object contains the default options to initialize the class.
 */
_annotation.defaults = {
  showLabel: true
};
module.exports = {
  state: annotationState,
  actionOwner: annotationActionOwner,
  annotation: _annotation,
  _editHandleFeatureLevel: editHandleFeatureLevel,
  defaultEditHandleStyle: defaultEditHandleStyle,
  constrainAspectRatio: constrainAspectRatio,
  // these aren't exposed in index.js
  annotationActionOwner: annotationActionOwner,
  continuousVerticesActions: continuousVerticesActions,
  continuousVerticesProcessAction: continuousVerticesProcessAction
};

/***/ }),

/***/ 9894:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var markerFeature = __webpack_require__(2225);
var util = __webpack_require__(642);
var ellipseAnnotation = __webpack_require__(3656);

/**
 * Circle annotation class.
 *
 * Circles are a subset of rectangles with a fixed aspect ratio.
 *
 * @class
 * @alias geo.circleAnnotation
 * @extends geo.annotation
 *
 * @param {geo.circleAnnotation.spec?} [args] Options for the annotation.
 * @param {string} [annotationName] Override the annotation name.
 */
var _circleAnnotation = function circleAnnotation(args, annotationName) {
  'use strict';

  if (!(this instanceof _circleAnnotation)) {
    return new _circleAnnotation(args, annotationName);
  }
  args = util.deepMerge({}, this.constructor.defaults, args, {
    constraint: 1
  });
  ellipseAnnotation.call(this, args, annotationName || 'circle');
};
inherit(_circleAnnotation, ellipseAnnotation);

/**
 * This object contains the default options to initialize the class.
 */
_circleAnnotation.defaults = Object.assign({}, ellipseAnnotation.defaults, {});
var circleRequiredFeatures = {};
circleRequiredFeatures[markerFeature.capabilities.feature] = true;
registerAnnotation('circle', _circleAnnotation, circleRequiredFeatures);
module.exports = _circleAnnotation;

/***/ }),

/***/ 3656:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var markerFeature = __webpack_require__(2225);
var util = __webpack_require__(642);
var annotationState = (__webpack_require__(6978).state);
var rectangleAnnotation = __webpack_require__(4019);

/**
 * Ellipse annotation class.
 *
 * Ellipses are always rendered as markers.
 *
 * @class
 * @alias geo.ellipseAnnotation
 * @extends geo.annotation
 *
 * @param {geo.ellipseAnnotation.spec?} [args] Options for the annotation.
 * @param {string} [annotationName] Override the annotation name.
 */
var _ellipseAnnotation = function ellipseAnnotation(args, annotationName) {
  'use strict';

  if (!(this instanceof _ellipseAnnotation)) {
    return new _ellipseAnnotation(args, annotationName);
  }
  args = util.deepMerge({}, this.constructor.defaults, args);
  rectangleAnnotation.call(this, args, annotationName || 'ellipse');
  var m_this = this;

  /**
   * Get a list of renderable features for this annotation.
   *
   * @returns {array} An array of features.
   */
  this.features = function () {
    var opt = m_this.options(),
      state = m_this.state(),
      features;
    features = [];
    if (opt.corners && opt.corners.length >= 4) {
      var style = m_this.styleForState(state);
      var w = Math.pow(Math.pow(opt.corners[0].x - opt.corners[1].x, 2) + Math.pow(opt.corners[0].y - opt.corners[1].y, 2), 0.5);
      var h = Math.pow(Math.pow(opt.corners[0].x - opt.corners[3].x, 2) + Math.pow(opt.corners[0].y - opt.corners[3].y, 2), 0.5);
      var radius = Math.max(w, h) / 2 / m_this.layer().map().unitsPerPixel(0);
      var aspect = w ? h / w : 1e20;
      var rotation = -Math.atan2(opt.corners[1].y - opt.corners[0].y, opt.corners[1].x - opt.corners[0].x);
      features = [{
        marker: {
          x: (opt.corners[0].x + opt.corners[1].x + opt.corners[2].x + opt.corners[3].x) / 4,
          y: (opt.corners[0].y + opt.corners[1].y + opt.corners[2].y + opt.corners[3].y) / 4,
          style: Object.assign({}, style, {
            radius: radius,
            symbolValue: aspect,
            rotation: rotation,
            strokeOffset: 0,
            radiusIncludesStroke: false,
            scaleWithZoom: markerFeature.scaleMode.fill,
            rotateWithMap: true,
            strokeOpacity: style.stroke === false ? 0 : style.strokeOpacity,
            fillOpacity: style.fill === false ? 0 : style.fillOpacity
          })
        }
      }];
    }
    if (state === annotationState.edit) {
      m_this._addEditHandles(features, opt.corners);
    }
    return features;
  };

  /**
   * Return this annotation as a polygon list.
   *
   * @param {geo.util.polyop.spec} [opts] The ``tolerance`` and
   *   ``pixelTolerance`` parameters are used if set.  Otherwise, a polygon is
   *   approximated to 1/10th of a pixel at the map's current maximum zoom
   *   level.
   * @returns {geo.polygonList} A list of polygons.
   */
  this.toPolygonList = function (opts) {
    var coord = m_this._coordinates();
    if (coord.length < 3) {
      return [];
    }
    var tolerance = opts && opts.tolerance || 0;
    if (!tolerance) {
      var map = m_this.layer().map();
      if (opts && opts.pixelTolerance) {
        tolerance = map.unitsPerPixel(map.zoom()) * opts.pixelTolerance;
      } else {
        tolerance = map.unitsPerPixel(map.zoomRange().max) * 0.1;
      }
    }
    var w = Math.pow(Math.pow(coord[0].x - coord[1].x, 2) + Math.pow(coord[0].y - coord[1].y, 2), 0.5);
    var h = Math.pow(Math.pow(coord[0].x - coord[3].x, 2) + Math.pow(coord[0].y - coord[3].y, 2), 0.5);
    var cx = (coord[0].x + coord[2].x) / 2;
    var cy = (coord[0].y + coord[2].y) / 2;
    var radius = Math.max(w, h) / 2;
    var rotation = -Math.atan2(coord[1].y - coord[0].y, coord[1].x - coord[0].x);
    var sides = Math.max(12, Math.ceil(Math.PI / Math.acos((radius - tolerance) / (radius + tolerance))));
    var a = w / 2 * (1 + (1 - Math.cos(Math.PI / sides)) / 2);
    var b = h / 2 * (1 + (1 - Math.cos(Math.PI / sides)) / 2);
    var poly = [];
    var cosr = Math.cos(rotation),
      sinr = Math.sin(rotation);
    for (var s = 0; s < sides; s += 1) {
      var sa = Math.PI * 2 * s / sides;
      var cosa = Math.cos(sa),
        sina = Math.sin(sa);
      var x = cx + a * cosr * cosa - b * sinr * sina;
      var y = cy + a * sinr * cosa + b * cosr * sina;
      poly.push([x, y]);
    }
    return [[poly]];
  };
};
inherit(_ellipseAnnotation, rectangleAnnotation);

/**
 * This object contains the default options to initialize the class.
 */
_ellipseAnnotation.defaults = Object.assign({}, rectangleAnnotation.defaults, {});
var ellipseRequiredFeatures = {};
ellipseRequiredFeatures[markerFeature.capabilities.feature] = true;
registerAnnotation('ellipse', _ellipseAnnotation, ellipseRequiredFeatures);
module.exports = _ellipseAnnotation;

/***/ }),

/***/ 4655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var annotation = __webpack_require__(6978);

/**
 * @namespace geo.annotation
 */
module.exports = {
  state: annotation.state,
  actionOwner: annotation.actionOwner,
  annotation: annotation.annotation,
  _editHandleFeatureLevel: annotation._editHandleFeatureLevel,
  defaultEditHandleStyle: annotation.defaultEditHandleStyle,
  constrainAspectRatio: annotation.constrainAspectRatio,
  baseAnnotation: annotation,
  circleAnnotation: __webpack_require__(9894),
  ellipseAnnotation: __webpack_require__(3656),
  lineAnnotation: __webpack_require__(2612),
  pointAnnotation: __webpack_require__(400),
  polygonAnnotation: __webpack_require__(1920),
  rectangleAnnotation: __webpack_require__(4019),
  squareAnnotation: __webpack_require__(5229)
};

/***/ }),

/***/ 2612:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var lineFeature = __webpack_require__(9281);
var util = __webpack_require__(642);
var annotation = (__webpack_require__(6978).annotation);
var annotationState = (__webpack_require__(6978).state);
var continuousVerticesActions = (__webpack_require__(6978).continuousVerticesActions);
var continuousVerticesProcessAction = (__webpack_require__(6978).continuousVerticesProcessAction);

/**
 * Line annotation specification.  Extends {@link geo.annotation.spec}.
 *
 * @typedef {object} geo.lineAnnotation.spec
 * @extends geo.annotation.spec
 * @property {geo.geoPosition[]} [vertices] A list of vertices in map gcs
 *    coordinates.
 * @property {geo.geoPosition[]} [coordinates] An alternate name for
 *    `vertices`.
 * @property {geo.lineFeature.styleSpec} [style] The style to apply to a
 *    finished line.  This uses styles for {@link geo.lineFeature}.
 * @property {geo.lineFeature.styleSpec} [editStyle] The style to apply to a
 *    line in edit mode.
 */

/**
 * Line annotation class.
 *
 * @class
 * @alias geo.lineAnnotation
 * @extends geo.annotation
 *
 * @param {geo.lineAnnotation.spec?} [args] Options for the annotation.
 */
var _lineAnnotation = function lineAnnotation(args) {
  'use strict';

  if (!(this instanceof _lineAnnotation)) {
    return new _lineAnnotation(args);
  }
  args = util.deepMerge({}, this.constructor.defaults, {
    style: {
      line: function line(d) {
        /* Return an array that has the same number of items as we have
         * vertices. */
        return Array(m_this.options('vertices').length).fill(d);
      },
      position: function position(d, i) {
        return m_this.options('vertices')[i];
      }
    },
    createStyle: {
      line: function line(d) {
        /* Return an array that has the same number of items as we have
         * vertices. */
        return Array(m_this.options('vertices').length).fill(d);
      },
      position: function position(d, i) {
        return m_this.options('vertices')[i];
      }
    }
  }, args);
  args.vertices = args.vertices || args.coordinates || [];
  delete args.coordinates;
  annotation.call(this, 'line', args);
  var m_this = this,
    s_actions = this.actions,
    s_processEditAction = this.processEditAction;

  /**
   * Get a list of renderable features for this annotation.
   *
   * @returns {array} An array of features.
   */
  this.features = function () {
    var opt = m_this.options(),
      state = m_this.state(),
      features;
    switch (state) {
      case annotationState.create:
        features = [{
          line: {
            line: opt.vertices,
            style: m_this.styleForState(state)
          }
        }];
        break;
      default:
        features = [{
          line: {
            line: opt.vertices,
            style: m_this.styleForState(state)
          }
        }];
        if (state === annotationState.edit) {
          m_this._addEditHandles(features, opt.vertices, undefined, !m_this.style('closed'));
        }
        break;
    }
    return features;
  };

  /**
   * Get and optionally set coordinates associated with this annotation in the
   * map gcs coordinate system.
   *
   * @param {geo.geoPosition[]} [coordinates] An optional array of coordinates
   *  to set.
   * @returns {geo.geoPosition[]} The current array of coordinates.
   */
  this._coordinates = function (coordinates) {
    if (coordinates) {
      m_this.options('vertices', coordinates);
    }
    return m_this.options('vertices');
  };

  /**
   * Handle a mouse move on this annotation.
   *
   * @param {geo.event} evt The mouse move event.
   * @returns {boolean?} Truthy to update the annotation, falsy to not
   *    update anything.
   */
  this.mouseMove = function (evt) {
    if (m_this.state() !== annotationState.create) {
      return undefined;
    }
    var vertices = m_this.options('vertices');
    if (vertices.length) {
      vertices[vertices.length - 1] = evt.mapgcs;
      return true;
    }
    return undefined;
  };

  /**
   * Handle a mouse click on this annotation.  If the event is processed,
   * evt.handled should be set to `true` to prevent further processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string|undefined} `true` to update the annotation,
   *    `'done'` if the annotation was completed (changed from create to done
   *    state), `'remove'` if the annotation should be removed, falsy to not
   *    update anything.
   */
  this.mouseClick = function (evt) {
    var layer = m_this.layer();
    if (m_this.state() !== annotationState.create || !layer) {
      return undefined;
    }
    var end = !!evt.buttonsDown.right,
      skip;
    if (!evt.buttonsDown.left && !evt.buttonsDown.right) {
      return undefined;
    }
    var vertices = m_this.options('vertices');
    if (evt.buttonsDown.right && !vertices.length) {
      return undefined;
    }
    evt.handled = true;
    if (evt.buttonsDown.left) {
      if (vertices.length) {
        if (vertices.length >= 2 && layer.displayDistance(vertices[vertices.length - 2], null, evt.map, 'display') <= layer.options('adjacentPointProximity')) {
          skip = true;
          if (m_this._lastClick && evt.time - m_this._lastClick < layer.options('dblClickTime')) {
            end = true;
          }
        } else if (vertices.length >= 2 && layer.displayDistance(vertices[0], null, evt.map, 'display') <= layer.options('finalPointProximity')) {
          end = 'close';
        } else {
          vertices[vertices.length - 1] = evt.mapgcs;
        }
      } else {
        vertices.push(evt.mapgcs);
      }
      if (!end && !skip) {
        vertices.push(evt.mapgcs);
      }
      m_this._lastClick = evt.time;
      m_this._lastClickVertexCount = vertices.length;
    }
    if (end) {
      if (vertices.length < 3) {
        return 'remove';
      }
      vertices.pop();
      m_this.options('style').closed = end === 'close';
      m_this.state(annotationState.done);
      return 'done';
    }
    return !skip;
  };

  /**
   * Return actions needed for the specified state of this annotation.
   *
   * @param {string} [state] The state to return actions for.  Defaults to
   *    the current state.
   * @returns {geo.actionRecord[]} A list of actions.
   */
  this.actions = function (state) {
    return continuousVerticesActions(m_this, s_actions, state, 'line', arguments);
  };

  /**
   * Process any actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, `'done'` if the
   *    annotation was completed (changed from create to done state),
   *    `'remove'` if the annotation should be removed, falsy to not update
   *    anything.
   */
  this.processAction = function (evt) {
    return continuousVerticesProcessAction(m_this, evt, 'line');
  };

  /**
   * Return the coordinates to be stored in a geojson geometry object.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {array?} An array of flattened coordinates in the interface gcs
   *    coordinate system.  `undefined` if this annotation is incomplete.
   */
  this._geojsonCoordinates = function (gcs) {
    var src = m_this.coordinates(gcs);
    if (!src || src.length < 2 || m_this.state() === annotationState.create) {
      return undefined;
    }
    var coord = [];
    for (var i = 0; i < src.length; i += 1) {
      coord.push([src[i].x, src[i].y]);
    }
    return coord;
  };

  /**
   * Return the geometry type that is used to store this annotation in geojson.
   *
   * @returns {string} A geojson geometry type.
   */
  this._geojsonGeometryType = function () {
    return 'LineString';
  };

  /**
   * Return a list of styles that should be preserved in a geojson
   * representation of the annotation.
   *
   * @returns {string[]} A list of style names to store.
   */
  this._geojsonStyles = function () {
    return ['closed', 'lineCap', 'lineJoin', 'strokeColor', 'strokeOffset', 'strokeOpacity', 'strokeWidth'];
  };

  /**
   * Process any edit actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, falsy to not
   *    update anything.
   */
  this.processEditAction = function (evt) {
    switch (m_this._editHandle.handle.type) {
      case 'vertex':
        return m_this._processEditActionVertex(evt, true);
    }
    return s_processEditAction.apply(m_this, arguments);
  };

  /**
   * Handle a mouse click on this annotation when in edit mode.  If the event
   * is processed, evt.handled should be set to `true` to prevent further
   * processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string|undefined} `true` to update the annotation,
   *    `'done'` if the annotation was completed (changed from create to done
   *    state), `'remove'` if the annotation should be removed, falsy to not
   *    update anything.
   */
  this.mouseClickEdit = function (evt) {
    // if we get a left double click on an edge on a closed line, break the
    // line at that edge
    var layer = m_this.layer(),
      handle = m_this._editHandle,
      split;
    // ensure we are in edit mode and this is a left click
    if (m_this.state() !== annotationState.edit || !layer || !evt.buttonsDown.left) {
      return undefined;
    }
    // ensure this is an edge on a closed line
    if (!handle || !handle.handle.selected || handle.handle.type !== 'edge' || !m_this.options('style').closed) {
      return;
    }
    evt.handled = true;
    if (m_this._lastClick && evt.time - m_this._lastClick < layer.options('dblClickTime')) {
      split = true;
    }
    m_this._lastClick = evt.time;
    if (split) {
      var index = handle.handle.index,
        curPts = m_this._coordinates(),
        pts = curPts.slice(index + 1).concat(curPts.slice(0, index + 1));
      m_this._coordinates(pts);
      m_this.options('style').closed = false;
      handle.handle.index = undefined;
      return true;
    }
    return undefined;
  };
};
inherit(_lineAnnotation, annotation);

/**
 * This object contains the default options to initialize the class.
 */
_lineAnnotation.defaults = Object.assign({}, annotation.defaults, {
  style: {
    strokeColor: {
      r: 0,
      g: 0,
      b: 0
    },
    strokeOpacity: 1,
    strokeWidth: 3,
    closed: false,
    lineCap: 'butt',
    lineJoin: 'miter'
  },
  highlightStyle: {
    strokeWidth: 5
  },
  createStyle: {
    strokeColor: {
      r: 0,
      g: 0,
      b: 1
    },
    strokeOpacity: 1,
    strokeWidth: 3,
    closed: false,
    lineCap: 'butt',
    lineJoin: 'miter'
  },
  allowBooleanOperations: ['annotation-cut']
});
var lineRequiredFeatures = {};
lineRequiredFeatures[lineFeature.capabilities.basic] = [annotationState.create];
registerAnnotation('line', _lineAnnotation, lineRequiredFeatures);
module.exports = _lineAnnotation;

/***/ }),

/***/ 400:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var util = __webpack_require__(642);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var pointFeature = __webpack_require__(7541);
var annotation = (__webpack_require__(6978).annotation);
var annotationState = (__webpack_require__(6978).state);

/**
 * Point annotation specification.  Extends {@link geo.annotation.spec}.
 *
 * @typedef {object} geo.pointAnnotation.spec
 * @extends geo.annotation.spec
 * @property {geo.geoPosition} [position] A coordinate in map gcs coordinates.
 * @property {geo.geoPosition[]} [coordinates] An array with one coordinate to
 *    use in place of `position`.
 * @property {geo.pointFeature.styleSpec} [style] The style to apply to a
 *    finished point.  This uses styles for {@link geo.pointFeature}.
 * @property {boolean|number} [style.scaled=false] If `false`, the point is not
 *    scaled with zoom level.  If `true`, the radius is based on the zoom level
 *    at first instantiation.  If a number, the radius is used at the `scaled`
 *    zoom level.
 * @property {geo.pointFeature.styleSpec} [editStyle] The style to apply to a
 *    point in edit mode.
 */

/**
 * Point annotation class.
 *
 * @class
 * @alias geo.pointAnnotation
 * @extends geo.annotation
 *
 * @param {geo.pointAnnotation.spec?} [args] Options for the annotation.
 */
var _pointAnnotation = function pointAnnotation(args) {
  'use strict';

  if (!(this instanceof _pointAnnotation)) {
    return new _pointAnnotation(args);
  }
  args = util.deepMerge({}, this.constructor.defaults, args);
  args.position = args.position || (args.coordinates ? args.coordinates[0] : undefined);
  delete args.coordinates;
  annotation.call(this, 'point', args);
  var m_this = this;

  /**
   * Get a list of renderable features for this annotation.
   *
   * @returns {array} An array of features.
   */
  this.features = function () {
    var opt = m_this.options(),
      state = m_this.state(),
      features,
      style,
      scaleOnZoom;
    switch (state) {
      case annotationState.create:
        features = [];
        break;
      default:
        style = m_this.styleForState(state);
        if (opt.style.scaled || opt.style.scaled === 0) {
          if (opt.style.scaled === true) {
            opt.style.scaled = m_this.layer().map().zoom();
          }
          style = Object.assign({}, style, {
            radius: function radius() {
              var radius = opt.style.radius,
                zoom = m_this.layer().map().zoom();
              if (util.isFunction(radius)) {
                radius = radius.apply(m_this, arguments);
              }
              radius *= Math.pow(2, zoom - opt.style.scaled);
              return radius;
            }
          });
          scaleOnZoom = true;
        }
        features = [{
          point: {
            x: opt.position.x,
            y: opt.position.y,
            style: style,
            scaleOnZoom: scaleOnZoom
          }
        }];
        if (state === annotationState.edit) {
          m_this._addEditHandles(features, [opt.position], {
            edge: false,
            center: false,
            resize: false,
            rotate: false
          });
        }
        break;
    }
    return features;
  };

  /**
   * Get and optionally set coordinates associated with this annotation in the
   * map gcs coordinate system.
   *
   * @param {geo.geoPosition[]} [coordinates] An optional array of coordinates
   *  to set.
   * @returns {geo.geoPosition[]} The current array of coordinates.
   */
  this._coordinates = function (coordinates) {
    if (coordinates && coordinates.length >= 1) {
      m_this.options('position', coordinates[0]);
    }
    if (m_this.state() === annotationState.create) {
      return [];
    }
    return [m_this.options('position')];
  };
  this._coordinateOption = 'position';

  /**
   * Handle a mouse click on this annotation.  If the event is processed,
   * evt.handled should be set to `true` to prevent further processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string|undefined} `true` to update the annotation,
   *    `'done'` if the annotation was completed (changed from create to done
   *    state), `'remove'` if the annotation should be removed, falsy to not
   *    update anything.
   */
  this.mouseClick = function (evt) {
    if (m_this.state() !== annotationState.create) {
      return undefined;
    }
    if (!evt.buttonsDown.left) {
      return undefined;
    }
    evt.handled = true;
    m_this.options('position', evt.mapgcs);
    m_this.state(annotationState.done);
    return 'done';
  };

  /**
   * Return a list of styles that should be preserved in a geojson
   * representation of the annotation.
   *
   * @returns {string[]} A list of style names to store.
   */
  this._geojsonStyles = function () {
    return ['fill', 'fillColor', 'fillOpacity', 'radius', 'scaled', 'stroke', 'strokeColor', 'strokeOpacity', 'strokeWidth'];
  };

  /**
   * Return the coordinates to be stored in a geojson geometry object.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {array?} An array of flattened coordinates in the interface gcs
   *    coordinate system.  `undefined` if this annotation is incomplete.
   */
  this._geojsonCoordinates = function (gcs) {
    var src = m_this.coordinates(gcs);
    if (!src || m_this.state() === annotationState.create || src.length < 1 || src[0] === undefined) {
      return undefined;
    }
    return [src[0].x, src[0].y];
  };

  /**
   * Return the geometry type that is used to store this annotation in geojson.
   *
   * @returns {string} A geojson geometry type.
   */
  this._geojsonGeometryType = function () {
    return 'Point';
  };
};
inherit(_pointAnnotation, annotation);

/**
 * This object contains the default options to initialize the class.
 */
_pointAnnotation.defaults = Object.assign({}, annotation.defaults, {
  style: {
    fill: true,
    fillColor: {
      r: 0,
      g: 1,
      b: 0
    },
    fillOpacity: 0.25,
    radius: 10,
    scaled: false,
    stroke: true,
    strokeColor: {
      r: 0,
      g: 0,
      b: 0
    },
    strokeOpacity: 1,
    strokeWidth: 3
  },
  createStyle: {
    fillColor: {
      r: 0.3,
      g: 0.3,
      b: 0.3
    },
    fillOpacity: 0.25,
    strokeColor: {
      r: 0,
      g: 0,
      b: 1
    }
  },
  highlightStyle: {
    fillColor: {
      r: 0,
      g: 1,
      b: 1
    },
    fillOpacity: 0.5,
    strokeWidth: 5
  }
});
var pointRequiredFeatures = {};
pointRequiredFeatures[pointFeature.capabilities.feature] = true;
registerAnnotation('point', _pointAnnotation, pointRequiredFeatures);
module.exports = _pointAnnotation;

/***/ }),

/***/ 1920:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var lineFeature = __webpack_require__(9281);
var polygonFeature = __webpack_require__(6645);
var util = __webpack_require__(642);
var annotation = (__webpack_require__(6978).annotation);
var annotationState = (__webpack_require__(6978).state);
var continuousVerticesActions = (__webpack_require__(6978).continuousVerticesActions);
var continuousVerticesProcessAction = (__webpack_require__(6978).continuousVerticesProcessAction);

/**
 * Polygon annotation specification.  Extends {@link geo.annotation.spec}.
 *
 * @typedef {object} geo.polygonAnnotation.spec
 * @extends geo.annotation.spec
 * @property {geo.geoPosition[]} [vertices] A list of vertices in map gcs
 *    coordinates.  These must be in order around the perimeter of the polygon
 *    (in either direction).
 * @property {geo.geoPosition[]} [coordinates] An alternate name for
 *    `vertices`.
 * @property {geo.polygonFeature.styleSpec} [style] The style to apply to a
 *    finished polygon.  This uses styles for {@link geo.polygonFeature}.
 * @property {geo.polygonFeature.styleSpec} [editStyle] The style to apply to ai
 *    polygon in edit mode.
 */

/**
 * Polygon annotation class
 *
 * When complete, polygons are rendered as polygons.  During creation they are
 * rendered as lines and polygons.
 *
 * @class
 * @alias geo.polygonAnnotation
 * @extends geo.annotation
 *
 * @param {geo.polygonAnnotation.spec?} [args] Options for the annotation.
 */
var _polygonAnnotation = function polygonAnnotation(args) {
  'use strict';

  if (!(this instanceof _polygonAnnotation)) {
    return new _polygonAnnotation(args);
  }
  var m_this = this;
  args = util.deepMerge({
    style: {
      polygon: function polygon(d) {
        return d.polygon;
      }
    },
    createStyle: {
      line: function line(d) {
        var coord = m_this._coordinates();
        /* Return an array that has the same number of items as we have
         * vertices. */
        return Array((coord.outer || coord).length).fill(d);
      },
      position: function position(d, i) {
        if (d.x !== undefined) {
          return d;
        }
        return m_this.options('vertices')[i];
      }
    },
    cursorStyle: {
      position: util.identityFunction
    }
  }, this.constructor.defaults, args);
  args.vertices = args.vertices || args.coordinates || [];
  delete args.coordinates;
  annotation.call(this, 'polygon', args);
  var s_actions = this.actions,
    s_state = this.state;

  /**
   * Get a list of renderable features for this annotation.  When the polygon
   * is done, this is just a single polygon.  During creation this can be a
   * polygon and line at z-levels 1 and 2.
   *
   * @returns {array} An array of features.
   */
  this.features = function () {
    var opt = m_this.options(),
      state = m_this.state(),
      style = m_this.styleForState(state),
      features;
    switch (state) {
      case annotationState.create:
        features = [];
        if (opt.vertices && (opt.vertices.outer || opt.vertices.length >= 3)) {
          features[1] = {
            polygon: {
              polygon: opt.vertices,
              style: style
            }
          };
        }
        if (opt.vertices && opt.vertices.length >= 2) {
          features[2] = {
            line: {
              line: opt.vertices,
              style: style
            }
          };
        }
        break;
      default:
        features = [{
          polygon: {
            polygon: opt.vertices,
            style: style
          }
        }];
        if (state === annotationState.edit) {
          m_this._addEditHandles(features, opt.vertices);
        }
        break;
    }
    return features;
  };

  /**
   * Return this annotation as a polygon list.
   *
   * @param {geo.util.polyop.spec} [opts] Ignored.
   * @returns {geo.polygonList} A list of polygons.
   */
  this.toPolygonList = function (opts) {
    var coord = m_this._coordinates();
    if (coord.outer) {
      var result = [[coord.outer.map(function (pt) {
        return [pt.x, pt.y];
      })]];
      (coord.inner || []).forEach(function (h) {
        return result[0].push(h.map(function (pt) {
          return [pt.x, pt.y];
        }));
      });
      return result;
    }
    if (coord.length < 3 || !coord.map) {
      return [];
    }
    return [[coord.map(function (pt) {
      return [pt.x, pt.y];
    })]];
  };

  /**
   * Get and optionally set coordinates associated with this annotation in the
   * map gcs coordinate system.
   *
   * @param {geo.geoPosition[]} [coordinates] An optional array of coordinates
   *  to set.
   * @returns {geo.geoPosition[]} The current array of coordinates.
   */
  this._coordinates = function (coordinates) {
    if (coordinates) {
      m_this.options('vertices', coordinates);
    }
    return m_this.options('vertices');
  };

  /**
   * Handle a mouse move on this annotation.
   *
   * @param {geo.event} evt The mouse move event.
   * @returns {boolean?} Truthy to update the annotation, falsy to not
   *    update anything.
   */
  this.mouseMove = function (evt) {
    if (m_this.state() !== annotationState.create) {
      return undefined;
    }
    var vertices = m_this.options('vertices');
    if (vertices.length) {
      vertices[vertices.length - 1] = evt.mapgcs;
      return true;
    }
    return undefined;
  };

  /**
   * Handle a mouse click on this annotation.  If the event is processed,
   * evt.handled should be set to `true` to prevent further processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string|undefined} `true` to update the annotation,
   *    `'done'` if the annotation was completed (changed from create to done
   *    state), `'remove'` if the annotation should be removed, falsy to not
   *    update anything.
   */
  this.mouseClick = function (evt) {
    var layer = m_this.layer();
    if (m_this.state() !== annotationState.create || !layer) {
      return undefined;
    }
    var end = !!evt.buttonsDown.right,
      skip;
    if (!evt.buttonsDown.left && !evt.buttonsDown.right) {
      return undefined;
    }
    var vertices = m_this.options('vertices');
    if (evt.buttonsDown.right && !vertices.length) {
      return undefined;
    }
    evt.handled = true;
    if (evt.buttonsDown.left) {
      if (vertices.length) {
        if (vertices.length >= 2 && layer.displayDistance(vertices[vertices.length - 2], null, evt.map, 'display') <= layer.options('adjacentPointProximity')) {
          skip = true;
          if (m_this._lastClick && evt.time - m_this._lastClick < layer.options('dblClickTime')) {
            end = true;
          }
        } else if (vertices.length >= 2 && layer.displayDistance(vertices[0], null, evt.map, 'display') <= layer.options('finalPointProximity')) {
          end = true;
        } else {
          vertices[vertices.length - 1] = evt.mapgcs;
        }
      } else {
        vertices.push(evt.mapgcs);
      }
      if (!end && !skip) {
        vertices.push(evt.mapgcs);
      }
      m_this._lastClick = evt.time;
      m_this._lastClickVertexCount = vertices.length;
    }
    if (end) {
      if (vertices.length < 4) {
        return 'remove';
      }
      vertices.pop();
      m_this.state(annotationState.done);
      return 'done';
    }
    return !skip;
  };

  /**
   * Return actions needed for the specified state of this annotation.
   *
   * @param {string} [state] The state to return actions for.  Defaults to
   *    the current state.
   * @returns {geo.actionRecord[]} A list of actions.
   */
  this.actions = function (state) {
    return continuousVerticesActions(m_this, s_actions, state, 'polygon', arguments);
  };

  /**
   * Get or set the state of this annotation.
   *
   * @param {string|undefined} [arg] If `undefined`, return the state,
   *    otherwise change it.  This should be one of the
   *    {@link geo.annotation.state} values.
   * @returns {this|string} The current state or this annotation.
   * @fires geo.event.annotation.state
   */
  this.state = function (arg) {
    var oldState = s_state();
    if (arg && arg !== oldState && (oldState === annotationState.create || oldState === annotationState.edit) && arg === annotationState.done) {
      /* Uncross polygons when they are complete. */
      var opts = {
        style: 'object-listlist-outer-list'
      };
      var polys = util.polyops.union(m_this.options('vertices'), [], opts);
      var merged = true;
      while (polys.length > 1 && merged) {
        merged = false;
        for (var i = 0; !merged && i < polys[0].outer.length; i += 1) {
          var pt1 = polys[0].outer[i];
          for (var p = 1; !merged && p < polys.length; p += 1) {
            for (var j = 0; !merged && j < polys[p].outer.length; j += 1) {
              var pt2 = polys[p].outer[j];
              if (pt1.x === pt2.x && pt1.y === pt2.y) {
                polys[0].inner = polys[0].inner.concat(polys[p].inner);
                polys[0].outer = polys[0].outer.slice(0, i).concat(polys[p].outer.slice(j)).concat(polys[p].outer.slice(0, j)).concat(polys[0].outer.slice(i));
                polys.splice(p, 1);
                merged = true;
              }
            }
          }
        }
      }
      if (polys.length === 1) {
        m_this.options('vertices', polys[0].inner.length ? polys[0] : polys[0].outer);
      }
    }
    return s_state(arg);
  };

  /**
   * Process any actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, `'done'` if the
   *    annotation was completed (changed from create to done state),
   *    `'remove'` if the annotation should be removed, falsy to not update
   *    anything.
   */
  this.processAction = function (evt) {
    return continuousVerticesProcessAction(m_this, evt, 'polygon');
  };

  /**
   * Return the coordinates to be stored in a geojson geometry object.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {array?} An array of flattened coordinates in the interface gcs
   *    coordinate system.  `undefined` if this annotation is incomplete.
   */
  this._geojsonCoordinates = function (gcs) {
    var src = m_this.coordinates(gcs);
    if (!src || !src.outer && src.length < 3 || m_this.state() === annotationState.create) {
      return undefined;
    }
    var coord = [];
    if (!src.outer) {
      coord = [src.map(function (pt) {
        return [pt.x, pt.y];
      })];
      coord[0].push(coord[0][0].slice());
    } else {
      coord = [src.outer.map(function (pt) {
        return [pt.x, pt.y];
      })];
      coord[0].push(coord[0][0].slice());
      (src.inner || []).forEach(function (h) {
        var poly = h.map(function (pt) {
          return [pt.x, pt.y];
        });
        poly.push(poly[0].slice());
        coord.push(poly);
      });
    }
    return coord;
  };

  /**
   * Return the geometry type that is used to store this annotation in geojson.
   *
   * @returns {string} A geojson geometry type.
   */
  this._geojsonGeometryType = function () {
    return 'Polygon';
  };

  /**
   * Return a list of styles that should be preserved in a geojson
   * representation of the annotation.
   *
   * @returns {string[]} A list of style names to store.
   */
  this._geojsonStyles = function () {
    return ['fill', 'fillColor', 'fillOpacity', 'lineCap', 'lineJoin', 'stroke', 'strokeColor', 'strokeOffset', 'strokeOpacity', 'strokeWidth'];
  };
};
inherit(_polygonAnnotation, annotation);

/**
 * This object contains the default options to initialize the class.
 */
_polygonAnnotation.defaults = Object.assign({}, annotation.defaults, {
  style: {
    fill: true,
    fillColor: {
      r: 0,
      g: 1,
      b: 0
    },
    fillOpacity: 0.25,
    stroke: true,
    strokeColor: {
      r: 0,
      g: 0,
      b: 0
    },
    strokeOpacity: 1,
    strokeWidth: 3,
    uniformPolygon: true
  },
  highlightStyle: {
    fillColor: {
      r: 0,
      g: 1,
      b: 1
    },
    fillOpacity: 0.5,
    strokeWidth: 5
  },
  createStyle: {
    closed: false,
    fillColor: {
      r: 0.3,
      g: 0.3,
      b: 0.3
    },
    fillOpacity: 0.25,
    stroke: false,
    strokeColor: {
      r: 0,
      g: 0,
      b: 1
    }
  },
  cursorStyle: {
    closed: true,
    fillColor: {
      r: 0.3,
      g: 0.3,
      b: 0.3
    },
    fillOpacity: 0.25,
    stroke: true,
    strokeColor: {
      r: 0,
      g: 0,
      b: 1
    }
  },
  allowBooleanOperations: true
});
var polygonRequiredFeatures = {};
polygonRequiredFeatures[polygonFeature.capabilities.feature] = true;
polygonRequiredFeatures[lineFeature.capabilities.basic] = [annotationState.create];
registerAnnotation('polygon', _polygonAnnotation, polygonRequiredFeatures);
module.exports = _polygonAnnotation;

/***/ }),

/***/ 4019:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var geo_event = __webpack_require__(6409);
var geo_action = __webpack_require__(8695);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var polygonFeature = __webpack_require__(6645);
var util = __webpack_require__(642);
var annotation = (__webpack_require__(6978).annotation);
var annotationState = (__webpack_require__(6978).state);
var annotationActionOwner = (__webpack_require__(6978).annotationActionOwner);

/**
 * Rectangle annotation specification.  Extends {@link geo.annotation.spec}.
 *
 * @typedef {object} geo.rectangleAnnotation.spec
 * @extends geo.annotation.spec
 * @property {geo.geoPosition[]} [corners] A list of four corners in map gcs
 *    coordinates.  These must be in order around the perimeter of the
 *    rectangle (in either direction).
 * @property {geo.geoPosition[]} [coordinates] An alternate name for `corners`.
 * @property {geo.polygonFeature.styleSpec} [style] The style to apply to a
 *    finished rectangle.  This uses styles for {@link geo.polygonFeature}.
 * @property {geo.polygonFeature.styleSpec} [editStyle] The style to apply to a
 *    rectangle in edit mode.
 * @property {number|number[]|Function} [constraint] If specified, an aspect
 *    ratio or list of aspect ratios to constraint the rectangle to.  If a
 *    function, a selection constraint function to call to adjust the
 *    rectangle.
 */

/**
 * Rectangle annotation class.
 *
 * Rectangles are always rendered as polygons.  This could be changed -- if no
 * stroke is specified, the quad feature would be sufficient and work on more
 * renderers.
 *
 * @class
 * @alias geo.rectangleAnnotation
 * @extends geo.annotation
 *
 * @param {geo.rectangleAnnotation.spec?} [args] Options for the annotation.
 * @param {string} [annotationName] Override the annotation name.
 */
var _rectangleAnnotation = function rectangleAnnotation(args, annotationName) {
  'use strict';

  if (!(this instanceof _rectangleAnnotation)) {
    return new _rectangleAnnotation(args, annotationName);
  }
  args = util.deepMerge({}, this.constructor.defaults, args);
  args.corners = args.corners || args.coordinates || [];
  delete args.coordinates;
  annotation.call(this, annotationName || 'rectangle', args);
  var m_this = this,
    s_actions = this.actions,
    s_processEditAction = this.processEditAction;

  /**
   * Return actions needed for the specified state of this annotation.
   *
   * @param {string} [state] The state to return actions for.  Defaults to
   *    the current state.
   * @returns {geo.actionRecord[]} A list of actions.
   */
  this.actions = function (state) {
    if (!state) {
      state = m_this.state();
    }
    switch (state) {
      case annotationState.create:
        return [{
          action: geo_action.annotation_rectangle,
          name: 'rectangle create',
          owner: annotationActionOwner,
          input: 'left',
          selectionRectangle: true,
          selectionConstraint: this._selectionConstraint
        }];
      default:
        return s_actions.apply(m_this, arguments);
    }
  };

  /**
   * Process any actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string|undefined} `true` to update the annotation,
   *    `'done'` if the annotation was completed (changed from create to done
   *    state), `'remove'` if the annotation should be removed, falsy to not
   *    update anything.
   */
  this.processAction = function (evt) {
    var layer = m_this.layer();
    if (m_this.state() !== annotationState.create || !layer || evt.event !== geo_event.actionselection || evt.state.action !== geo_action.annotation_rectangle) {
      return undefined;
    }
    var map = layer.map(),
      corners = [/* Keep in map gcs, not interface gcs to avoid wrapping issues */
      map.displayToGcs({
        x: evt.lowerLeft.x,
        y: evt.lowerLeft.y
      }, null), map.displayToGcs({
        x: evt.lowerLeft.x,
        y: evt.upperRight.y
      }, null), map.displayToGcs({
        x: evt.upperRight.x,
        y: evt.upperRight.y
      }, null), map.displayToGcs({
        x: evt.upperRight.x,
        y: evt.lowerLeft.y
      }, null)];
    if (this._selectionConstraint && evt.mouse && evt.state.origin) {
      this._selectionConstraint(evt.mouse.mapgcs, evt.state.origin.mapgcs, corners);
    }
    /* Don't keep rectangles that have nearly zero area in display pixels */
    if (layer.displayDistance(corners[0], null, corners[1], null) * layer.displayDistance(corners[0], null, corners[3], null) < 0.01) {
      return 'remove';
    }
    m_this.options('corners', corners);
    m_this.state(annotationState.done);
    return 'done';
  };

  /**
   * Get a list of renderable features for this annotation.
   *
   * @returns {array} An array of features.
   */
  this.features = function () {
    var opt = m_this.options(),
      state = m_this.state(),
      features;
    features = [];
    if (opt.corners && opt.corners.length >= 4) {
      features = [{
        polygon: {
          polygon: opt.corners,
          style: m_this.styleForState(state)
        }
      }];
    }
    if (state === annotationState.edit) {
      m_this._addEditHandles(features, opt.corners);
    }
    return features;
  };

  /**
   * Return this annotation as a polygon list.
   *
   * @param {geo.util.polyop.spec} [opts] Ignored.
   * @returns {geo.polygonList} A list of polygons.
   */
  this.toPolygonList = function (opts) {
    if (m_this._coordinates().length < 3) {
      return [];
    }
    return [[m_this._coordinates().map(function (pt) {
      return [pt.x, pt.y];
    })]];
  };

  /**
   * Get and optionally set coordinates associated with this annotation in the
   * map gcs coordinate system.
   *
   * @param {geo.geoPosition[]} [coordinates] An optional array of coordinates
   *  to set.
   * @returns {geo.geoPosition[]} The current array of coordinates.
   */
  this._coordinates = function (coordinates) {
    if (coordinates && coordinates.length >= 4) {
      m_this.options('corners', coordinates.slice(0, 4));
      /* Should we ensure that the four points form a rectangle in the current
       * projection, though this might not be rectangular in another gcs? */
    }
    return m_this.options('corners');
  };
  this._coordinateOption = 'corners';

  /**
   * Return the coordinates to be stored in a geojson geometry object.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {array?} An array of flattened coordinates in the interface gcs
   *    coordinate system.  `undefined` if this annotation is incomplete.
   */
  this._geojsonCoordinates = function (gcs) {
    var src = m_this.coordinates(gcs);
    if (!src || m_this.state() === annotationState.create || src.length < 4) {
      return undefined;
    }
    var coord = [];
    for (var i = 0; i < 4; i += 1) {
      coord.push([src[i].x, src[i].y]);
    }
    coord.push([src[0].x, src[0].y]);
    return [coord];
  };

  /**
   * Return the geometry type that is used to store this annotation in geojson.
   *
   * @returns {string} A geojson geometry type.
   */
  this._geojsonGeometryType = function () {
    return 'Polygon';
  };

  /**
   * Return a list of styles that should be preserved in a geojson
   * representation of the annotation.
   *
   * @returns {string[]} A list of style names to store.
   */
  this._geojsonStyles = function () {
    return ['fill', 'fillColor', 'fillOpacity', 'lineCap', 'lineJoin', 'stroke', 'strokeColor', 'strokeOffset', 'strokeOpacity', 'strokeWidth'];
  };

  /**
   * Set three corners based on an initial corner and a mouse event.
   *
   * @param {geo.geoPosition} corners An array of four corners to update.
   * @param {geo.event} evt The mouse move event.
   */
  this._setCornersFromMouse = function (corners, evt) {
    var map = m_this.layer().map(),
      c0 = map.gcsToDisplay({
        x: corners[0].x,
        y: corners[0].y
      }, null),
      c2 = map.gcsToDisplay(evt.mapgcs, null),
      c1 = {
        x: c2.x,
        y: c0.y
      },
      c3 = {
        x: c0.x,
        y: c2.y
      };
    corners[2] = Object.assign({}, evt.mapgcs);
    corners[1] = map.displayToGcs(c1, null);
    corners[3] = map.displayToGcs(c3, null);
    if (this._selectionConstraint) {
      this._selectionConstraint(evt.mapgcs, corners[0], corners);
    }
  };

  /**
   * Handle a mouse move on this annotation.
   *
   * @param {geo.event} evt The mouse move event.
   * @returns {boolean?} Truthy to update the annotation, falsy to not
   *    update anything.
   */
  this.mouseMove = function (evt) {
    if (m_this.state() !== annotationState.create) {
      return undefined;
    }
    var corners = m_this.options('corners');
    if (corners.length) {
      m_this._setCornersFromMouse(corners, evt);
      return true;
    }
    return undefined;
  };

  /**
   * Handle a mouse click on this annotation.  If the event is processed,
   * evt.handled should be set to `true` to prevent further processing.
   *
   * @param {geo.event} evt The mouse click event.
   * @returns {boolean|string|undefined} `true` to update the annotation,
   *    `'done'` if the annotation was completed (changed from create to done
   *    state), `'remove'` if the annotation should be removed, falsy to not
   *    update anything.
   */
  this.mouseClick = function (evt) {
    var layer = m_this.layer();
    if (m_this.state() !== annotationState.create || !layer) {
      return undefined;
    }
    if (!evt.buttonsDown.left && !evt.buttonsDown.right) {
      return undefined;
    }
    var corners = m_this.options('corners');
    if (evt.buttonsDown.right && !corners.length) {
      return undefined;
    }
    evt.handled = true;
    if (corners.length) {
      m_this._setCornersFromMouse(corners, evt);
      /* Don't keep rectangles that have nearly zero area in display pixels */
      if (layer.displayDistance(corners[0], null, corners[1], null) * layer.displayDistance(corners[0], null, corners[3], null) < 0.01) {
        return 'remove';
      }
      m_this.state(annotationState.done);
      return 'done';
    }
    if (evt.buttonsDown.left) {
      corners.push(Object.assign({}, evt.mapgcs));
      corners.push(Object.assign({}, evt.mapgcs));
      corners.push(Object.assign({}, evt.mapgcs));
      corners.push(Object.assign({}, evt.mapgcs));
      return true;
    }
    return undefined;
  };

  /**
   * Process any edit actions for this annotation.
   *
   * @param {geo.event} evt The action event.
   * @returns {boolean|string} `true` to update the annotation, falsy to not
   *    update anything.
   */
  this.processEditAction = function (evt) {
    var start = m_this._editHandle.startCoordinates,
      delta = {
        x: evt.mouse.mapgcs.x - evt.state.origin.mapgcs.x,
        y: evt.mouse.mapgcs.y - evt.state.origin.mapgcs.y
      },
      type = m_this._editHandle.handle.type,
      index = m_this._editHandle.handle.index,
      ang = [Math.atan2(start[1].y - start[0].y, start[1].x - start[0].x), Math.atan2(start[2].y - start[1].y, start[2].x - start[1].x), Math.atan2(start[3].y - start[2].y, start[3].x - start[2].x), Math.atan2(start[0].y - start[3].y, start[0].x - start[3].x)],
      corners,
      delta1,
      delta2,
      ang1,
      ang2;
    // an angle can be zero because it is horizontal or undefined.  If opposite
    // angles are both zero, this is a degenerate rectangle (a line or a point)
    if (!ang[0] && !ang[1] && !ang[2] && !ang[3]) {
      ang[1] = Math.PI / 2;
      ang[2] = Math.PI;
      ang[3] = -Math.PI / 2;
    }
    if (!ang[0] && !ang[2]) {
      ang[0] = ang[1] - Math.PI / 2;
      ang[2] = ang[1] + Math.PI / 2;
    }
    if (!ang[1] && !ang[3]) {
      ang[1] = ang[2] - Math.PI / 2;
      ang[3] = ang[2] + Math.PI / 2;
    }
    switch (type) {
      case 'vertex':
        corners = start.map(function (elem) {
          return {
            x: elem.x,
            y: elem.y
          };
        });
        ang1 = ang[(index + 1) % 4];
        delta1 = {
          x: (delta.x * Math.cos(ang1) + delta.y * Math.sin(ang1)) * Math.cos(ang1),
          y: (delta.y * Math.sin(ang1) + delta.x * Math.cos(ang1)) * Math.sin(ang1)
        };
        ang2 = ang[index];
        delta2 = {
          x: (delta.x * Math.cos(ang2) + delta.y * Math.sin(ang2)) * Math.cos(ang2),
          y: (delta.y * Math.sin(ang2) + delta.x * Math.cos(ang2)) * Math.sin(ang2)
        };
        corners[index].x += delta.x;
        corners[index].y += delta.y;
        corners[(index + 1) % 4].x += delta1.x;
        corners[(index + 1) % 4].y += delta1.y;
        corners[(index + 3) % 4].x += delta2.x;
        corners[(index + 3) % 4].y += delta2.y;
        if (this._selectionConstraint) {
          corners = this._selectionConstraint(evt.mouse.mapgcs, evt.state.origin.mapgcs, corners, 'vertex', ang, index).corners;
        }
        m_this.options('corners', corners);
        return true;
      case 'edge':
        corners = start.map(function (elem) {
          return {
            x: elem.x,
            y: elem.y
          };
        });
        ang1 = ang[(index + 1) % 4];
        delta = {
          x: (delta.x * Math.cos(ang1) + delta.y * Math.sin(ang1)) * Math.cos(ang1),
          y: (delta.y * Math.sin(ang1) + delta.x * Math.cos(ang1)) * Math.sin(ang1)
        };
        corners[index].x += delta.x;
        corners[index].y += delta.y;
        corners[(index + 1) % 4].x += delta.x;
        corners[(index + 1) % 4].y += delta.y;
        if (this._selectionConstraint) {
          corners = this._selectionConstraint(evt.mouse.mapgcs, evt.state.origin.mapgcs, corners, 'edge', ang, index).corners;
        }
        m_this.options('corners', corners);
        return true;
    }
    return s_processEditAction.apply(m_this, arguments);
  };
};
inherit(_rectangleAnnotation, annotation);

/**
 * This object contains the default options to initialize the class.
 */
_rectangleAnnotation.defaults = Object.assign({}, annotation.defaults, {
  style: {
    fill: true,
    fillColor: {
      r: 0,
      g: 1,
      b: 0
    },
    fillOpacity: 0.25,
    polygon: function polygon(d) {
      return d.polygon;
    },
    stroke: true,
    strokeColor: {
      r: 0,
      g: 0,
      b: 0
    },
    strokeOpacity: 1,
    strokeWidth: 3,
    uniformPolygon: true
  },
  highlightStyle: {
    fillColor: {
      r: 0,
      g: 1,
      b: 1
    },
    fillOpacity: 0.5,
    strokeWidth: 5
  },
  createStyle: {
    fillColor: {
      r: 0.3,
      g: 0.3,
      b: 0.3
    },
    fillOpacity: 0.25,
    strokeColor: {
      r: 0,
      g: 0,
      b: 1
    }
  },
  allowBooleanOperations: true
});
var rectangleRequiredFeatures = {};
rectangleRequiredFeatures[polygonFeature.capabilities.feature] = true;
registerAnnotation('rectangle', _rectangleAnnotation, rectangleRequiredFeatures);
module.exports = _rectangleAnnotation;

/***/ }),

/***/ 5229:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerAnnotation = (__webpack_require__(1098).registerAnnotation);
var polygonFeature = __webpack_require__(6645);
var util = __webpack_require__(642);
var rectangleAnnotation = __webpack_require__(4019);

/**
 * Square annotation class.
 *
 * Squares are a subset of rectangles with a fixed aspect ratio.
 *
 * @class
 * @alias geo.squareAnnotation
 * @extends geo.annotation
 *
 * @param {geo.squareAnnotation.spec?} [args] Options for the annotation.
 * @param {string} [annotationName] Override the annotation name.
 */
var _squareAnnotation = function squareAnnotation(args, annotationName) {
  'use strict';

  if (!(this instanceof _squareAnnotation)) {
    return new _squareAnnotation(args, annotationName);
  }
  args = util.deepMerge({}, this.constructor.defaults, args, {
    constraint: 1
  });
  rectangleAnnotation.call(this, args, annotationName || 'square');
};
inherit(_squareAnnotation, rectangleAnnotation);

/**
 * This object contains the default options to initialize the class.
 */
_squareAnnotation.defaults = Object.assign({}, rectangleAnnotation.defaults, {});
var squareRequiredFeatures = {};
squareRequiredFeatures[polygonFeature.capabilities.feature] = true;
registerAnnotation('square', _squareAnnotation, squareRequiredFeatures);
module.exports = _squareAnnotation;

/***/ }),

/***/ 2075:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var inherit = __webpack_require__(4626);
var featureLayer = __webpack_require__(6498);
var geo_annotation = __webpack_require__(4655);
var geo_event = __webpack_require__(6409);
var registry = __webpack_require__(1098);
var transform = __webpack_require__(5325);
var $ = __webpack_require__(5616);
var Mousetrap = __webpack_require__(7549);
var textFeature = __webpack_require__(6546);
var lineAnnotation = __webpack_require__(2612);

/**
 * Object specification for an annotation layer.
 *
 * @typedef {geo.layer.spec} geo.annotationLayer.spec
 * @extends {geo.layer.spec}
 * @property {number} [dblClickTime=300] The delay in milliseconds that is
 *   treated as a double-click when working with annotations.
 * @property {number} [adjacentPointProximity=5] The minimum distance in
 *   display coordinates (pixels) between two adjacent points when creating a
 *   polygon or line.  A value of 0 requires an exact match.
 * @property {number} [continuousPointProximity=5] The minimum distance in
 *   display coordinates (pixels) between two adjacent points when dragging
 *   to create an annotation.  `false` disables continuous drawing mode.
 * @property {number} [continuousPointCollinearity=1.0deg] The minimum angle
 *   between a series of three points when dragging to not interpret them as
 *   collinear.  Only applies if `continuousPointProximity` is not `false`.
 * @property {number} [continuousCloseProximity=10] The minimum distance in
 *   display coordinates (pixels) to close a polygon or end drawing a line when
 *   dragging to create an annotation.  `false` never closes at the end of a
 *   drag.  `true` is effectively infinite.
 * @property {number} [finalPointProximity=10] The maximum distance in display
 *   coordinates (pixels) between the starting point and the mouse coordinates
 *   to signal closing a polygon.  A value of 0 requires an exact match.  A
 *   negative value disables closing a polygon by clicking on the start point.
 * @property {boolean} [showLabels=true] Truthy to show feature labels that are
 *   allowed by the associated feature to be shown.
 * @property {boolean} [clickToEdit=false] Truthy to allow clicking an
 *   annotation to place it in edit mode.
 * @property {geo.textFeature.styleSpec} [defaultLabelStyle] Default styles for
 *   labels.
 */

/**
 * @typedef {object} geo.annotationLayer.labelRecord
 * @property {string} text The text of the label
 * @property {geo.geoPosition} position The position of the label in map gcs
 *    coordinates.
 * @property {geo.textFeature.styleSpec} [style] A {@link geo.textFeature}
 *    style object.
 */

/**
 * @typedef {geo.util.polyop.spec} geo.util.polyop.annotationLayerSpec
 * @extends {geo.util.polyop.spec}
 * @property {string} [keepAnnotations='exact'] Determine which annotations are
 *   present after a boolean operation.  `'exact'` replaces modified
 *   annotations with the results; unmodified annotations are left as is.
 *   `'all'` replaces all annotations, so unchanged annotations may be
 *   converted to polygonAnnotations.  `'none'` discards all existing
 *   annotations and only keeps modified results.
 */

/**
 * Layer to handle direct interactions with different features.  Annotations
 * (features) can be created by calling mode(<name of feature>) or cancelled
 * with mode(null).  There is also an "edit" mode which is used when modifying
 * an annotation.
 *
 * @class
 * @alias geo.annotationLayer
 * @extends geo.featureLayer
 * @param {geo.annotationLayer.spec} [arg] Specification for the new layer.
 * @returns {geo.annotationLayer}
 * @fires geo.event.annotation.state
 * @fires geo.event.annotation.coordinates
 * @fires geo.event.annotation.edit_action
 * @fires geo.event.annotation.select_edit_handle
 */
var _annotationLayer = function annotationLayer(arg) {
  'use strict';

  if (!(this instanceof _annotationLayer)) {
    return new _annotationLayer(arg);
  }
  featureLayer.call(this, arg);
  var mapInteractor = __webpack_require__(7908);
  var timestamp = __webpack_require__(77);
  var util = __webpack_require__(642);
  var m_this = this,
    s_init = this._init,
    s_exit = this._exit,
    s_draw = this.draw,
    s_update = this._update,
    m_buildTime = timestamp(),
    m_options,
    m_mode = null,
    m_annotations = [],
    m_annotationIds = {},
    m_features = [],
    m_labelFeature,
    m_labelLayer,
    m_keyHandler;
  var geojsonStyleProperties = {
    closed: {
      dataType: 'boolean',
      keys: ['closed', 'close']
    },
    fill: {
      dataType: 'boolean',
      keys: ['fill']
    },
    fillColor: {
      dataType: 'color',
      keys: ['fillColor', 'fill-color', 'marker-color', 'fill']
    },
    fillOpacity: {
      dataType: 'opacity',
      keys: ['fillOpacity', 'fill-opacity']
    },
    lineCap: {
      dataType: 'text',
      keys: ['lineCap', 'line-cap']
    },
    lineJoin: {
      dataType: 'text',
      keys: ['lineJoin', 'line-join']
    },
    radius: {
      dataType: 'positive',
      keys: ['radius']
    },
    scaled: {
      dataType: 'booleanOrNumber',
      keys: ['scaled']
    },
    stroke: {
      dataType: 'boolean',
      keys: ['stroke']
    },
    strokeColor: {
      dataType: 'color',
      keys: ['strokeColor', 'stroke-color', 'stroke']
    },
    strokeOffset: {
      dataType: 'number',
      keys: ['strokeOffset', 'stroke-offset']
    },
    strokeOpacity: {
      dataType: 'opacity',
      keys: ['strokeOpacity', 'stroke-opacity']
    },
    strokeWidth: {
      dataType: 'positive',
      keys: ['strokeWidth', 'stroke-width']
    }
  };
  var textFeatureDataTypes = {
    offset: 'coordinate2',
    rotateWithMap: 'boolean',
    rotation: 'angle',
    scaleWithMap: 'boolean',
    scale: 'booleanOrNumber',
    shadowBlur: 'numberOrBlank',
    shadowOffset: 'coordinate2',
    strokeWidth: 'numberOrBlank',
    visible: 'boolean'
  };
  textFeature.usedStyles.forEach(function (key) {
    geojsonStyleProperties[key] = {
      option: 'labelStyle',
      dataType: textFeatureDataTypes[key] || 'text',
      keys: [key, 'label' + key.charAt(0).toUpperCase() + key.slice(1), key.replace(/([A-Z])/g, '-$1').toLowerCase(), 'label-' + key.replace(/([A-Z])/g, '-$1').toLowerCase()]
    };
  });
  m_options = util.deepMerge({}, {
    dblClickTime: 300,
    adjacentPointProximity: 5,
    // in pixels, 0 is exact
    // in pixels; set to continuousPointProximity to false to disable
    // continuous drawing modes.
    continuousPointProximity: 5,
    // in radians, minimum angle between continuous points to interpret them as
    // being collinear
    continuousPointCollinearity: 1.0 * Math.PI / 180,
    continuousCloseProximity: 10,
    // in pixels, 0 is exact
    finalPointProximity: 10,
    // in pixels, 0 is exact
    showLabels: true,
    clickToEdit: false
  }, arg);

  /**
   * Process an action event.  If we are in rectangle-creation mode, this
   * creates a rectangle.
   *
   * @param {geo.event} evt The selection event.
   * @fires geo.event.annotation.edit_action
   */
  this._processAction = function (evt) {
    var update;
    if (evt.state && evt.state.actionRecord && evt.state.actionRecord.owner === geo_annotation.actionOwner && m_this.currentAnnotation) {
      switch (m_this.mode()) {
        case m_this.modes.edit:
          update = m_this.currentAnnotation.processEditAction(evt);
          if (m_this.currentAnnotation && m_this.currentAnnotation._editHandle && m_this.currentAnnotation._editHandle.handle) {
            m_this.geoTrigger(geo_event.annotation.edit_action, {
              annotation: m_this.currentAnnotation,
              handle: m_this.currentAnnotation._editHandle ? m_this.currentAnnotation._editHandle.handle : undefined,
              action: evt.event
            });
            if (evt.event === geo_event.actionup) {
              m_this._selectEditHandle({
                data: m_this.currentAnnotation._editHandle.handle
              }, m_this.currentAnnotation._editHandle.handle.selected);
            }
          }
          break;
        case m_this.modes.cursor:
          m_this.currentAnnotation._cursorHandleMousemove(evt.mouse);
          update = m_this.currentAnnotation.processAction(evt);
          m_this.geoTrigger(geo_event.annotation.cursor_action, {
            annotation: m_this.currentAnnotation,
            operation: m_this.currentBooleanOperation(),
            evt: evt
          });
          break;
        default:
          update = m_this.currentAnnotation.processAction(evt);
          break;
      }
    }
    m_this._updateFromEvent(update);
  };

  /**
   * Check if there is a current boolean operation.
   *
   * @returns {string?} Either undefined for no current boolean operation or
   *   the name of the operation.
   */
  this.currentBooleanOperation = function () {
    var op;
    if (m_this._currentBooleanClass) {
      op = m_this._currentBooleanClass.split('-')[1];
    }
    return op;
  };

  /**
   * Check if the map is currently in a mode where we are adding an annotation
   * with a boolean operation.  If so, remove the current annotation from the
   * layer, then apply it via the boolean operation.
   */
  this._handleBooleanOperation = function () {
    var op = m_this.currentBooleanOperation();
    if (!op || !m_this.currentAnnotation || !m_this.currentAnnotation.toPolygonList && (op !== 'cut' || !(m_this.currentAnnotation instanceof lineAnnotation))) {
      return;
    }
    var newAnnot = m_this.currentAnnotation;
    m_this.removeAnnotation(m_this.currentAnnotation, false);
    if (m_this.annotations().length || op !== 'difference' && op !== 'intersect') {
      var evt = {
        annotation: newAnnot,
        operation: op
      };
      m_this.geoTrigger(geo_event.annotation.boolean, evt);
      if (evt.cancel !== false) {
        if (op !== 'cut') {
          util.polyops[op](m_this, newAnnot.toPolygonList(), {
            correspond: {},
            keepAnnotations: 'exact',
            style: m_this
          });
        } else {
          m_this.cutOperation(newAnnot);
        }
      }
    }
  };

  /**
   * Given a line defined by two points, extend the first point to intersect a
   * bounding box.
   *
   * @param {number[]} p1 A 2-coordinate point.
   * @param {number[]} p2 A 2-coordinate point.
   * @param {object} bbox A bounding box consisting on min and max, each of
   *    which has x and y.
   * @returns {number[]} A 2-coordinate point.
   */
  this._extendLine = function (p1, p2, bbox) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    if (!dx && !dy) {
      return p1;
    }
    var best;
    var t = ((dx > 0 ? bbox.min.x : bbox.max.x) - p1[0]) / (dx || 1);
    if (t < 0) {
      var y = p1[1] + t * dy;
      if (y >= bbox.min.y && y <= bbox.max.y) {
        best = [dx > 0 ? bbox.min.x : bbox.max.x, y];
      }
    }
    t = ((dy > 0 ? bbox.min.y : bbox.max.y) - p1[1]) / (dy || 1);
    if (t < 0) {
      var x = p1[0] + t * dx;
      if (x >= bbox.min.x && x <= bbox.max.x && (!best || t < (bbox.min.x - p1[0]) / dx)) {
        best = [x, dy > 0 ? bbox.min.y : bbox.max.y];
      }
    }
    return best;
  };

  /**
   * Convert a line annotation to a polygonList.
   *
   * @param {geo.annotation} cutLine The line to convert.
   * @returns {geo.polygonList} A list of polygons.
   */
  this._cutLineToPoly = function (cutLine) {
    var cutPts = cutLine.coordinates(null).map(function (p) {
      return [p.x, p.y];
    });
    var range;
    for (var p = 0; p < cutPts.length; p += 1) {
      var x = cutPts[p][0];
      var y = cutPts[p][1];
      if (!p) {
        range = {
          min: {
            x: x,
            y: y
          },
          max: {
            x: x,
            y: y
          }
        };
      }
      if (x < range.min.x) {
        range.min.x = x;
      }
      if (y < range.min.y) {
        range.min.y = y;
      }
      if (x > range.max.x) {
        range.max.x = x;
      }
      if (y > range.max.y) {
        range.max.y = y;
      }
    }
    var polylist = m_this.toPolygonList();
    for (var poly = 0; poly < polylist.length; poly += 1) {
      for (var h = 0; h < polylist[poly].length; h += 1) {
        for (var _p = 0; _p < polylist[poly][h].length; _p += 1) {
          var _x = polylist[poly][h][_p][0];
          var _y = polylist[poly][h][_p][1];
          if (_x < range.min.x) {
            range.min.x = _x;
          }
          if (_y < range.min.y) {
            range.min.y = _y;
          }
          if (_x > range.max.x) {
            range.max.x = _x;
          }
          if (_y > range.max.y) {
            range.max.y = _y;
          }
        }
      }
    }
    m_this.annotations().forEach(function (annot) {
      if (annot instanceof lineAnnotation) {
        var pts = annot.coordinates(null);
        for (var _p2 = 0; _p2 < pts.length; _p2 += 1) {
          var _x2 = pts[_p2].x;
          var _y2 = pts[_p2].y;
          if (_x2 < range.min.x) {
            range.min.x = _x2;
          }
          if (_y2 < range.min.y) {
            range.min.y = _y2;
          }
          if (_x2 > range.max.x) {
            range.max.x = _x2;
          }
          if (_y2 > range.max.y) {
            range.max.y = _y2;
          }
        }
      }
    });
    if (range === undefined || range.min.x === range.max.x || range.min.y === range.max.y) {
      return [];
    }
    // expand the range so that all polygons and lines, including our cut line
    // are guaranteed to be inside the bounding box.
    range = {
      min: {
        x: range.min.x - (range.max.x - range.min.x) * 0.01,
        y: range.min.y - (range.max.y - range.min.y) * 0.01
      },
      max: {
        x: range.max.x + (range.max.x - range.min.x) * 0.01,
        y: range.max.y + (range.max.y - range.min.y) * 0.01
      }
    };
    // we convert our line annotation so it expands past our bounding box, then
    // close it on the left / top.  Our polygons will be the set that is cut
    // and the set that is union with this.
    cutPts[0] = m_this._extendLine(cutPts[0], cutPts[1], range);
    cutPts[cutPts.length - 1] = m_this._extendLine(cutPts[cutPts.length - 1], cutPts[cutPts.length - 2], range);
    var cutPoly = cutPts.slice();
    var corners = [[range.min.x, range.min.y], [range.max.x, range.min.y], [range.max.x, range.max.y], [range.min.x, range.max.y]];
    var n = cutPoly.length - 1;
    var idx0 = cutPoly[n][0] === range.min.x ? 0 : cutPoly[n][1] === range.min.y ? 1 : cutPoly[n][0] === range.max.x ? 2 : 3;
    var idx1 = cutPoly[0][0] === range.min.x ? 0 : cutPoly[0][1] === range.min.y ? 1 : cutPoly[0][0] === range.max.x ? 2 : 3;
    for (var idx = idx0; idx % 4 !== idx1; idx += 1) {
      cutPoly.push(corners[idx % 4]);
    }
    return [[cutPoly]];
  };

  /**
   * Given a cut line or polygon, cut existing polygons and lines.
   *
   * @param {geo.annotation} cutLineOrPoly The line or polygon to use to cut
   *    the existing annotations.
   */
  this.cutOperation = function (cutLineOrPoly) {
    var cutPoly;
    if (cutLineOrPoly instanceof lineAnnotation) {
      cutPoly = this._cutLineToPoly(cutLineOrPoly);
    } else {
      cutPoly = cutLineOrPoly.toPolygonList();
    }
    // mimic some of what is done in fromPolygonList because we need both sides
    // of the cut.
    var diffPoly;
    var annot = m_this.annotations();
    var diff = {
      poly2: cutPoly,
      correspond: {},
      keepAnnotations: 'exact',
      style: {
        fromPolygonList: function fromPolygonList(poly, opts) {
          diffPoly = poly;
        }
      }
    };
    diff.poly1 = m_this.toPolygonList(diff);
    util.polyops.difference(diff);
    util.polyops.intersect(m_this, cutPoly, {
      correspond: {},
      keepAnnotations: 'exact',
      style: m_this
    });
    var indices = (diff.annotationIndices || {})[m_this.id()];
    var correspond = diff.correspond.poly1;
    var exact = diff.correspond.exact1;
    diffPoly.forEach(function (p, idx) {
      p = p.map(function (h) {
        return h.map(function (pt) {
          return {
            x: pt[0],
            y: pt[1]
          };
        });
      });
      var result = {
        vertices: p.length === 1 ? p[0] : {
          outer: p[0],
          inner: p.slice(1)
        }
      };
      var _loop = function _loop() {
          if (correspond[i] && correspond[i].indexOf(idx) >= 0) {
            var orig = annot[indices[i]];
            if (exact[i] && exact[i].indexOf(idx) >= 0) {
              m_this.addAnnotation(orig, m_this.map().gcs(), false);
              return {
                v: void 0
              };
            }
            ['name', 'description', 'label'].forEach(function (k) {
              if (orig[k](undefined, true)) {
                result[k] = orig[k](undefined, true);
              }
            });
            Object.entries(orig.options()).forEach(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                key = _ref2[0],
                value = _ref2[1];
              if (['showLabel', 'style'].indexOf(key) >= 0 || key.endsWith('Style')) {
                result[key] = value;
              }
            });
            m_this.addAnnotation(registry.createAnnotation('polygon', result), m_this.map().gcs(), false);
            return {
              v: void 0
            };
          }
        },
        _ret;
      for (var i = 0; i < correspond.length; i += 1) {
        _ret = _loop();
        if (_ret) return _ret.v;
      }
      m_this.addAnnotation(registry.createAnnotation('polygon', result), m_this.map().gcs(), false);
    });
    // Add cutting lines here
  };

  /**
   * Handle updating the current annotation based on an update state.
   *
   * @param {string|undefined} update Truthy to update.  `'done'` if the
   *    annotation was completed and the mode should return to `null`.
   *    `'remove'` to remove the current annotation and set the mode to `null`.
   *    Falsy to do nothing.
   */
  this._updateFromEvent = function (update) {
    switch (update) {
      case 'remove':
        m_this.removeAnnotation(m_this.currentAnnotation, false);
        m_this.mode(null);
        break;
      case 'done':
        m_this._handleBooleanOperation();
        m_this.mode(null);
        break;
    }
    if (update) {
      m_this.modified();
      m_this.draw();
    }
  };

  /**
   * Check the state of the modifier keys and apply them if appropriate.
   *
   * @param {geo.event} evt The mouse move or click event.
   */
  this._handleMouseMoveModifiers = function (evt) {
    var ops = m_this.currentAnnotation.options('allowBooleanOperations');
    if (m_this.mode() !== m_this.modes.edit && ops && (m_this.currentAnnotation._coordinates().length < 2 || m_this.mode() === m_this.modes.cursor)) {
      if (evt.modifiers) {
        var mod = (evt.modifiers.shift ? 's' : '') + (evt.modifiers.ctrl ? 'c' : '') + (evt.modifiers.meta || evt.modifiers.alt ? 'a' : '');
        if (mod === '' && !m_this._currentBooleanClass) {
          return;
        }
        var op = Object.keys(m_this._booleanClasses).find(function (op) {
          return m_this._booleanClasses[op].includes(mod) && (ops === true || ops.includes(op));
        });
        if (m_this._currentBooleanClass === op) {
          return;
        }
        m_this._currentBooleanClass = op;
        var mapNode = m_this.map().node();
        Object.keys(m_this._booleanClasses).forEach(function (c) {
          mapNode.toggleClass(c, op === c);
        });
      }
    }
  };

  /**
   * Handle mouse movement.  If there is a current annotation, the movement
   * event is sent to it.
   *
   * @param {geo.event} evt The mouse move event.
   */
  this._handleMouseMove = function (evt) {
    if (m_this.mode() && m_this.currentAnnotation) {
      m_this._handleMouseMoveModifiers(evt);
      var update = m_this.currentAnnotation.mouseMove(evt);
      if (update) {
        m_this.modified();
        m_this.draw();
      }
    }
  };

  /**
   * Select or deselect an edit handle.
   *
   * @param {geo.event} evt The mouse move event.
   * @param {boolean} enable Truthy to select the handle, falsy to deselect it.
   * @returns {this?}
   */
  this._selectEditHandle = function (evt, enable) {
    if (!evt.data || !evt.data.editHandle) {
      return undefined;
    }
    $.each(m_features[geo_annotation._editHandleFeatureLevel], function (type, feature) {
      feature.feature.modified();
    });
    m_this.currentAnnotation.selectEditHandle(evt.data, enable);
    m_this.draw();
    m_this.map().node().toggleClass('annotation-input', !!enable);
    m_this.map().interactor().removeAction(undefined, undefined, geo_annotation.actionOwner);
    if (enable) {
      var actions = m_this.currentAnnotation.actions(geo_annotation.state.edit);
      $.each(actions, function (idx, action) {
        m_this.map().interactor().addAction(action);
      });
    }
    return m_this;
  };

  /**
   * Handle mouse on events.  If there is no current annotation and
   * clickToEdit is enabled, any hovered annotation is highlighted.
   * event is sent to it.
   *
   * @param {geo.event} evt The mouse move event.
   */
  this._handleMouseOn = function (evt) {
    if (!evt.data || !evt.data.annotation) {
      return;
    }
    if (m_this.mode() === m_this.modes.edit && m_this.currentAnnotation) {
      m_this._selectEditHandle(evt, true);
      return;
    }
    if (m_this.mode() || m_this.currentAnnotation || !m_this.options('clickToEdit')) {
      return;
    }
    evt.data.annotation.state(geo_annotation.state.highlight);
    m_this.modified();
    m_this.draw();
  };

  /**
   * Handle mouse off events.  If the specific annotation is in the highlight
   * state, move it back to the done state.
   *
   * @param {geo.event} evt The mouse move event.
   */
  this._handleMouseOff = function (evt) {
    if (!evt.data || !evt.data.annotation) {
      return;
    }
    if (m_this.mode() === m_this.modes.edit && evt.data.editHandle && evt.data.selected) {
      m_this._selectEditHandle(evt, false);
      return;
    }
    if (evt.data.annotation.state() === geo_annotation.state.highlight) {
      evt.data.annotation.state(geo_annotation.state.done);
      m_this.modified();
      m_this.draw();
    }
  };

  /**
   * Handle mouse clicks.  If there is a current annotation, the click event is
   * sent to it.
   *
   * @param {geo.event} evt The mouse click event.
   */
  this._handleMouseClick = function (evt) {
    var retrigger = false,
      update;
    if (m_this.mode() === m_this.modes.edit) {
      if (m_this.map().interactor().hasAction(undefined, undefined, geo_annotation.actionOwner)) {
        update = m_this.currentAnnotation.mouseClickEdit(evt);
        m_this._updateFromEvent(update);
        return;
      }
      m_this.mode(null);
      m_this.draw();
      $.each(m_features, function (idx, featureLevel) {
        $.each(featureLevel, function (type, feature) {
          feature.feature._clearSelectedFeatures();
        });
      });
      retrigger = true;
    } else if (m_this.mode() && m_this.currentAnnotation) {
      m_this._handleMouseMoveModifiers(evt);
      update = m_this.currentAnnotation.mouseClick(evt);
      m_this._updateFromEvent(update);
      retrigger = !m_this.mode();
      if (m_this.mode() === m_this.modes.cursor) {
        m_this.geoTrigger(geo_event.annotation.cursor_click, {
          annotation: m_this.currentAnnotation,
          operation: m_this.currentBooleanOperation(),
          evt: evt
        });
      }
    } else if (!m_this.mode() && !m_this.currentAnnotation && m_this.options('clickToEdit')) {
      var highlighted = m_this.annotations().filter(function (ann) {
        return ann.state() === geo_annotation.state.highlight;
      });
      if (highlighted.length !== 1) {
        return;
      }
      m_this.mode(m_this.modes.edit, highlighted[0]);
      m_this.draw();
      retrigger = true;
    }
    if (retrigger) {
      // retrigger mouse move to ensure the correct events are attached
      m_this.map().interactor().retriggerMouseMove();
    }
  };

  /**
   * Set or get options.
   *
   * @param {string|object} [arg1] If `undefined`, return the options object.
   *    If a string, either set or return the option of that name.  If an
   *    object, update the options with the object's values.
   * @param {object} [arg2] If `arg1` is a string and this is defined, set
   *    the option to this value.
   * @returns {object|this} If options are set, return the annotation,
   *    otherwise return the requested option or the set of options.
   */
  this.options = function (arg1, arg2) {
    if (arg1 === undefined) {
      return m_options;
    }
    if (typeof arg1 === 'string' && arg2 === undefined) {
      return m_options[arg1];
    }
    if (arg2 === undefined) {
      m_options = util.deepMerge(m_options, arg1);
    } else {
      m_options[arg1] = arg2;
    }
    m_this.modified();
    return m_this;
  };

  /**
   * Calculate the display distance for two coordinate in the current map.
   *
   * @param {geo.geoPosition|geo.screenPosition} coord1 The first coordinates.
   * @param {string|geo.transform|null} gcs1 `undefined` to use the interface
   *    gcs, `null` to use the map gcs, `'display'` if the coordinates are
   *    already in display coordinates, or any other transform.
   * @param {geo.geoPosition|geo.screenPosition} coord2 the second coordinates.
   * @param {string|geo.transform|null} [gcs2] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, `'display'` if the coordinates are
   *    already in display coordinates, or any other transform.
   * @returns {number} the Euclidean distance between the two coordinates.
   */
  this.displayDistance = function (coord1, gcs1, coord2, gcs2) {
    var map = m_this.map();
    if (gcs1 !== 'display') {
      gcs1 = gcs1 === null ? map.gcs() : gcs1 === undefined ? map.ingcs() : gcs1;
      coord1 = map.gcsToDisplay(coord1, gcs1);
    }
    if (gcs2 !== 'display') {
      gcs2 = gcs2 === null ? map.gcs() : gcs2 === undefined ? map.ingcs() : gcs2;
      coord2 = map.gcsToDisplay(coord2, gcs2);
    }
    var dist = Math.sqrt(Math.pow(coord1.x - coord2.x, 2) + Math.pow(coord1.y - coord2.y, 2));
    return dist;
  };

  /**
   * Add an annotation to the layer.  The annotation could be in any state.
   *
   * @param {geo.annotation} annotation The annotation to add.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @param {boolean} [update] If `false`, don't update the layer after adding
   *    the annotation.
   * @param {boolean} [trigger] If `false`, do not trigger add_before and add
   *    events.
   * @returns {this} The current layer.
   * @fires geo.event.annotation.add_before
   * @fires geo.event.annotation.add
   */
  this.addAnnotation = function (annotation, gcs, update, trigger) {
    if (m_annotationIds[annotation.id()] === undefined) {
      while (m_this.annotationById(annotation.id())) {
        annotation.newId();
      }
      if (trigger !== false) {
        m_this.geoTrigger(geo_event.annotation.add_before, {
          annotation: annotation
        });
      }
      m_annotations.push(annotation);
      m_annotationIds[annotation.id()] = annotation;
      annotation.layer(m_this);
      var map = m_this.map();
      gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
      if (gcs !== map.gcs()) {
        annotation._convertCoordinates(gcs, map.gcs());
      }
      if (update !== false) {
        m_this.modified();
        m_this.draw();
      }
      if (trigger !== false) {
        m_this.geoTrigger(geo_event.annotation.add, {
          annotation: annotation
        });
      }
    }
    return m_this;
  };

  /**
   * Add multiple annotations to the layer.  The annotations could be in any
   * state.
   *
   * @param {geo.annotation[]} annotations The annotations to add.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @param {boolean} [update] If `false`, don't update the layer after adding
   *    the annotation.
   * @returns {this} The current layer.
   * @fires geo.event.annotation.add_before
   * @fires geo.event.annotation.add
   */
  this.addMultipleAnnotations = function (annotations, gcs, update) {
    var added = [];
    m_this.geoTrigger(geo_event.annotation.add_before, {
      annotations: annotations
    });
    for (var i = 0; i < annotations.length; i += 1) {
      var annotation = annotations[i];
      if (m_annotationIds[annotation.id()] === undefined) {
        this.addAnnotation(annotation, gcs, update, false);
        added.push(annotation);
      }
    }
    if (added.length) {
      m_this.geoTrigger(geo_event.annotation.add, {
        annotations: added
      });
    }
    return m_this;
  };

  /**
   * Remove an annotation from the layer.
   *
   * @param {geo.annotation} annotation The annotation to remove.
   * @param {boolean} [update] If `false`, don't update the layer after removing
   *    the annotation.
   * @param {int} [pos] The posiiton of the annotation in the annotation list,
   *    if known.  This speeds up the process.
   * @param {boolean} [trigger] If `false`, do not trigger remove event.
   * @returns {boolean} `true` if an annotation was removed.
   * @fires geo.event.annotation.remove
   */
  this.removeAnnotation = function (annotation, update, pos, trigger) {
    if (annotation.id && m_annotationIds[annotation.id()] !== undefined) {
      pos = m_annotations.indexOf(annotation);
      if (annotation === m_this.currentAnnotation) {
        m_this.currentAnnotation = null;
      }
      if (m_annotationIds[annotation.id()] !== undefined) {
        delete m_annotationIds[annotation.id()];
      }
      annotation._exit();
      m_annotations.splice(pos, 1);
      if (update !== false) {
        m_this.modified();
        m_this.draw();
      }
      if (trigger !== false) {
        m_this.geoTrigger(geo_event.annotation.remove, {
          annotation: annotation
        });
      }
      return true;
    }
    return false;
  };

  /**
   * Remove all annotations from the layer.
   *
   * @param {boolean} [skipCreating] If truthy, don't remove annotations that
   *    are in the create state.
   * @param {boolean} [update] If `false`, don't update the layer after
   *    removing the annotation.
   * @param {boolean} [trigger] If `false`, do not trigger remove events.
   * @returns {number} The number of annotations that were removed.
   */
  this.removeAllAnnotations = function (skipCreating, update, trigger) {
    var removed = 0,
      annotation;
    for (var pos = m_annotations.length - 1; pos >= 0; pos -= 1) {
      annotation = m_annotations[pos];
      if (skipCreating && annotation.state() === geo_annotation.state.create) {
        continue;
      }
      m_this.removeAnnotation(annotation, false, pos, trigger);
      removed += 1;
    }
    if (removed && update !== false) {
      m_this.modified();
      m_this.draw();
    }
    return removed;
  };

  /**
   * Get the list of annotations on the layer.
   *
   * @returns {geo.annotation[]} An array of annotations.
   */
  this.annotations = function () {
    return m_annotations.slice();
  };

  /**
   * Get an annotation by its id.
   *
   * @param {number} id The annotation ID.
   * @returns {geo.annotation} The selected annotation or `undefined` if none
   *    matches the id.
   */
  this.annotationById = function (id) {
    if (id !== undefined && id !== null) {
      id = +id; /* Cast to int */
    }
    return m_annotationIds[id];
  };

  /* A list of special modes */
  this.modes = {
    edit: 'edit',
    cursor: 'cursor'
  };

  /* Keys are classes to apply to the map node.  Values are short-hand for
   * preferred event modifiers. */
  this._booleanClasses = {
    'annotation-union': ['s'],
    'annotation-intersect': ['sc'],
    'annotation-difference': ['c'],
    'annotation-xor': ['sa'],
    'annotation-cut': ['c', 'ca']
  };

  /**
   * Get or set the current mode.
   *
   * @param {string|null} [arg] `undefined` to get the current mode, `null` to
   *    stop creating/editing, `this.modes.edit` (`'edit'`) plus an annotation
   *    to switch to edit mode, `this.modes.cursor` plus an annotation to
   *    switch to using the annotation as a cursor, or the name of the type of
   *    annotation to create.  Available annotations can listed via
   *    {@link geo.listAnnotations}.
   * @param {geo.annotation} [editAnnotation] If `arg === this.modes.edit` or
   *    `arg === this.modes.cursor`, this is the annotation that should be
   *    edited or used.
   * @param {object} [options] Additional options to pass when creating an
   *    annotation.
   * @param {string} [reason] An optional reason to pass to the
   *    `geo.event.annotation.mode` event.
   * @returns {string|null|this} The current mode or the layer.
   * @fires geo.event.annotation.mode
   */
  this.mode = function (arg, editAnnotation, options, reason) {
    if (arg === undefined) {
      return m_mode;
    }
    if (arg !== m_mode || (arg === m_this.modes.edit || arg === m_this.modes.cursor) && editAnnotation !== m_this.editAnnotation || arg !== m_this.modes.edit && arg !== m_this.modes.cursor && arg && !m_this.currentAnnotation) {
      var createAnnotation,
        actions,
        mapNode = m_this.map().node(),
        oldMode = m_mode;
      m_mode = arg;
      mapNode.toggleClass('annotation-input', !!(m_mode && m_mode !== m_this.modes.edit && m_mode !== m_this.modes.cursor));
      if (!m_mode || m_mode === m_this.modes.edit) {
        Object.keys(m_this._booleanClasses).forEach(function (c) {
          return mapNode.toggleClass(c, false);
        });
        m_this._currentBooleanClass = undefined;
      }
      if (!m_keyHandler) {
        m_keyHandler = Mousetrap(mapNode[0]);
      }
      if (m_mode) {
        m_keyHandler.bind('esc', function () {
          m_this.mode(null, undefined, undefined, 'escape');
        });
      } else {
        m_keyHandler.unbind('esc');
      }
      var oldState, oldCoordinates;
      if (m_this.currentAnnotation) {
        oldState = m_this.currentAnnotation.state();
        oldCoordinates = m_this.currentAnnotation._copyOfCoordinates();
        switch (m_this.currentAnnotation.state()) {
          case geo_annotation.state.create:
            m_this.removeAnnotation(m_this.currentAnnotation);
            break;
          case geo_annotation.state.edit:
            m_this.currentAnnotation.state(geo_annotation.state.done);
            m_this.modified();
            m_this.draw();
            break;
          case geo_annotation.state.cursor:
            m_this.currentAnnotation.state(geo_annotation.state.done);
            m_this.modified();
            m_this.draw();
            m_this.map().node().toggleClass('annotation-cursor', false);
            break;
        }
        m_this.currentAnnotation = null;
      }
      if (m_mode === m_this.modes.edit) {
        m_this.currentAnnotation = editAnnotation;
        m_this.currentAnnotation.state(geo_annotation.state.edit);
        m_this.modified();
      } else if (m_mode === m_this.modes.cursor) {
        m_this.currentAnnotation = editAnnotation;
        m_this.currentAnnotation.state(geo_annotation.state.cursor);
        m_this.modified();
        m_this.map().node().toggleClass('annotation-cursor', true);
        actions = m_this.currentAnnotation.actions(geo_annotation.state.cursor);
      } else if (registry.registries.annotations[m_mode]) {
        createAnnotation = registry.registries.annotations[m_mode].func;
      }
      m_this.map().interactor().removeAction(undefined, undefined, geo_annotation.actionOwner);
      if (createAnnotation) {
        options = Object.assign({}, options || {}, {
          state: geo_annotation.state.create,
          layer: m_this
        });
        m_this.currentAnnotation = createAnnotation(options);
        m_this.addAnnotation(m_this.currentAnnotation, null);
        actions = m_this.currentAnnotation.actions(geo_annotation.state.create);
      }
      if (actions) {
        $.each(actions, function (idx, action) {
          m_this.map().interactor().addAction(action);
        });
      }
      m_this.geoTrigger(geo_event.annotation.mode, {
        mode: m_mode,
        oldMode: oldMode,
        oldState: oldState,
        oldCoordinates: oldCoordinates,
        reason: reason
      });
      if (oldMode === m_this.modes.edit || oldMode === m_this.modes.cursor) {
        m_this.modified();
      }
    }
    return m_this;
  };

  /**
   * Return the current set of annotations as a geojson object.  Alternately,
   * add a set of annotations from a geojson object.
   *
   * @param {string|object|File} [geojson] If present, add annotations based on
   *    the given geojson object.  If `undefined`, return the current
   *    annotations as geojson.  This may be a JSON string, a javascript
   *    object, or a File object.
   * @param {boolean|string} [clear] If `true`, when adding annotations, first
   *    remove all existing objects.  If `'update'`, update existing
   *    annotations and remove annotations that no longer exist.  If falsy,
   *    update existing annotations and leave annotations that have not
   *    changed.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @param {boolean} [includeCrs] If truthy, include the coordinate system in
   *    the output.
   * @returns {object|number|undefined} If `geojson` was undefined, the current
   *    annotations is a javascript object that can be converted to geojson
   *    using JSON.stringify.  If `geojson` is specified, either the number of
   *    annotations now present upon success, or `undefined` if the value in
   *    `geojson` was not able to be parsed.
   */
  this.geojson = function (geojson, clear, gcs, includeCrs) {
    if (geojson !== undefined) {
      var reader = registry.createFileReader('geojsonReader', {
        layer: m_this,
        lineStyle: (__webpack_require__(2612).defaults).style,
        pointStyle: (__webpack_require__(400).defaults).style,
        polygonStyle: (__webpack_require__(1920).defaults).style
      });
      if (!reader.canRead(geojson)) {
        return;
      }
      if (clear === true) {
        m_this.removeAllAnnotations(true, false);
      }
      if (clear === 'update') {
        $.each(m_this.annotations(), function (idx, annotation) {
          annotation.options('updated', false);
        });
      }
      reader.read(geojson, function (features) {
        $.each(features.slice(), function (feature_idx, feature) {
          m_this._geojsonFeatureToAnnotation(feature, gcs);
          m_this.deleteFeature(feature);
        });
      });
      if (clear === 'update') {
        $.each(m_this.annotations(), function (idx, annotation) {
          if (annotation.options('updated') === false && annotation.state() === geo_annotation.state.done) {
            m_this.removeAnnotation(annotation, false);
          }
        });
      }
      m_this.modified();
      m_this.draw();
      return m_annotations.length;
    }
    geojson = null;
    var features = [];
    $.each(m_annotations, function (annotation_idx, annotation) {
      var obj = annotation.geojson(gcs, includeCrs);
      if (obj) {
        features.push(obj);
      }
    });
    if (features.length) {
      geojson = {
        type: 'FeatureCollection',
        features: features
      };
    }
    return geojson;
  };

  /**
   * Convert a feature as parsed by the geojson reader into one or more
   * annotations.
   *
   * @param {geo.feature} feature The feature to convert.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @fires geo.event.annotation.update
   */
  this._geojsonFeatureToAnnotation = function (feature, gcs) {
    var dataList = feature.data(),
      annotationList = registry.listAnnotations(),
      map = m_this.map();
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    $.each(dataList, function (data_idx, data) {
      var type = (data.properties || {}).annotationType || feature.featureType,
        options = Object.assign({}, data.properties || {}),
        position,
        datagcs,
        i,
        existing;
      if (!annotationList.includes(type)) {
        return;
      }
      options.style = options.style || {};
      options.labelStyle = options.labelStyle || {};
      delete options.annotationType;
      // the geoJSON reader can emit line, polygon, point, and marker
      switch (feature.featureType) {
        case 'line':
          position = feature.line()(data, data_idx);
          if (!position || position.length < 2) {
            return;
          }
          // make a copy of the position array to avoid mutating the original.
          position = position.slice();
          break;
        case 'polygon':
          position = feature.polygon()(data, data_idx);
          if (!position || !position.outer || position.outer.length < 3) {
            return;
          }
          // make a copy of the position array to avoid mutating the original.
          position = {
            outer: position.outer.slice(),
            inner: (position.inner || []).map(function (h) {
              return h.slice();
            })
          };
          if (position.outer[position.outer.length - 1][0] === position.outer[0][0] && position.outer[position.outer.length - 1][1] === position.outer[0][1]) {
            position.outer.splice(position.outer.length - 1, 1);
            if (position.outer.length < 3) {
              return;
            }
          }
          position.inner.forEach(function (h) {
            if (h.length > 3 && h[h.length - 1][0] === h[0][0] && h[h.length - 1][1] === h[0][1]) {
              h.splice(h.length - 1, 1);
            }
          });
          if (!position.inner || !position.inner.length) {
            position = position.outer;
          }
          break;
        case 'marker':
          position = data.geometry.coordinates[0].slice(0, 4);
          break;
        case 'point':
          position = [feature.position()(data, data_idx)];
          break;
      }
      datagcs = data.crs && data.crs.type === 'name' && data.crs.properties && data.crs.properties.type === 'proj4' && data.crs.properties.name ? data.crs.properties.name : gcs;
      [position.outer || position].concat(position.inner || []).forEach(function (poslist) {
        for (i = 0; i < poslist.length; i += 1) {
          poslist[i] = util.normalizeCoordinates(poslist[i]);
        }
        if (datagcs !== map.gcs()) {
          var transposlist = transform.transformCoordinates(datagcs, map.gcs(), poslist);
          for (i = 0; i < poslist.length; i += 1) {
            poslist[i] = transposlist[i];
          }
        }
      });
      options.coordinates = position;
      /* For each style listed in the geojsonStyleProperties object, check if
       * is given under any of the variety of keys as a valid instance of the
       * required data type.  If not, use the property from the feature. */
      $.each(geojsonStyleProperties, function (key, prop) {
        var value;
        $.each(prop.keys, function (idx, altkey) {
          if (value === undefined) {
            value = m_this.validateAttribute(options[altkey], prop.dataType);
          }
        });
        if (value === undefined) {
          value = m_this.validateAttribute(feature.style.get(key)(data, data_idx), prop.dataType);
        }
        if (value !== undefined) {
          options[prop.option || 'style'][key] = value;
        }
      });
      /* Delete property keys we have used */
      $.each(geojsonStyleProperties, function (key, prop) {
        $.each(prop.keys, function (idx, altkey) {
          delete options[altkey];
        });
      });
      if (options.annotationId !== undefined) {
        existing = m_this.annotationById(options.annotationId);
        if (existing) {
          delete options.annotationId;
        }
      }
      if (existing && existing.type() === type && existing.state() === geo_annotation.state.done && existing.options('updated') === false) {
        /* We could change the state of the existing annotation if it differs
         * from done. */
        delete options.state;
        delete options.layer;
        options.updated = true;
        existing.options(options);
        m_this.geoTrigger(geo_event.annotation.update, {
          annotation: existing
        });
      } else {
        options.state = geo_annotation.state.done;
        options.layer = m_this;
        options.updated = 'new';
        m_this.addAnnotation(registry.createAnnotation(type, options), null);
      }
    });
  };

  /**
   * Validate a value for an attribute based on a specified data type.  This
   * returns a sanitized value or `undefined` if the value was invalid.  Data
   * types include:
   * - `color`: a css string, `#rrggbb` hex string, `#rgb` hex string, number,
   *   or object with r, g, b properties in the range of [0-1].
   * - `opacity`: a floating point number in the range [0, 1].
   * - `positive`: a floating point number greater than zero.
   * - `boolean`: a string whose lowercase value is `'false'`, `'off'`, or
   *   `'no'`, and falsy values are false, all else is true.  `null` and
   *   `undefined` are still considered invalid values.
   * - `booleanOrNumber`: a string whose lowercase value is `'false'`, `'off'`,
   *   `'no'`, `'true'`, `'on'`, or `'yes'`, falsy values that aren't 0, and
   *   `true` are handled as booleans.  Otherwise, a floating point number that
   *   isn't NaN or an infinity.
   * - `coordinate2`: either an object with x and y properties that are
   *   numbers, or a string of the form <x>[,]<y> with optional whitespace, or
   *   a JSON encoded object with x and y values, or a JSON encoded list of at
   *   leasst two numbers.
   * - `number`: a floating point number that isn't NaN or an infinity.
   * - `angle`: a number that represents radians.  If followed by one of `deg`,
   *   `grad`, or `turn`, it is converted to radians.  An empty string is also
   *   allowed.
   * - `text`: any text string.
   * @param {number|string|object|boolean} value The value to validate.
   * @param {string} dataType The data type for validation.
   * @returns {number|string|object|boolean|undefined} The sanitized value or
   *    `undefined`.
   */
  this.validateAttribute = function (value, dataType) {
    var parts;
    if (value === undefined || value === null) {
      return;
    }
    switch (dataType) {
      case 'angle':
        if (value === '') {
          break;
        }
        parts = /^\s*([-.0-9eE]+)\s*(deg|rad|grad|turn)?\s*$/.exec(('' + value).toLowerCase());
        if (!parts || !isFinite(parts[1])) {
          return;
        }
        var factor = parts[2] === 'grad' ? Math.PI / 200 : parts[2] === 'deg' ? Math.PI / 180 : parts[2] === 'turn' ? 2 * Math.PI : 1;
        value = +parts[1] * factor;
        break;
      case 'boolean':
        value = !!value && ['false', 'no', 'off'].indexOf(('' + value).toLowerCase()) < 0;
        break;
      case 'booleanOrNumber':
        if (!value && value !== 0 && value !== '' || ['true', 'false', 'off', 'on', 'no', 'yes'].indexOf(('' + value).toLowerCase()) >= 0) {
          value = !!value && ['false', 'no', 'off'].indexOf(('' + value).toLowerCase()) < 0;
        } else {
          if (!util.isNonNullFinite(value)) {
            return;
          }
          value = +value;
        }
        break;
      case 'coordinate2':
        if (value === '') {
          break;
        }
        if (value && util.isNonNullFinite(value.x) && util.isNonNullFinite(value.y)) {
          value.x = +value.x;
          value.y = +value.y;
          break;
        }
        try {
          value = JSON.parse(value);
        } catch (err) {}
        if (value && util.isNonNullFinite(value.x) && util.isNonNullFinite(value.y)) {
          value.x = +value.x;
          value.y = +value.y;
          break;
        }
        if (Array.isArray(value) && util.isNonNullFinite(value[0]) && util.isNonNullFinite(value[1])) {
          value = {
            x: +value[0],
            y: +value[1]
          };
          break;
        }
        parts = /^\s*([-.0-9eE]+)(?:\s+|\s*,)\s*([-.0-9eE]+)\s*$/.exec('' + value);
        if (!parts || !isFinite(parts[1]) || !isFinite(parts[2])) {
          return;
        }
        value = {
          x: +parts[1],
          y: +parts[2]
        };
        break;
      case 'color':
        value = util.convertColor(value);
        if (value === undefined || value.r === undefined) {
          return;
        }
        break;
      case 'number':
        if (!util.isNonNullFinite(value)) {
          return;
        }
        value = +value;
        break;
      case 'numberOrBlank':
        if (value === '') {
          break;
        }
        if (!util.isNonNullFinite(value)) {
          return;
        }
        value = +value;
        break;
      case 'opacity':
        if (value === '') {
          return;
        }
        value = +value;
        if (isNaN(value) || value < 0 || value > 1) {
          return;
        }
        break;
      case 'positive':
        value = +value;
        if (!isFinite(value) || value <= 0) {
          return;
        }
        break;
      case 'text':
        value = '' + value;
        break;
    }
    return value;
  };

  /**
   * Update layer.
   *
   * @returns {this} The current layer.
   */
  this._update = function () {
    if (m_this.timestamp() > m_buildTime.timestamp()) {
      var labels = m_this.options('showLabels') ? [] : null,
        editable = m_this.options('clickToEdit') || m_this.mode() === m_this.modes.edit;
      /* Internally, we have a set of feature levels (to provide z-index
       * support), each of which can have data from multiple annotations.  We
       * clear the data on each of these features, then build it up from each
       * annotation.  Eventually, it may be necessary to optimize this and
       * only update the features that are changed.
       */
      $.each(m_features, function (idx, featureLevel) {
        $.each(featureLevel, function (type, feature) {
          feature.data = [];
          delete feature.feature.scaleOnZoom;
        });
      });
      $.each(m_annotations, function (annotation_idx, annotation) {
        var features = annotation.features();
        if (labels) {
          var annotationLabel = annotation.labelRecord();
          if (annotationLabel) {
            labels.push(annotationLabel);
          }
        }
        $.each(features, function (idx, featureLevel) {
          if (m_features[idx] === undefined) {
            m_features[idx] = {};
          }
          $.each(featureLevel, function (type, featureSpec) {
            /* Create features as needed */
            if (!m_features[idx][type]) {
              var feature = m_this.createFeature(type, {
                gcs: m_this.map().gcs(),
                selectionAPI: editable
              });
              if (!feature) {
                /* We can't create the desired feature, probably because of the
                 * selected renderer.  Issue one warning only. */
                var key = 'error_feature_' + type;
                if (!m_this[key]) {
                  console.warn('Cannot create a ' + type + ' feature for annotations.'); // eslint-disable-line no-console
                  m_this[key] = true;
                }
                return;
              }
              if (editable) {
                feature.geoOn(geo_event.feature.mouseon, m_this._handleMouseOn);
                feature.geoOn(geo_event.feature.mouseoff, m_this._handleMouseOff);
              }

              /* Since each annotation can have separate styles, the styles are
               * combined together with a meta-style function.  Any style that
               * could be used should be in this list.  Color styles may be
               * restricted to {r, g, b} objects for efficiency, but this
               * hasn't been tested.
               */
              var style = {};
              $.each(['closed', 'fill', 'fillColor', 'fillOpacity', 'line', 'lineCap', 'lineJoin', 'polygon', 'position', 'radius', 'radiusIncludesStroke', 'rotateWithMap', 'rotation', 'scaleWithZoom', 'stroke', 'strokeColor', 'strokeOffset', 'strokeOpacity', 'strokeWidth', 'symbolValue', 'uniformPolygon'], function (keyidx, key) {
                var origFunc;
                if (feature.style()[key] !== undefined) {
                  origFunc = feature.style.get(key);
                }
                style[key] = function (d, i, d2, i2) {
                  var style = d && d.style ? d.style : d && d[2] && d[2].style ? d[2].style : d2.style;
                  var result = style ? style[key] : d;
                  if (util.isFunction(result)) {
                    result = result(d, i, d2, i2);
                  }
                  if (result === undefined && origFunc) {
                    result = origFunc(d, i, d2, i2);
                  }
                  return result;
                };
              });
              feature.style(style);
              m_features[idx][type] = {
                feature: feature,
                style: style,
                data: []
              };
            } else {
              feature = m_features[idx][type].feature;
              // update whether we check for selections on existing features
              if (feature.selectionAPI() !== !!editable) {
                feature.selectionAPI(editable);
                if (editable) {
                  feature.geoOn(geo_event.feature.mouseon, m_this._handleMouseOn);
                  feature.geoOn(geo_event.feature.mouseoff, m_this._handleMouseOff);
                } else {
                  feature.geoOff(geo_event.feature.mouseon, m_this._handleMouseOn);
                  feature.geoOff(geo_event.feature.mouseoff, m_this._handleMouseOff);
                }
              }
            }
            /* Collect the data for each feature */
            var dataEntry = featureSpec.data || featureSpec;
            if (!Array.isArray(dataEntry)) {
              dataEntry = [dataEntry];
            }
            dataEntry.forEach(function (dataElement) {
              dataElement.annotation = annotation;
              m_features[idx][type].data.push(dataElement);
              if (featureSpec.scaleOnZoom) {
                m_features[idx][type].feature.scaleOnZoom = true;
              }
            });
          });
        });
      });
      /* Update the data for each feature */
      $.each(m_features, function (idx, featureLevel) {
        $.each(featureLevel, function (type, feature) {
          feature.feature.data(feature.data);
        });
      });
      m_this._updateLabels(labels);
      m_buildTime.modified();
    }
    s_update.call(m_this, arguments);
    return m_this;
  };

  /**
   * Show or hide annotation labels.  Create or destroy a child layer or a
   * feature as needed.
   *
   * @param {object[]|null} labels The list of labels to display of `null` for
   *    no labels.
   * @returns {this} The class instance.
   * @fires geo.event.annotation.layerAdd
   */
  this._updateLabels = function (labels) {
    if (!labels || !labels.length) {
      m_this._removeLabelFeature();
      return m_this;
    }
    if (!m_labelFeature) {
      if (!(registry.registries.features[m_this.rendererName()] || {}).text) {
        var renderer = registry.rendererForFeatures(['text']);
        m_labelLayer = registry.createLayer('feature', m_this.map(), {
          renderer: renderer
        });
        m_this.addChild(m_labelLayer);
        m_labelLayer._update();
        m_this.geoTrigger(geo_event.layerAdd, {
          target: m_this,
          layer: m_labelLayer
        });
      }
      var style = {};
      textFeature.usedStyles.forEach(function (key) {
        style[key] = function (d, i) {
          if (d.style && d.style[key] !== undefined) {
            return d.style[key];
          }
          return (m_this.options('defaultLabelStyle') || {})[key];
        };
      });
      m_labelFeature = (m_labelLayer || m_this).createFeature('text', {
        style: style,
        gcs: m_this.map().gcs(),
        position: function position(d) {
          return d.position;
        }
      });
    }
    m_labelFeature.data(labels);
    return m_this;
  };

  /**
   * Check if any features are marked that they need to be updated when a zoom
   * occurs.  If so, mark that feature as modified.
   */
  this._handleZoom = function () {
    var i,
      features = m_this.features();
    for (i = 0; i < features.length; i += 1) {
      if (features[i].scaleOnZoom) {
        features[i].modified();
      }
    }
  };

  /**
   * Remove the label feature if it exists.
   *
   * @returns {this} The current layer.
   * @fires geo.event.annotation.layerRemove
   */
  this._removeLabelFeature = function () {
    if (m_labelLayer) {
      m_labelLayer._exit();
      m_this.removeChild(m_labelLayer);
      m_this.geoTrigger(geo_event.layerRemove, {
        target: m_this,
        layer: m_labelLayer
      });
      m_labelLayer = m_labelFeature = null;
    }
    if (m_labelFeature) {
      m_this.removeFeature(m_labelFeature);
      m_labelFeature = null;
    }
    return m_this;
  };

  /**
   * Update if necessary and draw the layer.
   *
   * @returns {this} The current layer.
   */
  this.draw = function () {
    m_this._update();
    s_draw.call(m_this);
    return m_this;
  };

  /**
   * Return any annotation that has area as a polygon list: an array of
   * polygons, each of which is an array of polylines, each of which is an
   * array of points, each of which is a 2-tuple of numbers.
   *
   * @param {geo.util.polyop.spec} [opts] Ignored.
   * @returns {geo.polygonList} A list of polygons.
   */
  this.toPolygonList = function (opts) {
    var poly = [];
    opts = opts || {};
    var indices = [];
    if (!opts.annotationIndices) {
      opts.annotationIndices = {};
    }
    opts.annotationIndices[m_this.id()] = indices;
    m_annotations.forEach(function (annotation, idx) {
      if (annotation.toPolygonList) {
        annotation.toPolygonList(opts).forEach(function (p) {
          return poly.push(p);
        });
        indices.push(idx);
      }
    });
    return poly;
  };

  /**
   * Replace appropriate annotations with a list of polygons.
   *
   * @param {geo.polygonList} poly A list of polygons.
   * @param {geo.util.polyop.annotationLayerSpec} [opts] This contains
   *   annotationIndices and correspondence used to track annotations.
   * @returns {this}
   */
  this.fromPolygonList = function (poly, opts) {
    if (!poly || !poly.length) {
      return m_this;
    }
    /* One of 'all', 'exact', 'none'; default is 'exact' */
    var keep = opts.keepAnnotations;
    var keepIds = {};
    var reusedIds = {};
    var correspond, exact, annot;
    var indices = (opts.annotationIndices || {})[m_this.id()];
    if (indices && opts.correspond && opts.correspond.poly1 && indices.length === opts.correspond.poly1.length) {
      correspond = opts.correspond.poly1;
      exact = opts.correspond.exact1;
      annot = m_this.annotations();
    }
    if (keep !== 'all' && keep !== 'none' && annot) {
      annot.forEach(function (oldAnnot, idx) {
        if (indices.indexOf(idx) < 0) {
          keepIds[oldAnnot.id()] = true;
        }
      });
    }
    var polyAnnot = [];
    poly.forEach(function (p, idx) {
      p = p.map(function (h) {
        return h.map(function (pt) {
          return {
            x: pt[0],
            y: pt[1]
          };
        });
      });
      var result = {
        vertices: p.length === 1 ? p[0] : {
          outer: p[0],
          inner: p.slice(1)
        }
      };
      if (correspond) {
        var _loop2 = function _loop2() {
            if (correspond[i] && correspond[i].indexOf(idx) >= 0) {
              var orig = annot[indices[i]];
              if (keep !== 'all' && keep !== 'none' && exact && exact[i] && exact[i].indexOf(idx) >= 0) {
                keepIds[orig.id()] = true;
                return {
                  v: void 0
                };
              }
              if (keep !== 'all' && reusedIds[orig.id()] === undefined) {
                result.annotationId = orig.id();
                reusedIds[orig.id()] = true;
              }
              ['name', 'description', 'label'].forEach(function (k) {
                if (orig[k](undefined, true)) {
                  result[k] = orig[k](undefined, true);
                }
              });
              Object.entries(orig.options()).forEach(function (_ref3) {
                var _ref4 = _slicedToArray(_ref3, 2),
                  key = _ref4[0],
                  value = _ref4[1];
                if (['showLabel', 'style'].indexOf(key) >= 0 || key.endsWith('Style')) {
                  result[key] = value;
                }
              });
              return 0; // break
            }
          },
          _ret2;
        for (var i = 0; i < correspond.length; i += 1) {
          _ret2 = _loop2();
          if (_ret2 === 0) break;
          if (_ret2) return _ret2.v;
        }
      }
      polyAnnot.push(result);
    });
    var update = false;
    // delete extant annotations
    if (keep !== 'all' && annot) {
      annot.filter(function (oldAnnot) {
        return keepIds[oldAnnot.id()] === undefined;
      }).forEach(function (oldAnnot) {
        m_this.removeAnnotation(oldAnnot, false);
        update = true;
      });
    }
    // add new annotations
    polyAnnot.forEach(function (p) {
      m_this.addAnnotation(registry.createAnnotation('polygon', p), m_this.map().gcs(), false);
      update = true;
    });
    if (update) {
      m_this.modified();
      m_this.draw();
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @returns {this} The current layer.
   */
  this._init = function () {
    // Call super class init
    s_init.call(m_this);
    if (!m_this.map().interactor()) {
      m_this.map().interactor(mapInteractor({
        actions: []
      }));
    }
    m_this.geoOn(geo_event.actionselection, m_this._processAction);
    m_this.geoOn(geo_event.actionmove, m_this._processAction);
    m_this.geoOn(geo_event.actionup, m_this._processAction);
    m_this.geoOn(geo_event.mouseclick, m_this._handleMouseClick);
    m_this.geoOn(geo_event.mousemove, m_this._handleMouseMove);
    m_this.geoOn(geo_event.zoom, m_this._handleZoom);
    return m_this;
  };

  /**
   * Free all resources.
   *
   * @returns {this} The current layer.
   */
  this._exit = function () {
    if (m_keyHandler) {
      m_keyHandler.reset();
    }
    m_this._removeLabelFeature();
    // Call super class exit
    s_exit.call(m_this);
    m_annotations = [];
    m_annotationIds = {};
    m_features = [];
    return m_this;
  };
  return m_this;
};
inherit(_annotationLayer, featureLayer);
registry.registerLayer('annotation', _annotationLayer);
module.exports = _annotationLayer;

/***/ }),

/***/ 3578:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var object = __webpack_require__(1338);
var util = __webpack_require__(642);
var mat3 = __webpack_require__(3638);
var vec3 = __webpack_require__(1982);
var mat4 = __webpack_require__(3503);
var vec4 = __webpack_require__(4663);

/**
 * This class defines the raw interface for a camera.  At a low level, the
 * camera provides a methods for converting between a map's coordinate system
 * to display pixel coordinates.
 *
 * For the moment, all camera transforms are assumed to be expressible as
 * 4x4 matrices.  More general cameras may follow that break this assumption.
 *
 * The interface for the camera is relatively stable for "map-like" views,
 * e.g. when the camera is pointing in the direction [0, 0, -1], and placed
 * above the z=0 plane.  More general view changes and events have not yet
 * been defined.
 *
 * The camera emits the following events when the view changes:
 *
 *   {@link geo.event.camera.pan} when the camera is translated in the
 *       x/y plane
 *   {@link geo.event.camera.zoom} when the camera is changed in a way
 *       that modifies the current zoom level
 *   {@link geo.event.camera.view} when the visible bounds change for
 *       any reason
 *   {@link geo.event.camera.projection} when the projection type changes
 *   {@link geo.event.camera.viewport} when the viewport changes
 *
 * By convention, protected methods do not update the internal matrix state,
 * public methods do.  There are a few primary methods that are intended to
 * be used by external classes to mutate the internal state:
 *
 *   bounds: Set the visible bounds (for initialization and zooming)
 *   pan: Translate the camera in x/y by an offset (for panning)
 *   viewFromCenterSizeRotation: set the camera view based on a center
 *        point, boundary size, and rotation angle.
 *
 * @class
 * @alias geo.camera
 * @extends geo.object
 * @param {object?} spec Options argument
 * @param {string} spec.projection One of the supported
 *    {@link geo.camera.projection}.
 * @param {object} spec.viewport The initial camera viewport
 * @param {object} spec.viewport.width
 * @param {object} spec.viewport.height
 * @returns {geo.camera}
 */
var _camera = function camera(spec) {
  if (!(this instanceof _camera)) {
    return new _camera(spec);
  }
  var geo_event = __webpack_require__(6409);
  spec = spec || {};
  object.call(this, spec);

  /**
   * The view matrix
   * @protected
   */
  this._view = util.mat4AsArray();

  /**
   * The projection matrix
   * @protected
   */
  this._proj = util.mat4AsArray();

  /**
   * The projection type (one of `this.constructor.projection`)
   * @protected
   */
  this._projection = null;

  /**
   * The transform matrix (view * proj)
   * @protected
   */
  this._transform = util.mat4AsArray();

  /**
   * The inverse transform matrix (view * proj)^-1
   * @protected
   */
  this._inverse = util.mat4AsArray();

  /**
   * Cached bounds object recomputed on demand.
   * @protected
   */
  this._bounds = null;

  /**
   * Cached "display" matrix recomputed on demand.
   * @see {@link geo.camera.display}
   * @protected
   */
  this._display = null;

  /**
   * Cached "world" matrix recomputed on demand.
   * @see {@link geo.camera.world}
   * @protected
   */
  this._world = null;

  /**
   * The viewport parameters size and offset.
   * @property {number} height Viewport height in pixels
   * @property {number} width Viewport width in pixels
   * @protected
   */
  this._viewport = {
    width: 1,
    height: 1
  };

  /**
   * Set up the projection matrix for the current projection type.
   * @protected
   */
  this._createProj = function () {
    var func = this._projection === 'perspective' ? mat4.frustum : mat4.ortho,
      clipbounds = this._clipbounds[this._projection];
    func(this._proj, clipbounds.left, clipbounds.right, clipbounds.bottom, clipbounds.top, clipbounds.near, clipbounds.far);
  };

  /**
   * Update the internal state of the camera on change to camera
   * parameters.
   * @protected
   * @fires geo.event.camera.view
   */
  this._update = function () {
    this._bounds = null;
    this._display = null;
    this._world = null;
    this._transform = mat4.multiply(util.mat4AsArray(), this._proj, this._view);
    mat4.invert(this._inverse, this._transform);
    this.geoTrigger(geo_event.camera.view, {
      camera: this
    });
  };

  /**
   * Getter/setter for the view matrix.
   * @note copies the matrix value on set.
   * @property {mat4} view The view matrix.
   * @name geo.camera#view
   */
  Object.defineProperty(this, 'view', {
    get: function get() {
      return this._view;
    },
    set: function set(view) {
      mat4.copy(this._view, view);
      this._update();
    },
    configurable: true
  });

  /**
   * Getter/setter for the view bounds.
   *
   * @property {object} bounds The view bounds.
   * @property {number} bounds.left The left view bounds.
   * @property {number} bounds.top The top view bounds.
   * @property {number} bounds.right The right view bounds.
   * @property {number} bounds.bottom The bottom view bounds.
   * @name geo.camera#bounds
   */
  Object.defineProperty(this, 'bounds', {
    get: function get() {
      if (this._bounds === null) {
        this._bounds = this._getBounds();
      }
      return this._bounds;
    },
    set: function set(bounds) {
      this._setBounds(bounds);
      this._update();
    }
  });

  /**
   * Getter/setter for the render clipbounds.  Opposite bounds must have
   * different values.  There are independent clipbounds for each projection
   * (parallel and perspective); switching the projection will switch to the
   * clipbounds.  Individual values of the clipbounds can be set either via a
   * command like `camera.clipbounds = {near: 3, far: 1}` or
   * `camera.clipbounds.near = 3`.  In the second example, no check is made to
   * ensure a non-zero volume clipbounds.
   *
   * @property {object} clipbounds The clipbounds for the current projection.
   * @name geo.camera#clipbounds
   */
  Object.defineProperty(this, 'clipbounds', {
    get: function get() {
      return this._clipbounds[this._projection];
    },
    set: function set(bounds) {
      var clipbounds = this._clipbounds[this._projection];
      bounds = {
        left: bounds.left === undefined ? clipbounds.left : bounds.left,
        right: bounds.right === undefined ? clipbounds.right : bounds.right,
        top: bounds.top === undefined ? clipbounds.top : bounds.top,
        bottom: bounds.bottom === undefined ? clipbounds.bottom : bounds.bottom,
        near: bounds.near === undefined ? clipbounds.near : bounds.near,
        far: bounds.far === undefined ? clipbounds.far : bounds.far
      };
      if (bounds.left === bounds.right) {
        throw new Error('Left and right values must be different');
      }
      if (bounds.top === bounds.bottom) {
        throw new Error('Top and bottom values must be different');
      }
      if (bounds.near === bounds.far) {
        throw new Error('Near and far values must be different');
      }
      this._clipbounds[this._projection] = bounds;
      this._createProj();
      this._update();
    }
  });

  /**
   * Getter for the "display" matrix.  This matrix converts from world
   * coordinates into display coordinates.  Read only.
   *
   * @property {mat4} display The display matrix.
   * @name geo.camera#display
   */
  Object.defineProperty(this, 'display', {
    get: function get() {
      if (this._display === null) {
        var b = this._clipbounds[this._projection];
        var mat = util.mat4AsArray();
        mat4.translate(mat, mat, [this.viewport.width / 2, this.viewport.height / 2, 0]);
        mat4.scale(mat, mat, [this.viewport.width / (b.right - b.left), this.viewport.height / (b.bottom - b.top), 1]);
        mat4.translate(mat, mat, [-(b.left + b.right) / 2, -(b.top + b.bottom) / 2, 0]);
        mat4.multiply(mat, mat, this._transform);
        this._display = mat;
      }
      return this._display;
    }
  });

  /**
   * Getter for the "world" matrix.  This matrix converts from display
   * coordinates into world coordinates.  This is the inverse of the "display"
   * matrix.  Read only.
   *
   * @property {mat4} world The world matrix.
   * @name geo.camera#world
   */
  Object.defineProperty(this, 'world', {
    get: function get() {
      if (this._world === null) {
        this._world = mat4.invert(util.mat4AsArray(), this.display);
      }
      return this._world;
    }
  });

  /**
   * Getter/setter for the projection type.
   *
   * @property {string} projection The projection type.  One of `parallel` or
   *    `perspective`.
   * @name geo.camera#projection
   * @fires geo.event.camera.projection
   */
  Object.defineProperty(this, 'projection', {
    get: function get() {
      return this._projection;
    },
    set: function set(type) {
      if (!this.constructor.projection[type]) {
        throw new Error('Unsupported projection type: ' + type);
      }
      if (type !== this._projection) {
        this._projection = type;
        this._createProj();
        this._update();
        this.geoTrigger(geo_event.camera.projection, {
          camera: this,
          projection: type
        });
      }
    }
  });

  /**
   * Getter for the projection matrix.  Read only.
   *
   * @property {mat4} projectionMatrix The projection matrix.
   * @name geo.camera#projectionMatrix
   */
  Object.defineProperty(this, 'projectionMatrix', {
    get: function get() {
      return this._proj;
    }
  });

  /**
   * Getter for the transform matrix.  This is the projection multiplied by the
   * view matrix.  Read only.
   *
   * @property {mat4} transform The transform matrix.
   * @name geo.camera#transform
   */
  Object.defineProperty(this, 'transform', {
    get: function get() {
      return this._transform;
    }
  });

  /**
   * Getter for the inverse transform matrix.  Read only.
   *
   * @property {mat4} inverse The inverse transform matrix.
   * @name geo.camera#inverse
   */
  Object.defineProperty(this, 'inverse', {
    get: function get() {
      return this._inverse;
    }
  });

  /**
   * Getter/setter for the viewport.
   *
   * The viewport consists of a width and height in pixels, plus a left and
   * top offset in pixels.  The offsets are only used to determine if pixel
   * alignment is possible.
   *
   * @property {object} viewport The viewport in pixels.
   * @property {number} viewport.width The viewport width in pixels.
   * @property {number} viewport.height The viewport height in pixels.
   * @property {number} viewport.top The viewport top in pixels.
   * @property {number} viewport.left The viewport left in pixels.
   * @name geo.camera#viewport
   * @fires geo.event.camera.viewport
   */
  Object.defineProperty(this, 'viewport', {
    get: function get() {
      return {
        width: this._viewport.width,
        height: this._viewport.height,
        left: this._viewport.left,
        top: this._viewport.top
      };
    },
    set: function set(viewport) {
      if (!(viewport.width > 0 && viewport.height > 0)) {
        throw new Error('Invalid viewport dimensions');
      }
      if (viewport.width === this._viewport.width && viewport.height === this._viewport.height) {
        return;
      }

      // apply scaling to the view matrix to account for the new aspect ratio
      // without changing the apparent zoom level
      if (this._viewport.width && this._viewport.height) {
        this._scale([this._viewport.width / viewport.width, this._viewport.height / viewport.height, 1]);

        // translate by half the difference to keep the center the same
        this._translate([(viewport.width - this._viewport.width) / 2, (viewport.height - this._viewport.height) / 2, 0]);
      }
      this._viewport = {
        width: viewport.width,
        height: viewport.height,
        left: viewport.left,
        top: viewport.top
      };
      this._update();
      this.geoTrigger(geo_event.camera.viewport, {
        camera: this,
        viewport: this.viewport
      });
    }
  });

  /**
   * Reset the view matrix to its initial (identity) state.
   * @protected
   * @returns {this} Chainable.
   */
  this._resetView = function () {
    mat4.identity(this._view);
    return this;
  };

  /**
   * Uses `mat4.translate` to translate the camera by the given vector amount.
   * @protected
   * @param {vec3|Array} offset The camera translation vector.
   * @returns {this} Chainable.
   */
  this._translate = function (offset) {
    mat4.translate(this._view, this._view, offset);
    return this;
  };

  /**
   * Uses `mat4.scale` to scale the camera by the given vector amount.
   * @protected
   * @param {vec3|Array} scale The scaling vector.
   * @returns {this} Chainable.
   */
  this._scale = function (scale) {
    mat4.scale(this._view, this._view, scale);
    return this;
  };

  /**
   * Project a vec4 from world space into clipped space [-1, 1] in place.
   * @protected
   * @param {vec4} point The point in world coordinates (mutated).
   * @returns {vec4} The point in clip space coordinates.
   */
  this._worldToClip4 = function (point) {
    return vec4.transformMat4(point, point, this._transform);
  };

  /**
   * Project a vec4 from clipped space into world space in place.
   * @protected
   * @param {vec4} point The point in clipped coordinates (mutated).
   * @returns {vec4} The point in world space coordinates.
   */
  this._clipToWorld4 = function (point) {
    return vec4.transformMat4(point, point, this._inverse);
  };

  /**
   * Apply the camera's projection transform to the given point.
   * @param {vec4} pt a point in clipped coordinates.
   * @returns {vec4} the point in normalized coordinates.
   */
  this.applyProjection = function (pt) {
    var w;
    if (this._projection === 'perspective') {
      w = 1 / (pt[3] || 1);
      pt[0] = w * pt[0];
      pt[1] = w * pt[1];
      pt[2] = w * pt[2];
      pt[3] = w;
    } else {
      pt[3] = 1;
    }
    return pt;
  };

  /**
   * Unapply the camera's projection transform from the given point.
   * @param {vec4} pt a point in normalized coordinates.
   * @returns {vec4} the point in clipped coordinates.
   */
  this.unapplyProjection = function (pt) {
    var w;
    if (this._projection === 'perspective') {
      w = pt[3] || 1;
      pt[0] = w * pt[0];
      pt[1] = w * pt[1];
      pt[2] = w * pt[2];
      pt[3] = w;
    } else {
      pt[3] = 1;
    }
    return pt;
  };

  /**
   * Project a vector from world space into viewport (display) space.  The
   * resulting vector always has the last component (`w`) equal to 1.
   *
   * @param {vec3|vec4} point The point in world coordinates.
   * @returns {vec4} The point in display coordinates.
   */
  this.worldToDisplay4 = function (point) {
    point = [point[0], point[1], point[2] || 0, point[3] || 1];
    point = vec4.transformMat4(point, point, this.display);
    if (point[3] && point[3] !== 1) {
      point = [point[0] / point[3], point[1] / point[3], point[2] / point[3], 1];
    }
    return point;
  };

  /**
   * Project a vector from viewport (display) space into world space.  The
   * resulting vector always has the last component (`w`) equal to 1.
   *
   * @param {vec3|vec4} point The point in display coordinates.
   * @returns {vec4} The point in world space coordinates.
   */
  this.displayToWorld4 = function (point) {
    point = [point[0], point[1], point[2] || 0, point[3] || 1];
    point = vec4.transformMat4(point, point, this.world);
    if (point[3] && point[3] !== 1) {
      point = [point[0] / point[3], point[1] / point[3], point[2] / point[3], 1];
    }
    return point;
  };

  /**
   * Project a 2D point object from world space into viewport space.  `z` is
   * set to `-this.clipbounds.near` to scale with the clip space.
   *
   * @param {object} point The point in world coordinates.
   * @param {number} point.x
   * @param {number} point.y
   * @returns {object} The point in display coordinates.
   */
  this.worldToDisplay = function (point) {
    var b = this._clipbounds[this._projection];
    point = this.worldToDisplay4([point.x, point.y, -b.near]);
    return {
      x: point[0],
      y: point[1]
    };
  };

  /**
   * Project a 2D point object from viewport space into world space.  `z` is
   * set to -1 to scale with the clip space.
   *
   * @param {object} point The point in display coordinates.
   * @param {number} point.x
   * @param {number} point.y
   * @returns {object} The point in world coordinates.
   */
  this.displayToWorld = function (point) {
    point = this.displayToWorld4([point.x, point.y, -1]);
    return {
      x: point[0],
      y: point[1]
    };
  };

  /**
   * Calculate the current bounds in world coordinates from the
   * current view matrix.  This computes a matrix vector multiplication
   * so the result is cached for public facing methods.
   *
   * @protected
   * @returns {object} bounds object.
   */
  this._getBounds = function () {
    var ul,
      ur,
      ll,
      lr,
      bds = {};

    // get corners
    ul = this.displayToWorld({
      x: 0,
      y: 0
    });
    ur = this.displayToWorld({
      x: this._viewport.width,
      y: 0
    });
    ll = this.displayToWorld({
      x: 0,
      y: this._viewport.height
    });
    lr = this.displayToWorld({
      x: this._viewport.width,
      y: this._viewport.height
    });
    bds.left = Math.min(ul.x, ur.x, ll.x, lr.x);
    bds.bottom = Math.min(ul.y, ur.y, ll.y, lr.y);
    bds.right = Math.max(ul.x, ur.x, ll.x, lr.x);
    bds.top = Math.max(ul.y, ur.y, ll.y, lr.y);
    return bds;
  };

  /**
   * Sets the view matrix so that the given world bounds
   * are in view.  To account for the viewport aspect ratio,
   * the resulting bounds may be larger in width or height than
   * the requested bound, but should be centered in the frame.
   *
   * @protected
   * @param {object} bounds
   * @param {number} bounds.left
   * @param {number} bounds.right
   * @param {number} bounds.bottom
   * @param {number} bounds.top
   * @param {number?} bounds.near Currently ignored.
   * @param {number?} bounds.far Currently ignored.
   * @returns {this} Chainable.
   */
  this._setBounds = function (bounds) {
    var size = {
      width: bounds.right - bounds.left,
      height: bounds.top - bounds.bottom
    };
    var center = {
      x: (bounds.left + bounds.right) / 2,
      y: (bounds.bottom + bounds.top) / 2
    };
    this._viewFromCenterSizeRotation(center, size, 0);
    return this;
  };

  /**
   * Sets the view matrix so that the given world center is centered, at
   * least a certain width and height are visible, and a rotation is applied.
   * The resulting bounds may be larger in width or height than the values if
   * the viewport is a different aspect ratio.
   *
   * @protected
   * @param {object} center Center of the view in gcs coordinates.
   * @param {number} center.x
   * @param {number} center.y
   * @param {object} size Minimum size of the view in gcs units.
   * @param {number} size.width
   * @param {number} size.height
   * @param {number} rotation in clockwise radians.  Optional.
   * @returns {this} Chainable.
   */
  this._viewFromCenterSizeRotation = function (center, size, rotation) {
    var translate = util.vec3AsArray(),
      scale = util.vec3AsArray(),
      c_ar,
      v_ar,
      w,
      h;

    // reset view to the identity
    this._resetView();
    w = Math.abs(size.width);
    h = Math.abs(size.height);
    c_ar = w / h;
    v_ar = this._viewport.width / this._viewport.height;
    if (c_ar >= v_ar) {
      // grow camera bounds vertically
      h = w / v_ar;
      scale[0] = 2 / w;
      scale[1] = 2 / h;
    } else {
      // grow bounds horizontally
      w = h * v_ar;
      scale[0] = 2 / w;
      scale[1] = 2 / h;
    }
    scale[2] = 1;
    this._scale(scale);
    if (rotation) {
      this._rotate(rotation);
    }

    // translate to the new center.
    translate[0] = -center.x;
    translate[1] = -center.y;
    translate[2] = 0;
    this._translate(translate);
    return this;
  };

  /**
   * Sets the view matrix so that the given world center is centered, at
   * least a certain width and height are visible, and a rotation is applied.
   * The resulting bounds may be larger in width or height than the values if
   * the viewport is a different aspect ratio.
   *
   * @param {object} center Center of the view in gcs coordinates.
   * @param {number} center.x
   * @param {number} center.y
   * @param {object} size Minimum size of the view in gcs units.
   * @param {number} size.width
   * @param {number} size.height
   * @param {number} rotation in clockwise radians.  Optional.
   * @returns {this} Chainable.
   */
  this.viewFromCenterSizeRotation = function (center, size, rotation) {
    this._viewFromCenterSizeRotation(center, size, rotation);
    this._update();
    return this;
  };

  /**
   * Pans the view matrix by the given amount.
   *
   * @param {object} offset The delta in world space coordinates.
   * @param {number} offset.x
   * @param {number} offset.y
   * @param {number} [offset.z]
   * @returns {this} Chainable.
   */
  this.pan = function (offset) {
    if (!offset.x && !offset.y && !offset.z) {
      return this;
    }
    this._translate([offset.x, offset.y, offset.z || 0]);
    this._update();
    return this;
  };

  /**
   * Zooms the view matrix by the given amount.
   *
   * @param {number} zoom The zoom scale to apply
   * @returns {this} Chainable.
   */
  this.zoom = function (zoom) {
    if (zoom === 1) {
      return this;
    }
    mat4.scale(this._view, this._view, [zoom, zoom, zoom]);
    this._update();
    return this;
  };

  /**
   * Rotate the view matrix by the given amount.
   *
   * @param {number} rotation Counter-clockwise rotation angle in radians.
   * @param {object} center Center of rotation in world space coordinates.
   * @param {vec3} [axis] axis of rotation.
   * @returns {this} Chainable.
   */
  this._rotate = function (rotation, center, axis) {
    if (!rotation) {
      return this;
    }
    axis = axis || [0, 0, -1];
    if (!center) {
      center = [0, 0, 0];
    } else if (center.x !== undefined) {
      center = [center.x || 0, center.y || 0, center.z || 0];
    }
    var invcenter = [-center[0], -center[1], -center[2]];
    mat4.translate(this._view, this._view, center);
    mat4.rotate(this._view, this._view, rotation, axis);
    mat4.translate(this._view, this._view, invcenter);
    return this;
  };

  /**
   * Returns a CSS transform that converts (by default) from world coordinates
   * into display coordinates.  This allows users of this module to position
   * elements using world coordinates directly inside DOM elements.  This
   * expects that the transform-origin is 0 0.
   *
   * @param {string} [transform] The transform to return.  One of
   *   `display` or `world`.
   * @returns {string} The css transform string.
   */
  this.css = function (transform) {
    var m;
    switch ((transform || '').toLowerCase()) {
      case 'display':
      case '':
        m = this.display;
        break;
      case 'world':
        m = this.world;
        break;
      default:
        throw new Error('Unknown transform ' + transform);
    }
    return _camera.css(m);
  };

  /**
   * Represent a glmatrix as a pretty-printed string.
   * @param {mat4} mat A 4 x 4 matrix.
   * @param {number} [prec] The number of decimal places.
   * @returns {string}
   */
  this.ppMatrix = function (mat, prec) {
    var t = mat;
    prec = prec || 2;
    function f(i) {
      var d = t[i],
        s = d.toExponential(prec);
      if (d >= 0) {
        s = ' ' + s;
      }
      return s;
    }
    return [[f(0), f(4), f(8), f(12)].join(' '), [f(1), f(5), f(9), f(13)].join(' '), [f(2), f(6), f(10), f(14)].join(' '), [f(3), f(7), f(11), f(15)].join(' ')].join('\n');
  };

  /**
   * Pretty print the transform matrix.
   * @returns {string} A string representation of the matrix.
   */
  this.toString = function () {
    return this.ppMatrix(this._transform);
  };

  /**
   * Return a debugging string of the current camera state.
   * @returns {string} A string with the camera state.
   */
  this.debug = function () {
    return ['bounds', JSON.stringify(this.bounds), 'view:', this.ppMatrix(this._view), 'projection:', this.ppMatrix(this._proj), 'transform:', this.ppMatrix(this._transform)].join('\n');
  };

  /**
   * Represent the value of the camera as its transform matrix.
   * @returns {mat4} The transform matrix.
   */
  this.valueOf = function () {
    return this._transform;
  };
  this._clipbounds = this.constructor.clipbounds;
  // initialize the view matrix
  this._resetView();

  // set up the projection matrix
  this.projection = spec.projection || 'parallel';

  // initialize the viewport
  if (spec.viewport) {
    this.viewport = spec.viewport;
  }

  // trigger an initial update to set up the camera state
  this._update();
  return this;
};

/**
 * Supported projection types.
 * @enum {boolean}
 */
_camera.projection = {
  perspective: true,
  parallel: true
};

/**
 * Default camera clipping bounds.  Some features and renderers may rely on the
 * far clip value being more positive than the near clip value.
 * @enum {number}
 */
_camera.clipbounds = {
  perspective: {
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    far: 2000,
    near: 0.01
  },
  parallel: {
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    far: -1,
    near: 1
  }
};

/**
 * Output a mat4 as a css transform.  This expects that the transform-origin is
 * 0 0.
 *
 * @variation 2
 * @param {mat4} t A matrix transform.
 * @returns {string} A css transform string.
 */
_camera.css = function (t) {
  return 'matrix3d(' + t.map(function (val) {
    /* Format each value with a certain precision, but don't use scientific
     * notation or keep needless trailing zeroes. */
    val = (+val).toPrecision(15);
    if (val.indexOf('e') >= 0) {
      val = (+val).toString();
    } else if (val.indexOf('.') >= 0) {
      val = val.replace(/(\.|)0+$/, '');
    }
    return val;
  }).join(',') + ')';
};

// expose the vector and matrix functions for convenience
_camera.vec3 = vec3;
_camera.mat3 = mat3;
_camera.vec4 = vec4;
_camera.mat4 = mat4;
inherit(_camera, object);
module.exports = _camera;

/***/ }),

/***/ 1103:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerRenderer = (__webpack_require__(1098).registerRenderer);
var renderer = __webpack_require__(2274);

/**
 * Create a new instance of class canvasRenderer.
 *
 * @class
 * @alias geo.canvas.renderer
 * @extends geo.renderer
 * @param {object} arg Options for the renderer.
 * @param {geo.layer} [arg.layer] Layer associated with the renderer.
 * @param {HTMLElement} [arg.canvas] Canvas element associated with the
 *   renderer.
 * @returns {geo.canvas.canvasRenderer}
 */
var _canvasRenderer = function canvasRenderer(arg) {
  'use strict';

  var $ = __webpack_require__(5616);
  if (!(this instanceof _canvasRenderer)) {
    return new _canvasRenderer(arg);
  }
  arg = arg || {};
  renderer.call(this, arg);
  var m_this = this,
    m_clearCanvas = true,
    s_init = this._init,
    s_exit = this._exit;

  /**
   * Set the clear canvas flag.  If truthy, the canvas is erased at the start
   * of the render cycle.  If falsy, the old data is kept.
   *
   * @param {boolean} arg Truthy to clear the canvas when rendering is started.
   */
  this.clearCanvas = function (arg) {
    m_clearCanvas = arg;
  };

  /**
   * Get API used by the renderer.
   *
   * @returns {string} 'canvas'.
   */
  this.api = function () {
    return _canvasRenderer.apiname;
  };

  /**
   * Initialize.
   *
   * @returns {this}
   */
  this._init = function () {
    if (m_this.initialized()) {
      return m_this;
    }
    s_init.call(m_this);
    var canvas = arg.canvas || $(document.createElement('canvas'));
    m_this.context2d = canvas[0].getContext('2d');
    canvas.addClass('canvas-canvas');
    $(m_this.layer().node().get(0)).append(canvas);
    m_this.canvas(canvas);
    /* Initialize the size of the renderer */
    var map = m_this.layer().map(),
      mapSize = map.size();
    m_this._resize(0, 0, mapSize.width, mapSize.height);
    return m_this;
  };

  /**
   * Handle resize event.
   *
   * @param {number} x Ignored.
   * @param {number} y Ignored.
   * @param {number} w New width in pixels.
   * @param {number} h New height in pixels.
   * @returns {this}
   */
  this._resize = function (x, y, w, h) {
    var canvas = m_this.canvas();
    if (parseInt(canvas.attr('width'), 10) !== w || parseInt(canvas.attr('height'), 10) !== h) {
      m_this._setWidthHeight(w, h);
      canvas.attr('width', w);
      canvas.attr('height', h);
      m_this._render();
    }
    return m_this;
  };

  /**
   * Render.
   *
   * @returns {this}
   */
  this._render = function () {
    m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame);
    return m_this;
  };

  /**
   * Render during an animation frame callback.
   */
  this._renderFrame = function () {
    var layer = m_this.layer(),
      map = layer.map(),
      mapSize = map.size(),
      features = layer.features ? layer.features() : [],
      i;
    for (i = 0; i < features.length; i += 1) {
      if (features[i]._delayRender()) {
        // reschedule the render for the next animation frame
        m_this._render();
        // exit this render loop so it doesn't occur
        return;
      }
    }

    // Clear the canvas.
    if (m_clearCanvas) {
      m_this.context2d.setTransform(1, 0, 0, 1, 0, 0);
      m_this.context2d.clearRect(0, 0, mapSize.width, mapSize.height);
    }
    for (i = 0; i < features.length; i += 1) {
      if (features[i].visible()) {
        features[i]._renderOnCanvas(m_this.context2d, map);
      }
    }
  };

  /**
   * Exit.
   */
  this._exit = function () {
    m_this.canvas().remove();
    s_exit();
  };
  return this;
};
_canvasRenderer.apiname = 'canvas';
inherit(_canvasRenderer, renderer);
registerRenderer('canvas', _canvasRenderer);

/* Code for checking if the renderer is supported */

var checkedCanvas;

/**
 * Report if the canvas renderer is supported.
 *
 * @returns {boolean} true if available.
 */
_canvasRenderer.supported = function () {
  if (checkedCanvas === undefined) {
    /* This is extracted from what Modernizr uses. */
    var canvas;
    try {
      canvas = document.createElement('canvas');
      checkedCanvas = !!(canvas.getContext && canvas.getContext('2d'));
    } catch (e) {
      checkedCanvas = false;
    }
    canvas = undefined;
  }
  return checkedCanvas;
};

/**
 * If the canvas renderer is not supported, supply the name of a renderer that
 * should be used instead.  This asks for the null renderer.
 *
 * @returns {null} `null` for the null renderer.
 */
_canvasRenderer.fallback = function () {
  return null;
};
module.exports = _canvasRenderer;

/***/ }),

/***/ 9142:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var heatmapFeature = __webpack_require__(9163);
var timestamp = __webpack_require__(77);
var util = __webpack_require__(642);

/**
 * Create a new instance of class canvas.heatmapFeature.
 * Inspired from
 *    https://github.com/mourner/simpleheat/blob/gh-pages/simpleheat.js .
 *
 * @class
 * @alias geo.canvas.heatmapFeature
 * @param {geo.heatmapFeature.spec} arg
 * @extends geo.heatmapFeature
 * @returns {canvas_heatmapFeature}
 */
var _canvas_heatmapFeature = function canvas_heatmapFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_heatmapFeature)) {
    return new _canvas_heatmapFeature(arg);
  }
  heatmapFeature.call(this, arg);
  var object = __webpack_require__(5895);
  object.call(this);

  /**
   * @private
   */
  var geo_event = __webpack_require__(6409);
  var m_this = this,
    m_typedBuffer,
    m_typedClampedBuffer,
    m_typedBufferData,
    m_heatMapPosition,
    m_heatMapTransform,
    s_init = this._init,
    s_update = this._update,
    m_lastRenderDuration,
    m_renderTime = timestamp();

  /**
   * Compute gradient.  This creates a color lookup table.
   *
   * @returns {this}
   */
  this._computeGradient = function () {
    var canvas, stop, context2d, gradient, colors;
    colors = m_this.style('color');
    if (!m_this._grad || m_this._gradColors !== colors) {
      canvas = document.createElement('canvas');
      context2d = canvas.getContext('2d');
      gradient = context2d.createLinearGradient(0, 0, 0, 256);
      canvas.width = 1;
      canvas.height = 256;
      for (stop in colors) {
        gradient.addColorStop(stop, util.convertColorToRGBA(colors[stop]));
      }
      context2d.fillStyle = gradient;
      context2d.fillRect(0, 0, 1, 256);
      m_this._grad = context2d.getImageData(0, 0, 1, 256).data;
      m_this._gradColors = colors;
    }
    return m_this;
  };

  /**
   * Create a circle to render at each data point.
   *
   * @returns {this}
   */
  this._createCircle = function () {
    var circle, ctx, r, r2, blur, gaussian, scale;
    r = m_this.style('radius');
    blur = m_this.style('blurRadius');
    gaussian = m_this.style('gaussian');
    scale = m_this.style('scaleWithZoom');
    if (scale) {
      var zoom = this.layer().map().zoom();
      scale = Math.pow(2, zoom);
      r *= scale;
      blur *= scale;
    }
    if (!m_this._circle || m_this._circle.gaussian !== gaussian || m_this._circle.radius !== r || m_this._circle.blurRadius !== blur) {
      circle = m_this._circle = document.createElement('canvas');
      ctx = circle.getContext('2d');
      r2 = blur + r;
      circle.width = circle.height = r2 * 2;
      if (!gaussian) {
        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
        ctx.shadowBlur = blur;
        ctx.shadowColor = 'black';
        ctx.beginPath();
        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
      } else {
        /* This approximates a gaussian distribution by using a 10-step
         * piecewise linear radial gradient.  Strictly, it should not stop at
         * the radius, but should be attenuated further.  The scale has been
         * selected such that the values at the radius are around 1/256th of
         * the maximum, and therefore would not be visible using an 8-bit alpha
         * channel for the summation.  The values for opacity were generated by
         * the python expression:
         *   from scipy.stats import norm
         *   for r in [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]:
         *     opacity = norm.pdf(r, scale=0.3) / norm.pdf(0, scale=0.3)
         * Using a 10-interval approximation is accurate to within 0.5% of the
         * actual Gaussian magnitude.  Switching to a 20-interval approximation
         * would get within 0.1%, at which point there is more error from using
         * a Gaussian truncated at the radius than from the approximation.
         */
        var grad = ctx.createRadialGradient(r2, r2, 0, r2, r2, r2);
        grad.addColorStop(0.0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.1, 'rgba(255,255,255,0.946)');
        grad.addColorStop(0.2, 'rgba(255,255,255,0.801)');
        grad.addColorStop(0.3, 'rgba(255,255,255,0.607)');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.411)');
        grad.addColorStop(0.5, 'rgba(255,255,255,0.249)');
        grad.addColorStop(0.6, 'rgba(255,255,255,0.135)');
        grad.addColorStop(0.7, 'rgba(255,255,255,0.066)');
        grad.addColorStop(0.8, 'rgba(255,255,255,0.029)');
        grad.addColorStop(0.9, 'rgba(255,255,255,0.011)');
        grad.addColorStop(1.0, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, r2 * 2, r2 * 2);
      }
      circle.radius = r;
      circle.blurRadius = blur;
      circle.gaussian = gaussian;
      m_this._circle = circle;
    }
    return m_this;
  };

  /**
   * Compute color for each pixel on the screen.
   *
   * @param {Uint8ClampedArray} pixels A 2D canvas `getImageData` buffer.
   * @param {Uint8ClampedArray} gradient A 2D canvas with 256 pixels that
   *    contain a color gradient.
   * @protected
   */
  this._colorize = function (pixels, gradient) {
    var grad = new Uint32Array(gradient.buffer),
      pixlen = pixels.length,
      i,
      j,
      k;
    if (!m_typedBuffer || m_typedBuffer.length !== pixlen) {
      m_typedBuffer = new ArrayBuffer(pixlen);
      m_typedClampedBuffer = new Uint8ClampedArray(m_typedBuffer);
      m_typedBufferData = new Uint32Array(m_typedBuffer);
    }
    for (i = 3, k = 0; i < pixlen; i += 4, k += 1) {
      // Get opacity from the temporary canvas image and look up the final
      // value from gradient
      j = pixels[i];
      if (j) {
        m_typedBufferData[k] = grad[j];
      }
    }
    pixels.set(m_typedClampedBuffer);
  };

  /**
   * Render individual data points on the canvas.
   *
   * @param {RenderingContext} context2d The canvas context to draw in.
   * @param {geo.map} map The parent map object.
   * @param {array} data The main data array.
   * @param {number} radius The sum of `radius` and `blurRadius`.
   */
  this._renderPoints = function (context2d, map, data, radius) {
    var position = m_this.gcsPosition(),
      intensityFunc = m_this.intensity(),
      minIntensity = m_this.minIntensity(),
      rangeIntensity = m_this.maxIntensity() - minIntensity || 1,
      idx,
      pos,
      intensity;
    for (idx = data.length - 1; idx >= 0; idx -= 1) {
      pos = map.worldToDisplay(position[idx]);
      intensity = (intensityFunc(data[idx], idx) - minIntensity) / rangeIntensity;
      if (intensity <= 0) {
        continue;
      }
      // Small values are not visible because globalAlpha < .01
      // cannot be read from imageData
      context2d.globalAlpha = intensity < 0.01 ? 0.01 : intensity > 1 ? 1 : intensity;
      context2d.drawImage(m_this._circle, pos.x - radius, pos.y - radius);
    }
  };

  /**
   * Render data points on the canvas by binning.
   *
   * @param {RenderingContext} context2d The canvas context to draw in.
   * @param {geo.map} map The parent map object.
   * @param {array} data The main data array.
   * @param {number} radius The sum of `radius` and `blurRadius`.
   * @param {number} binSize Size of the bins in pixels.
   */
  this._renderBinnedData = function (context2d, map, data, radius, binSize) {
    var position = m_this.gcsPosition(),
      intensityFunc = m_this.intensity(),
      minIntensity = m_this.minIntensity(),
      rangeIntensity = m_this.maxIntensity() - minIntensity || 1,
      mapSize = map.size(),
      bins = [],
      rw = Math.ceil(radius / binSize),
      maxx = Math.ceil(mapSize.width / binSize) + rw * 2 + 2,
      maxy = Math.ceil(mapSize.height / binSize) + rw * 2 + 2,
      datalen = data.length,
      idx,
      pos,
      intensity,
      x,
      y,
      binrow,
      offsetx,
      offsety;

    /* We create bins of size (binSize) pixels on a side.  We only track bins
     * that are on the viewport or within the radius of it, plus one extra bin
     * width. */
    for (idx = 0; idx < datalen; idx += 1) {
      pos = map.worldToDisplay(position[idx]);
      /* To make the results look more stable, we use the first data point as a
       * hard-reference to where the bins should line up.  Otherwise, as we pan
       * points would shift which bin they are in and the display would ripple
       * oddly. */
      if (isNaN(pos.x) || isNaN(pos.y)) {
        continue;
      }
      if (offsetx === undefined) {
        offsetx = (pos.x % binSize + binSize) % binSize;
        offsety = (pos.y % binSize + binSize) % binSize;
      }
      /* We handle points that are in the viewport, plus the radius on either
       * side, as they will add into the visual effect, plus one additional bin
       * to account for the offset alignment. */
      x = Math.floor((pos.x - offsetx) / binSize) + rw + 1;
      if (x < 0 || x >= maxx) {
        continue;
      }
      y = Math.floor((pos.y - offsety) / binSize) + rw + 1;
      if (y < 0 || y >= maxy) {
        continue;
      }
      intensity = (intensityFunc(data[idx], idx) - minIntensity) / rangeIntensity;
      if (intensity <= 0) {
        continue;
      }
      if (intensity > 1) {
        intensity = 1;
      }
      /* bins is an array of arrays.  The subarrays would be conceptually
       * better represented as an array of dicts, but having a sparse array is
       * uses much less memory and is faster.  Each bin uses four array entries
       * that are (weight, intensity, x, y).  The weight is the sum of the
       * intensities for all points in the bin.  The intensity is the geometric
       * sum of the intensities to approximate what happens to the unbinned
       * data on the alpha channel of the canvas.  The x and y coordinates are
       * weighted by the intensity of each point. */
      bins[y] = bins[y] || [];
      x *= 4;
      binrow = bins[y];
      if (!binrow[x]) {
        binrow[x] = binrow[x + 1] = intensity;
        binrow[x + 2] = pos.x * intensity;
        binrow[x + 3] = pos.y * intensity;
      } else {
        binrow[x] += intensity; // weight
        binrow[x + 1] += (1 - binrow[x + 1]) * intensity;
        binrow[x + 2] += pos.x * intensity;
        binrow[x + 3] += pos.y * intensity;
      }
    }
    /* For each bin, render a point on the canvas. */
    for (y = bins.length - 1; y >= 0; y -= 1) {
      binrow = bins[y];
      if (binrow) {
        for (x = binrow.length - 4; x >= 0; x -= 4) {
          if (binrow[x]) {
            intensity = binrow[x + 1];
            context2d.globalAlpha = intensity < 0.01 ? 0.01 : intensity > 1 ? 1 : intensity;
            /* The position is eighted by the intensities, so we have to divide
             * it to get the necessary position */
            context2d.drawImage(m_this._circle, binrow[x + 2] / binrow[x] - radius, binrow[x + 3] / binrow[x] - radius);
          }
        }
      }
    }
  };

  /**
   * Render the data on the canvas, then colorize the resulting opacity map.
   *
   * @param {RenderingContext} context2d The canvas context to draw in.
   * @param {geo.map} map The parent map object.
   * @returns {this}
   */
  this._renderOnCanvas = function (context2d, map) {
    if (m_renderTime.timestamp() < m_this.buildTime().timestamp()) {
      var starttime = Date.now();
      var data = m_this.data() || [],
        radius = m_this.style('radius') + m_this.style('blurRadius'),
        binned = m_this.binned(),
        canvas,
        pixelArray,
        layer = m_this.layer(),
        mapSize = map.size();
      if (m_this.style('scaleWithZoom')) {
        radius *= Math.pow(2, map.zoom());
      }
      /* Determine if we should bin the data */
      if (binned === true || binned === 'auto') {
        binned = Math.max(Math.floor(radius / 8), Math.max(1.5, Math.min(3, radius / 2.5)));
        if (m_this.binned() === 'auto') {
          var numbins = Math.ceil((mapSize.width + radius * 2) / binned) * Math.ceil((mapSize.height + radius * 2) / binned);
          if (numbins >= data.length) {
            binned = 0;
          }
        }
      }
      if (binned < 1 || isNaN(binned)) {
        binned = false;
      }
      /* Store what we did, in case this is ever useful elsewhere */
      m_this._binned = binned;
      context2d.setTransform(1, 0, 0, 1, 0, 0);
      context2d.clearRect(0, 0, mapSize.width, mapSize.height);
      m_heatMapTransform = '';
      if (radius > 0.5 && radius < 8192) {
        map.scheduleAnimationFrame(m_this._setTransform, false);
        layer.canvas().css({
          transform: ''
        });
        m_this._createCircle();
        m_this._computeGradient();
        if (!binned) {
          m_this._renderPoints(context2d, map, data, radius);
        } else {
          m_this._renderBinnedData(context2d, map, data, radius, binned);
        }
        canvas = layer.canvas()[0];
        pixelArray = context2d.getImageData(0, 0, canvas.width, canvas.height);
        m_this._colorize(pixelArray.data, m_this._grad);
        context2d.putImageData(pixelArray, 0, 0);
      }
      m_heatMapPosition = {
        zoom: map.zoom(),
        gcsOrigin: map.displayToGcs({
          x: 0,
          y: 0
        }, null),
        rotation: map.rotation(),
        lastScale: undefined,
        lastOrigin: {
          x: 0,
          y: 0
        },
        lastRotation: undefined
      };
      m_renderTime.modified();
      layer.renderer().clearCanvas(false);
      m_lastRenderDuration = Date.now() - starttime;
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @returns {this}
   */
  this._init = function () {
    s_init.call(m_this, arg);
    m_this.geoOn(geo_event.pan, m_this._animatePan);
    return m_this;
  };

  /**
   * Update the feature.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.buildTime().timestamp() <= m_this.dataTime().timestamp() || m_this.updateTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Update the css transform for the layer as part of an animation frame.
   * This allows an existing rendered version of the heatmap to appear with a
   * transform until a new version can be computed.
   */
  this._setTransform = function () {
    if (m_this.layer() && m_this.layer().canvas() && m_this.layer().canvas()[0]) {
      m_this.layer().canvas()[0].style.transform = m_heatMapTransform;
    }
  };

  /**
   * Animate pan and zoom.
   */
  this._animatePan = function () {
    if (!m_heatMapPosition) {
      return;
    }
    var map = m_this.layer().map(),
      zoom = map.zoom(),
      scale = Math.pow(2, zoom - m_heatMapPosition.zoom),
      origin = map.gcsToDisplay(m_heatMapPosition.gcsOrigin, null),
      rotation = map.rotation();
    if (m_heatMapPosition.lastScale === scale && m_heatMapPosition.lastOrigin.x === origin.x && m_heatMapPosition.lastOrigin.y === origin.y && m_heatMapPosition.lastRotation === rotation) {
      return;
    }
    var transform = '' + ' translate(' + origin.x + 'px' + ',' + origin.y + 'px' + ')' + ' scale(' + scale + ')' + ' rotate(' + (rotation - m_heatMapPosition.rotation) * 180 / Math.PI + 'deg)';
    map.scheduleAnimationFrame(m_this._setTransform);
    m_heatMapTransform = transform;
    m_heatMapPosition.lastScale = scale;
    m_heatMapPosition.lastOrigin.x = origin.x;
    m_heatMapPosition.lastOrigin.y = origin.y;
    m_heatMapPosition.lastRotation = rotation;
    if (m_heatMapPosition.timeout) {
      window.clearTimeout(m_heatMapPosition.timeout);
      m_heatMapPosition.timeout = undefined;
    }
    /* This conditional can change if we compute the heatmap beyond the visible
     * viewport so that we don't have to update on pans as often.  If we are
     * close to where the heatmap was originally computed, don't bother
     * updating it. */
    if (parseFloat(scale.toFixed(4)) !== 1 || parseFloat((rotation - m_heatMapPosition.rotation).toFixed(4)) !== 0 || parseFloat(origin.x.toFixed(1)) !== 0 || parseFloat(origin.y.toFixed(1)) !== 0) {
      var delay = m_this.updateDelay();
      if (delay < 0 && m_lastRenderDuration) {
        delay = m_lastRenderDuration - Math.floor(1000 / 60 * delay);
      } else if (m_lastRenderDuration) {
        delay = m_lastRenderDuration * 2;
      } else {
        delay = 100;
      }
      m_heatMapPosition.timeout = window.setTimeout(function () {
        m_heatMapPosition.timeout = undefined;
        m_this.buildTime().modified();
        m_this.layer().draw();
      }, m_this.updateDelay());
    }
  };
  m_this._init(arg);
  return this;
};
inherit(_canvas_heatmapFeature, heatmapFeature);

// Now register it
registerFeature('canvas', 'heatmap', _canvas_heatmapFeature);
module.exports = _canvas_heatmapFeature;

/***/ }),

/***/ 8074:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @namespace geo.canvas
 */
module.exports = {
  canvasRenderer: __webpack_require__(1103),
  heatmapFeature: __webpack_require__(9142),
  isolineFeature: __webpack_require__(1195),
  lineFeature: __webpack_require__(2954),
  pixelmapFeature: __webpack_require__(5398),
  quadFeature: __webpack_require__(5578),
  textFeature: __webpack_require__(2213),
  tileLayer: __webpack_require__(511),
  trackFeature: __webpack_require__(1795)
};

/***/ }),

/***/ 1195:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var isolineFeature = __webpack_require__(2586);

/**
 * Create a new instance of class isolineFeature.
 *
 * @class
 * @alias geo.canvas.isolineFeature
 * @extends geo.isolineFeature
 * @param {geo.isolineFeature.spec} arg
 * @returns {geo.canvas.isolineFeature}
 */
var _canvas_isolineFeature = function canvas_isolineFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_isolineFeature)) {
    return new _canvas_isolineFeature(arg);
  }
  arg = arg || {};
  isolineFeature.call(this, arg);
  var object = __webpack_require__(5895);
  object.call(this);
  this._init(arg);
  return this;
};
inherit(_canvas_isolineFeature, isolineFeature);

// Now register it
registerFeature('canvas', 'isoline', _canvas_isolineFeature);
module.exports = _canvas_isolineFeature;

/***/ }),

/***/ 2954:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var lineFeature = __webpack_require__(9281);

/**
 * Create a new instance of class lineFeature.
 *
 * @class
 * @alias geo.canvas.lineFeature
 * @extends geo.lineFeature
 * @param {geo.lineFeature.spec} arg
 * @returns {geo.canvas.lineFeature}
 */
var _canvas_lineFeature = function canvas_lineFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_lineFeature)) {
    return new _canvas_lineFeature(arg);
  }
  var object = __webpack_require__(5895);
  arg = arg || {};
  lineFeature.call(this, arg);
  object.call(this);

  /**
   * @private
   */
  var m_this = this;

  /**
   * Render the data on the canvas.
   *
   * @protected
   * @param {object} context2d the canvas context to draw in.
   * @param {geo.map} map the parent map object.
   */
  this._renderOnCanvas = function (context2d, map) {
    var data = m_this.data(),
      posFunc = m_this.position(),
      lineFunc = m_this.line(),
      strokeWidthFunc = m_this.style.get('strokeWidth'),
      strokeColorFunc = m_this.style.get('strokeColor'),
      strokeOpacityFunc = m_this.style.get('strokeOpacity'),
      lineCapFunc = m_this.style.get('lineCap'),
      lineJoinFunc = m_this.style.get('lineJoin'),
      miterLimit = m_this.style.get('miterLimit')(data),
      closedFunc = m_this.style.get('closed'),
      last = {},
      cur = {},
      temp,
      line,
      pos,
      firstPos,
      j;
    data.forEach(function (d, i) {
      line = lineFunc(d, i);
      if (line.length < 2) {
        return;
      }
      cur.closed = closedFunc(d, i);
      cur.width = strokeWidthFunc(line[0], 0, d, i);
      cur.color = strokeColorFunc(line[0], 0, d, i);
      cur.opacity = strokeOpacityFunc(line[0], 0, d, i);
      cur.linecap = lineCapFunc(line[0], 0, d, i);
      cur.linejoin = lineJoinFunc(line[0], 0, d, i);
      cur.strokeStyle = 'rgba(' + cur.color.g * 255 + ', ' + cur.color.g * 255 + ', ' + cur.color.b * 255 + ', ' + (cur.opacity !== undefined ? cur.opacity : 1) + ')';
      if (last.strokeStyle !== cur.strokeStyle || last.width !== cur.width || last.linecap !== cur.linecap || last.linejoin !== cur.linejoin || last.miterlimit !== cur.miterlimit) {
        if (last.strokeStyle !== undefined) {
          context2d.stroke();
        }
        context2d.beginPath();
        context2d.strokeStyle = cur.strokeStyle;
        context2d.lineWidth = cur.width;
        context2d.lineCap = cur.linecap;
        context2d.lineJoin = cur.linejoin;
        context2d.miterLimit = miterLimit;
      }
      for (j = 0; j < line.length; j += 1) {
        pos = m_this.featureGcsToDisplay(posFunc(line[j], j, d, i));
        if (!j) {
          firstPos = pos;
          context2d.moveTo(pos.x, pos.y);
        } else {
          context2d.lineTo(pos.x, pos.y);
        }
      }
      if (cur.closed) {
        context2d.lineTo(firstPos.x, firstPos.y);
      }
      temp = last;
      last = cur;
      cur = temp;
    });
    if (last.strokeStyle !== undefined) {
      context2d.stroke();
    }
  };
  this._init(arg);
  return this;
};
inherit(_canvas_lineFeature, lineFeature);

// Now register it
var capabilities = {};
capabilities[lineFeature.capabilities.basic] = true;
capabilities[lineFeature.capabilities.multicolor] = false;
registerFeature('canvas', 'line', _canvas_lineFeature, capabilities);
module.exports = _canvas_lineFeature;

/***/ }),

/***/ 5895:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Canvas specific subclass of object which rerenders when the object is drawn.
 * @class
 * @alias geo.canvas.object
 * @extends geo.sceneObject
 * @param {object} arg Options for the object.
 * @returns {geo.canvas.object}
 */
var _canvas_object = function canvas_object(arg) {
  'use strict';

  var object = __webpack_require__(1338);

  // this is used to extend other geojs classes, so only generate
  // a new object when that is not the case... like if this === window
  if (!(this instanceof object)) {
    return new _canvas_object(arg);
  }
  var m_this = this,
    s_draw = this.draw,
    m_canvasProperties = {};

  /**
   * This must be overridden by any feature that needs to render.
   */
  this._renderOnCanvas = function () {};

  /**
   * If this returns true, the render will be skipped and tried again on the
   * next animation frame.
   *
   * @returns {boolean} Truthy to delay rendering.
   */
  this._delayRender = function () {
    return false;
  };

  /**
   * Check if a property has already been set on a canvas's context.  If so,
   * don't set it again.  Some browsers are much slower if the properties are
   * set, even if no change is made.
   *
   * @param {CanvasRenderingContext2D} [context] The canvas context to modify.
   *    If `undefined`, clear the internal property buffer.
   * @param {string} [key] The property to set on the canvas.
   * @param {object} [value] The value for the property.
   * @returns {this} The current object.
   */
  this._canvasProperty = function (context, key, value) {
    if (!context || !key) {
      m_canvasProperties = {};
      return m_this;
    }
    if (m_canvasProperties[key] !== value) {
      m_canvasProperties[key] = value;
      context[key] = value;
    }
    return m_this;
  };

  /**
   * Redraw the object.
   *
   * @returns {this} The current object.
   */
  this.draw = function () {
    if (m_this.ready) {
      m_this._update();
      m_this.renderer()._render();
      s_draw();
    }
    return m_this;
  };
  return this;
};
module.exports = _canvas_object;

/***/ }),

/***/ 5398:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var pixelmapFeature = __webpack_require__(7761);
var geo_event = __webpack_require__(6409);
var util = __webpack_require__(642);

/**
 * Pixelmap feature information record.
 *
 * @typedef {object} geo.pixelmapFeature.info
 * @property {number} width The width of the source image.
 * @property {number} height The width of the source image.
 * @property {CanvasRenderingContext2D} context The HTMLCanvasElement context
 *    used for handling the pixelmap.
 * @property {ImageData} imageData The context's image data.
 * @property {number[]} indices An array, one per pixel, of the index value in
 *    the image.  This decodes the pixel value to the corresponding integer.
 * @property {number} area The number of pixels in the image.  This is
 *    `width * height`.
 * @property {object[]} mappedColors This has one entry for each distinct index
 *    value.  Each entry has `first` and `last` with the first and last pixel
 *    locations where that index occurs.  Note that last is the inclusive value
 *    of the location (so its maximum possible value is `size - 1`).
 */

/**
 * Create a new instance of class pixelmapFeature.
 *
 * @class
 * @alias geo.canvas.pixelmapFeature
 * @extends geo.pixelmapFeature
 * @param {geo.pixelmapFeature.spec} arg
 * @returns {geo.canvas.pixelmapFeature}
 */
var _canvas_pixelmapFeature = function canvas_pixelmapFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_pixelmapFeature)) {
    return new _canvas_pixelmapFeature(arg);
  }
  pixelmapFeature.call(this, arg);
  var object = __webpack_require__(5895);
  object.call(this);
  var m_quadFeature,
    m_quadFeatureInit,
    s_exit = this._exit,
    m_this = this;

  /**
   * If the specified coordinates are in the rendered quad, use the basis
   * information from the quad to determine the pixelmap index value so that it
   * can be included in the `found` results.
   *
   * @param {geo.geoPosition} geo Coordinate.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.feature.searchResult} An object with a list of features and
   *    feature indices that are located at the specified point.
   */
  this.pointSearch = function (geo, gcs) {
    if (m_quadFeature) {
      var result = m_quadFeature.pointSearch(geo, gcs);
      if (m_this.m_info) {
        if (result.index.length === 1 && result.extra && result.extra[result.index[0]].basis) {
          var basis = result.extra[result.index[0]].basis,
            x,
            y,
            idx;
          x = Math.floor(basis.x * m_this.m_info.width);
          y = Math.floor(basis.y * m_this.m_info.height);
          if (x >= 0 && x < m_this.m_info.width && y >= 0 && y < m_this.m_info.height) {
            idx = m_this.m_info.indices[y * m_this.m_info.width + x];
            result = {
              index: [idx],
              found: [m_this.data()[idx]]
            };
            return result;
          }
        }
      } else {
        return this._pointSearchProcess(result);
      }
    }
    return {
      index: [],
      found: []
    };
  };

  /**
   * Compute information for this pixelmap image.  It is wasteful to call this
   * if the pixelmap has already been prepared (it is invalidated by a change
   * in the image).
   *
   * @param {object} [quad] A quad to use as the base instead of the class
   *    instance.
   * @returns {geo.pixelmapFeature.info?}
   */
  this._preparePixelmap = function (quad) {
    var base = quad || m_this;
    if (quad && quad.m_info) {
      return quad.m_info;
    }
    var i, idx, pixelData;
    if (!util.isReadyImage(base.m_srcImage)) {
      return undefined;
    }
    base.m_info = {
      width: base.m_srcImage.naturalWidth,
      height: base.m_srcImage.naturalHeight,
      canvas: document.createElement('canvas')
    };
    base.m_info.canvas.width = base.m_info.width;
    base.m_info.canvas.height = base.m_info.height;
    base.m_info.context = base.m_info.canvas.getContext('2d');
    base.m_info.context.drawImage(base.m_srcImage, 0, 0);
    base.m_info.imageData = base.m_info.context.getImageData(0, 0, base.m_info.canvas.width, base.m_info.canvas.height);
    pixelData = base.m_info.imageData.data;
    base.m_info.indices = new Array(pixelData.length / 4);
    base.m_info.area = pixelData.length / 4;
    base.m_info.mappedColors = {};
    for (i = 0; i < pixelData.length; i += 4) {
      idx = pixelData[i] + (pixelData[i + 1] << 8) + (pixelData[i + 2] << 16);
      base.m_info.indices[i / 4] = idx;
      if (!base.m_info.mappedColors[idx]) {
        base.m_info.mappedColors[idx] = {
          first: i / 4
        };
      }
      base.m_info.mappedColors[idx].last = i / 4;
    }
    return base.m_info;
  };

  /**
   * Given the loaded pixelmap image, create a canvas the size of the image.
   * Compute a color for each distinct index and recolor the canvas based on
   * these colors, then draw the resultant image as a quad.
   *
   * @fires geo.event.pixelmap.prepared
   * @param {object} [quad] A quad to use as the base instead of the class
   *    instance.
   */
  this._computePixelmap = function (quad) {
    var base = quad || m_this;
    var data = m_this.data() || [],
      colorFunc = m_this.style.get('color'),
      i,
      idx,
      lastidx,
      color,
      pixelData,
      indices,
      mappedColors,
      updateFirst,
      updateLast = -1,
      update,
      prepared;
    if (!m_quadFeatureInit && m_quadFeature && !quad) {
      m_quadFeature._hookRenderImageQuads = function (quads) {
        quads.forEach(function (quad) {
          if (!quad.m_srcImage) {
            quad.m_srcImage = quad.image;
            m_this._computePixelmap(quad);
            quad.image = quad.m_info.context.canvas;
            quad._build = m_this.buildTime().timestamp();
          } else if (m_this.buildTime().timestamp() > quad._build) {
            m_this._computePixelmap(quad);
            quad.image = quad.m_info.context.canvas;
            quad._build = m_this.buildTime().timestamp();
          }
        });
      };
      m_quadFeatureInit = true;
    }
    if (!base.m_info) {
      m_this.indexModified(undefined, 'clear');
      if (!m_this._preparePixelmap(quad)) {
        return;
      }
      prepared = true;
    }
    m_this.indexModified(undefined, 'clear');
    mappedColors = base.m_info.mappedColors;
    updateFirst = base.m_info.area;
    for (idx in mappedColors) {
      if (mappedColors.hasOwnProperty(idx)) {
        color = colorFunc(data[idx], +idx) || {};
        color = [(color.r || 0) * 255, (color.g || 0) * 255, (color.b || 0) * 255, color.a === undefined ? 255 : color.a * 255];
        mappedColors[idx].update = !mappedColors[idx].color || mappedColors[idx].color[0] !== color[0] || mappedColors[idx].color[1] !== color[1] || mappedColors[idx].color[2] !== color[2] || mappedColors[idx].color[3] !== color[3];
        if (mappedColors[idx].update) {
          mappedColors[idx].color = color;
          updateFirst = Math.min(mappedColors[idx].first, updateFirst);
          updateLast = Math.max(mappedColors[idx].last, updateLast);
        }
      }
    }
    /* If nothing was updated, we are done */
    if (updateFirst >= updateLast) {
      return;
    }
    /* Update only the extent that has changed */
    pixelData = base.m_info.imageData.data;
    indices = base.m_info.indices;
    for (i = updateFirst; i <= updateLast; i += 1) {
      idx = indices[i];
      if (idx !== lastidx) {
        lastidx = idx;
        color = mappedColors[idx].color;
        update = mappedColors[idx].update;
      }
      if (update) {
        pixelData[i * 4] = color[0];
        pixelData[i * 4 + 1] = color[1];
        pixelData[i * 4 + 2] = color[2];
        pixelData[i * 4 + 3] = color[3];
      }
    }
    /* Place the updated area into the canvas */
    base.m_info.context.putImageData(base.m_info.imageData, 0, 0, 0, Math.floor(updateFirst / base.m_info.width), base.m_info.width, Math.ceil((updateLast + 1) / base.m_info.width));
    if (quad) {
      return;
    }
    /* If we haven't made a quad feature, make one now.  The quad feature needs
     * to have the canvas capability. */
    if (!m_quadFeature) {
      m_quadFeature = m_this.layer().createFeature('quad', {
        selectionAPI: false,
        gcs: m_this.gcs(),
        visible: m_this.visible(undefined, true)
      });
      m_this.dependentFeatures([m_quadFeature]);
      m_quadFeature.style({
        image: m_this.m_info.canvas,
        position: m_this.style.get('position')
      }).data([{}]).draw();
      m_quadFeatureInit = true;
    }
    /* If we prepared the pixelmap and rendered it, send a prepared event */
    if (prepared) {
      m_this.geoTrigger(geo_event.pixelmap.prepared, {
        pixelmap: m_this
      });
    }
  };

  /**
   * Destroy.  Deletes the associated quadFeature.
   *
   * @returns {this}
   */
  this._exit = function () {
    if (m_quadFeature && m_this.layer()) {
      m_this.layer().deleteFeature(m_quadFeature);
      m_quadFeature = null;
      m_this.dependentFeatures([]);
    }
    s_exit();
    return m_this;
  };
  if (arg.quadFeature) {
    m_quadFeature = arg.quadFeature;
  }
  this._init(arg);
  return this;
};
inherit(_canvas_pixelmapFeature, pixelmapFeature);

// Now register it
var capabilities = {};
capabilities[pixelmapFeature.capabilities.lookup] = true;
registerFeature('canvas', 'pixelmap', _canvas_pixelmapFeature, capabilities);
module.exports = _canvas_pixelmapFeature;

/***/ }),

/***/ 5578:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var quadFeature = __webpack_require__(3842);
var util = __webpack_require__(642);

/**
 * Create a new instance of class quadFeature.
 *
 * @class
 * @alias geo.canvas.quadFeature
 * @param {geo.quadFeature.spec} arg Options object.
 * @extends geo.quadFeature
 * @returns {geo.canvas.quadFeature}
 */
var _canvas_quadFeature = function canvas_quadFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_quadFeature)) {
    return new _canvas_quadFeature(arg);
  }
  quadFeature.call(this, arg);
  var object = __webpack_require__(5895);
  object.call(this);
  var $ = __webpack_require__(5616);
  var m_this = this,
    s_exit = this._exit,
    s_init = this._init,
    s_update = this._update,
    m_quads;

  /**
   * Build this feature.
   */
  this._build = function () {
    if (!m_this.position()) {
      return;
    }
    m_quads = m_this._generateQuads();
    if (m_quads.imgQuads) {
      m_quads.imgQuads.sort(function (a, b) {
        return a.pos[2] - b.pos[2];
      });
    }
    m_this.buildTime().modified();
  };

  /**
   * When any quad may have changed, ask for a animation frame callback so we
   * can update the quad on the next animation cycle.
   *
   * This is called when a video qaud may have changed play state.
   * @param {object} quad The quad record that triggered this.
   * @param {jQuery.Event} [evt] The event that triggered this.
   */
  this._checkQuadUpdate = function (quad, evt) {
    m_this.layer().map().scheduleAnimationFrame(m_this._checkIfChanged);
  };

  /**
   * Check if any video quads are changing or need rerendering.  If any are
   * changing (because they are seeking), defer rendering and check again.  If
   * any need rendering, schedule it.
   */
  this._checkIfChanged = function () {
    if (!m_quads || !m_quads.vidQuads || !m_quads.vidQuads.length) {
      return;
    }
    var render = false,
      changing = false;
    $.each(m_quads.vidQuads, function (idx, quad) {
      if (quad.video && quad.video.HAVE_CURRENT_DATA !== undefined) {
        if (!quad.video.seeking && quad.video.readyState >= quad.video.HAVE_CURRENT_DATA) {
          render = true;
        }
        if (!quad.video.paused || quad.video.seeking) {
          changing = true;
        }
      }
    });
    if (render && m_this.renderer()) {
      m_this.renderer()._render();
    }
    if (changing) {
      m_this.layer().map().scheduleAnimationFrame(m_this._checkIfChanged);
    }
  };

  /**
   * Render all of the color quads.
   *
   * @param {CanvasRenderingContext2D} context2d The rendering context.
   * @param {geo.map} map The current renderer's parent map.
   */
  this._renderColorQuads = function (context2d, map) {
    if (!m_quads.clrQuads || !m_quads.clrQuads.length) {
      return;
    }
    var oldAlpha = context2d.globalAlpha;
    var opacity = oldAlpha;
    $.each(m_quads.clrQuads, function (idx, quad) {
      var p0 = map.gcsToDisplay({
          x: quad.pos[0],
          y: quad.pos[1]
        }, null),
        p1 = map.gcsToDisplay({
          x: quad.pos[3],
          y: quad.pos[4]
        }, null),
        p2 = map.gcsToDisplay({
          x: quad.pos[6],
          y: quad.pos[7]
        }, null),
        p3 = map.gcsToDisplay({
          x: quad.pos[9],
          y: quad.pos[10]
        }, null);
      if (quad.opacity !== opacity) {
        opacity = quad.opacity;
        context2d.globalAlpha = opacity;
      }
      context2d.fillStyle = util.convertColorToHex(quad.color, true);
      context2d.beginPath();
      context2d.moveTo(p0.x, p0.y);
      context2d.lineTo(p1.x, p1.y);
      context2d.lineTo(p3.x, p3.y);
      context2d.lineTo(p2.x, p2.y);
      context2d.closePath();
      context2d.fill();
    });
    if (opacity !== oldAlpha) {
      context2d.globalAlpha = oldAlpha;
    }
  };

  /**
   * Render all of the image and video quads.
   *
   * @param {CanvasRenderingContext2D} context2d The rendering context.
   * @param {geo.map} map The current renderer's parent map.
   */
  this._renderImageAndVideoQuads = function (context2d, map) {
    if ((!m_quads.imgQuads || !m_quads.imgQuads.length) && (!m_quads.vidQuads || !m_quads.vidQuads.length)) {
      return;
    }
    var oldAlpha = context2d.globalAlpha;
    var opacity = oldAlpha;
    var nearestPixel = m_this.nearestPixel();
    if (nearestPixel !== undefined) {
      if (nearestPixel !== true && util.isNonNullFinite(nearestPixel)) {
        var curZoom = m_this.layer().map().zoom();
        nearestPixel = curZoom >= nearestPixel;
      }
      context2d.imageSmoothingEnabled = !nearestPixel;
    }
    if (m_this._hookRenderImageQuads) {
      m_this._hookRenderImageQuads(m_quads.imgQuads);
    }
    $.each([m_quads.imgQuads, m_quads.vidQuads], function (listidx, quadlist) {
      if (!quadlist) {
        return;
      }
      $.each(quadlist, function (idx, quad) {
        var src, w, h;
        if (quad.image) {
          src = quad.image;
          w = src.width;
          h = src.height;
        } else if (quad.video) {
          src = quad.video;
          w = src.videoWidth;
          h = src.videoHeight;
          if (src.seeking) {
            return;
          }
        }
        if (!src || !w || !h || quad.opacity <= 0) {
          return;
        }
        // Canvas transform is affine, so quad has to be a parallelogram
        // Also, canvas has no way to render z.
        var p0 = map.gcsToDisplay({
            x: quad.pos[0],
            y: quad.pos[1]
          }, null),
          p2 = map.gcsToDisplay({
            x: quad.pos[6],
            y: quad.pos[7]
          }, null),
          p3 = map.gcsToDisplay({
            x: quad.pos[9],
            y: quad.pos[10]
          }, null);
        var cw = Math.min(w, quad.crop ? quad.crop.x || w : w);
        var ch = Math.min(h, quad.crop ? quad.crop.y || h : h);
        context2d.setTransform((p3.x - p2.x) / cw, (p3.y - p2.y) / cw, (p0.x - p2.x) / ch, (p0.y - p2.y) / ch, p2.x, p2.y);
        if (quad.opacity !== opacity) {
          opacity = quad.opacity;
          context2d.globalAlpha = opacity;
        }
        if (!quad.crop) {
          context2d.drawImage(src, 0, 0);
        } else {
          var cropx0 = Math.max(0, quad.crop.left || 0),
            cropy0 = Math.max(0, quad.crop.top || 0),
            cropx1 = Math.min(w, quad.crop.right || w),
            cropy1 = Math.min(h, quad.crop.bottom || h);
          if (w && h && cw > 0 && ch > 0 && cropx1 > cropx0 && cropy1 > cropy0) {
            context2d.drawImage(src, cropx0, cropy0, cropx1 - cropx0, cropy1 - cropy0, 0, 0, cw, ch);
          }
        }
      });
    });
    if (opacity !== oldAlpha) {
      context2d.globalAlpha = oldAlpha;
    }
    context2d.setTransform(1, 0, 0, 1, 0, 0);
    context2d.imageSmoothingEnabled = true;
  };

  /**
   * If this returns true, the render will be skipped and tried again on the
   * next animation frame.
   *
   * @returns {boolean} Truthy to delay rendering.
   */
  this._delayRender = function () {
    var delay = false;
    if (m_quads && m_quads.vidQuads && m_quads.vidQuads.length) {
      $.each(m_quads.vidQuads, function (idx, quad) {
        if (quad.video && quad.video.HAVE_CURRENT_DATA !== undefined) {
          delay |= quad.video.seeking && quad.delayRenderWhenSeeking;
        }
      });
    }
    return delay;
  };

  /**
   * Render all of the quads.
   *
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {geo.map} map The current renderer's parent map.
   */
  this._renderOnCanvas = function (context, map) {
    if (m_quads) {
      m_this._renderImageAndVideoQuads(context, map);
      m_this._renderColorQuads(context, map);
    }
  };

  /**
   * Update.
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.buildTime().timestamp() <= m_this.dataTime().timestamp() || m_this.updateTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }
    m_this.updateTime().modified();
    m_this.layer().map().scheduleAnimationFrame(m_this._checkIfChanged);
  };

  /**
   * Initialize.
   */
  this._init = function () {
    s_init.call(m_this, arg);
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    s_exit.call(m_this);
  };
  m_this._init(arg);
  return this;
};
inherit(_canvas_quadFeature, quadFeature);

// Now register it
var capabilities = {};
capabilities[quadFeature.capabilities.color] = true;
capabilities[quadFeature.capabilities.image] = true;
capabilities[quadFeature.capabilities.imageCrop] = true;
capabilities[quadFeature.capabilities.imageFixedScale] = true;
capabilities[quadFeature.capabilities.imageFull] = false;
capabilities[quadFeature.capabilities.canvas] = true;
capabilities[quadFeature.capabilities.video] = true;
capabilities[quadFeature.capabilities.texture] = false;
registerFeature('canvas', 'quad', _canvas_quadFeature, capabilities);
module.exports = _canvas_quadFeature;

/***/ }),

/***/ 2213:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var textFeature = __webpack_require__(6546);
var util = __webpack_require__(642);
var mat3 = __webpack_require__(3638);
var vec3 = __webpack_require__(1982);

/**
 * Create a new instance of class canvas.textFeature.
 *
 * @class
 * @alias geo.canvas.textFeature
 * @extends geo.textFeature
 * @extends geo.canvas.object
 *
 * @param {geo.textFeature.spec} [arg] Options for the feature.
 * @returns {geo.canvas.textFeature} The created feature.
 */
var _canvas_textFeature = function canvas_textFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_textFeature)) {
    return new _canvas_textFeature(arg);
  }
  var object = __webpack_require__(5895);
  arg = arg || {};
  textFeature.call(this, arg);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    m_defaultFont = 'bold 16px sans-serif',
    /* This regexp parses css font specifications into style, variant,
     * weight, stretch, size, line height, and family.  It is based on a
     * regexp here: https://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font,
     * but has been modified to fix some issues and handle font stretch. */
    m_cssFontRegExp = new RegExp('^\\s*' + '(?=(?:(?:[-a-z0-9]+\\s+){0,3}(italic|oblique))?)' + '(?=(?:(?:[-a-z0-9]+\\s+){0,3}(small-caps))?)' + '(?=(?:(?:[-a-z0-9]+\\s+){0,3}(bold(?:er)?|lighter|[1-9]00))?)' + '(?=(?:(?:[-a-z0-9]+\\s+){0,3}((?:ultra-|extra-|semi-)?(?:condensed|expanded)))?)' + '(?:(?:normal|\\1|\\2|\\3|\\4)\\s+){0,4}' + '((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))' + '(?:/(normal|[.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])))?\\s+' + '([-,\\"\\sa-z]+?)\\s*$', 'i');

  /**
   * Get the font for a specific data item.  This falls back to the default
   * font if the value is unset or doesn't contain sufficient information.
   *
   * @param {boolean} useSubValues If truthy, check all font styles (such as
   *    `fontSize`, `lineHeight`, etc., and override the code `font` style
   *    with those values.  If falsy, only use `font`.
   * @param {object} d The current data element.
   * @param {number} i The index of the current data element.
   * @returns {string} The font style.
   */
  this.getFontFromStyles = function (useSubValues, d, i) {
    var font = m_this.style.get('font')(d, i) || m_defaultFont;
    if (useSubValues) {
      var parts = m_cssFontRegExp.exec(font);
      if (parts === null) {
        parts = m_cssFontRegExp.exec(m_defaultFont);
      }
      parts[1] = m_this.style.get('fontStyle')(d, i) || parts[1];
      parts[2] = m_this.style.get('fontVariant')(d, i) || parts[2];
      parts[3] = m_this.style.get('fontWeight')(d, i) || parts[3];
      parts[4] = m_this.style.get('fontStretch')(d, i) || parts[4];
      parts[5] = m_this.style.get('fontSize')(d, i) || parts[5] || '16px';
      parts[6] = m_this.style.get('lineHeight')(d, i) || parts[6];
      parts[7] = m_this.style.get('fontFamily')(d, i) || parts[7] || 'sans-serif';
      font = (parts[1] || '') + ' ' + (parts[2] || '') + ' ' + (parts[3] || '') + ' ' + (parts[4] || '') + ' ' + (parts[5] || '') + (parts[6] ? '/' + parts[6] : '') + ' ' + parts[7];
      font = font.trim().replace(/\s\s+/g, ' ');
    }
    return font;
  };

  /**
   * Render the data on the canvas.
   *
   * This does not currently support multiline text or word wrapping, since
   * canvas doesn't implement that directly.  To support these, each text item
   * would need to be split on line breaks, and have the width of the text
   * calculated with context2d.measureText to determine word wrapping.  This
   * would also need to calculate the effective line height from the font
   * specification.
   *
   * @protected
   * @param {CanvasRenderingContext2D} context2d The canvas context to draw in.
   * @param {geo.map} map The parent map object.
   */
  this._renderOnCanvas = function (context2d, map) {
    var data = m_this.data(),
      posFunc = m_this.style.get('position'),
      renderThreshold = m_this.style.get('renderThreshold')(data),
      textFunc = m_this.style.get('text'),
      mapRotation = map.rotation(),
      mapZoom = map.zoom(),
      mapSize = map.size(),
      fontFromSubValues,
      text,
      posArray,
      pos,
      visible,
      color,
      blur,
      stroke,
      width,
      rotation,
      rotateWithMap,
      scale,
      offset,
      transform,
      lastTransform = util.mat3AsArray();

    /* If any of the font styles other than `font` have values, then we need to
     * construct a single font value from the subvalues.  Otherwise, we can
     * skip it. */
    fontFromSubValues = ['fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'lineHeight', 'fontFamily'].some(function (key) {
      return m_this.style(key) !== null && m_this.style(key) !== undefined;
    });
    /* Clear the canvas property buffer */
    m_this._canvasProperty();
    posArray = m_this.featureGcsToDisplay(data.map(posFunc));
    data.forEach(function (d, i) {
      /* If the position is far enough outside of the map viewport, don't
       * render it, even if the offset of size would be sufficient to make it
       * appear in the viewport. */
      pos = posArray[i];
      if (renderThreshold > 0 && (pos.x < -renderThreshold || pos.x > mapSize.width + renderThreshold || pos.y < -renderThreshold || pos.y > mapSize.height + renderThreshold)) {
        return;
      }
      visible = m_this.style.get('visible')(d, i);
      if (!visible && visible !== undefined) {
        return;
      }
      color = util.convertColorAndOpacity(m_this.style.get('color')(d, i), m_this.style.get('textOpacity')(d, i));
      stroke = util.convertColorAndOpacity(m_this.style.get('textStrokeColor')(d, i), m_this.style.get('textOpacity')(d, i), {
        r: 0,
        g: 0,
        b: 0,
        a: 0
      });
      if (color.a === 0 && stroke.a === 0) {
        return;
      }
      m_this._canvasProperty(context2d, 'fillStyle', util.convertColorToRGBA(color));
      text = textFunc(d, i);
      if (text === undefined || text === null || text === '') {
        return;
      }
      m_this._canvasProperty(context2d, 'font', m_this.getFontFromStyles(fontFromSubValues, d, i));
      m_this._canvasProperty(context2d, 'textAlign', m_this.style.get('textAlign')(d, i) || 'center');
      m_this._canvasProperty(context2d, 'textBaseline', m_this.style.get('textBaseline')(d, i) || 'middle');
      /* rotation, scale, and offset */
      rotation = m_this.style.get('rotation')(d, i) || 0;
      rotateWithMap = m_this.style.get('rotateWithMap')(d, i) && mapRotation;
      scale = m_this.style.get('textScaled')(d, i);
      scale = util.isNonNullFinite(scale) ? Math.pow(2, mapZoom - scale) : null;
      offset = m_this.style.get('offset')(d, i);
      transform = util.mat3AsArray();
      if (rotation || rotateWithMap || scale && scale !== 1 || offset && (offset.x || offset.y)) {
        mat3.translate(transform, transform, [pos.x, pos.y]);
        if (rotateWithMap && mapRotation) {
          mat3.rotate(transform, transform, mapRotation);
        }
        mat3.translate(transform, transform, [offset && offset.x ? +offset.x : 0, offset && offset.y ? +offset.y : 0]);
        if (rotation) {
          mat3.rotate(transform, transform, rotation);
        }
        if (scale && scale !== 1) {
          mat3.scale(transform, transform, [scale, scale]);
        }
        mat3.translate(transform, transform, [-pos.x, -pos.y]);
      }
      if (lastTransform[0] !== transform[0] || lastTransform[1] !== transform[1] || lastTransform[3] !== transform[3] || lastTransform[4] !== transform[4] || lastTransform[6] !== transform[6] || lastTransform[7] !== transform[7]) {
        context2d.setTransform(transform[0], transform[1], transform[3], transform[4], transform[6], transform[7]);
        mat3.copy(lastTransform, transform);
      }
      /* shadow */
      color = util.convertColorAndOpacity(m_this.style.get('shadowColor')(d, i), undefined, {
        r: 0,
        g: 0,
        b: 0,
        a: 0
      });
      if (color.a) {
        offset = m_this.style.get('shadowOffset')(d, i);
        blur = m_this.style.get('shadowBlur')(d, i);
      }
      if (color.a && (offset && (offset.x || offset.y) || blur)) {
        m_this._canvasProperty(context2d, 'shadowColor', util.convertColorToRGBA(color));
        if (offset && (rotation || rotateWithMap) && m_this.style.get('shadowRotate')(d, i)) {
          transform = [+offset.x, +offset.y, 0];
          vec3.rotateZ(transform, transform, [0, 0, 0], rotation + (rotateWithMap ? mapRotation : 0));
          offset = {
            x: transform[0],
            y: transform[1]
          };
        }
        m_this._canvasProperty(context2d, 'shadowOffsetX', offset && offset.x ? +offset.x : 0);
        m_this._canvasProperty(context2d, 'shadowOffsetY', offset && offset.y ? +offset.y : 0);
        m_this._canvasProperty(context2d, 'shadowBlur', blur || 0);
      } else {
        m_this._canvasProperty(context2d, 'shadowColor', 'rgba(0,0,0,0)');
      }
      /* draw the text */
      if (stroke.a) {
        width = m_this.style.get('textStrokeWidth')(d, i);
        if (isFinite(width) && width > 0) {
          m_this._canvasProperty(context2d, 'strokeStyle', util.convertColorToRGBA(stroke));
          m_this._canvasProperty(context2d, 'lineWidth', width);
          context2d.strokeText(text, pos.x, pos.y);
          m_this._canvasProperty(context2d, 'shadowColor', 'rgba(0,0,0,0)');
        }
      }
      context2d.fillText(text, pos.x, pos.y);
    });
    m_this._canvasProperty(context2d, 'globalAlpha', 1);
    context2d.setTransform(1, 0, 0, 1, 0, 0);
  };
  return this;
};
inherit(_canvas_textFeature, textFeature);

// Now register it
var capabilities = {};
registerFeature('canvas', 'text', _canvas_textFeature, capabilities);
module.exports = _canvas_textFeature;

/***/ }),

/***/ 511:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var registerLayerAdjustment = (__webpack_require__(1098).registerLayerAdjustment);
var canvas_tileLayer = function canvas_tileLayer() {
  'use strict';

  var m_this = this,
    s_init = this._init,
    s_exit = this._exit,
    s_update = this._update,
    m_quadFeature,
    m_nextTileId = 0,
    m_tiles = [];

  /* Add a tile to the list of quads */
  this._drawTile = function (tile) {
    if (!m_quadFeature) {
      return;
    }
    var bounds = m_this._tileBounds(tile),
      level = tile.index.level || 0,
      to = m_this._tileOffset(level),
      crop = m_this.tileCropFromBounds(tile),
      quad = {};
    if (crop) {
      quad.crop = crop;
    }
    quad.ul = m_this.fromLocal(m_this.fromLevel({
      x: bounds.left - to.x,
      y: bounds.top - to.y
    }, level), 0);
    quad.ll = m_this.fromLocal(m_this.fromLevel({
      x: bounds.left - to.x,
      y: bounds.bottom - to.y
    }, level), 0);
    quad.ur = m_this.fromLocal(m_this.fromLevel({
      x: bounds.right - to.x,
      y: bounds.top - to.y
    }, level), 0);
    quad.lr = m_this.fromLocal(m_this.fromLevel({
      x: bounds.right - to.x,
      y: bounds.bottom - to.y
    }, level), 0);
    quad.ul.z = quad.ll.z = quad.ur.z = quad.lr.z = level;
    m_nextTileId += 1;
    quad.id = m_nextTileId;
    tile.quadId = quad.id;
    quad.image = tile.image;
    m_tiles.push(quad);
    m_quadFeature.data(m_tiles);
    m_quadFeature._update();
    m_this.draw();
  };

  /* Remove the tile feature. */
  this._remove = function (tile) {
    if (tile.quadId !== undefined && m_quadFeature) {
      for (var i = 0; i < m_tiles.length; i += 1) {
        if (m_tiles[i].id === tile.quadId) {
          m_tiles.splice(i, 1);
          break;
        }
      }
      m_quadFeature.data(m_tiles);
      m_quadFeature._update();
      m_this.draw();
    }
  };

  /**
   * Update layer.
   *
   * @param {object} request A value to pass to the parent class.
   * @returns {this}
   */
  this._update = function (request) {
    s_update.call(m_this, request);
    if (m_quadFeature && m_quadFeature.nearestPixel) {
      m_quadFeature.nearestPixel(m_this.nearestPixel());
    }
    m_this._addBaseQuadToTiles(m_quadFeature, m_tiles);
    return m_this;
  };

  /**
   * Clean up the layer.
   */
  this._exit = function () {
    m_this.deleteFeature(m_quadFeature);
    m_quadFeature = null;
    m_tiles = [];
    s_exit.apply(m_this, arguments);
  };

  /**
   * Initialize after the layer is added to the map.
   */
  this._init = function () {
    s_init.apply(m_this, arguments);
    m_quadFeature = m_this.createFeature('quad', {
      previewColor: m_this._options.previewColor,
      previewImage: m_this._options.previewImage
    });
    m_quadFeature.geoTrigger = undefined;
    m_quadFeature.gcs(m_this._options.gcs || m_this.map().gcs());
    m_quadFeature.data(m_tiles);
    m_quadFeature._update();
  };

  /* These functions don't need to do anything. */
  this._getSubLayer = function () {};
  this._updateSubLayers = undefined;
};
registerLayerAdjustment('canvas', 'tile', canvas_tileLayer);
module.exports = canvas_tileLayer;

/***/ }),

/***/ 1795:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var trackFeature = __webpack_require__(338);

/**
 * Create a new instance of class trackFeature.
 *
 * @class
 * @alias geo.canvas.trackFeature
 * @extends geo.trackFeature
 * @param {geo.trackFeature.spec} arg
 * @returns {geo.canvas.trackFeature}
 */
var _canvas_trackFeature = function canvas_trackFeature(arg) {
  'use strict';

  if (!(this instanceof _canvas_trackFeature)) {
    return new _canvas_trackFeature(arg);
  }
  arg = arg || {};
  trackFeature.call(this, arg);
  var object = __webpack_require__(5895);
  object.call(this);
  this._init(arg);
  return this;
};
inherit(_canvas_trackFeature, trackFeature);

// Now register it
registerFeature('canvas', 'track', _canvas_trackFeature);
module.exports = _canvas_trackFeature;

/***/ }),

/***/ 3561:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Choropleth feature specification.
 *
 * @typedef {geo.feature.spec} geo.choroplethFeature.spec
 * @extends geo.feature.spec
 * @property {geo.colorObject[]} [colorRange] Color lookup table.  Default is
 *   9-step color table.
 * @property {Function} [scale] A scale converts a input domain into the
 *   the colorRange.  Default is `d3.scaleQuantize()`.
 * @property {Function} [geoId] Given a geometry feature, return an identifier.
 * @property {Function} [scalarId] Given a scalar element, return an
 *   identifier.
 * @property {Function} [scalarValue] Given a scalar element, return a numeric
 *   values.
 */

/**
 * Create a new instance of class choroplethFeature.
 *
 * @class
 * @alias geo.choroplethFeature
 * @param {geo.choroplethFeature.spec} arg Feature specification.
 * @extends geo.feature
 * @returns {geo.choroplethFeature}
 */
var _choroplethFeature = function choroplethFeature(arg) {
  'use strict';

  if (!(this instanceof _choroplethFeature)) {
    return new _choroplethFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);
  var ensureFunction = (__webpack_require__(642).ensureFunction);
  delete arg.layer;
  delete arg.renderer;
  /**
   * @private
   */
  var d3 = (__webpack_require__(2493).d3),
    m_this = this,
    s_init = this._init,
    m_choropleth = Object.assign({}, {
      colorRange: [{
        r: 0.07514311,
        g: 0.468049805,
        b: 1
      }, {
        r: 0.468487184,
        g: 0.588057293,
        b: 1
      }, {
        r: 0.656658579,
        g: 0.707001303,
        b: 1
      }, {
        r: 0.821573924,
        g: 0.837809045,
        b: 1
      }, {
        r: 0.943467973,
        g: 0.943498599,
        b: 0.943398095
      }, {
        r: 1,
        g: 0.788626485,
        b: 0.750707739
      }, {
        r: 1,
        g: 0.6289553,
        b: 0.568237474
      }, {
        r: 1,
        g: 0.472800903,
        b: 0.404551679
      }, {
        r: 0.916482116,
        g: 0.236630659,
        b: 0.209939162
      }],
      scale: d3.scaleQuantize(),
      //accessor for ID on geodata feature
      geoId: function geoId(geoFeature) {
        return geoFeature.properties.GEO_ID;
      },
      //accessor for ID on scalar element
      scalarId: function scalarId(scalarElement) {
        return scalarElement.id;
      },
      //accessor for value on scalar element
      scalarValue: function scalarValue(scalarElement) {
        return scalarElement.value;
      }
    }, arg);
  this.featureType = 'choropleth';

  /**
   * Get/Set choropleth scalar data.
   *
   * @param {object[]} [data] An array of objects that are passed to the
   *   `scalarId` and `scalarValue` functions to get the associated information
   *   for each scalar.
   * @param {Function} [aggregator] The aggregator aggregates the scalar when
   *   there are multiple values with the same id. The default is `d3.mean`.
   * @returns {object[]|this} Either the current scalar data or the feature
   *   instance.
   */
  this.scalar = function (data, aggregator) {
    var scalarId, scalarValue;
    if (data === undefined) {
      return m_this.choropleth.get('scalar')() || [];
    } else {
      scalarId = m_this.choropleth.get('scalarId');
      scalarValue = m_this.choropleth.get('scalarValue');
      m_choropleth.scalar = data;
      m_choropleth.scalarAggregator = aggregator || d3.mean;
      // we make internal dictionary from array for faster lookup
      // when matching geojson features to scalar values,
      // note that we also allow for multiple scalar elements
      // for the same geo feature
      m_choropleth.scalar._dictionary = data.reduce(function (accumeDictionary, scalarElement) {
        var id, value;
        id = scalarId(scalarElement);
        value = scalarValue(scalarElement);
        accumeDictionary[id] = accumeDictionary[id] ? accumeDictionary[id].push(value) : [value];
        return accumeDictionary;
      }, {});
      m_this.dataTime().modified();
    }
    return m_this;
  };

  /**
   * Get/Set choropleth accessor.
   *
   * @param {string|geo.choroplethFeature.spec} [arg1] If `undefined`,
   *    return the current choropleth specification.  If a string is specified,
   *    either get or set the named property.  If an object is given, set
   *    or update the specification with the specified parameters.
   * @param {object} [arg2] If `arg1` is a string, set that property to `arg2`.
   *    If `undefined`, return the current value of the named  property.
   * @returns {geo.choroplethFeature.spec|object|this} The current choropleth
   *    specification, the value of a named property, or this object.
   */
  this.choropleth = function (arg1, arg2) {
    var choropleth;
    if (arg1 === undefined) {
      return m_choropleth;
    }
    if (typeof arg1 === 'string' && arg2 === undefined) {
      return m_choropleth[arg1];
    }
    if (arg2 === undefined) {
      choropleth = Object.assign({}, m_choropleth, arg1);
      m_choropleth = choropleth;
    } else {
      m_choropleth[arg1] = arg2; //if you pass in accessor for prop
    }
    m_this.modified();
    return m_this;
  };

  /**
   * A uniform getter that always returns a function even for constant
   * choropleth properties.  This can also return all defined properties as
   * functions in a single object.
   *
   * @function choropleth_DOT_get
   * @memberof geo.choroplethFeature
   * @instance
   * @param {string} [key] If defined, return a function for the named
   *    property.  Otherwise, return an object with a function for all defined
   *    properties.
   * @returns {Function|object} Either a function for the named property or an
   *    object with functions for all defined properties.
   */
  this.choropleth.get = function (key) {
    var all = {},
      k;
    if (key === undefined) {
      for (k in m_choropleth) {
        if (m_choropleth.hasOwnProperty(k)) {
          all[k] = m_this.choropleth.get(k);
        }
      }
      return all;
    }
    return ensureFunction(m_choropleth[key]);
  };

  /**
   * Add a geojson polygon feature to the current layer.
   *
   * @param {geo.geojsonFeature} feature A geojson parsed feature.
   * @param {geo.geoColor} fillColor The fill color for the feature.
   * @returns {geo.polygonFeature}
   */
  this._featureToPolygons = function (feature, fillColor) {
    var newFeature = m_this.layer().createFeature('polygon', {});
    if (feature.geometry.type === 'Polygon') {
      newFeature.data([{
        type: 'Polygon',
        coordinates: feature.geometry.coordinates
      }]);
    } else if (feature.geometry.type === 'MultiPolygon') {
      newFeature.data(feature.geometry.coordinates.map(function (coordinateMap) {
        return {
          type: 'Polygon',
          coordinates: coordinateMap
        };
      }));
    }
    newFeature.polygon(function (d) {
      return {
        outer: d.coordinates[0],
        inner: d.coordinates[1] // undefined but ok
      };
    }).position(function (d) {
      return {
        x: d[0],
        y: d[1]
      };
    }).style({
      fillColor: fillColor
    });
    return newFeature;
  };

  /**
   * Set a choropleth scale's domain and range.
   *
   * @param {Function} valueAccessor A function that can be passed to
   *    `d3.extent`.
   * @returns {this}
   */
  this._generateScale = function (valueAccessor) {
    var extent = d3.extent(m_this.scalar(), valueAccessor || undefined);
    m_this.choropleth().scale.domain(extent).range(m_this.choropleth().colorRange);
    return m_this;
  };

  /**
   * Generate scale for choropleth.data(), make polygons from features.
   *
   * @returns {geo.featurePolygon[]}
   */
  this.createChoropleth = function () {
    var choropleth = m_this.choropleth,
      data = m_this.data(),
      scalars = m_this.scalar(),
      valueFunc = choropleth.get('scalarValue'),
      getFeatureId = choropleth.get('geoId');
    m_this._generateScale(valueFunc);
    return data.map(function (feature) {
      var id = getFeatureId(feature);
      var valueArray = scalars._dictionary[id];
      var accumulatedScalarValue = choropleth().scalarAggregator(valueArray);
      // take average of this array of values
      // which allows for non-bijective correspondence
      // between geo data and scalar data
      var fillColor = m_this.choropleth().scale(accumulatedScalarValue);
      return m_this._featureToPolygons(feature, fillColor);
    });
  };

  /**
   * Initialize.
   *
   * @param {geo.choroplethFeature} arg
   * @returns {this}
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    if (m_choropleth) {
      m_this.dataTime().modified();
    }
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_choroplethFeature, feature);
module.exports = _choroplethFeature;

/***/ }),

/***/ 6761:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var meshFeature = __webpack_require__(6124);

/**
 * Contour feature specification.
 *
 * @typedef {geo.feature.spec} geo.contourFeature.spec
 * @extends geo.feature.spec
 * @property {object[]} [data=[]] An array of arbitrary objects used to
 *    construct the feature.
 * @property {geo.contourFeature.styleSpec} [style] An object that contains
 *    style values for the feature.
 * @property {geo.contourFeature.contourSpec} [contour] The contour
 *    specification for the feature.
 */

/**
 * Style specification for a contour feature.
 *
 * @typedef {geo.feature.styleSpec} geo.contourFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {geo.geoPosition|Function} [position=data] The position of each
 *    data element.  This defaults to just using `x`, `y`, and `z` properties
 *    of the data element itself.  The position is in the feature's gcs
 *    coordinates.
 * @property {number|Function} [value=data.z] The value of each data element.
 *    This defaults to the `z` property of the data elements.  If the value of
 *    a grid point is `null` or `undefined`, the point and elements that use
 *    that point won't be included in the results.
 * @property {number|Function} [opacity=1] The opacity for the whole feature on
 *    a scale of 0 to 1.
 * @property {number[]|Function} [origin] Origin in map gcs coordinates used
 *   for to ensure high precision drawing in this location.  When called as a
 *   function, this is passed the vertex positions as a single continuous array
 *   in map gcs coordinates.  It defaults to the first vertex used in the
 *   contour.
 */

/**
 * Contour specification.  All of these properties can be functions, which get
 * passed the {@link geo.meshFeature.meshInfo} object.
 *
 * @typedef {geo.meshFeature.meshSpec} geo.contourFeature.contourSpec
 * @extends geo.meshFeature.meshSpec
 * @property {number} [min] Minimum contour value.  If unspecified, taken from
 *    the computed minimum of the `value` style.
 * @property {number} [max] Maximum contour value.  If unspecified, taken from
 *    the computed maximum of the `value` style.
 * @property {geo.geoColor} [minColor='black'] Color used for any value below
 *    the minimum.
 * @property {number} [minOpacity=0] Opacity used for any value below the
 *    minimum.
 * @property {geo.geoColor} [maxColor='black'] Color used for any value above
 *    the maximum.
 * @property {number} [maxOpacity=0] Opacity used for any value above the
 *    maximum.
 * @property {boolean} [stepped] If falsy but not `undefined`, smooth
 *    transitions between colors.
 * @property {geo.geoColor[]} [colorRange=<color table>] An array of colors
 *    used to show the range of values.  The default is a 9-step color table.
 * @property {number[]} [opacityRange] An array of opacities used to show the
 *    range of values.  If unspecified, the opacity is 1.  If this is a shorter
 *    list than the `colorRange`, an opacity of 1 is used for the entries near
 *    the end of the color range.
 * @property {number[]} [rangeValues] An array used to map values to the
 *    `colorRange`.  By default, values are spaced linearly.  If specified, the
 *    entries must be increasing weakly monotonic, and there must be one more
 *    entry then the length of `colorRange` if the contour is stepped, or the
 *    same length as the `colorRange` if unstepped.
 */

/**
 * Computed contour information.
 *
 * @typedef {geo.meshFeature.meshColoredInfo} geo.contourFeature.contourInfo
 * @extends geo.meshFeature.meshColoredInfo
 */

/**
 * Create a new instance of class contourFeature.
 *
 * @class
 * @alias geo.contourFeature
 * @extends geo.meshFeature
 *
 * @borrows geo.contourFeature#mesh as geo.contourFeature#contour
 *
 * @param {geo.contourFeature.spec} arg
 * @returns {geo.contourFeature}
 */
var _contourFeature = function contourFeature(arg) {
  'use strict';

  if (!(this instanceof _contourFeature)) {
    return new _contourFeature(arg);
  }
  var util = __webpack_require__(642);
  var meshUtil = __webpack_require__(5905);
  arg = arg || {};
  meshFeature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init;

  /**
   * Create a set of vertices, values at the vertices, and opacities at the
   * vertices.  Create a set of triangles of indices into the vertex array.
   * Create a color and opacity map corresponding to the values.
   *
   * @returns {geo.contourFeature.contourInfo} An object with the contour
   *    information.
   */
  this._createContours = function () {
    return meshUtil.createColoredMesh(m_this, false);
  };
  this.contour = m_this.mesh;

  /**
   * Initialize.
   *
   * @param {geo.contourFeature.spec} arg The contour feature specification.
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      opacity: 1.0,
      value: function value(d, i) {
        return util.isNonNullFinite(d) ? d : m_this.position()(d, i).z;
      },
      position: function position(d) {
        return d || {
          x: 0,
          y: 0
        };
      },
      origin: function origin(p) {
        return p.length >= 3 ? [p[0], p[1], 0] : [0, 0, 0];
      }
    }, arg.style === undefined ? {} : arg.style);
    m_this.style(defaultStyle);
    m_this.contour(Object.assign({}, {
      minColor: 'black',
      minOpacity: 0,
      maxColor: 'black',
      maxOpacity: 0,
      /* 9-step based on paraview bwr colortable */
      colorRange: [{
        r: 0.07514311,
        g: 0.468049805,
        b: 1
      }, {
        r: 0.468487184,
        g: 0.588057293,
        b: 1
      }, {
        r: 0.656658579,
        g: 0.707001303,
        b: 1
      }, {
        r: 0.821573924,
        g: 0.837809045,
        b: 1
      }, {
        r: 0.943467973,
        g: 0.943498599,
        b: 0.943398095
      }, {
        r: 1,
        g: 0.788626485,
        b: 0.750707739
      }, {
        r: 1,
        g: 0.6289553,
        b: 0.568237474
      }, {
        r: 1,
        g: 0.472800903,
        b: 0.404551679
      }, {
        r: 0.916482116,
        g: 0.236630659,
        b: 0.209939162
      }]
    }, arg.mesh || {}, arg.contour || {}));
    if (arg.mesh || arg.contour) {
      m_this.dataTime().modified();
    }
  };
  this._init(arg);
  return this;
};
inherit(_contourFeature, meshFeature);
module.exports = _contourFeature;

/* Example:

layer.createFeature('contour', {
})
.data(<array with w x h elements>)
.position(function (d) {
  return { x: <longitude>, y: <latitude>, z: <altitude>};
})
.style({
  opacity: function (d) {
    return <opacity of grid point>;
  },
  value: function (d) {            // defaults to position().z
    return <contour value>;
  }
})
.contour({
  gridWidth: <width of grid>,
  gridHeight: <height of grid>,
  x0: <the x coordinate of the 0th point in the value array>,
  y0: <the y coordinate of the 0th point in the value array>,
  dx: <the distance in the x direction between the 0th and 1st point in the
    value array>,
  dy: <the distance in the y direction between the 0th and (gridWidth)th point
    in the value array>,
  wrapLongitude: <boolean (default true).  If true, AND the position array is
    not used, assume the x coordinates is longitude and should be adjusted to
    be within -180 to 180.  If the data spans 180 degrees, the points or
    squares will be duplicated to ensure that the map is covered from -180 to
    180 as appropriate.  Set this to false if using a non longitude x
    coordinate.  This is ignored if the position array is used.>,
  min: <optional minimum contour value, otherwise taken from style.value>,
  max: <optional maximum contour value, otherwise taken from style.value>,
  minColor: <color for any value below the minimum>,
  minOpacity: <opacity for any value below the minimum>,
  maxColor: <color for any value above the maximum>,
  maxOpacity: <opacity for any value above the maximum>,
  stepped: <boolean (default true).  If false, smooth transitions between
    colors>,
  colorRange: [<array of colors used for the contour>],
  opacityRange: [<optional array of opacities used for the contour, expected to
    be the same length as colorRange>],
  rangeValues: [<if specified, instead of spacing the colors linearly, use this
    spacing.  Must be increasing monotonic and one value longer than the length
    of colorRange>]
})
 */

/***/ }),

/***/ 9726:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var renderer = __webpack_require__(2274);
var registerRenderer = (__webpack_require__(1098).registerRenderer);

/**
 * Create a new instance of class domRenderer.
 *
 * @class
 * @alias geo.domRenderer
 * @extends geo.renderer
 * @param {object} arg Options for the renderer.
 * @param {geo.layer} [arg.layer] Layer associated with the renderer.
 * @param {HTMLElement} [arg.canvas] Canvas element associated with the
 *   renderer.
 * @returns {geo.domRenderer}
 */
var _domRenderer = function domRenderer(arg) {
  'use strict';

  if (!(this instanceof _domRenderer)) {
    return new _domRenderer(arg);
  }
  renderer.call(this, arg);
  arg = arg || {};
  var m_this = this;

  /**
   * Get API used by the renderer.
   *
   * @returns {string} 'dom'.
   */
  this.api = function () {
    return 'dom';
  };

  /**
   * Initialize.
   *
   * @param {object} [arg] Optional arguments.
   * @returns {this}
   */
  this._init = function (arg) {
    var layer = m_this.layer().node();
    if (!m_this.canvas() && layer && layer.length) {
      // The renderer and the UI Layer share the same canvas
      // at least for now. This renderer is essentially a noop renderer
      // designed for backwards compatibility
      m_this.canvas(layer[0]);
    }
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_domRenderer, renderer);
registerRenderer('dom', _domRenderer);
module.exports = _domRenderer;

/***/ }),

/***/ 6409:
/***/ (function(module) {

/**
 * Common object containing all event types that are provided by the GeoJS
 * API.  Each property contained here is a valid target for event handling
 * via {@link geo.object#geoOn}.  The event object provided to handlers is
 * different for each event type.  Each handler is generally called with the
 * `this` context being the class that caused the event.
 *
 * @namespace
 * @alias geo.event
 * @type {object}
 *
 * @example
 * map.geoOn(geo.event.layerAdd, function (event) {
 *   // event is an object with type: {@link geo.event.layerAdd}
 * });
 *
 */
var geo_event = {};

/**
 * All events are sent an object that are an extension of this type.
 *
 * @typedef geo.event.base
 * @type {object}
 * @property {string} event The event type that was triggered.
 * @property {object} geo A universal event object for controlling propagation.
 */

/*
 * Event types
 */

/**
 * Triggered when a layer is added to the map.
 *
 * @event geo.event.layerAdd
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 * @property {geo.layer} layer The new layer that was added.
 */
geo_event.layerAdd = 'geo_layerAdd';

/**
 * Triggered when a layer is removed from the map.
 *
 * @event geo.event.layerRemove
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 * @property {geo.layer} layer The old layer that was removed.
 */
geo_event.layerRemove = 'geo_layerRemove';

/**
 * Triggered when a layer z-index is changed.
 *
 * @event geo.event.layerMove
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 * @property {geo.layer} layer The old layer that was removed.
 */
geo_event.layerMove = 'geo_layerMove';

/**
 * Triggered when the map's zoom level is changed.
 *
 * @event geo.event.zoom
 * @type {geo.event.base}
 * @property {number} zoomLevel New zoom level.
 * @property {geo.screenPosition} screenPosition The screen position of the
 *      mouse pointer.
 */
geo_event.zoom = 'geo_zoom';

/**
 * Triggered when the map is rotated around the current map center (pointing
 * downward so that positive angles are clockwise rotations).
 *
 * @event geo.event.rotate
 * @type {geo.event.base}
 * @property {number} rotation The angle of the rotation in radians.  This is
 *      the map's complete rotation, not a delta.
 * @property {geo.screenPosition} screenPosition The screen position of the
 *      mouse pointer.
 */
geo_event.rotate = 'geo_rotate';

/**
 * Triggered when the map is panned either by user interaction or map
 * transition.
 *
 * @event geo.event.pan
 * @type {geo.event.base}
 * @property {object} screenDelta The number of pixels of the pan.
 * @property {number} screenDelta.x Horizontal pan distance in pixels.
 * @property {number} screenDelta.y Vertical pan distance in pixels.
 */
geo_event.pan = 'geo_pan';

/**
 * Triggered when the map's canvas is resized.
 *
 * @event geo.event.resize
 * @type {geo.event.base}
 * @property {geo.map} target The map that was resized.
 * @property {number} width The new width in pixels.
 * @property {number} height The new height in pixels.
 */
geo_event.resize = 'geo_resize';

/**
 * Triggered on every call to {@link geo.map#draw} before the map is rendered.
 *
 * @event geo.event.draw
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 */
geo_event.draw = 'geo_draw';

/**
 * Triggered on every call to {@link geo.map#draw} after the map is rendered.
 *
 * @event geo.event.drawEnd
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 */
geo_event.drawEnd = 'geo_drawEnd';

/**
 * Triggered when the map is shown (the browser tab is made visible)
 *
 * @event geo.event.unhidden
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 */
geo_event.unhidden = 'geo_unhidden';

/**
 * Triggered when the map is hidden (the browser tab is no longer visible)
 *
 * @event geo.event.hidden
 * @type {geo.event.base}
 * @property {geo.map} target The current map.
 */
geo_event.hidden = 'geo_hidden';

/**
 * Triggered on every `mousemove` over the map's DOM element unless a click
 * might occur.  The event object extends {@link geo.mouseState}.
 *
 * @event geo.event.mousemove
 * @type {(geo.event.base|geo.mouseState)}
 */
geo_event.mousemove = 'geo_mousemove';

/**
 * Triggered on `mouseup` events that happen soon enough and close enough to a
 * `mousedown` event.  The event object extends {@link geo.mouseState}.
 *
 * @event geo.event.mouseclick
 * @type {(geo.event.base|geo.mouseState)}
 * @property {geo.mouseButtons} buttonsDown The buttons that were down at the
 *      start of the click action.
 */
geo_event.mouseclick = 'geo_mouseclick';

/**
 * Triggered on `mouseup` events.  The event object extends
 * {@link geo.mouseState}.
 *
 * @event geo.event.mouseup
 * @type {(geo.event.base|geo.mouseState)}
 * @property {geo.mouseButtons} buttonsDown The buttons that were down at the
 *      start of the up action.
 */
geo_event.mouseup = 'geo_mouseup';

/**
 * Triggered on `mousedown` events.  The event object extends
 * {@link geo.mouseState}.
 *
 * @event geo.event.mousedown
 * @type {(geo.event.base|geo.mouseState)}
 * @property {geo.mouseButtons} buttonsDown The buttons that were down at the
 *      end of the down action.
 */
geo_event.mousedown = 'geo_mousedown';

/**
 * Triggered on every `mousemove` during a brushing selection.
 * The event object extends {@link geo.brushSelection}.
 *
 * @event geo.event.brush
 * @type {(geo.event.base|geo.brushSelection)}
 */
geo_event.brush = 'geo_brush';

/**
 * Triggered after a brush selection ends.
 * The event object extends {@link geo.brushSelection}.
 *
 * @event geo.event.brushend
 * @type {(geo.event.base|geo.brushSelection)}
 */
geo_event.brushend = 'geo_brushend';

/**
 * Triggered when a brush selection starts.
 * The event object extends {@link geo.brushSelection}.
 *
 * @event geo.event.brushstart
 * @type {(geo.event.base|geo.brushSelection)}
 */
geo_event.brushstart = 'geo_brushstart';

/**
 * Triggered when brushing results in a selection.
 * The event object extends {@link geo.brushSelection}.
 *
 * @event geo.event.select
 * @type {(geo.event.base|geo.brushSelection)}
 */
geo_event.select = 'geo_select';

/**
 * Triggered when brushing results in a zoom selection.
 * The event object extends {@link geo.brushSelection}.
 *
 * @event geo.event.zoomselect
 * @type {(geo.event.base|geo.brushSelection)}
 */
geo_event.zoomselect = 'geo_zoomselect';

/**
 * Triggered when brushing results in a zoom-out selection.
 * The event object extends {@link geo.brushSelection}.
 *
 * @event geo.event.unzoomselect
 * @type {(geo.event.base|geo.brushSelection)}
 */

geo_event.unzoomselect = 'geo_unzoomselect';

/**
 * Triggered when an action is initiated with mouse down.
 *
 * @event geo.event.actiondown
 * @type {geo.event.base}
 * @property {geo.actionState} state The action state.
 * @property {geo.mouseState} mouse The mouse state.
 * @property {jQuery.Event} event The triggering jQuery event.
 */
geo_event.actiondown = 'geo_actiondown';

/**
 * Triggered when an action is being processed during mouse movement.
 *
 * @event geo.event.actionmove
 * @type {geo.event.base}
 * @property {geo.actionState} state The action state.
 * @property {geo.mouseState} mouse The mouse state.
 * @property {jQuery.Event} event The triggering event.
 */
geo_event.actionmove = 'geo_actionmove';

/**
 * Triggered when an action is ended with a mouse up.
 *
 * @event geo.event.actionup
 * @type {geo.event.base}
 * @property {geo.actionState} state The action state.
 * @property {geo.mouseState} mouse The mouse state.
 * @property {jQuery.Event} event The triggering event.
 */
geo_event.actionup = 'geo_actionup';

/**
 * Triggered when an action results in a selection.
 *
 * @event geo.event.actionselection
 * @type {geo.event.base}
 * @property {geo.actionState} state The action state.
 * @property {geo.mouseState} mouse The mouse state.
 * @property {jQuery.Event} event The triggering event.
 * @property {geo.screenPosition} lowerLeft Lower left of selection in screen
 *      coordinates.
 * @property {geo.screenPosition} upperRight Upper right of selection in screen
 *      coordinates.
 */
geo_event.actionselection = 'geo_actionselection';

/**
 * Triggered when an action is triggered with a mouse wheel event.
 *
 * @event geo.event.actionwheel
 * @type {geo.event.base}
 * @property {geo.actionState} state The action state.
 * @property {geo.mouseState} mouse The mouse state.
 * @property {jQuery.Event} event The triggering event.
 */
geo_event.actionwheel = 'geo_actionwheel';

/**
 * Triggered when an action is triggered via the keyboard.
 *
 * @event geo.event.keyaction
 * @type {geo.event.base}
 * @property {object} move The movement that would happen if the action is
 *      passed through.
 * @property {number} [move.zoomDelta] A change in the zoom level.
 * @property {number} [move.zoom] A new zoom level.
 * @property {number} [move.rotationDelta] A change in the rotation in radians.
 * @property {number} [move.rotation] A new absolute rotation in radians.
 * @property {number} [move.panX] A horizontal shift in display pixels.
 * @property {number} [move.panY] A vertical shift in display pixels.
 * @property {boolean} [move.cancel] Set to `true` to cancel the entire
 *      movement.
 * @property {string} action Action based on key
 * @property {number} factor Factor based on metakeys [0-2].  0 means a small
 *      movement is preferred, 1 a medium movement, and 2 a large movement.
 * @property {jQuery.Event} event The triggering event
 */
geo_event.keyaction = 'geo_keyaction';

/**
 * Triggered before a map navigation animation begins.  Set
 * `event.geo.cancelAnimation` to cancel the animation of the navigation.  This
 * will cause the map to navigate to the target location immediately.  Set
 * `event.geo.cancelNavigation` to cancel the navigation completely.  The
 * transition options can be modified in place.
 *
 * @event geo.event.transitionstart
 * @type {geo.event.base}
 * @property {geo.geoPosition} center The target center.
 * @property {number} zoom The target zoom level.
 * @property {number} duration The duration of the transition in milliseconds.
 * @property {Function} ease The easing function.
 */
geo_event.transitionstart = 'geo_transitionstart';

/**
 * Triggered after a map navigation animation ends.
 *
 * @event geo.event.transitionend
 * @type {geo.event.base}
 * @property {geo.geoPosition} center The target center.
 * @property {number} zoom The target zoom level.
 * @property {number} duration The duration of the transition in milliseconds.
 * @property {Function} ease The easing function.
 */
geo_event.transitionend = 'geo_transitionend';

/**
 * Triggered if a map navigation animation is canceled.
 *
 * @event geo.event.transitioncancel
 * @type {geo.event.base}
 * @property {geo.geoPosition} center The target center.
 * @property {number} zoom The target zoom level.
 * @property {number} duration The duration of the transition in milliseconds.
 * @property {Function} ease The easing function.
 */
geo_event.transitioncancel = 'geo_transitioncancel';

/**
 * Triggered when the parallel projection mode is changes.
 *
 * @event geo.event.parallelprojection
 * @type {geo.event.base}
 * @property {boolean} paralellProjection `true` if parallel projection is
 *      turned on.
 */
geo_event.parallelprojection = 'geo_parallelprojection';

/**
 * This event object provides mouse/keyboard events that can be handled
 * by the features.  This provides a similar interface as core events,
 * but with different names so the events don't interfere.  Subclasses
 * can override this to provide custom events.
 *
 * These events will only be triggered on features which were instantiated
 * with the option 'selectionAPI'.
 * @namespace geo.event.feature
 */
geo_event.feature = {
  /**
   * The event is the feature version of {@link geo.event.mousemove}.  It is
   * fired for each data component of a feature below the mouse when the mouse
   * moves.
   *
   * @event geo.event.feature.mousemove
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is over.
   * @property {number} index The index of the feature data the mouse is over.
   * @property {object} extra Extra information about the feature and mouse
   *    location.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse moves over simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mousemove: 'geo_feature_mousemove',
  /**
   * This event is fired for each data component of a feature when the mouse is
   * above it.
   *
   * @event geo.event.feature.mouseover
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is over.
   * @property {number} index The index of the feature data the mouse is over.
   * @property {object} extra Extra information about the feature and mouse
   *    location.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse goes over simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseover: 'geo_feature_mouseover',
  /**
   * This event is fired when the mouse changes either which feature components
   * or the order of the feature components that it is over.
   *
   * @event geo.event.feature.mouseover_order
   * @type {geo.event.base}
   * @property {geo.feature} feature The feature.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {geo.feature.searchResult} over A list of feature components
   *    that the mouse is over.
   * @property {number[]} The indices of the data components that the mouse
   *    was over before this event.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseover_order: 'geo_feature_mouseover_order',
  /**
   * The event is the feature version of {@link geo.event.mouseout}.
   * This event is fired for each data component of a feature when the mouse is
   * no longer above it.
   *
   * @event geo.event.feature.mouseout
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is over.
   * @property {number} index The index of the feature data the mouse is over.
   * @property {object} extra Extra information about the feature and mouse
   *    location.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse goes over simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseout: 'geo_feature_mouseout',
  /**
   * This event is fired when mouse is over a new topmost data component of a
   * feature.
   *
   * @event geo.event.feature.mouseon
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is on.
   * @property {number} index The index of the feature data the mouse is on.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseon: 'geo_feature_mouseon',
  /**
   * This event is fired when mouse is no longer has the same topmost data
   * component of a feature.
   *
   * @event geo.event.feature.mouseoff
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is off.
   * @property {number} index The index of the feature data the mouse is off.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseoff: 'geo_feature_mouseoff',
  /**
   * The event is the feature version of {@link geo.event.mouseclick}.
   *
   * @event geo.event.feature.mouseclick
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is off.
   * @property {number} index The index of the feature data the mouse is off.
   * @property {object} extra Extra information about the feature and mouse
   *    location.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse clicks simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseclick: 'geo_feature_mouseclick',
  /**
   * The event contains the `feature`, the `mouse` record, and `over`, the
   * record of data elements that are under the mouse.
   *
   * @event geo.event.feature.mouseclick_order
   * @type {geo.event.base}
   * @property {geo.feature} feature The feature that was clicked.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {geo.feature.searchResult} over A list of feature components
   *    that the mouse is over.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseclick_order: 'geo_feature_mouseclick_order',
  /**
   * The event is the feature version of {@link geo.event.mousedown}.
   *
   * @event geo.event.feature.mousedown
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is above.
   * @property {number} index The index of the feature data the mouse is above.
   * @property {object} extra Extra information about the feature and mouse
   *    location.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse goes down on simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mousedown: 'geo_feature_mousedown',
  /**
   * The event is the feature version of {@link geo.event.mouseup}.
   *
   * @event geo.event.feature.mouseup
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is above.
   * @property {number} index The index of the feature data the mouse is above.
   * @property {object} extra Extra information about the feature and mouse
   *    location.
   * @property {geo.mouseState} mouse The mouse state.  The buttons are before
   *    the up action occurs.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse goes up on simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   * @property {geo.event} sourceEvent The underlying event that trigger this.
   */
  mouseup: 'geo_feature_mouseup',
  /**
   * This event is fired for each data component of a feature under a brush
   * that has just finished its selection.
   *
   * @event geo.event.feature.brushend
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is over.
   * @property {number} index The index of the feature data the mouse is over.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {geo.brushSelection} brush The current brush selection.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse goes over simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   */
  brushend: 'geo_feature_brushend',
  /**
   * This event is fired for each data component of a feature under an active
   * brush.
   *
   * @event geo.event.feature.brush
   * @type {geo.event.base}
   * @property {object} data The feature data the mouse is over.
   * @property {number} index The index of the feature data the mouse is over.
   * @property {geo.mouseState} mouse The mouse state.
   * @property {geo.brushSelection} brush The current brush selection.
   * @property {number} eventID a monotonically increasing event number.  All
   *    features that the mouse goes over simultaneously will have the same
   *    `eventID`.
   * @property {boolean} top True if this is the topmost data element.
   */
  brush: 'geo_feature_brush'
};

/**
 * These events are triggered by the pixelmap feature.
 * @namespace geo.event.pixelmap
 */
geo_event.pixelmap = {
  /**
   * Report that an image associated with a pixel map has been prepared and
   * rendered once.
   *
   * @event geo.event.pixelmap.prepared
   * @type {geo.event.base}
   * @property {geo.pixelmapFeature} pixelmap The pixelmap object that was
   *    prepared.
   */
  prepared: 'geo_pixelmap_prepared'
};

/**
 * These events are triggered by the map screenshot feature.
 * @namespace geo.event.screenshot
 */
geo_event.screenshot = {
  /**
   * Triggered when a screenshot has been completed.
   *
   * @event geo.event.screenshot.ready
   * @type {geo.event.base}
   * @property {HTMLCanvasElement} canvas The canvas used to take the
   *    screenshot.
   * @property {string|HTMLCanvasElement} screenshot The screenshot as a
   *    dataURL string or the canvas, depending on the screenshot request.
   */
  ready: 'geo_screenshot_ready'
};

/**
 * These events are triggered by the camera when it's internal state is
 * mutated.
 * @namespace geo.event.camera
 */
geo_event.camera = {};

/**
 * Triggered after a general view matrix change (any change in the visible
 * bounds).  This is equivalent to the union of pan and zoom.
 *
 * @event geo.event.camera.view
 * @type {geo.event.base}
 * @property {geo.camera} camera The camera instance.
 */
geo_event.camera.view = 'geo_camera_view';

/**
 * Triggered after a projection change.
 *
 * @event geo.event.camera.projection
 * @type {geo.event.base}
 * @property {geo.camera} camera The camera instance.
 * @property {string} type The projection type, either `'perspective'` or
 *      `'parallel'`.
 */
geo_event.camera.projection = 'geo_camera_projection';

/**
 * Triggered after a viewport change.
 *
 * @event geo.event.camera.viewport
 * @type {geo.event.base}
 * @property {geo.camera} camera The camera instance.
 * @property {geo.screenSize} viewport The new viewport size.
 */
geo_event.camera.viewport = 'geo_camera_viewport';

/**
 * These events are triggered by the annotation layer.
 * @namespace geo.event.annotation
 */
geo_event.annotation = {};

/**
 * Triggered when or more multiple annotations have been added.
 *
 * @event geo.event.annotation.add
 * @type {geo.event.base}
 * @property {geo.annotation} [annotation] The annotation that was added.
 * @property {geo.annotation} [annotations] The annotations that were added.
 */
geo_event.annotation.add = 'geo_annotation_add';

/**
 * Triggered when one or multiple annotations are about to be added.
 *
 * @event geo.event.annotation.add_before
 * @type {geo.event.base}
 * @property {geo.annotation} [annotation] The annotation that will be added.
 * @property {geo.annotation[]} [annotations] The annotations that will be
 *   added.
 */
geo_event.annotation.add_before = 'geo_annotation_add_before';

/**
 * Triggered when an annotation has been altered.  This is currently only
 * triggered when updating existing annotations via the geojson function.
 *
 * @event geo.event.annotation.update
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that was altered.
 */
geo_event.annotation.update = 'geo_annotation_update';

/**
 * Triggered when an annotation's coordinates have been updated.
 *
 * @event geo.event.annotation.coordinates
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that was altered.
 */
geo_event.annotation.coordinates = 'geo_annotation_coordinates';

/**
 * Triggered when an annotation's edit handle is selected or released.
 *
 * @event geo.event.annotation.select_edit_handle
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that has an edit handle
 *   selected or unselected.
 * @property {object} handle Information on the edit handle.
 * @property {boolean} enable Truthy if the handle was enabled, falsy if
 *   disabled.
 */
geo_event.annotation.select_edit_handle = 'geo_annotation_select_edit_handle';

/**
 * Triggered when an action is performed on an annotation's edit handle.
 *
 * @event geo.event.annotation.edit_action
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that has an edit handle
 *   selected or unselected.
 * @property {object} handle Information on the edit handle.
 * @property {boolean} action The edit action, typically one of
 *  {@link geo.event.actiondown}, {@link geo.event.actionmove},
 *  {@link geo.event.actionup}.
 */
geo_event.annotation.edit_action = 'geo_annotation_edit_action';

/**
 * Triggered when an annotation has been removed.
 *
 * @event geo.event.annotation.remove
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that was removed.
 */
geo_event.annotation.remove = 'geo_annotation_remove';

/**
 * Triggered when an annotation's state changes.
 *
 * @event geo.event.annotation.state
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that changed.
 */
geo_event.annotation.state = 'geo_annotation_state';

/**
 * Triggered when the annotation mode is changed.
 *
 * @event geo.event.annotation.mode
 * @type {geo.event.base}
 * @property {string?} mode The new annotation mode.  This is one of the values
 *      from {@link geo.annotationLayer.mode} or an annotation name.
 * @property {string?} oldMode The annotation mode before this change.  This is
 *      one of the values from {@link geo.annotationLayer.mode} or an
 *      annotation name.
 * @property {string?} oldState If there was an active annotation before the
 *      mode change, this is the annotation state before the change.  This is
 *      one of the values from {@link geo.annotation.state}.
 * @property {string?} oldCoordinates If there was an active annotation before
 *      the mode change, these are the annotation's coordinates before the
 *      change.  This will be an empty list if an annotation in create state
 *      had not been started and a non-empty list if it is partially created.
 * @property {string?} reason An optional string that was passed to the mode
 *      change method.
 */
geo_event.annotation.mode = 'geo_annotation_mode';

/**
 * Triggered when an annotation can be combined via a boolean operation (union,
 * intersect, difference, xor, cut).
 *
 * @event geo.event.annotation.boolean
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that is being operated
 *      on.
 * @property {string} operation The operation being performed.
 * @property {boolean} [cancel] If the handle sets this to false, don't apply
 *      the operation to the annotation layer.
 */
geo_event.annotation.boolean = 'geo_annotation_boolean';

/**
 * Triggered when an annotation is in cursor mode and the mouse is clicked.
 *
 * @event geo.event.annotation.cursor_click
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that is being operated
 *      on.
 * @property {string} operation The operation being performed.
 * @property {boolean} [cancel] If the handle sets this to false, don't apply
 *      the operation to the annotation layer.
 * @property {object} event The triggering event.
 */
geo_event.annotation.cursor_click = 'geo_annotation_cursor_click';

/**
 * Triggered when an annotation is in cursor mode and an action occurs.
 *
 * @event geo.event.annotation.cursor_action
 * @type {geo.event.base}
 * @property {geo.annotation} annotation The annotation that is being operated
 *      on.
 * @property {string} operation The operation being performed.
 * @property {boolean} [cancel] If the handle sets this to false, don't apply
 *      the operation to the annotation layer.
 * @property {object} event The triggering event.
 */
geo_event.annotation.cursor_action = 'geo_annotation_cursor_action';
module.exports = geo_event;

/***/ }),

/***/ 1275:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var sceneObject = __webpack_require__(5402);
var timestamp = __webpack_require__(77);
var transform = __webpack_require__(5325);
var geo_event = __webpack_require__(6409);

/**
 * General specification for features.
 *
 * @typedef {object} geo.feature.spec
 * @property {geo.layer} [layer] the parent layer associated with the feature.
 * @property {boolean|'auto'} [selectionAPI='auto'] If `'auto'`, enable
 *   selection events if any {@link geo.event.feature} events are bound to the
 *   feature.  Otherwise, if truthy, enable selection events on the feature.
 *   Selection events are those in {@link geo.event.feature}.  They can be
 *   bound via a call like
 *   ```
 *   feature.geoOn(geo.event.feature.mousemove, function (evt) {
 *     // do something with the feature
 *   });
 *   ```
 *   where the handler is passed a {@link geo.event.feature} object.
 * @property {boolean} [visible=true] If truthy, show the feature.  If falsy,
 *   hide the feature and do not allow interaction with it.
 * @property {string} [gcs] The interface gcs for this feature.  If `undefined`
 *   or `null`, this uses the layer's interface gcs.  This is a string used by
 *   {@link geo.transform}.
 * @property {number} [bin=null] The bin number is used to determine the order
 *   of multiple features on the same layer.  It has no effect except on the
 *   webgl renderer.  A negative value hides the feature without stopping
 *   interaction with it.  Otherwise, more features with higher bin numbers are
 *   drawn above those with lower bin numbers.  If two features have the same
 *   bin number, their order relative to one another is indeterminate and may
 *   be unstable.  A value of `null` will use the current position of the
 *   feature within its parent's list of children as the bin number.
 * @property {geo.renderer} [renderer] A reference to the renderer used for
 *   the feature.  If `null` or unset or identical to `layer.renderer()`, the
 *   layer's renderer is used.
 * @property {geo.feature.styleSpec} [style] An object that contains style
 *   values for the feature.
 */

/**
 * Style specification for a feature.
 *
 * @typedef {*} geo.feature.styleSpec
 */

/**
 * @typedef {geo.feature.spec} geo.feature.createSpec
 * @extends geo.feature.spec
 * @property {string} type A supported feature type.
 * @property {object[]} [data=[]] An array of arbitrary objects used to
 *   construct the feature.  These objects (and their associated indices in the
 *   array) will be passed back to style and attribute accessors provided by
 *   the user.
 */

/**
 * @typedef {geo.event} geo.feature.event
 * @property {number} index The index of the feature within the data array.
 * @property {object} data The data element associated with the indexed
 *   feature.
 * @property {geo.mouseState} mouse The mouse information during the event.
 * @property {object} [extra] Additional information about the feature.  This
 *   is sometimes used to identify a subsection of the feature.
 * @property {number} [eventID] A monotonically increasing number identifying
 *   this feature event loop.  This is provided on
 *   {@link geo.event.feature.mousemove}, {@link geo.event.feature.mouseclick},
 *   {@link geo.event.feature.mouseover}, {@link geo.event.feature.mouseout},
 *   {@link geo.event.feature.brush}, and {@link geo.event.feature.brushend}
 *   events, since each of those can trigger multiple events for one mouse
 *   action (all events triggered by the same mouse action will have the same
 *   `eventID`).
 * @property {boolean} [top] `true` if this is the top-most feature that the
 *   mouse is over.  Only the top-most feature gets
 *   {@link geo.event.feature.mouseon} events, whereas multiple features can
 *   get other events.
 */

/**
 * @typedef {object} geo.feature.searchResult
 * @property {object[]} found A list of elements from the data array that were
 *   found by the search.
 * @property {number[]} index A list of the indices of the elements that were
 *   found by the search.
 * @property {object[]} [extra] A list of additional information per found
 *   element.  The information is passed to events without change.
 */

/**
 * Create a new instance of class feature.
 *
 * @class
 * @alias geo.feature
 * @extends geo.sceneObject
 * @param {geo.feature.spec} [arg] A feature specification.
 * @returns {geo.feature}
 */
var _feature = function feature(arg) {
  'use strict';

  if (!(this instanceof _feature)) {
    return new _feature(arg);
  }
  sceneObject.call(this);
  var util = __webpack_require__(642);

  /**
   * @private
   */
  arg = arg || {};
  var m_this = this,
    s_exit = this._exit,
    s_geoOn = this.geoOn,
    s_geoOff = this.geoOff,
    m_ready,
    m_selectionAPI = arg.selectionAPI === undefined ? 'auto' : arg.selectionAPI,
    m_style = {},
    m_layer = arg.layer === undefined ? null : arg.layer,
    m_gcs = arg.gcs,
    m_visible = arg.visible === undefined ? true : arg.visible,
    m_bin = arg.bin === undefined ? null : arg.bin,
    m_renderer = arg.renderer === undefined || m_layer && arg.renderer === m_layer.renderer() ? null : arg.renderer,
    m_dataTime = timestamp(),
    m_buildTime = timestamp(),
    m_updateTime = timestamp(),
    m_dependentFeatures = [],
    m_selectedFeatures = [];

  // subclasses can add keys to this for styles that apply to subcomponents of
  // data items, such as individual vertices on lines or polygons.
  this._subfeatureStyles = {};

  /**
   * @property {boolean} ready `true` if this feature has been initialized,
   *    `false` if it was destroyed, `undefined` if it was created but not
   *    initialized.
   * @name geo.feature#ready
   */
  Object.defineProperty(this, 'ready', {
    get: function get() {
      return m_ready;
    }
  });

  /**
   * Private method to bind mouse handlers on the map element.  This does
   * nothing if the selectionAPI is turned off.  Otherwise, it first unbinds
   * any existing handlers and then binds handlers.
   */
  this._bindMouseHandlers = function () {
    // Don't bind handlers for improved performance on features that don't
    // require it.
    if (!m_this.selectionAPI()) {
      return;
    }

    // First unbind to be sure that the handlers aren't bound twice.
    m_this._unbindMouseHandlers();
    m_this.geoOn(geo_event.mousemove, m_this._handleMousemove);
    m_this.geoOn(geo_event.mousedown, m_this._handleMousedown);
    m_this.geoOn(geo_event.mouseup, m_this._handleMouseup);
    m_this.geoOn(geo_event.mouseclick, m_this._handleMouseclick);
    m_this.geoOn(geo_event.brushend, m_this._handleBrushend);
    m_this.geoOn(geo_event.brush, m_this._handleBrush);
  };

  /**
   * Private method to unbind mouse handlers on the map element.
   */
  this._unbindMouseHandlers = function () {
    m_this.geoOff(geo_event.mousemove, m_this._handleMousemove);
    m_this.geoOff(geo_event.mousedown, m_this._handleMousedown);
    m_this.geoOff(geo_event.mouseup, m_this._handleMouseup);
    m_this.geoOff(geo_event.mouseclick, m_this._handleMouseclick);
    m_this.geoOff(geo_event.brushend, m_this._handleBrushend);
    m_this.geoOff(geo_event.brush, m_this._handleBrush);
  };

  /**
   * Search for features containing the given point.  This should be defined in
   * relevant subclasses.
   *
   * @param {geo.geoPosition} geo Coordinate.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.feature.searchResult} An object with a list of features and
   *    feature indices that are located at the specified point.
   */
  this.pointSearch = function (geo, gcs) {
    // base class method does nothing
    return {
      index: [],
      found: []
    };
  };

  /**
   * Search for features contained within a rectangular region.
   *
   * @param {geo.geoPosition} lowerLeft Lower-left corner.
   * @param {geo.geoPosition} upperRight Upper-right corner.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include features that are
   *    partially in the box, otherwise only include features that are fully
   *    within the region.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.feature.searchResult} An object with a list of features and
   *    feature indices that are located at the specified point.
   */
  this.boxSearch = function (lowerLeft, upperRight, opts, gcs) {
    return m_this.polygonSearch([lowerLeft, {
      x: lowerLeft.x,
      y: upperRight.y
    }, upperRight, {
      x: upperRight.x,
      y: lowerLeft.y
    }], opts, gcs);
  };

  /**
   * Search for features contained within a polygon.  This should be defined in
   * relevant subclasses.
   *
   * @param {geo.polygonObject} poly A polygon as an array of coordinates or an
   *    object with `outer` and optionally `inner` parameters.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include features that are
   *    partially in the polygon, otherwise only include features that are
   *    fully within the region.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.feature.searchResult} An object with a list of features and
   *    feature indices that are located at the specified point.
   */
  this.polygonSearch = function (poly, opts, gcs) {
    // base class method does nothing
    return {
      index: [],
      found: []
    };
  };

  /**
   * Private mousedown handler.  This uses `pointSearch` to determine which
   * features the mouse is over, then fires appropriate events.
   *
   * @param {geo.event} evt The event that triggered this handler.
   * @fires geo.event.feature.mousedown
   */
  this._handleMousedown = function (evt) {
    this._handleMousemove(evt, geo_event.feature.mousedown);
  };

  /**
   * Private mouseup handler.  This uses `pointSearch` to determine which
   * features the mouse is over, then fires appropriate events.
   *
   * @param {geo.event} evt The event that triggered this handler.
   * @fires geo.event.feature.mouseup
   */
  this._handleMouseup = function (evt) {
    this._handleMousemove(evt, geo_event.feature.mouseup);
  };

  /**
   * Private mousemove handler.  This uses `pointSearch` to determine which
   * features the mouse is over, then fires appropriate events.
   *
   * @param {geo.event} evt The event that triggered this handler.
   * @param {string} [updown] If "mouseup" or "mousedown", fire that event
   *    instead of mouseon.
   * @fires geo.event.feature.mouseover_order
   * @fires geo.event.feature.mouseover
   * @fires geo.event.feature.mouseout
   * @fires geo.event.feature.mousemove
   * @fires geo.event.feature.mouseoff
   * @fires geo.event.feature.mouseon
   * @fires geo.event.feature.mouseup
   * @fires geo.event.feature.mousedown
   */
  this._handleMousemove = function (evt, updown) {
    var mouse = evt && evt.mouse ? evt.mouse : m_this.layer().map().interactor().mouse(),
      data = m_this.data(),
      over = m_this.pointSearch(mouse.geo),
      newFeatures = [],
      oldFeatures = [],
      lastTop = -1,
      top = -1,
      extra;

    // exit if we have no old or new found entries
    if (!m_selectedFeatures.length && !over.index.length) {
      return;
    }
    extra = over.extra || {};

    // if we are over more than one item, trigger an event that is allowed to
    // reorder the values in evt.over.index.  Event handlers don't have to
    // maintain evt.over.found.  Handlers should not modify evt.over.extra or
    // evt.previous.
    if (over.index.length > 1) {
      m_this.geoTrigger(geo_event.feature.mouseover_order, {
        feature: m_this,
        mouse: mouse,
        previous: m_selectedFeatures,
        over: over,
        sourceEvent: evt
      });
    }
    _feature.eventID += 1;
    if (updown) {
      over.index.forEach(function (i, idx) {
        m_this.geoTrigger(updown, {
          data: data[i],
          index: i,
          extra: extra[i],
          mouse: mouse,
          eventID: _feature.eventID,
          top: idx === over.length - 1,
          sourceEvent: evt
        }, true);
      });
      return;
    }

    // Get the index of the element that was previously on top
    if (m_selectedFeatures.length) {
      lastTop = m_selectedFeatures[m_selectedFeatures.length - 1];
    }

    // There are probably faster ways of doing this:
    newFeatures = over.index.filter(function (i) {
      return m_selectedFeatures.indexOf(i) < 0;
    });
    oldFeatures = m_selectedFeatures.filter(function (i) {
      return over.index.indexOf(i) < 0;
    });

    // Fire events for mouse in first.
    newFeatures.forEach(function (i, idx) {
      m_this.geoTrigger(geo_event.feature.mouseover, {
        data: data[i],
        index: i,
        extra: extra[i],
        mouse: mouse,
        eventID: _feature.eventID,
        top: idx === newFeatures.length - 1,
        sourceEvent: evt
      }, true);
    });
    _feature.eventID += 1;
    // Fire events for mouse out next
    oldFeatures.forEach(function (i, idx) {
      m_this.geoTrigger(geo_event.feature.mouseout, {
        data: data[i],
        index: i,
        mouse: mouse,
        eventID: _feature.eventID,
        top: idx === oldFeatures.length - 1,
        sourceEvent: evt
      }, true);
    });
    _feature.eventID += 1;
    // Fire events for mouse move last
    over.index.forEach(function (i, idx) {
      m_this.geoTrigger(geo_event.feature.mousemove, {
        data: data[i],
        index: i,
        extra: extra[i],
        mouse: mouse,
        eventID: _feature.eventID,
        top: idx === over.index.length - 1,
        sourceEvent: evt
      }, true);
    });

    // Replace the selected features array
    m_selectedFeatures = over.index;

    // Get the index of the element that is now on top
    if (m_selectedFeatures.length) {
      top = m_selectedFeatures[m_selectedFeatures.length - 1];
    }
    if (lastTop !== top) {
      // The element on top changed so we need to fire mouseon/mouseoff
      if (lastTop !== -1) {
        m_this.geoTrigger(geo_event.feature.mouseoff, {
          data: data[lastTop],
          index: lastTop,
          mouse: mouse,
          sourceEvent: evt
        }, true);
      }
      if (top !== -1) {
        m_this.geoTrigger(geo_event.feature.mouseon, {
          data: data[top],
          index: top,
          extra: extra[top],
          mouse: mouse,
          sourceEvent: evt
        }, true);
      }
    }
  };

  /**
   * Clear our tracked selected features.
   *
   * @returns {this}
   */
  this._clearSelectedFeatures = function () {
    m_selectedFeatures = [];
    return m_this;
  };

  /**
   * Private mouseclick handler.  This uses `pointSearch` to determine which
   * features the mouse is over, then fires a click event for each such
   * feature.
   *
   * @param {geo.event} evt The event that triggered this handler.
   * @fires geo.event.feature.mouseclick_order
   * @fires geo.event.feature.mouseclick
   */
  this._handleMouseclick = function (evt) {
    var mouse = m_this.layer().map().interactor().mouse(),
      data = m_this.data(),
      over = m_this.pointSearch(mouse.geo),
      extra = over.extra || {};

    // if we are over more than one item, trigger an event that is allowed to
    // reorder the values in evt.over.index.  Event handlers don't have to
    // maintain evt.over.found.  Handlers should not modify evt.over.extra.
    if (over.index.length > 1) {
      m_this.geoTrigger(geo_event.feature.mouseclick_order, {
        feature: m_this,
        mouse: mouse,
        over: over,
        sourceEvent: evt
      });
    }
    mouse.buttonsDown = evt.buttonsDown;
    _feature.eventID += 1;
    over.index.forEach(function (i, idx) {
      m_this.geoTrigger(geo_event.feature.mouseclick, {
        data: data[i],
        index: i,
        extra: extra[i],
        mouse: mouse,
        eventID: _feature.eventID,
        top: idx === over.index.length - 1,
        sourceEvent: evt
      }, true);
    });
  };

  /**
   * Private brush handler.  This uses `polygonSearch` to determine which
   * features the brush includes, then fires appropriate events.
   *
   * @param {geo.brushSelection} brush The current brush selection.
   * @fires geo.event.feature.brush
   */
  this._handleBrush = function (brush) {
    var corners = [brush.gcs.lowerLeft, brush.gcs.lowerRight, brush.gcs.upperRight, brush.gcs.upperLeft];
    if (m_this.layer()) {
      var map = m_this.layer().map();
      corners = transform.transformCoordinates(map.gcs(), map.ingcs(), corners);
    }
    var search = m_this.polygonSearch(corners);
    _feature.eventID += 1;
    search.index.forEach(function (idx, i) {
      m_this.geoTrigger(geo_event.feature.brush, {
        data: search.found[i],
        index: idx,
        mouse: brush.mouse,
        brush: brush,
        eventID: _feature.eventID,
        top: i === search.index.length - 1
      }, true);
    });
  };

  /**
   * Private brushend handler.  This uses `polygonSearch` to determine which
   * features the brush includes, then fires appropriate events.
   *
   * @param {geo.brushSelection} brush The current brush selection.
   * @fires geo.event.feature.brushend
   */
  this._handleBrushend = function (brush) {
    var corners = [brush.gcs.lowerLeft, brush.gcs.lowerRight, brush.gcs.upperRight, brush.gcs.upperLeft];
    if (m_this.layer()) {
      var map = m_this.layer().map();
      corners = transform.transformCoordinates(map.gcs(), map.ingcs(), corners);
    }
    var search = m_this.polygonSearch(corners);
    _feature.eventID += 1;
    search.index.forEach(function (idx, i) {
      m_this.geoTrigger(geo_event.feature.brushend, {
        data: search.found[i],
        index: idx,
        mouse: brush.mouse,
        brush: brush,
        eventID: _feature.eventID,
        top: i === search.index.length - 1
      }, true);
    });
  };

  /**
   * Get/Set style used by the feature.  Styles can be constant values or
   * functions.  If a function, the style is typically called with parameters
   * such as `(dataElement, dataIndex)` or, if the specific style of a feature
   * has a subfeature style, with `(subfeatureElement, subfeatureIndex,
   * dataElement, dataIndex)`.
   *
   * See the <a href="#.styleSpec">style specification
   * <code>styleSpec</code></a> for available styles.
   *
   * @param {string|object} [arg1] If `undefined`, return the current style
   *    object.  If a string and `arg2` is undefined, return the style
   *    associated with the specified key.  If a string and `arg2` is defined,
   *    set the named style to the specified value.  Otherwise, extend the
   *    current style with the values in the specified object.
   * @param {*} [arg2] If `arg1` is a string, the new value for that style.
   * @returns {object|this} Either the entire style object, the value of a
   *    specific style, or the current class instance.
   */
  this.style = function (arg1, arg2) {
    if (arg1 === undefined) {
      return m_style;
    } else if (typeof arg1 === 'string' && arg2 === undefined) {
      return m_style[arg1];
    } else if (arg2 === undefined) {
      m_style = Object.assign({}, m_style, arg1);
      m_this.modified();
      return m_this;
    } else {
      m_style[arg1] = arg2;
      m_this.modified();
      return m_this;
    }
  };

  /**
   * A uniform getter that always returns a function even for constant styles.
   * This can also return all defined styles as functions in a single object.
   *
   * If the style `key` is a color, the returned function will also coerce
   * the result to be a {@link geo.geoColorObject}.
   *
   * @function style_DOT_get
   * @memberof geo.feature
   * @instance
   * @param {string} [key] If defined, return a function for the named style.
   *    Otherwise, return an object with a function for all defined styles.
   * @returns {Function|object} Either a function for the named style or an
   *    object with functions for all defined styles.
   */
  this.style.get = function (key) {
    var out;
    if (key === undefined) {
      var all = {},
        k;
      for (k in m_style) {
        if (m_style.hasOwnProperty(k)) {
          all[k] = m_this.style.get(k);
        }
      }
      return all;
    }
    if (key.toLowerCase().match(/color$/)) {
      if (util.isFunction(m_style[key])) {
        out = function out() {
          return util.convertColor(m_style[key].apply(m_this, arguments));
        };
      } else {
        // if the color is not a function, only convert it once
        out = util.ensureFunction(util.convertColor(m_style[key]));
      }
    } else {
      out = util.ensureFunction(m_style[key]);
    }
    return out;
  };

  /**
   * Set style(s) from array(s).  For each style, the array should have one
   * value per data item.  The values are not converted or validated.  Color
   * values should be {@link geo.geoColorObject}s.  If invalid values are given
   * the behavior is undefined.
   *   For some feature styles, if the first entry of an array is itself an
   * array, then each entry of the array is expected to be an array, and values
   * are used from these subarrays.  This allows a style to apply, for
   * instance, per vertex of a data item rather than per data item.
   *
   * @param {string|object} keyOrObject Either the name of a single style or
   *    an object where the keys are the names of styles and the values are
   *    each arrays.
   * @param {array} styleArray If keyOrObject is a string, an array of values
   *    for the style.  If keyOrObject is an object, this parameter is ignored.
   * @param {boolean} [refresh] `true` to redraw the feature when it has
   *    been updated.  If an object with styles is passed, the redraw is only
   *    done once.
   * @returns {this} The feature instance.
   */
  this.updateStyleFromArray = function (keyOrObject, styleArray, refresh) {
    if (typeof keyOrObject !== 'string') {
      $.each(keyOrObject, function (key, value) {
        m_this.updateStyleFromArray(key, value);
      });
    } else {
      /* colors are always expected to be objects with r, g, b values, so for
       * any color, make sure we don't have undefined entries. */
      var fallback;
      if (keyOrObject.toLowerCase().match(/color$/)) {
        fallback = {
          r: 0,
          g: 0,
          b: 0
        };
      }
      if (!Array.isArray(styleArray)) {
        return m_this;
      }
      if (m_this._subfeatureStyles[keyOrObject]) {
        if (styleArray.length && Array.isArray(styleArray[0])) {
          m_this.style(keyOrObject, function (v, j, d, i) {
            var val = (styleArray[i] || [])[j];
            return val !== undefined ? val : fallback;
          });
        } else {
          m_this.style(keyOrObject, function (v, j, d, i) {
            var val = styleArray[i];
            return val !== undefined ? val : fallback;
          });
        }
      } else {
        m_this.style(keyOrObject, function (d, i) {
          var val = styleArray[i];
          return val !== undefined ? val : fallback;
        });
      }
    }
    if (refresh && m_this.visible()) {
      m_this.draw();
    }
    return m_this;
  };

  /**
   * Get the layer referenced by the feature.
   *
   * @returns {geo.layer} The layer associated with the feature.
   */
  this.layer = function () {
    return m_layer;
  };

  /**
   * Get the renderer used by the feature.
   *
   * @returns {geo.renderer} The renderer used to render the feature.
   */
  this.renderer = function () {
    return m_renderer || m_layer && m_layer.renderer();
  };

  /**
   * Get/Set the projection of the feature.
   *
   * @param {string?} [val] If `undefined`, return the current gcs.  If
   *    `null`, use the map's interface gcs.  Otherwise, set a new value for
   *    the gcs.
   * @returns {string|this} A string used by {@link geo.transform}.  If the
   *    map interface gcs is in use, that value will be returned.  If the gcs
   *    is set, return the current class instance.
   */
  this.gcs = function (val) {
    if (val === undefined) {
      if ((m_gcs === undefined || m_gcs === null) && m_layer) {
        return m_layer.map().ingcs();
      }
      return m_gcs;
    } else {
      m_gcs = val;
      m_this.modified();
      return m_this;
    }
  };

  /**
   * Convert from the feature's gcs coordinates to display coordinates.
   *
   * @param {geo.geoPosition} c The input coordinate to convert.
   * @returns {geo.screenPosition} Display space coordinates.
   */
  this.featureGcsToDisplay = function (c) {
    var map = m_layer.map();
    c = map.gcsToWorld(c, m_this.gcs());
    c = map.worldToDisplay(c);
    if (m_this.renderer().baseToLocal) {
      c = m_this.renderer().baseToLocal(c);
    }
    return c;
  };

  /**
   * Get/Set the visibility of the feature.
   *
   * @param {boolean} [val] A boolean to change the visibility, or `undefined`
   *    to return the visibility.
   * @param {boolean} [direct] If `true`, when getting the visibility,
   *    disregard the visibility of the parent layer, and when setting, refresh
   *    the state regardless of whether it has changed or not.  Otherwise, the
   *    functional visibility is returned, where both the feature and the layer
   *    must be visible for a `true` result.
   * @returns {boolean|this} Either the visibility (if getting) or the feature
   *    (if setting).
   */
  this.visible = function (val, direct) {
    if (val === undefined) {
      if (!direct && m_layer && m_layer.visible && !m_layer.visible()) {
        return false;
      }
      return m_visible;
    }
    if (m_visible !== val || direct) {
      m_visible = val;
      if (m_layer && m_layer.visible && !m_layer.visible()) {
        val = false;
      }
      // bind or unbind mouse handlers on visibility change
      if (val) {
        m_this._bindMouseHandlers();
      } else {
        m_this._unbindMouseHandlers();
      }
      for (var i = 0; i < m_dependentFeatures.length; i += 1) {
        m_dependentFeatures[i].visible(m_visible, direct);
      }
    }
    return m_this;
  };

  /**
   * Get/Set a list of dependent features.  Dependent features have their
   * visibility changed at the same time as the feature.
   *
   * @param {geo.feature[]} [arg] If specified, the new list of dependent
   *    features.  Otherwise, return the current list of dependent features.
   * @returns {geo.feature[]|this} The current list of dependent features or
   *    a reference to `this`.
   */
  this.dependentFeatures = function (arg) {
    if (arg === undefined) {
      return m_dependentFeatures.slice();
    }
    m_dependentFeatures = arg.slice();
    return m_this;
  };

  /**
   * Get/Set bin of the feature.  The bin number is used to determine the order
   * of multiple features on the same layer.  It has no effect except on the
   * webgl renderer.  A negative value hides the feature without stopping
   * interaction with it.  Otherwise, features with higher bin numbers are
   * drawn above those with lower bin numbers.  If two features have the same
   * bin number, their order relative to one another is indeterminate and may
   * be unstable.
   *
   * @param {number} [val] The new bin number.  If `undefined`, return the
   *    current bin number.  If `null`, the bin is dynamically computed based
   *    on order within the parent.  If children are nested, this may not be
   *    what is desired.
   * @param {boolean} [actualValue] If truthy and `val` is undefined, return
   *    the actual value of bin, rather than the dynamically computed value.
   * @returns {number|this} The current bin number or a reference to `this`.
   */
  this.bin = function (val, actualValue) {
    if (val === undefined) {
      if (m_bin === null && !actualValue) {
        var parent = m_this.parent(),
          idx = parent ? parent.children().indexOf(m_this) : -1;
        return idx >= 0 ? idx : 0;
      }
      return m_bin;
    } else {
      if (util.isNonNullFinite(val)) {
        m_bin = parseInt(val, 10);
      } else {
        m_bin = null;
      }
      m_this.modified();
      return m_this;
    }
  };

  /**
   * Get/Set timestamp of data change.
   *
   * @param {geo.timestamp} [val] The new data timestamp object or `undefined`
   *    to get the current data timestamp object.
   * @returns {geo.timestamp|this}
   */
  this.dataTime = function (val) {
    if (val === undefined) {
      return m_dataTime;
    } else {
      m_dataTime = val;
      m_this.modified();
      return m_this;
    }
  };

  /**
   * Get/Set timestamp of last time a build happened.
   *
   * @param {geo.timestamp} [val] The new build timestamp object or `undefined`
   *    to get the current build timestamp object.
   * @returns {geo.timestamp|this}
   */
  this.buildTime = function (val) {
    if (val === undefined) {
      return m_buildTime;
    } else {
      m_buildTime = val;
      m_this.modified();
      return m_this;
    }
  };

  /**
   * Get/Set timestamp of last time an update happened.
   *
   * @param {geo.timestamp} [val] The new update timestamp object or
   *    `undefined` to get the current update timestamp object.
   * @returns {geo.timestamp|this}
   */
  this.updateTime = function (val) {
    if (val === undefined) {
      return m_updateTime;
    } else {
      m_updateTime = val;
      m_this.modified();
      return m_this;
    }
  };

  /**
   * Get/Set the data array for the feature.  This is equivalent to getting or
   * setting the `data` style, except that setting the data array via this
   * method updates the data timestamp, whereas setting it via the style does
   * not.
   *
   * @param {array} [data] A new data array or `undefined` to return the
   *    existing array.
   * @returns {array|this}
   */
  this.data = function (data) {
    if (data === undefined) {
      return m_this.style('data') || [];
    } else {
      m_this.style('data', data);
      m_this.dataTime().modified();
      m_this.modified();
      return m_this;
    }
  };

  /**
   * Get/Set if the selection API is enabled for this feature.
   *
   * @param {boolean|string} [arg] `undefined` to return the selectionAPI
   *    state, a boolean to change the state, or `'auto'` to set the state
   *    based on the existence of event handlers.  When getting the state, if
   *    `direct` is not specified, `'auto'` is never returned.
   * @param {boolean} [direct] If `true`, when getting the selectionAPI state,
   *    disregard the state of the parent layer, and when setting, refresh the
   *    state regardless of whether it has changed or not.
   * @returns {boolean|string|this} Either the selectionAPI state or the
   *    feature instance.
   */
  this.selectionAPI = function (arg, direct) {
    if (arg === undefined) {
      if (!direct && m_layer && m_layer.selectionAPI && !m_layer.selectionAPI()) {
        return false;
      }
      if (!direct && m_selectionAPI === 'auto') {
        return !!m_this.geoIsOn(Object.values(geo_event.feature));
      }
      return m_selectionAPI;
    }
    if (arg !== 'auto') {
      arg = !!arg;
    }
    if (arg !== m_selectionAPI || direct) {
      m_selectionAPI = arg;
      m_this._unbindMouseHandlers();
      m_this._bindMouseHandlers();
    }
    return m_this;
  };

  /**
   * If the selectionAPI is on, then setting
   * `this.geoOn(geo.event.feature.mouseover_order, this.mouseOverOrderHighestIndex)`
   * will make it so that the mouseon events prefer the highest index feature.
   *
   * @param {geo.event} evt The event; this should be triggered from
   *    {@link geo.event.feature.mouseover_order}.
   */
  this.mouseOverOrderHighestIndex = function (evt) {
    // sort the found indices.  The last one is the one "on top".
    evt.over.index.sort();
    // this isn't necessary, but ensures that other event handlers have
    // consistent information
    var data = evt.feature.data();
    evt.over.index.forEach(function (di, idx) {
      evt.over.found[idx] = data[di];
    });
  };

  /**
   * Initialize the class instance.  Derived classes should implement this.
   *
   * @param {geo.feature.spec} arg The feature specification.
   */
  this._init = function (arg) {
    if (!m_layer) {
      throw new Error('Feature requires a valid layer');
    }
    m_style = Object.assign({}, {
      opacity: 1.0
    }, arg.style === undefined ? {} : arg.style);
    m_this._bindMouseHandlers();
    m_ready = true;
  };

  /**
   * Build.
   *
   * Derived classes should implement this.
   */
  this._build = function () {};

  /**
   * Update.
   *
   * Derived classes should implement this.
   */
  this._update = function () {};

  /**
   * Bind an event handler to this object.
   *
   * @param {string} event An event from {@link geo.event} or a user-defined
   *   value.
   * @param {Function} handler A function that is called when `event` is
   *   triggered.  The function is passed a {@link geo.event} object.
   * @returns {this}
   */
  this.geoOn = function (event, handler) {
    var isAuto = m_this.selectionAPI(undefined, true) === 'auto',
      selection = isAuto && m_this.selectionAPI();
    var result = s_geoOn.apply(m_this, arguments);
    if (isAuto && !selection && m_this.selectionAPI()) {
      m_this._bindMouseHandlers();
    }
    return result;
  };

  /**
   * Remove handlers from one event or an array of events.  If no event is
   * provided all handlers will be removed.
   *
   * @param {string|string[]} [event] An event or a list of events from
   *   {@link geo.event} or defined by the user, or `undefined` to remove all
   *   events (in which case `arg` is ignored).
   * @param {(function|function[])?} [arg] A function or array of functions to
   *   remove from the events or a falsy value to remove all handlers from the
   *   events.
   * @returns {this}
   */
  this.geoOff = function (event, arg) {
    var isAuto = m_this.selectionAPI(undefined, true) === 'auto',
      selection = isAuto && m_this.selectionAPI();
    var result = s_geoOff.apply(m_this, arguments);
    if (isAuto && selection && !m_this.selectionAPI()) {
      m_this._unbindMouseHandlers();
    }
    return result;
  };

  /**
   * Destroy.  Unbind mouse handlers, clear internal variables, and call the
   * parent destroy method.
   *
   * Derived classes should implement this.
   */
  this._exit = function () {
    m_this._unbindMouseHandlers();
    m_selectedFeatures = [];
    m_style = {};
    s_exit();
    m_ready = false;
  };
  this._init(arg);
  return this;
};

/**
 * The most recent {@link geo.feature.event} triggered.
 * @type {number}
 */
_feature.eventID = 0;

/**
 * Create a feature.  This defines a general interface; see individual feature
 * types for specific details.
 *
 * @param {geo.layer} layer The layer to add the feature to.
 * @param {geo.feature.spec} spec The feature specification.  At least the
 *      `type` must be specified.
 * @returns {geo.feature|null} The created feature or `null` for a failure.
 */
_feature.create = function (layer, spec) {
  'use strict';

  // Check arguments
  if (!(layer instanceof __webpack_require__(5156))) {
    console.warn('Invalid layer'); // eslint-disable-line no-console
    return null;
  }
  if (_typeof(spec) !== 'object') {
    console.warn('Invalid spec'); // eslint-disable-line no-console
    return null;
  }
  var type = spec.type;
  var feature = layer.createFeature(type, spec);
  if (!feature) {
    console.warn('Could not create feature type "' + type + '"'); // eslint-disable-line no-console
    return null;
  }
  spec.data = spec.data || [];
  return feature.style(spec);
};
inherit(_feature, sceneObject);
module.exports = _feature;

/***/ }),

/***/ 6498:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var layer = __webpack_require__(5156);
var geo_event = __webpack_require__(6409);
var registry = __webpack_require__(1098);

/**
 * Layer to draw points, lines, and polygons on the map The polydata layer
 * provide mechanisms to create and draw geometrical shapes such as points,
 * lines, and polygons.
 * @class
 * @alias geo.featureLayer
 * @extends geo.layer
 * @param {geo.layer.spec} [arg] Specification for the new layer.
 * @returns {geo.featureLayer}
 */
var _featureLayer = function featureLayer(arg) {
  'use strict';

  if (!(this instanceof _featureLayer)) {
    return new _featureLayer(arg);
  }
  layer.call(this, arg);

  /**
   * private
   */
  var m_this = this,
    m_features = [],
    s_init = this._init,
    s_exit = this._exit,
    s_update = this._update,
    s_visible = this.visible,
    s_selectionAPI = this.selectionAPI,
    s_draw = this.draw;

  /**
   * Create a feature by name.
   *
   * @param {string} featureName The name of the feature to create.
   * @param {object} arg Properties for the new feature.
   * @returns {geo.feature} The created feature.
   */
  this.createFeature = function (featureName, arg) {
    var newFeature = registry.createFeature(featureName, m_this, m_this.renderer(), arg);
    if (newFeature) {
      m_this.addFeature(newFeature);
    } else {
      console.warn('Layer renderer (' + m_this.rendererName() + ') does not support feature type "' + featureName + '"'); // eslint-disable-line no-console
    }
    return newFeature;
  };

  /**
   * Add a feature to the layer if it is not already present.
   *
   * @param {object} feature the feature to add.
   * @returns {this}
   */
  this.addFeature = function (feature) {
    /* try to remove the feature first so that we don't have two copies */
    m_this.removeFeature(feature);
    m_this.addChild(feature);
    m_features.push(feature);
    m_this.dataTime().modified();
    m_this.modified();
    return m_this;
  };

  /**
   * Remove a feature without destroying it.
   *
   * @param {geo.feature} feature The feature to remove.
   * @returns {this}
   */
  this.removeFeature = function (feature) {
    var pos;
    pos = m_features.indexOf(feature);
    if (pos >= 0) {
      m_features.splice(pos, 1);
      m_this.removeChild(feature);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Delete feature.
   *
   * @param {geo.feature} feature The feature to delete.
   * @returns {this}
   */
  this.deleteFeature = function (feature) {
    // call _exit first, as destroying the feature affect other features
    if (feature) {
      if (m_features.indexOf(feature) >= 0) {
        feature._exit();
      }
      m_this.removeFeature(feature);
    }
    return m_this;
  };

  /**
   * Get/Set drawables.
   *
   * @param {geo.feature[]} [val] A list of features, or unspecified to return
   *    the current feature list.  If a list is provided, features are added or
   *    removed as needed.
   * @returns {geo.feature[]|this} The current features associated with the
   *    layer or the current layer.
   */
  this.features = function (val) {
    if (val === undefined) {
      return m_features.slice();
    } else {
      // delete existing features that aren't in the new array.  Since features
      // can affect other features during their exit process, make sure each
      // feature still exists as we work through the list.
      var existing = m_features.slice();
      var i;
      for (i = 0; i < existing.length; i += 1) {
        if (val.indexOf(existing[i]) < 0 && m_features.indexOf(existing[i]) >= 0) {
          m_this.deleteFeature(existing[i]);
        }
      }
      for (i = 0; i < val.length; i += 1) {
        m_this.addFeature(val[i]);
      }
      return m_this;
    }
  };

  /**
   * Get or set the gcs for all features.  For features, the default is usually
   * the map's ingcs.
   *
   * @param {string?} [val] If `undefined`, return the current gcs.  If
   *    `null`, use the map's interface gcs.  Otherwise, set a new value for
   *    the gcs.  When getting the current gcs, if not all features have the
   *    same gcs, `undefined` will be returned.
   * @returns {string|this} A string used by {@link geo.transform}.  If the
   *    map interface gcs is in use, that value will be returned.  If the gcs
   *    is set, return the current class instance.
   */
  this.gcsFeatures = function (val) {
    if (val === undefined) {
      var gcs, mixed;
      this.features().forEach(function (feature) {
        if (gcs === undefined) {
          gcs = feature.gcs();
        } else if (feature.gcs() !== gcs) {
          mixed = true;
        }
      });
      return mixed ? undefined : gcs;
    }
    m_this.features().forEach(function (feature) {
      if (feature.gcs() !== val) {
        feature.gcs(val);
      }
    });
    return m_this;
  };

  /**
   * Initialize.
   *
   * @returns {this}
   */
  this._init = function () {
    if (m_this.initialized()) {
      return m_this;
    }

    // Call super class init
    s_init.call(m_this, true);

    // Bind events to handlers
    m_this.geoOn(geo_event.resize, function (event) {
      if (m_this.renderer()) {
        m_this.renderer()._resize(event.x, event.y, event.width, event.height);
        m_this._update({
          event: event
        });
        m_this.renderer()._render();
      } else {
        m_this._update({
          event: event
        });
      }
    });
    m_this.geoOn(geo_event.pan, function (event) {
      m_this._update({
        event: event
      });
      if (m_this.renderer()) {
        m_this.renderer()._render();
      }
    });
    m_this.geoOn(geo_event.rotate, function (event) {
      m_this._update({
        event: event
      });
      if (m_this.renderer()) {
        m_this.renderer()._render();
      }
    });
    m_this.geoOn(geo_event.zoom, function (event) {
      m_this._update({
        event: event
      });
      if (m_this.renderer()) {
        m_this.renderer()._render();
      }
    });
    return m_this;
  };

  /**
   * Update layer.
   *
   * @param {object} request A value to pass to the parent class.
   * @returns {this}
   */
  this._update = function (request) {
    var i;
    if (!m_features.length) {
      return m_this;
    }

    // Call base class update
    s_update.call(m_this, request);
    if (m_this.dataTime().timestamp() > m_this.updateTime().timestamp()) {
      for (i = 0; i < m_features.length; i += 1) {
        m_features[i].renderer(m_this.renderer());
      }
    }
    for (i = 0; i < m_features.length; i += 1) {
      m_features[i]._update();
    }
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Free all resources.
   */
  this._exit = function () {
    m_this.clear();
    s_exit();
  };

  /**
   * Draw.  If the layer is visible, call the parent class's draw function and
   * the renderer's render function.
   *
   * @returns {this}
   */
  this.draw = function () {
    if (m_this.visible()) {
      // Call sceneObject.draw, which calls draw on all child objects.
      s_draw();

      // Now call render on the renderer. In certain cases it may not do
      // anything if the child objects are drawn on the screen already.
      if (m_this.renderer()) {
        m_this.renderer()._render();
      }
    }
    return m_this;
  };

  /**
   * Get/Set visibility of the layer.
   *
   * @param {boolean} [val] If specified, change the visibility, otherwise
   *    return it.
   * @returns {boolean|this} The current visibility or the layer.
   */
  this.visible = function (val) {
    if (val === undefined) {
      return s_visible();
    }
    if (m_this.visible() !== val) {
      s_visible(val);

      // take a copy of the features; changing visible could mutate them.
      var features = m_features.slice(),
        i;
      for (i = 0; i < features.length; i += 1) {
        features[i].visible(features[i].visible(undefined, true), true);
      }
      if (val) {
        m_this.draw();
      }
    }
    return m_this;
  };

  /**
   * Get/Set selectionAPI of the layer.
   *
   * @param {boolean} [val] If specified change the selectionAPI state of the
   *    layer, otherwise return the current state.
   * @returns {boolean|this} The selectionAPI state or the current layer.
   */
  this.selectionAPI = function (val) {
    if (val === undefined) {
      return s_selectionAPI();
    }
    if (m_this.selectionAPI() !== val) {
      s_selectionAPI(val);

      // take a copy of the features; changing selectionAPI could mutate them.
      var features = m_features.slice(),
        i;
      for (i = 0; i < features.length; i += 1) {
        features[i].selectionAPI(features[i].selectionAPI(undefined, true), true);
      }
    }
    return m_this;
  };

  /**
   * Clear all features in layer.
   *
   * @returns {this}
   */
  this.clear = function () {
    while (m_features.length) {
      m_this.deleteFeature(m_features[0]);
    }
    return m_this;
  };
  return m_this;
};
inherit(_featureLayer, layer);
registry.registerLayer('feature', _featureLayer);
module.exports = _featureLayer;

/***/ }),

/***/ 5938:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);

/**
 * @typedef {object} geo.fetchQueue.spec
 * @property {number} [size=6] The maximum number of concurrent deferred
 *   objects.
 * @property {number} [track=600] The number of objects that are tracked that
 *   trigger checking if any of them have been abandoned.  The fetch queue can
 *   grow to the greater of this size and the number of items that are still
 *   needed.  Setting this to a low number will increase processing time, to a
 *   high number can increase memory.  Ideally, it should reflect the number of
 *   items that are kept in memory elsewhere.  If `needed` is `null`, this is
 *   ignored.
 * @property {Function} [needed=null] If set, this function is passed a
 *   Deferred object and must return a truthy value if the object is still
 *   needed.
 */

/**
 * This class implements a queue for Deferred objects.  Whenever one of the
 * objects in the queue completes (resolved or rejected), another item in the
 * queue is processed.  The number of concurrently processing items can be
 * adjusted.
 *
 * At this time (2018-11-02) most major browsers support 6 concurrent requests
 * from any given server, so, when using the queue for tile images, the number
 * of concurrent requests should be 6 * (number of subdomains serving tiles).
 *
 * @class
 * @alias geo.fetchQueue
 * @param {geo.fetchQueue.spec} [options] A configuration object for the queue.
 * @returns {geo.fetchQueue}
 */
var _fetchQueue = function fetchQueue(options) {
  if (!(this instanceof _fetchQueue)) {
    return new _fetchQueue(options);
  }
  options = options || {};
  this._size = options.size || 6;
  this._initialSize = options.initialSize || 0;
  this._track = options.track || 600;
  this._initialTrack = this._track;
  this._needed = options.needed || null;
  this._batch = false;
  var m_this = this,
    m_next_batch = 1;

  /**
   * Get/set the maximum concurrent deferred object size.
   * @property {number} size The maximum number of deferred objects.
   * @name geo.fetchQueue#size
   */
  Object.defineProperty(this, 'size', {
    get: function get() {
      return m_this._size;
    },
    set: function set(n) {
      m_this._size = n;
      if (m_this._initialSize > 1 && n < m_this._initialSize) {
        m_this._initialSize = n;
      }
      m_this.next_item();
    }
  });

  /**
   * Get/set the initial maximum concurrent deferred object size.
   * @property {number} initialSize The initial maximum number of deferred
   *    objects.  `0` to use `size`.
   * @name geo.fetchQueue#initialSize
   */
  Object.defineProperty(this, 'initialSize', {
    get: function get() {
      return m_this._initialSize;
    },
    set: function set(n) {
      m_this._initialSize = n;
      m_this.next_item();
    }
  });

  /**
   * Get/set the track size.  This is used to determine when to check if
   * entries can be discarded.
   * @property {number} track The number of entries to track without checking
   *    for discards.
   * @name geo.fetchQueue#track
   */
  Object.defineProperty(this, 'track', {
    get: function get() {
      return m_this._track;
    },
    set: function set(n) {
      m_this._track = n;
    }
  });

  /**
   * Get/set the initial track size.  Unless changed, this is the value used
   * for track on class initialization.
   * @property {number} initialTrack The number of entries to track without
   *    checking for discards.
   * @name geo.fetchQueue#intitialTrack
   */
  Object.defineProperty(this, 'initialTrack', {
    get: function get() {
      return m_this._initialTrack;
    },
    set: function set(n) {
      m_this._initialTrack = n;
    }
  });

  /**
   * Get the current queue size.  Read only.
   * @property {number} length The current queue size.
   * @name geo.fetchQueue#length
   */
  Object.defineProperty(this, 'length', {
    get: function get() {
      return m_this._queue.length;
    }
  });

  /**
   * Get the current number of processing items.  Read only.
   * @property {number} processing The current number of processing items.
   * @name geo.fetchQueue#processing
   */
  Object.defineProperty(this, 'processing', {
    get: function get() {
      return m_this._processing;
    }
  });

  /**
   * Remove all items from the queue.
   *
   * @returns {this}
   */
  this.clear = function () {
    m_this._queue = [];
    m_this._processing = 0;
    return m_this;
  };

  /**
   * Add a Deferred object to the queue.
   *
   * @param {jQuery.Deferred} defer Deferred object to add to the queue.
   * @param {Function} callback A function to call when the item's turn is
   *  granted.
   * @param {boolean} atEnd If falsy, add the item to the front of the queue
   *  if batching is turned off or at the end of the current batch if it is
   *  turned on.  If truthy, always add the item to the end of the queue.
   * @returns {jQuery.Deferred} The deferred object that was passed to the
   *  function.
   */
  this.add = function (defer, callback, atEnd) {
    if (defer.__fetchQueue) {
      var pos = m_this._queue.indexOf(defer);
      if (pos >= 0) {
        // m_this._queue.splice(pos, 1);
        m_this._addToQueue(defer, atEnd, pos);
        return defer;
      }
    }
    var wait = $.Deferred();
    var process = $.Deferred();
    wait.done(function () {
      $.when(callback.call(defer)).always(process.resolve);
    }).fail(process.resolve);
    defer.__fetchQueue = wait;
    m_this._addToQueue(defer, atEnd);
    $.when(wait, process).always(function () {
      if (m_this._processing > 0) {
        m_this._processing -= 1;
      }
      m_this._initialSize = 0;
      m_this.next_item();
    }).promise(defer);
    m_this.next_item();
    return defer;
  };

  /**
   * Add an item to the queue.  If batches are being used, add it at after
   * other items in the same batch.
   *
   * @param {jQuery.Deferred} defer Deferred object to add to the queue.
   * @param {boolean} atEnd If falsy, add the item to the front of the queue
   *  if batching is turned off or at the end of the current batch if it is
   *  turned on.  If truthy, always add the item to the end of the queue.
   * @param {number} [pos] If specified, the current location in the queue of
   *   the object being added.  This avoids having to splice, push, or unshift
   *   the queue.
   */
  this._addToQueue = function (defer, atEnd, pos) {
    var move = atEnd ? m_this._queue.length - 1 : 0;
    defer.__fetchQueue._batch = m_this._batch;
    if (!atEnd && m_this._batch) {
      for (move = 0; move < m_this._queue.length - (pos === undefined ? 0 : 1); move += 1) {
        if (m_this._queue[move].__fetchQueue._batch !== m_this._batch) {
          break;
        }
      }
    }
    if (pos === undefined) {
      if (atEnd) {
        m_this._queue.push(defer);
      } else if (!move) {
        m_this._queue.unshift(defer);
      } else {
        m_this._queue.splice(move, 0, defer);
      }
    } else if (pos !== move) {
      var dir = pos < move ? 1 : -1;
      for (var i = pos; i !== move; i += dir) {
        m_this._queue[i] = m_this._queue[i + dir];
      }
      m_this._queue[move] = defer;
    }
  };

  /**
   * Get the position of a deferred object in the queue.
   *
   * @param {jQuery.Deferred} defer Deferred object to get the position of.
   * @returns {number} -1 if not in the queue, or the position in the queue.
   */
  this.get = function (defer) {
    return m_this._queue.indexOf(defer);
  };

  /**
   * Remove a Deferred object from the queue.
   *
   * @param {jQuery.Deferred} defer Deferred object to add to the queue.
   * @returns {boolean} `true` if the object was removed.
   */
  this.remove = function (defer) {
    var pos = m_this._queue.indexOf(defer);
    if (pos >= 0) {
      m_this._queue.splice(pos, 1);
      return true;
    }
    return false;
  };

  /**
   * Start a new batch or clear using batches.
   *
   * @param {boolean} start Truthy to start a new batch, falsy to turn off
   *   using batches.  `undefined` to return the current state of batches.
   * @returns {number|boolean|this} `false` if batches are turned off, the
   *   batch number if turned on, or `this` if setting the batch.
   */
  this.batch = function (start) {
    if (start === undefined) {
      return m_this._batch;
    }
    if (!start) {
      m_this._batch = false;
    } else {
      m_this._batch = m_next_batch;
      m_next_batch += 1;
    }
    return m_this;
  };

  /**
   * Check if any items are queued and if the processing allotment is not
   * full.  If so, process more items.
   */
  this.next_item = function () {
    if (m_this._innextitem) {
      return;
    }
    m_this._innextitem = true;
    /* if the queue is greater than the track size, check each item to see
     * if it is still needed. */
    if (m_this._queue.length > m_this._track && m_this._needed) {
      for (var i = m_this._queue.length - 1; i >= 0; i -= 1) {
        if (!m_this._needed(m_this._queue[i])) {
          var discard = m_this._queue.splice(i, 1)[0];
          m_this._processing += 1;
          discard.__fetchQueue.reject();
          delete discard.__fetchQueue;
        }
      }
    }
    while (m_this._processing < (m_this._initialSize || m_this._size) && m_this._queue.length) {
      var defer = m_this._queue.shift();
      if (defer.__fetchQueue) {
        m_this._processing += 1;
        var needed = m_this._needed ? m_this._needed(defer) : true;
        if (needed) {
          defer.__fetchQueue.resolve();
        } else {
          defer.__fetchQueue.reject();
        }
        delete defer.__fetchQueue;
      }
    }
    m_this._innextitem = false;
  };
  this.clear();
  return this;
};
module.exports = _fetchQueue;

/***/ }),

/***/ 703:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var featureLayer = __webpack_require__(6498);
var object = __webpack_require__(1338);

/**
 * Object specification for a fileReader.
 *
 * @typedef {object} geo.fileReader.spec
 * @property {geo.featureLayer} [layer] The target feature layer.
 */

/**
 * Create a new instance of class fileReader.
 *
 * @class
 * @alias geo.fileReader
 * @extends geo.object
 * @param {geo.fileReader.spec} [arg]
 * @returns {geo.fileReader}
 */
var _fileReader = function fileReader(arg) {
  'use strict';

  if (!(this instanceof _fileReader)) {
    return new _fileReader(arg);
  }
  object.call(this);

  /**
   * @private
   */
  arg = arg || {};
  if (!(arg.layer instanceof featureLayer)) {
    throw new Error('fileReader must be given a feature layer');
  }
  var m_layer = arg.layer;

  /**
   * Get the feature layer attached to the reader.
   *
   * @returns {geo.featureLayer} The layer associated with the reader.
   */
  this.layer = function () {
    return m_layer;
  };

  /**
   * Tells the caller if it can handle the given file by returning a boolean.
   *
   * @param {File|Blob|string|object} file This is either a `File` object, a
   *    `Blob` object, a string representation of a file, or an object
   *    representing data from a file.
   * @returns {boolean} `true` if this reader can read a file.
   */
  this.canRead = function (file) {
    return false;
  };

  /**
   * Reads the file and optionally calls a function when finished.  The `done`
   * function is called with a value that is truthy if the read was a success.
   * Depending on the specific reader, this value may be an object with details
   * of the read operation.
   *
   * @param {File|Blob|string|object} file This is either a `File` object, a
   *    `Blob` object, a string representation of a file, or an object
   *    representing data from a file.
   * @param {Function} [done] An optional callback function when the read is
   *    complete.  This is called with `false` on error or the object that was
   *    read and parsed by the reader.
   * @param {Function} [progress] A function which is passed `ProgressEvent`
   *    information from a `FileReader`.  This includes `loaded` and `total`
   *    each with a number of bytes.
   * @returns {Promise} A `Promise` that resolves with object parsed by the
   *    reader or is rejected if the reader fails.
   */
  this.read = function (file, done, progress) {
    var promise = new Promise(function (resolve, reject) {
      if (done) {
        done(false);
      }
      throw new Error('The default file reader always fails');
    });
    this.addPromise(promise);
    return promise;
  };

  /**
   * Return a `FileReader` with handlers attached.
   *
   * @param {Function} done A callback that receives either the string read
   *    from the file or a `DOMException` with an error.
   * @param {Function} [progress] A function which is passed `ProgressEvent`
   *    information from a `FileReader`.  This includes `loaded` and `total`
   *    each with a number of bytes.
   * @returns {FileReader} The `FileReader` with done and progress handles
   *    attached to it.
   */
  function newFileReader(done, progress) {
    var reader = new FileReader();
    if (progress) {
      reader.onprogress = progress;
    }
    reader.onloadend = function () {
      done(reader.error || reader.result);
    };
    return reader;
  }

  /**
   * Read a file object as a string.  Calls `done` with the string content
   * when finished or an error object if unsuccessful.
   *
   * @param {File|Blob} file A `File` or `Blob` object to read.
   * @param {Function} done A callback that receives either the string read
   *    from the file or a `DOMException` with an error.
   * @param {Function} [progress] A function which is passed `ProgressEvent`
   *    information from a `FileReader`.  This includes `loaded` and `total`
   *    each with a number of bytes.
   */
  this._getString = function (file, done, progress) {
    var reader = newFileReader(done, progress);
    reader.readAsText(file);
  };
  return this;
};
inherit(_fileReader, object);
module.exports = _fileReader;

/***/ }),

/***/ 5173:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var inherit = __webpack_require__(4626);
var registerFileReader = (__webpack_require__(1098).registerFileReader);
var fileReader = __webpack_require__(703);

/**
 * Object specification for a geojsonReader.
 *
 * @typedef {geo.fileReader.spec} geo.geojsonReader.spec
 * @extends geo.fileReader.spec
 * @property {geo.pointFeature.styleSpec} [pointStyle] Default style for
 *   points.
 * @property {geo.pointFeature.styleSpec} [lineStyle] Default style for lines.
 * @property {geo.pointFeature.styleSpec} [polygonStyle] Default style for
 *   polygons.
 */

/**
 * Create a new instance of class geo.geojsonReader.
 *
 * @class
 * @alias geo.geojsonReader
 * @extends geo.fileReader
 * @param {geo.fileReader.spec} arg
 * @returns {geo.geojsonReader}
 */
var _geojsonReader = function geojsonReader(arg) {
  'use strict';

  if (!(this instanceof _geojsonReader)) {
    return new _geojsonReader(arg);
  }
  var $ = __webpack_require__(5616);
  var convertColor = (__webpack_require__(642).convertColor);
  var markerFeature = __webpack_require__(2225);
  var transform = __webpack_require__(5325);
  var m_this = this,
    m_options = _objectSpread(_objectSpread({}, arg), {}, {
      pointStyle: _objectSpread({
        fill: true,
        fillColor: '#ff7800',
        fillOpacity: 0.8,
        stroke: true,
        strokeColor: '#000',
        strokeWidth: 1,
        strokeOpacity: 1,
        radius: 8
      }, arg.pointStyle),
      lineStyle: _objectSpread({
        strokeColor: '#ff7800',
        strokeWidth: 4,
        strokeOpacity: 0.5,
        strokeOffset: 0,
        lineCap: 'butt',
        lineJoin: 'miter',
        uniformLine: true,
        closed: false
      }, arg.lineStyle),
      polygonStyle: _objectSpread({
        fill: true,
        fillColor: '#b0de5c',
        fillOpacity: 0.8,
        stroke: true,
        strokeColor: '#999999',
        strokeWidth: 2,
        strokeOpacity: 1,
        uniformPolygon: true,
        pattern: undefined
      }, arg.polygonStyle)
    });
  fileReader.call(this, m_options);

  /**
   * Tells the caller if it can handle the given file by returning a boolean.
   *
   * @param {File|Blob|string|object} file This is either a `File` object, a
   *    `Blob` object, a string representation of a file, or an object
   *    representing data from a file.
   * @returns {boolean} `true` if this reader can read a file.
   */
  this.canRead = function (file) {
    if (file instanceof File || file instanceof Blob) {
      return !!(file.type === 'application/json' || file.name && file.name.match(/\.json$/));
    } else if (typeof file === 'string') {
      try {
        JSON.parse(file);
      } catch (e) {
        return false;
      }
      return true;
    }
    try {
      if (Array.isArray(m_this._featureArray(file))) {
        return true;
      }
    } catch (e) {}
    return false;
  };

  /**
   * Read or parse a file or object, then call a done function.
   *
   * @param {File|Blob|string|object} file This is either a `File` object, a
   *    `Blob` object, a string representation of a file, or an object
   *    representing data from a file.
   * @param {Function} done A callback function when the read is complete.
   *    This is called with `false` on error or the object that was read but
   *    not yet parsed.
   * @param {Function} [progress] A function which is passed `ProgressEvent`
   *    information from a `FileReader`.  This includes `loaded` and `total`
   *    each with a number of bytes.
   */
  this._readObject = function (file, done, progress) {
    var object;
    function onDone(fileString) {
      // if fileString is not a JSON string, expect it to be a URL.
      try {
        object = JSON.parse(fileString);
        done(object);
      } catch (err) {
        if (!object) {
          $.ajax({
            type: 'GET',
            url: fileString,
            dataType: 'text'
          }).done(function (data) {
            try {
              object = JSON.parse(data);
              done(object);
            } catch (err) {
              if (!object) {
                done(false);
              }
            }
          }).fail(function () {
            done(false);
          });
        }
      }
    }
    if (file instanceof File || file instanceof Blob) {
      m_this._getString(file, onDone, progress);
    } else if (typeof file === 'string') {
      onDone(file);
    } else {
      done(file);
    }
  };

  /**
   * Return an array of normalized geojson features.  This turns bare
   * geometries into features and multi-geometry features into single geometry
   * features.
   *
   * Returns an array of Point, LineString, or Polygon features.
   * @param {geojson.object} spec A parsed geojson object.
   * @returns {geojson.FeatureObject[]} An array of feature objects, none of
   *    which include multi-geometries, and none have empty geometries.
   */
  this._featureArray = function (spec) {
    var features,
      normalized = [];
    switch (spec.type) {
      case 'FeatureCollection':
        features = spec.features;
        break;
      case 'Feature':
        features = [spec];
        break;
      case 'GeometryCollection':
        features = spec.geometries.map(function (g) {
          return {
            type: 'Feature',
            geometry: g,
            properties: {}
          };
        });
        break;
      case 'Point':
      case 'LineString':
      case 'Polygon':
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
        features = [{
          type: 'Feature',
          geometry: spec,
          properties: {}
        }];
        break;
      default:
        throw new Error('Invalid json type');
    }

    // flatten multi features
    features.forEach(function (feature) {
      Array.prototype.push.apply(normalized, m_this._feature(feature));
    });

    // remove features with empty geometries
    normalized = normalized.filter(function (feature) {
      return feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length;
    });
    return normalized;
  };

  /**
   * Normalize a feature object turning multi geometry features into an array
   * of features, and single geometry features into an array containing one
   * feature.
   *
   * @param {geojson.object} spec A parsed geojson object.
   * @returns {geojson.FeatureObject[]} An array of feature objects, none of
   *    which include multi-geometries.
   */
  this._feature = function (spec) {
    if (spec.type !== 'Feature') {
      throw new Error('Invalid feature object');
    }
    switch (spec.geometry.type) {
      case 'Point':
      case 'LineString':
      case 'Polygon':
        return [spec];
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
        return spec.geometry.coordinates.map(function (c) {
          return {
            type: 'Feature',
            geometry: {
              type: spec.geometry.type.replace('Multi', ''),
              coordinates: c
            },
            properties: spec.properties
          };
        });
      default:
        throw new Error('Invalid geometry type');
    }
  };

  /**
   * Convert from a geojson position array into a geojs position object.
   *
   * @param {number[]} p A coordinate in the form of an array with two or three
   *    components.
   * @returns {geo.geoPosition}
   */
  this._position = function (p) {
    return {
      x: p[0],
      y: p[1],
      z: p[2] || 0
    };
  };

  /**
   * Defines a style accessor the returns the given value of the property
   * object or a default value.
   *
   * @param {string} prop The property name.
   * @param {object} _default The default value.
   * @returns {Function} A style function for the property.
   */
  this._style = function (prop, _default) {
    var isColor = prop.toLowerCase().match(/color$/);
    if (isColor) {
      _default = convertColor(_default);
    }
    return function (v, j, d, i) {
      var p;
      if (d !== undefined && d.properties) {
        p = d.properties;
      } else {
        p = v.properties;
      }
      if (p !== undefined && p.hasOwnProperty(prop)) {
        return isColor ? convertColor(p[prop]) : p[prop];
      }
      return _default;
    };
  };

  /**
   * Reads the file and optionally calls a function when finished.  The `done`
   * function is called with a list of {@link geo.feature} on success or
   * `false` on failure.
   *
   * @param {File|Blob|string|object} file This is either a `File` object, a
   *    `Blob` object, a string representation of a file, or an object
   *    representing data from a file.
   * @param {Function} [done] An optional callback function when the read is
   *    complete.  This is called with `false` on error or a list of
   *    {@link geo.feature} on success.
   * @param {Function} [progress] A function which is passed `ProgressEvent`
   *    information from a `FileReader`.  This includes `loaded` and `total`
   *    each with a number of bytes.
   * @returns {Promise} A `Promise` that resolves with a list of
   *    {@link geo.feature} or is rejected if the reader fails.
   */
  this.read = function (file, done, progress) {
    var promise = new Promise(function (resolve, reject) {
      /**
       * Check if a feature is a circle or an ellipse.
       *
       * @param {geojson.object} f A geojson feature.
       * @returns {boolean} true if this should be rendered as an ellipse or
       *   circle.
       */
      function _isEllipse(f) {
        if (f.geometry.type !== 'Polygon' || f.geometry.coordinates.length !== 1 || f.geometry.coordinates[0].length !== 5) {
          return false;
        }
        return (f.properties || {}).annotationType === 'ellipse' || (f.properties || {}).annotationType === 'circle';
      }

      /**
       * Given a parsed GeoJSON object, convert it into features on the
       * reader's layer.
       *
       * @param {geojson.object|false} object Either a parse GeoJSON object or
       *    `false` for an error.
       */
      function _done(object) {
        if (object === false) {
          if (done) {
            done(object);
          }
          reject(new Error('Failed to parse GeoJSON'));
          return;
        }
        var features, feature;
        var allFeatures = [];
        try {
          features = m_this._featureArray(object);
        } catch (err) {
          reject(err);
          return;
        }

        // process points
        var points = features.filter(function (f) {
          return f.geometry.type === 'Point';
        });
        if (points.length) {
          feature = m_this.layer().createFeature('point');
          if (feature) {
            feature.data(points).position(function (d) {
              return m_this._position(d.geometry.coordinates);
            })
            // create an object with each property in m_options.pointStyle,
            // mapping the values through the _style function.
            .style([{}].concat(Object.keys(m_options.pointStyle)).reduce(function (styleObj, key) {
              return _objectSpread(_defineProperty({}, key, points.some(function (d) {
                return d.properties && d.properties[key] !== undefined;
              }) ? m_this._style(key, m_options.pointStyle[key]) : m_options.pointStyle[key]), styleObj);
            }));
            allFeatures.push(feature);
          }
        }

        // process lines
        var lines = features.filter(function (f) {
          return f.geometry.type === 'LineString';
        });
        if (lines.length) {
          feature = m_this.layer().createFeature('line');
          if (feature) {
            feature.data(lines).line(function (d) {
              return d.geometry.coordinates;
            }).position(m_this._position)
            // create an object with each property in m_options.lineStyle,
            // mapping the values through the _style function.
            .style([{}].concat(Object.keys(m_options.lineStyle)).reduce(function (styleObj, key) {
              return _objectSpread(_defineProperty({}, key, lines.some(function (d) {
                return d.properties && d.properties[key] !== undefined;
              }) ? m_this._style(key, m_options.lineStyle[key]) : m_options.lineStyle[key]), styleObj);
            }));
            allFeatures.push(feature);
          }
        }

        // process polygons
        var polygons = features.filter(function (f) {
          return f.geometry.type === 'Polygon' && !_isEllipse(f);
        });
        if (polygons.length) {
          feature = m_this.layer().createFeature('polygon');
          if (feature) {
            feature.data(polygons).polygon(function (d, i) {
              return {
                outer: d.geometry.coordinates[0],
                inner: d.geometry.coordinates.slice(1)
              };
            }).position(m_this._position)
            // create an object with each property in m_options.polygonStyle,
            // mapping the values through the _style function.
            .style([{}].concat(Object.keys(m_options.polygonStyle)).reduce(function (styleObj, key) {
              return _objectSpread(_defineProperty({}, key, polygons.some(function (d) {
                return d.properties && d.properties[key] !== undefined;
              }) ? m_this._style(key, m_options.polygonStyle[key]) : m_options.polygonStyle[key]), styleObj);
            }));
            allFeatures.push(feature);
          }
        }
        // handle ellipses and circle
        var ellipses = features.filter(_isEllipse);
        if (ellipses.length) {
          feature = m_this.layer().createFeature('marker');
          if (feature) {
            ellipses.forEach(function (d) {
              var map = m_this.layer().map();
              var coord = transform.transformCoordinates(map.ingcs(), map.gcs(), d.geometry.coordinates[0]);
              var w = Math.pow(Math.pow(coord[0][0] - coord[1][0], 2) + Math.pow(coord[0][1] - coord[1][1], 2), 0.5);
              var h = Math.pow(Math.pow(coord[0][0] - coord[3][0], 2) + Math.pow(coord[0][1] - coord[3][1], 2), 0.5);
              var radius = Math.max(w, h) / 2 / map.unitsPerPixel(0);
              var aspect = w ? h / w : 1e20;
              var rotation = -Math.atan2(coord[1][1] - coord[0][1], coord[1][0] - coord[0][0]);
              var pos = transform.transformCoordinates(map.gcs(), map.ingcs(), {
                x: (coord[0][0] + coord[1][0] + coord[2][0] + coord[3][0]) / 4,
                y: (coord[0][1] + coord[1][1] + coord[2][1] + coord[3][1]) / 4
              });
              d._props = {
                pos: pos,
                radius: radius,
                aspect: aspect,
                rotation: rotation
              };
            });
            feature.data(ellipses).position(function (d) {
              return d._props.pos;
            })
            // create an object with each property in m_options.polygonStyle,
            // mapping the values through the _style function.
            .style([{}].concat(Object.keys(m_options.polygonStyle)).reduce(function (styleObj, key) {
              return _objectSpread(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, key, ellipses.some(function (d) {
                return d.properties && d.properties[key] !== undefined;
              }) ? m_this._style(key, m_options.polygonStyle[key]) : m_options.polygonStyle[key]), "radius", function radius(d) {
                return d._props.radius;
              }), "radiusIncludesStroke", false), "symbolValue", function symbolValue(d) {
                return d._props.aspect;
              }), "rotation", function rotation(d) {
                return d._props.rotation;
              }), "strokeOffset", 0), "rotateWithMap", true), "scaleWithZoom", markerFeature.scaleMode.fill), styleObj);
            }));
            allFeatures.push(feature);
          }
        }
        if (done) {
          done(allFeatures);
        }
        resolve(allFeatures);
      }
      m_this._readObject(file, _done, progress);
    });
    m_this.addPromise(promise);
    return promise;
  };
};
inherit(_geojsonReader, fileReader);
registerFileReader('geojsonReader', _geojsonReader);
// Also register under an alternate name (alias for backwards compatibility)
registerFileReader('jsonReader', _geojsonReader);
module.exports = _geojsonReader;

/***/ }),

/***/ 3187:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Object specification for a graph feature.
 *
 * @typedef {geo.feature.spec} geo.graphFeature.spec
 * @extends geo.feature.spec
 * @property {geo.graphFeature.styleSpec} [style] Style object with default
 *   style options.
 */

/**
 * Style specification for a graph feature.
 *
 * @typedef {geo.feature.styleSpec} geo.graphFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {geo.pointFeature.styleSpec} [nodes] Point style for nodes.
 * @property {geo.lineFeature.styleSpec|geo.pathFeature.styleSpec} [links] Line
 *   or path style for links.
 * @property {string} [linkType='path'] Link type, either `'line'` or `'path'`.
 */

/**
 * Create a new instance of class graphFeature.
 *
 * @class
 * @alias geo.graphFeature
 * @extends geo.feature
 * @param {geo.graphFeature.spec} arg Feature options.
 * @returns {geo.graphFeature}
 */
var _graphFeature = function graphFeature(arg) {
  'use strict';

  if (!(this instanceof _graphFeature)) {
    return new _graphFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);
  var util = __webpack_require__(642);
  var registry = __webpack_require__(1098);
  var m_this = this,
    s_draw = this.draw,
    s_style = this.style,
    m_nodes = null,
    m_points = null,
    m_children = function m_children(d) {
      return d.children;
    },
    m_links = [],
    s_init = this._init,
    s_exit = this._exit;
  this.featureType = 'graph';

  /**
   * Initialize.
   *
   * @param {geo.graphFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    var defaultStyle = util.deepMerge({}, {
      nodes: {
        radius: 5.0,
        fill: true,
        fillColor: {
          r: 1.0,
          g: 0.0,
          b: 0.0
        },
        strokeColor: {
          r: 0,
          g: 0,
          b: 0
        }
      },
      links: {
        strokeColor: {
          r: 0.0,
          g: 0.0,
          b: 0.0
        }
      },
      linkType: 'path' /* 'path' || 'line' */
    }, arg.style === undefined ? {} : arg.style);
    m_this.style(defaultStyle);
    m_this.nodes(util.identityFunction);
    return m_this;
  };

  /**
   * Call child _build methods.
   */
  this._build = function () {
    m_this.children().forEach(function (child) {
      child._build();
    });
  };

  /**
   * Call child _update methods.
   */
  this._update = function () {
    m_this.children().forEach(function (child) {
      child._update();
    });
  };

  /**
   * Custom _exit method to remove all sub-features.
   *
   * @returns {this}
   */
  this._exit = function () {
    m_this.data([]);
    m_links.forEach(function (link) {
      link._exit();
      m_this.removeChild(link);
    });
    m_links = [];
    m_points._exit();
    m_this.removeChild(m_points);
    s_exit();
    return m_this;
  };

  /**
   * Get/Set style used by the feature.  Styles can be constant values or
   * functions.  If a function, the style is typically called with parameters
   * such as `(dataElement, dataIndex)` or, if the specific style of a feature
   * has a subfeature style, with `(subfeatureElement, subfeatureIndex,
   * dataElement, dataIndex)`.
   *
   * See the <a href="#.styleSpec">style specification
   * <code>styleSpec</code></a> for available styles.
   *
   * @param {string|object} [arg1] If `undefined`, return the current style
   *    object.  If a string and `arg2` is undefined, return the style
   *    associated with the specified key.  If a string and `arg2` is defined,
   *    set the named style to the specified value.  Otherwise, extend the
   *    current style with the values in the specified object.
   * @param {*} [arg2] If `arg1` is a string, the new value for that style.
   * @returns {object|this} Either the entire style object, the value of a
   *    specific style, or the current class instance.
   */
  this.style = function (arg1, arg2) {
    var out = s_style.call(m_this, arg1, arg2);
    if (out !== m_this) {
      return out;
    }
    // set styles for sub-features
    m_points.style(arg1.nodes);
    m_links.forEach(function (l) {
      l.style(arg1.links);
    });
    return m_this;
  };
  this.style.get = s_style.get;

  /**
   * Get/Set links accessor.
   *
   * @param {Function|array} [arg] If specified, the list of links or a
   *    function that returns the list of links.  If unspecified, return the
   *    existing value.
   * @returns {Function|this} Either a function that returns the list of links,
   *    or the feature.
   */
  this.links = function (arg) {
    if (arg === undefined) {
      return m_children;
    }
    m_children = util.ensureFunction(arg);
    return m_this;
  };

  /**
   * Get/Set nodes.
   *
   * @param {geo.geoPosition[]} [val] If specified, set the nodes to this list,
   *    otherwise return the current list of nodes.
   * @returns {geo.geoPostion[]|this} Either the current list of nodes or this
   *    feature.
   */
  this.nodes = function (val) {
    if (val === undefined) {
      return m_nodes;
    }
    m_nodes = val;
    m_this.modified();
    return m_this;
  };

  /**
   * Get internal node feature.
   *
   * @returns {geo.pointFeature} The point feature used for nodes.
   */
  this.nodeFeature = function () {
    return m_points;
  };

  /**
   * Get internal link features.
   *
   * @returns {geo.lineFeature[]|geo.pathFeature[]} An array or line or path
   *    features used for links.
   */
  this.linkFeatures = function () {
    return m_links;
  };

  /**
   * Draw the feature, building as necessary.
   *
   * @returns {this}
   */
  this.draw = function () {
    var layer = m_this.layer(),
      data = m_this.data(),
      nLinks = 0,
      style;

    // get the feature style object
    style = m_this.style();

    // Bind data to the point nodes
    m_points.data(data);
    m_points.style(style.nodes);

    // get links from node connections
    data.forEach(function (source) {
      (source.children || []).forEach(function (target) {
        var link;
        nLinks += 1;
        if (m_links.length < nLinks) {
          link = registry.createFeature(style.linkType, layer, layer.renderer()).style(style.links);
          m_this.addChild(link);
          m_links.push(link);
        }
        m_links[nLinks - 1].data([source, target]);
      });
    });
    m_links.splice(nLinks, m_links.length - nLinks).forEach(function (l) {
      l._exit();
      m_this.removeChild(l);
    });
    s_draw();
    return m_this;
  };
  m_points = registry.createFeature('point', this.layer(), this.layer().renderer());
  m_this.addChild(m_points);
  if (arg.nodes) {
    this.nodes(arg.nodes);
  }
  this._init(arg);
  return this;
};
inherit(_graphFeature, feature);
module.exports = _graphFeature;

/***/ }),

/***/ 2499:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var meshFeature = __webpack_require__(6124);

/**
 * Grid feature specification.
 *
 * @typedef {geo.feature.spec} geo.gridFeature.spec
 * @extends geo.feature.spec
 * @property {object[]} [data=[]] An array of arbitrary objects used to
 *    construct the feature.
 * @property {geo.gridFeature.styleSpec} [style] An object that contains
 *    style values for the feature.
 * @property {geo.gridFeature.gridSpec} [grid] The grid specification for the
 *    feature.
 */

/**
 * Style specification for a grid feature.
 *
 * @typedef {geo.feature.styleSpec} geo.gridFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {geo.geoPosition|Function} [position=data] The position of each
 *    data element.  This defaults to just using `x`, `y`, and `z` properties
 *    of the data element itself.  The position is in the feature's gcs
 *    coordinates.
 * @property {number|Function} [value=data.z] The value of each data element.
 *    This defaults to the `z` property of the data elements.  If the value of
 *    a grid point is `null` or `undefined`, the point and elements that use
 *    that point won't be included in the results.
 * @property {number|Function} [opacity=1] The opacity for the whole feature on
 *    a scale of 0 to 1.
 * @property {number[]|Function} [origin] Origin in map gcs coordinates used
 *   for to ensure high precision drawing in this location.  When called as a
 *   function, this is passed the vertex positions as a single continuous array
 *   in map gcs coordinates.  It defaults to the first vertex used in the
 *   grid.
 */

/**
 * Grid specification.  All of these properties can be functions, which get
 * passed the {@link geo.meshFeature.meshInfo} object.
 *
 * @typedef {geo.meshFeature.meshSpec} geo.gridFeature.gridSpec
 * @extends geo.meshFeature.meshSpec
 * @property {number} [min] Minimum grid value.  If unspecified, taken from
 *    the computed minimum of the `value` style.
 * @property {number} [max] Maximum grid value.  If unspecified, taken from
 *    the computed maximum of the `value` style.
 * @property {geo.geoColor} [minColor='black'] Color used for any value below
 *    the minimum.
 * @property {number} [minOpacity=0] Opacity used for any value below the
 *    minimum.
 * @property {geo.geoColor} [maxColor='black'] Color used for any value above
 *    the maximum.
 * @property {number} [maxOpacity=0] Opacity used for any value above the
 *    maximum.
 * @property {boolean} [stepped] If falsy but not `undefined`, smooth
 *    transitions between colors.
 * @property {geo.geoColor[]} [colorRange=<color table>] An array of colors
 *    used to show the range of values.  The default is a 9-step color table.
 * @property {number[]} [opacityRange] An array of opacities used to show the
 *    range of values.  If unspecified, the opacity is 1.  If this is a shorter
 *    list than the `colorRange`, an opacity of 1 is used for the entries near
 *    the end of the color range.
 * @property {number[]} [rangeValues] An array used to map values to the
 *    `colorRange`.  By default, values are spaced linearly.  If specified, the
 *    entries must be increasing weakly monotonic, and there must be one more
 *    entry then the length of `colorRange`.
 */

/**
 * Computed grid information.
 *
 * @typedef {geo.meshFeature.meshColoredInfo} geo.gridFeature.gridInfo
 * @extends geo.meshFeature.meshColoredInfo
 */

/**
 * Create a new instance of class gridFeature.
 *
 * @class
 * @alias geo.gridFeature
 * @extends geo.meshFeature
 *
 * @borrows geo.gridFeature#mesh as geo.gridFeature#grid
 *
 * @param {geo.gridFeature.spec} arg
 * @returns {geo.gridFeature}
 */
var _gridFeature = function gridFeature(arg) {
  'use strict';

  if (!(this instanceof _gridFeature)) {
    return new _gridFeature(arg);
  }
  var util = __webpack_require__(642);
  var meshUtil = __webpack_require__(5905);
  arg = arg || {};
  meshFeature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init;

  /**
   * Create a set of vertices and values and opacities inside triangles.
   * Create a set of triangles of indices into the vertex array.  Create a
   *  color and opacity map corresponding to the values.
   *
   * @returns {geo.gridFeature.gridInfo} An object with the grid
   *    information.
   */
  this._createGrids = function () {
    return meshUtil.createColoredMesh(m_this, true);
  };
  this.grid = m_this.mesh;

  /**
   * Initialize.
   *
   * @param {geo.gridFeature.spec} arg The grid feature specification.
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      opacity: 1.0,
      value: function value(d, i) {
        return util.isNonNullFinite(d) ? d : m_this.position()(d, i).z;
      },
      position: function position(d) {
        return d || {
          x: 0,
          y: 0
        };
      },
      origin: function origin(p) {
        return p.length >= 3 ? [p[0], p[1], 0] : [0, 0, 0];
      }
    }, arg.style === undefined ? {} : arg.style);
    m_this.style(defaultStyle);
    m_this.grid(Object.assign({}, {
      minColor: 'black',
      minOpacity: 0,
      maxColor: 'black',
      maxOpacity: 0,
      /* 9-step based on paraview bwr colortable */
      colorRange: [{
        r: 0.07514311,
        g: 0.468049805,
        b: 1
      }, {
        r: 0.468487184,
        g: 0.588057293,
        b: 1
      }, {
        r: 0.656658579,
        g: 0.707001303,
        b: 1
      }, {
        r: 0.821573924,
        g: 0.837809045,
        b: 1
      }, {
        r: 0.943467973,
        g: 0.943498599,
        b: 0.943398095
      }, {
        r: 1,
        g: 0.788626485,
        b: 0.750707739
      }, {
        r: 1,
        g: 0.6289553,
        b: 0.568237474
      }, {
        r: 1,
        g: 0.472800903,
        b: 0.404551679
      }, {
        r: 0.916482116,
        g: 0.236630659,
        b: 0.209939162
      }]
    }, arg.mesh || {}, arg.grid || {}));
    if (arg.mesh || arg.grid) {
      m_this.dataTime().modified();
    }
  };
  this._init(arg);
  return this;
};
inherit(_gridFeature, meshFeature);
module.exports = _gridFeature;

/***/ }),

/***/ 9163:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var transform = __webpack_require__(5325);
var util = __webpack_require__(642);

/**
 * Heatmap feature specification.
 *
 * @typedef {geo.feature.spec} geo.heatmapFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 * @property {Function} [intensity] Scalar value of each data point.  The
 *   scalar value must be a positive real number and is used to compute the
 *   weight for each data point.
 * @property {number} [maxIntensity=null] Maximum intensity of the data.
 *   Maximum intensity must be a positive real number and is used to normalize
 *   all intensities within a dataset.  If `null`, it is computed.
 * @property {number} [minIntensity=null] Minimum intensity of the data.
 *   Minimum intensity must be a positive real number and is used to normalize
 *   all intensities within a dataset.  If `null`, it is computed.
 * @property {number} [updateDelay=-1] Delay in milliseconds after a zoom,
 *   rotate, or pan event before recomputing the heatmap.  If 0, this is double
 *   the last render time.  If negative, it is roughly the last render time
 *   plus the absolute value of the specified number of refresh intervals.
 *   compute a delay based on the last heatmap render time.
 * @property {boolean|number|'auto'} [binned='auto'] If `true` or a number,
 *   spatially bin data as part of producing the heatmap.  If falsy, each
 *   datapoint stands on its own.  If `'auto'`, bin data if there are more data
 *   points than there would be bins.  Using `true` or `auto` uses bins that
 *   are `max(Math.floor((radius + blurRadius) / 8), 3)`.
 * @property {object} [style] A style for the heatmap.
 * @property {object} [style.color] An object where the keys are numbers from
 *   [0-1] and the values are {@link geo.geoColor}.  This is used to transform
 *   normalized intensity.
 * @property {number} [style.radius=10] Radius of a point in pixels.
 * @property {number} [style.blurRadius=10] Blur radius for each point in
 *   pixels.
 * @property {boolean} [style.gaussian=true] If truthy, approximate a gaussian
 *   distribution for each point using a multi-segment linear radial
 *   approximation.  The total weight of the gaussian area is approximately the
 *   `9/16 r^2`.  The sum of `radius + blurRadius` is used as the radius for
 *   the gaussian distribution.
 * @property {boolean} [scaleWithZoom=false] If truthy, the value for radius
 *   and blurRadius scale with zoom.  In this case, the values for radius and
 *   blurRadius are the values at zoom-level zero.  If the scaled radius is
 *   less than 0.5 or more than 8192 screen pixels, the heatmap will not
 *   render.
 */

/**
 * Create a new instance of class heatmapFeature.
 *
 * @class
 * @alias geo.heatmapFeature
 * @param {geo.heatmapFeature.spec} arg Feature specification.
 * @extends geo.feature
 * @returns {geo.heatmapFeature}
 */
var _heatmapFeature = function heatmapFeature(arg) {
  'use strict';

  if (!(this instanceof _heatmapFeature)) {
    return new _heatmapFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    m_position,
    m_intensity,
    m_maxIntensity,
    m_minIntensity,
    m_updateDelay,
    m_binned,
    m_gcsPosition,
    s_init = this._init;
  this.featureType = 'heatmap';
  m_position = arg.position || util.identityFunction;
  m_intensity = arg.intensity || function (d) {
    return 1;
  };
  m_maxIntensity = arg.maxIntensity !== undefined ? arg.maxIntensity : null;
  m_minIntensity = arg.minIntensity !== undefined ? arg.minIntensity : null;
  m_binned = arg.binned !== undefined ? arg.binned : 'auto';
  m_updateDelay = arg.updateDelay || arg.updateDelay === 0 ? parseInt(arg.updateDelay, 10) : -1;

  /**
   * Get/Set maxIntensity.
   *
   * @param {number|null} [val] If not specified, return the current value.
   *    If a number, use this as the maximum intensity.  If `null`, compute
   *    the maximum intensity.
   * @returns {number|null|this}
   */
  this.maxIntensity = function (val) {
    if (val === undefined) {
      return m_maxIntensity;
    } else {
      m_maxIntensity = val;
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set minIntensity.
   *
   * @param {number|null} [val] If not specified, return the current value.
   *    If a number, use this as the minimum intensity.  If `null`, compute
   *    the minimum intensity.
   * @returns {number|null|this}
   */
  this.minIntensity = function (val) {
    if (val === undefined) {
      return m_minIntensity;
    } else {
      m_minIntensity = val;
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set updateDelay.
   *
   * @param {number} [val] If not specified, return the current update delay.
   *    If specified, this is the delay in milliseconds after a zoom, rotate,
   *    or pan event before recomputing the heatmap.  If 0, this is double the
   *    last render time.  If negative, it is roughly the last render time plus
   *    the absolute value of the specified number of refresh intervals.
   * @returns {number|this}
   */
  this.updateDelay = function (val) {
    if (val === undefined) {
      return m_updateDelay;
    } else {
      m_updateDelay = parseInt(val, 10);
    }
    return m_this;
  };

  /**
   * Get/Set binned value.
   *
   * @param {boolean|number|'auto'} [val] If not specified, return the current
   *    binned value.  If `true` or a number, spatially bin data as part of
   *    producing the heatmap.  If falsy, each datapoint stands on its own.
   *    If `'auto'`, bin data if there are more data points than there would be
   *    bins.  Using `true` or `auto` uses bins that are
   *    `max(Math.floor((radius + blurRadius) / 8), 3)`.
   * @returns {boolean|number|'auto'|this}
   */
  this.binned = function (val) {
    if (val === undefined) {
      return m_binned;
    } else {
      if (val === 'true') {
        val = true;
      } else if (val === 'false') {
        val = false;
      } else if (val !== 'auto' && val !== true && val !== false) {
        val = parseInt(val, 10);
        if (val <= 0 || isNaN(val)) {
          val = false;
        }
      }
      m_binned = val;
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set position accessor.
   *
   * @param {geo.geoPosition|Function} [val] If not specified, return the
   *    current position accessor.  If specified, use this for the position
   *    accessor and return `this`.  If a function is given, this is called
   *    with `(dataElement, dataIndex)`.
   * @returns {geo.geoPosition|Function|this} The current position or this
   *    feature.
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_position;
    } else {
      m_position = val;
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get pre-computed gcs position accessor.
   *
   * @returns {geo.heatmap}
   */
  this.gcsPosition = function () {
    m_this._update();
    return m_gcsPosition;
  };

  /**
   * Get/Set intensity.
   *
   * @param {Function} [val] If not specified, the current intensity accessor.
   *    Otherwise, a function that returns the intensity of each data point.
   * @returns {Function|this}
   */
  this.intensity = function (val) {
    if (val === undefined) {
      return m_intensity;
    } else {
      m_intensity = val;
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.heatmapFeature.spec} arg
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      radius: 10,
      blurRadius: 10,
      gaussian: true,
      color: {
        0: {
          r: 0,
          g: 0,
          b: 0.0,
          a: 0.0
        },
        0.25: {
          r: 0,
          g: 0,
          b: 1,
          a: 0.5
        },
        0.5: {
          r: 0,
          g: 1,
          b: 1,
          a: 0.6
        },
        0.75: {
          r: 1,
          g: 1,
          b: 0,
          a: 0.7
        },
        1: {
          r: 1,
          g: 0,
          b: 0,
          a: 0.8
        }
      },
      scaleWithZoom: false
    }, arg.style === undefined ? {} : arg.style);
    m_this.style(defaultStyle);
    if (m_position) {
      m_this.dataTime().modified();
    }
  };

  /**
   * Build the feature.
   *
   * @returns {this}
   */
  this._build = function () {
    var data = m_this.data(),
      intensity = null,
      position = [],
      setMax = m_maxIntensity === null || m_maxIntensity === undefined,
      setMin = m_minIntensity === null || m_minIntensity === undefined;
    data.forEach(function (d, i) {
      position.push(m_this.position()(d, i));
      if (setMax || setMin) {
        intensity = m_this.intensity()(d, i);
        if (m_maxIntensity === null || m_maxIntensity === undefined) {
          m_maxIntensity = intensity;
        }
        if (m_minIntensity === null || m_minIntensity === undefined) {
          m_minIntensity = intensity;
        }
        if (setMax && intensity > m_maxIntensity) {
          m_maxIntensity = intensity;
        }
        if (setMin && intensity < m_minIntensity) {
          m_minIntensity = intensity;
        }
      }
    });
    if (setMin && setMax && m_minIntensity === m_maxIntensity) {
      m_minIntensity -= 1;
    }
    m_gcsPosition = transform.transformCoordinates(m_this.gcs(), m_this.layer().map().gcs(), position);
    m_this.buildTime().modified();
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_heatmapFeature, feature);
module.exports = _heatmapFeature;

/***/ }),

/***/ 4912:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var tile = __webpack_require__(5289);

/**
 * @typedef {geo.tile.spec} geo.imageTile.spec
 * @extends {geo.tile.spec}
 * @property {object} index The global position of the tile.
 * @property {number} index.x The x-coordinate (the column number).
 * @property {number} index.y The y-coordinate (the row number).
 * @property {number} index.level The zoom level.
 * @property {object} [size] The size of each tile.
 * @property {number} [size.x=256] Width in pixels.
 * @property {number} [size.y=256] Height in pixels.
 * @property {string} [crossDomain='anonymous'] Image CORS attribute.  This is
 *   used for the `crossorigin` property when loading images.
 */

/**
 * This class defines a tile that is part of a standard "image pyramid", such
 * as an open street map tile set.  Every tile is uniquely indexed by a row,
 * column, and zoom level.  The number of rows/columns at zoom level z is
 * `2^z`, the number of pixels per tile is configurable.
 *
 * By default, this class assumes that images are fetched from the url, but
 * subclasses may define additional rendering steps to produce the images
 * before passing them off to the handlers.
 *
 * @class
 * @alias geo.imageTile
 * @extends geo.tile
 * @param {geo.imageTile.spec} spec The tile specification.
 */
var _imageTile = function imageTile(spec) {
  if (!(this instanceof _imageTile)) {
    return new _imageTile(spec);
  }
  var $ = __webpack_require__(5616);
  spec.size = spec.size || {
    x: 256,
    y: 256
  };
  this._image = null;
  this._cors = spec.crossDomain || spec.crossDomain === null ? spec.crossDomain : 'anonymous';

  // Call superclass constructor
  tile.call(this, spec);

  /**
   * Read only accessor to the Image object used by the tile.  Note, this
   * method does not guarantee that the image data is available.  Use the
   * promise interface to add asynchronous handlers.
   *
   * @property {Image} image The image object used by the tile.
   * @name geo.imageTile#image
   */
  Object.defineProperty(this, 'image', {
    get: function get() {
      return this._image;
    }
  });

  /**
   * Initiate the image request.
   *
   * @returns {this}
   */
  this.fetch = function () {
    var defer;
    if (!this._image) {
      this._image = new Image(this.right - this.left, this.bottom - this.top);
      // Only set the crossOrigin parameter if this is going across origins.
      if (this._cors && this._url.indexOf(':') >= 0 && this._url.indexOf('/') === this._url.indexOf(':') + 1) {
        this._image.crossOrigin = this._cors;
      }
      defer = $.Deferred();
      this._image.onload = defer.resolve;
      this._image.onerror = defer.reject;
      this._image.src = this._url;

      // attach a promise interface to `this`
      defer.done(function () {
        this._fetched = true;
      }.bind(this)).promise(this);
    }
    return this;
  };

  /**
   * Set the opacity of the tile to 0 and gradually fade in over the given
   * number of milliseconds.  This will also resolve the embedded promise
   * interface.
   *
   * @param {number} duration The duration of the animation in ms.
   * @returns {this}
   */
  this.fadeIn = function (duration) {
    var promise = this.fetch(),
      defer = $.Deferred();
    $(this._image).css('display', 'none');
    promise.done(function () {
      $(this._image).fadeIn(duration, function () {
        defer.resolve();
      });
    }.bind(this));
    return defer.promise(this);
  };
  return this;
};
inherit(_imageTile, tile);
module.exports = _imageTile;

/***/ }),

/***/ 2257:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// License headers that will be preserved in distributed bundles.
/**
 * GeoJS
 * @copyright 2013-2022, Kitware, Inc.
 * @license Apache-2.0
 * @namespace geo
 */
/*
 * Bundled with the following libraries:
 *
 * Proj4js
 * @copyright 2014, Mike Adair, Richard Greenwood, Didier Richard, Stephen Irons, Olivier Terral and Calvin Metcalf
 * @license MIT
 *
 * gl-matrix
 * @copyright 2015, Brandon Jones, Colin MacKenzie IV
 * @license MIT
 *
 * JQuery
 * @copyright jQuery Foundation and other contributors
 * @license MIT
 *
 * earcut
 * @copyright 2016, Mapbox
 * @license ISC
 *
 * kdbush
 * @copyright 2017, Vladimir Agafonkin
 * @license ISC
 */

var $ = __webpack_require__(5616);
/* jQuery 3.5 made a change that breaks some aspect of our library.  Until
 * tutorials and examples upgrade to Bootstrap 4 and dependencies are checked,
 * apply the recommended workaround (see https://jquery.com/upgrade-guide/3.5).
 */
var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi;
$.htmlPrefilter = function (html) {
  return html.replace(rxhtmlTag, '<$1></$2>');
};
__webpack_require__(7605);
module.exports = Object.assign({
  annotationLayer: __webpack_require__(2075),
  camera: __webpack_require__(3578),
  choroplethFeature: __webpack_require__(3561),
  contourFeature: __webpack_require__(6761),
  domRenderer: __webpack_require__(9726),
  event: __webpack_require__(6409),
  feature: __webpack_require__(1275),
  featureLayer: __webpack_require__(6498),
  fetchQueue: __webpack_require__(5938),
  fileReader: __webpack_require__(703),
  geo_action: __webpack_require__(8695),
  graphFeature: __webpack_require__(3187),
  heatmapFeature: __webpack_require__(9163),
  imageTile: __webpack_require__(4912),
  isolineFeature: __webpack_require__(2586),
  geojsonReader: __webpack_require__(5173),
  gridFeature: __webpack_require__(2499),
  layer: __webpack_require__(5156),
  lineFeature: __webpack_require__(9281),
  map: __webpack_require__(6211),
  mapInteractor: __webpack_require__(7908),
  markerFeature: __webpack_require__(2225),
  meshFeature: __webpack_require__(6124),
  object: __webpack_require__(1338),
  osmLayer: __webpack_require__(4880),
  pathFeature: __webpack_require__(2266),
  pointFeature: __webpack_require__(7541),
  polygonFeature: __webpack_require__(6645),
  quadFeature: __webpack_require__(3842),
  pixelmapFeature: __webpack_require__(7761),
  pixelmapLayer: __webpack_require__(534),
  renderer: __webpack_require__(2274),
  sceneObject: __webpack_require__(5402),
  textFeature: __webpack_require__(6546),
  tile: __webpack_require__(5289),
  tileCache: __webpack_require__(9123),
  tileLayer: __webpack_require__(9264),
  timestamp: __webpack_require__(77),
  trackFeature: __webpack_require__(338),
  transform: __webpack_require__(5325),
  typedef: __webpack_require__(3170),
  vectorFeature: __webpack_require__(6858),
  inherit: __webpack_require__(4626),
  version: __webpack_require__(4081),
  sha: __webpack_require__(9079),
  annotation: __webpack_require__(4655),
  util: __webpack_require__(642),
  jQuery: $,
  canvas: __webpack_require__(8074),
  svg: __webpack_require__(6488),
  vtkjs: __webpack_require__(394),
  webgl: __webpack_require__(8635),
  gui: __webpack_require__(4812),
  vgl: __webpack_require__(1611)
}, __webpack_require__(1098));
if (window && !window.$) {
  window.$ = $;
}
if (window && !window.jQuery) {
  window.jQuery = $;
}
if (window && !window.geojsMap) {
  window.geojsMap = function () {
    var maps = $('.geojs-map').map(function (idx, m) {
      return $(m).data('data-geojs-map');
    });
    return maps.length === 0 ? undefined : maps.length === 1 ? maps[0] : maps;
  };
}

/***/ }),

/***/ 4626:
/***/ (function(module) {

function newfunc() {
  return function () {};
}

/**
 * Convenient function to define JS inheritance.
 *
 * @param {object} C Child class instance.
 * @param {object} P Parent class instance.
 */
module.exports = function (C, P) {
  var F = newfunc();
  F.prototype = P.prototype;
  C.prototype = new F();
  C.prototype.constructor = C;
};

/***/ }),

/***/ 2586:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var meshFeature = __webpack_require__(6124);
var registry = __webpack_require__(1098);
var util = __webpack_require__(642);

/**
 * Isoline feature specification.
 *
 * @typedef {geo.feature.spec} geo.isolineFeature.spec
 * @extend geo.feature.spec
 * @property {object[]} [data=[]] An array of arbitrary objects used to
 *    construct the feature.
 * @property {geo.isolineFeature.styleSpec} [style] An object that contains
 *    style values for the feature.
 * @property {geo.isolineFeature.isolineSpec} [isoline] The isoline
 *    specification for the feature.
 */

/**
 * Style specification for an isoline feature.  Extends
 * {@link geo.lineFeasture.styleSpec} and {@link geo.textFeasture.styleSpec}.
 *
 * @typedef {geo.feature.styleSpec} geo.isolineFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @extends geo.textFeature.styleSpec
 * @extends geo.lineFeature.styleSpec
 * @property {geo.geoPosition|Function} [position=data] The position of each
 *    data element.  This defaults to just using `x`, `y`, and `z` properties
 *    of the data element itself.  The position is in the feature's gcs
 *    coordinates.
 * @property {number|Function} [value=data.z] The value of each data element.
 *    This defaults to the `z` property of the data elements.  If the value of
 *    a grid point is `null` or `undefined`, the point and elements that use
 *    that point won't be included in the results.
 * @property {geo.geoColor|Function} [strokeColor='black'] Color to stroke each
 *    line.
 * @property {number|Function} [strokeWidth] The weight of the line stroke in
 *    pixels.  This defaults to the line value's level + 0.5.
 * @property {boolean|Function} [rotateWithMap=true] Rotate label text when the
 *    map rotates.
 * @property {number|Function} [rotation] Text rotation in radians.  This
 *    defaults to the label oriented so that top of the text is toward the
 *    higher value.  There is a utility function that can be used for common
 *    rotation preferences.  See {@link geo.isolineFeature#rotationFunction}.
 *    For instance, `rotation=geo.isolineFeature.rotationFunction('map')`.
 * @property {string|Function} [fontSize='12px'] The font size.
 * @property {geo.geoColor|Function} [textStrokeColor='white'] Text
 *    stroke color.  This adds contrast between the label and the isoline.
 * @property {geo.geoColor|Function} [textStrokeWidth=2] Text stroke width in
 *    pixels.
 */

/**
 * Isoline specification.  All of these properties can be functions, which get
 * passed the {@link geo.meshFeature.meshInfo} object.
 *
 * @typedef {geo.meshFeature.meshSpec} geo.isolineFeature.isolineSpec
 * @extends geo.meshFeature.meshSpec
 * @property {number} [min] Minimum isoline value.  If unspecified, taken from
 *    the computed minimum of the `value` style.
 * @property {number} [max] Maximum isoline value.  If unspecified, taken from
 *    the computed maximum of the `value` style.
 * @property {number} [count=15] Approximate number of isolines shown through
 *    the value range.  Used if `spacing` or `values` is not specified.
 * @property {boolean} [autofit=true] If `count` is used to determine the
 *    isolines, and this is truthy, the isoline values will be round numbers.
 *    If falsy, they will include the exact minimum and maximum values.
 * @property {number} [spacing] Distance in value units between isolines.
 *    Used if specified and `values` is not specified.
 * @property {number[]|geo.isolineFeature.valueEntry[]} [values] An array of
 *    explicit values for isolines.
 * @property {number[]} [levels=[5, 5]] If `values` is not used to explicitly
 *    set isoline levels, this determines the spacing of levels which can be
 *    used to style lines distinctly.  Most isolines will be level 0.  If
 *    `levels` is an array of [`n0`, `n1`, ...], every `n0`th line will be
 *    level 1, every `n0 * n1`th line will be level 2, etc.
 * @property {boolean|Function} [label] Truthy if a label should be shown for a
 *    isoline value.  If a function, this is called with
 *    `(geo.isolineFeature.valueEntry, index)`.  This defaults to
 *    `valueEntry.level >= 1`.
 * @property {string|Function} [labelText] Text for a label.  If a function,
 *    this is called with `(geo.isolineFeature.valueEntry, index)`.  This
 *    defaults to `valueEntry.value`.
 * @property {number|Function} [labelSpacing=200] Minimum distance between
 *    labels on an isoline in screen pixels.  If a function, this is called
 *    with `(geo.isolineFeature.valueEntry, index)`.
 * @property {number|Function} [labelOffset=0] Offset for labels along an
 *    isoline relative to where they would be placed by default on a scale of
 *    [-0.5, 0.5].  +/- 1 would move the text to the next repeated occurrence
 *    of the label.  If a function, this is called with
 *    `(geo.isolineFeature.valueEntry, index)`.
 * @property {number|Function} [labelViewport=10000] If the main position of a
 *    label would be further than this many pixels from the current viewport,
 *    don't create it.  This prevents creating an excessive number of labels
 *    when zoomed in, but requires regenerating labels occasionally when
 *    panning.  If <= 0, all labels are generated regardless of location.
 * @property {boolean|Function} [labelAutoUpdate=true] If truthy, when the map
 *    is panned (including zoom, rotation, etc.), periodically regenerate
 *    labels.  This uses an internal function that has a threshold based on a
 *    fixed change in zoom, size, and other parameters.  Set `labelAutoUpdate`
 *    to `false` and handle the {@link geo.event.pan} elsewhere.
 */

/**
 * Isoline value entry.
 *
 * @typedef {object} geo.isolineFeature.valueEntry
 * @property {number} value The value of the isoline.
 * @property {number} level The level of the isoline.
 * @property {number} [position] An index of the position of the isoline.  For
 *   evenly spaced or autofit values, this is the value modulo the spacing.
 *   Otherwise, this is the index position within the list of values.  This is
 *   computed when calculating isolines.
 * @property {string} [label] The label to display on this value.  This is
 *   computed from the `label` and `labelText` styles when calculating
 *   isolines.
 */

/**
 * Computed isoline information.
 *
 * @typedef {object} geo.isolineFeature.isolineInfo
 * @property {geo.isolineFeature.valueEntry[]} values The values used to
 *    produce the isolines.
 * @property {geo.meshFeature.meshInfo} mesh The normalized mesh.
 * @property {array[]} lines An array of arrays.  Each entry is a list of
 *    vertices that also have a `value` property with the appropriate entry in
 *    `values`.  If the line should show a label, it will  also have a `label`
 *    property with the text of the label.
 * @property {boolean} hasLabels `true` if there are any lines that have
 *    labels that need to be shown if there is enough resolution.
 */

/* This includes both the marching triangles and marching squares conditions.
 * The triangle pattern has three values, where 0 is less below the threshold
 * and 1 is above it.  The square pattern has four values in the order
 * ul-ur-ll-lr.  For each line a pattern produces, the line is created with a
 * low and high vertex from each of two edges.  Additionally, the create line
 * is such that the low value is outside of a clockwise winding.
 *
 * Performance note: Initially this table used string keys (e.g., '0001'), but
 * the string lookup was vastly slower than an integer lookup.
 */
var patternLineTable = {
  /* triangles with one high vertex */
  17 /* 001 */: [{
    l0: 1,
    h0: 2,
    l1: 0,
    h1: 2
  }],
  18 /* 010 */: [{
    l0: 0,
    h0: 1,
    l1: 2,
    h1: 1
  }],
  20 /* 100 */: [{
    l0: 2,
    h0: 0,
    l1: 1,
    h1: 0
  }],
  /* triangles with one low vertex */
  22 /* 110 */: [{
    l0: 2,
    h0: 0,
    l1: 2,
    h1: 1
  }],
  21 /* 101 */: [{
    l0: 1,
    h0: 2,
    l1: 1,
    h1: 0
  }],
  19 /* 011 */: [{
    l0: 0,
    h0: 1,
    l1: 0,
    h1: 2
  }],
  /* squares with one high vertex */
  1 /* 0001 */: [{
    l0: 2,
    h0: 3,
    l1: 1,
    h1: 3
  }],
  2 /* 0010 */: [{
    l0: 0,
    h0: 2,
    l1: 3,
    h1: 2
  }],
  4 /* 0100 */: [{
    l0: 3,
    h0: 1,
    l1: 0,
    h1: 1
  }],
  8 /* 1000 */: [{
    l0: 1,
    h0: 0,
    l1: 2,
    h1: 0
  }],
  /* squares with one low vertex */
  14 /* 1110 */: [{
    l0: 3,
    h0: 1,
    l1: 3,
    h1: 2
  }],
  13 /* 1101 */: [{
    l0: 2,
    h0: 3,
    l1: 2,
    h1: 0
  }],
  11 /* 1011 */: [{
    l0: 1,
    h0: 0,
    l1: 1,
    h1: 3
  }],
  7 /* 0111 */: [{
    l0: 0,
    h0: 2,
    l1: 0,
    h1: 1
  }],
  /* squares with two low vertices sharing a side */
  3 /* 0011 */: [{
    l0: 0,
    h0: 2,
    l1: 1,
    h1: 3
  }],
  10 /* 1010 */: [{
    l0: 1,
    h0: 0,
    l1: 3,
    h1: 2
  }],
  12 /* 1100 */: [{
    l0: 3,
    h0: 1,
    l1: 2,
    h1: 0
  }],
  5 /* 0101 */: [{
    l0: 2,
    h0: 3,
    l1: 0,
    h1: 1
  }],
  /* squares with two low vertices on opposite corners.  These could generate
   * a different pair of lines each. */
  6 /* 0110 */: [{
    l0: 0,
    h0: 2,
    l1: 0,
    h1: 1
  }, {
    l0: 3,
    h0: 1,
    l1: 3,
    h1: 2
  }],
  9 /* 1001 */: [{
    l0: 1,
    h0: 0,
    l1: 1,
    h1: 3
  }, {
    l0: 2,
    h0: 3,
    l1: 2,
    h1: 0
  }]
};

/**
 * Create a new instance of class isolineFeature.
 *
 * @class
 * @alias geo.isolineFeature
 * @extends geo.meshFeature
 *
 * @borrows geo.isolineFeature#mesh as geo.isolineFeature#contour
 * @borrows geo.isolineFeature#mesh as geo.isolineFeature#isoline
 *
 * @param {geo.isolineFeature.spec} arg
 * @returns {geo.isolineFeature}
 */
var _isolineFeature = function isolineFeature(arg) {
  'use strict';

  if (!(this instanceof _isolineFeature)) {
    return new _isolineFeature(arg);
  }
  var transform = __webpack_require__(5325);
  var geo_event = __webpack_require__(6409);
  var textFeature = __webpack_require__(6546);
  arg = arg || {};
  meshFeature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    m_isolines,
    m_lastLabelPositions,
    m_lineFeature,
    m_labelLayer,
    m_labelFeature,
    s_draw = this.draw,
    s_exit = this._exit,
    s_init = this._init,
    s_modified = this.modified,
    s_update = this._update;
  this.featureType = 'isoline';
  this.contour = m_this.mesh;
  this.isoline = m_this.mesh;

  /**
   * Create a set of isolines.  This is a set of lines that could be used for a
   * line feature and to inform a text feature.
   *
   * @returns {geo.isolineFeature.isolineInfo} An object with the isoline
   *    information.
   */
  this._createIsolines = function () {
    var valueFunc = m_this.style.get('value'),
      usedFunc = m_this.style('used') !== undefined ? m_this.style.get('used') : function (d, i) {
        return util.isNonNullFinite(valueFunc(d, i));
      },
      values,
      hasLabels = false,
      lines = [];
    var mesh = m_this._createMesh({
      used: usedFunc,
      value: valueFunc
    });
    values = m_this._getValueList(mesh);
    if (!values.length) {
      return {};
    }
    values.forEach(function (value) {
      var valueLines = m_this._isolinesForValue(mesh, value);
      if (valueLines.length) {
        lines = lines.concat(valueLines);
        hasLabels = hasLabels || !!value.label;
      }
    });
    /* We may want to rdpSimplify the result to remove very small segments, but
     * if we do, it must NOT change the winding direction. */
    return {
      lines: lines,
      mesh: mesh,
      values: values,
      hasLabels: hasLabels
    };
  };

  /**
   * Generate an array of values for which isolines will be generated.
   *
   * @param {geo.meshFeature.meshInfo} mesh The normalized mesh.
   * @returns {geo.isolineFeature.valueEntry[]} The values in ascending order.
   */
  this._getValueList = function (mesh) {
    var isoline = m_this.isoline,
      values = isoline.get('values')(mesh),
      spacing = isoline.get('spacing')(mesh),
      count = isoline.get('count')(mesh),
      autofit = isoline.get('autofit')(mesh),
      levels = isoline.get('levels')(mesh),
      minmax,
      delta,
      step,
      steppow,
      steplog10,
      fixedDigits,
      i;
    if (!mesh.numVertices || !mesh.numElements) {
      return [];
    }
    minmax = util.getMinMaxValues(mesh.value, isoline.get('min')(mesh), isoline.get('max')(mesh), true);
    mesh.minValue = minmax.min;
    mesh.maxValue = minmax.max;
    delta = mesh.maxValue - mesh.minValue;
    if (delta <= 0) {
      return [];
    }
    /* Determine values for which we need to generate isolines. */
    if (Array.isArray(values)) {
      /* if the caller specified values, use them.  Each can either be a number
       * or an object with `value` and optionally `level`.  If it doesn't have
       * level, the position is just the index in the array. */
      values = values.map(function (val, idx) {
        return {
          value: val.value !== undefined ? val.value : val,
          position: idx,
          level: val.level
        };
      });
      /* Remove any values that are outside of the data range. */
      values = values.filter(function (val) {
        return val.value >= mesh.minValue && val.value <= mesh.maxValue;
      });
    } else if (!spacing && !autofit) {
      /* If no values or spacing are specified and autofit is falsy, then
       * use uniform spacing across the value range.  The max and min won't
       * produce contours (since they are exact values), so there range is
       * divided into `count + 1` sections to get `count` visible lines. */
      values = Array(count);
      for (i = 0; i < count; i += 1) {
        values[i] = {
          value: mesh.minValue + delta * (i + 1) / (count + 1),
          position: i + 1
        };
      }
    } else {
      if (!spacing) {
        /* If no spacing is specified, then this has a count with autofit.
         * Generate at least 2/3rds as many lines as the count, but it could be
         * 5/2 of that when adjusted to "nice values" (so between 2/3 and 5/3
         * of the specified count). */
        step = delta / (count * 2 / 3);
        steplog10 = Math.floor(Math.log10(step));
        fixedDigits = Math.max(0, -steplog10);
        steppow = Math.pow(10, steplog10);
        step /= steppow; // will now be in range [1, 10)
        step = step >= 5 ? 5 : step >= 2 ? 2 : 1; // now 1, 2, or 5
        spacing = step * steppow;
      }
      /* Generate the values based on a spacing.  The `position` is used for
       * figuring out level further on and is based so that 0 will be the
       * maximum level. */
      values = [];
      for (i = Math.ceil(mesh.minValue / spacing); i <= Math.floor(mesh.maxValue / spacing); i += 1) {
        values.push({
          value: i * spacing,
          position: i,
          fixedDigits: fixedDigits
        });
      }
    }
    /* Mark levels for each value.  These are intended for styling.  All values
     * will have a `value` and `position` attribute at this point. */
    if (levels.length) {
      values.forEach(function (val, idx) {
        if (val.level === undefined) {
          val.level = 0;
          for (var i = 0, basis = levels[0]; i < levels.length && !(val.position % basis); i += 1, basis *= levels[i]) {
            val.level = i + 1;
          }
        }
        if (isoline.get('label')(val, val.position)) {
          var label = isoline.get('labelText')(val, val.position);
          if (label === undefined) {
            if (val.fixedDigits !== undefined) {
              label = '' + parseFloat(val.value.toFixed(val.fixedDigits));
            } else {
              label = '' + val.value;
            }
          }
          if (label) {
            val.label = label;
          }
        }
      });
    }
    return values;
  };

  /**
   * Add a new segment to a list of chains.  Each chain is a list of vertices,
   * each of which is an array of two values with the low/high mesh vertices
   * for that chain vertex.  There are then three possibilities:  (a) The
   * segment forms a new chain that doesn't attach to an existing chain.  (b)
   * One endpoint of the segment matches the endpoint of an existing chain, and
   * it gets added to that chain.  (c) Both endpoints of the segment match
   * endpoints of two different chains, and those two chains are combined via
   * the segment.  A chain may represent a loop, in which case its two
   * endpoints will match.  This function does not join the loop.
   *
   * @param {array} chains An array of existing chains.
   * @param {array} first One endpoint of the new segment.  This is an array of
   *    two numbers defining the mesh vertices used for the endpoint.
   * @param {array} last The second endpoint of the new segment.
   * @returns {array} The modified chains array.
   */
  this._addSegment = function (chains, first, last) {
    var chain = [first, last],
      idx = chains.length,
      i,
      iter,
      check,
      checkFirst,
      checkLast,
      combine;
    /* Add the segment as a new chain by itself. */
    chains.push(chain);
    for (iter = 0; iter < 2; iter += 1) {
      /* Check if the new chain can attach to an existing chain */
      for (i = idx - 1; i >= 0; i -= 1) {
        check = chains[i];
        checkFirst = check[0];
        checkLast = check[check.length - 1];
        /* The segment can be inserted at the start of this chain */
        if (last[0] === checkFirst[0] && last[1] === checkFirst[1]) {
          combine = chain.concat(check.slice(1));
          /* The segment can be inserted at the end of this chain */
        } else if (first[0] === checkLast[0] && first[1] === checkLast[1]) {
          combine = check.concat(chain.slice(1));
          /* These two conditions should never be required, as we generate
           * segments with a consistent winding direction.
          } else if (first[0] === checkFirst[0] && first[1] === checkFirst[1]) {
            combine = chain.slice(1).reverse().concat(check);
          } else if (last[0] === checkLast[0] && last[1] === checkLast[1]) {
            combine = check.concat(chain.slice(0, chain.length - 1).reverse());
           */
          /* The segment doesn't match this chain, so keep scanning chains */
        } else {
          continue;
        }
        /* The segment matched and `combine` contains the chain it has been
         * merged with. */
        chains.splice(idx, 1);
        chains[i] = chain = combine;
        idx = i;
        first = chain[0];
        last = chain[chain.length - 1];
        break;
      }
      /* If we didn't combine the new chain to any existing chains, then don't
       * check if the other end also joins an existing chain. */
      if (i < 0) {
        break;
      }
    }
    return chains;
  };

  /**
   * Given a vertex of the form [low vertex index, high vertex index], compute
   * the coordinates of the vertex.
   *
   * @param {geo.meshFeature.meshInfo} mesh The normalized mesh.
   * @param {geo.isolineFeature.valueEntry} value The value for which to
   *    generate the vertex.
   * @param {number[]} vertex The low vertex index and high vertex index.
   * @returns {geo.geoPosition} The calculated coordinate.
   */
  this._chainVertex = function (mesh, value, vertex) {
    var v0 = vertex[0],
      v1 = vertex[1],
      v03 = v0 * 3,
      v13 = v1 * 3,
      f = (value.value - mesh.value[v0]) / (mesh.value[v1] - mesh.value[v0]),
      g = 1 - f;
    return {
      x: mesh.pos[v03] * g + mesh.pos[v13] * f,
      y: mesh.pos[v03 + 1] * g + mesh.pos[v13 + 1] * f,
      z: mesh.pos[v03 + 2] * g + mesh.pos[v13 + 2] * f
    };
  };

  /**
   * Generate the lines for associated with a particular value.  This performs
   * either marching triangles or marching squares.
   *
   * @param {geo.meshFeature.meshInfo} mesh The normalized mesh.
   * @param {geo.isolineFeature.valueEntry} value The value for which to
   *    generate the isolines.
   * @returns {geo.isolineFeature.line[]} An array of lines.
   */
  this._isolinesForValue = function (mesh, value) {
    var val = value.value,
      lowhigh = Array(mesh.value.length),
      chains = [],
      i,
      v,
      pattern,
      lines;
    /* Determine if each vertex is above or below the value.  It is faster to
     * use a for loop than map since it avoids function calls. */
    for (i = lowhigh.length - 1; i >= 0; i -= 1) {
      lowhigh[i] = mesh.value[i] <= val ? 0 : 1;
    }
    var vpe = mesh.verticesPerElement,
      square = mesh.shape === 'square',
      elem = mesh.elements,
      elemLen = elem.length;
    for (v = 0; v < elemLen; v += vpe) {
      if (square) {
        pattern = lowhigh[elem[v]] * 8 + lowhigh[elem[v + 1]] * 4 + lowhigh[elem[v + 2]] * 2 + lowhigh[elem[v + 3]];
        if (pattern === 0 || pattern === 15) {
          continue;
        }
      } else {
        pattern = 16 + lowhigh[elem[v]] * 4 + lowhigh[elem[v + 1]] * 2 + lowhigh[elem[v + 2]];
        if (pattern === 16 || pattern === 23) {
          continue;
        }
      }
      patternLineTable[pattern].forEach(function (lineEntry) {
        chains = m_this._addSegment(chains, [elem[v + lineEntry.l0], elem[v + lineEntry.h0]], [elem[v + lineEntry.l1], elem[v + lineEntry.h1]]);
      });
    }
    /* convert chains to lines */
    lines = chains.map(function (chain) {
      var line = [];
      chain.forEach(function (vertex) {
        var v = m_this._chainVertex(mesh, value, vertex);
        if (!line.length || v.x !== line[line.length - 1].x || v.y !== line[line.length - 1].y) {
          line.push(v);
        }
      });
      line.closed = line[0].x === line[line.length - 1].x && line[0].y === line[line.length - 1].y;
      /* Add value, level, position, and label information to the line. */
      line.value = value.value;
      line.level = value.level;
      line.position = value.position;
      line.label = value.label;
      return line;
    }).filter(function (line) {
      return line.length > 1;
    });
    return lines;
  };

  /**
   * Update the timestamp to the next global timestamp value.  Mark
   * sub-features as modified, too.
   *
   * @returns {object} The results of the superclass modified function.
   */
  this.modified = function () {
    var result = s_modified();
    if (m_lineFeature) {
      m_lineFeature.modified();
    }
    if (m_labelFeature) {
      m_labelFeature.modified();
    }
    return result;
  };

  /**
   * Compute the positions for labels on each line.  This can be called to
   * recompute label positions without needign to recompute isolines, for
   * instance when the zoom level changes.  Label positions are computed in the
   * map gcs coordinates, not interface gcs coordinates, since the interface
   * gcs may not be linear with the display space.
   *
   * @returns {this}
   */
  this.labelPositions = function () {
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp()) {
      m_this._build();
    }
    m_lastLabelPositions = null;
    if (!m_labelFeature) {
      return m_this;
    }
    if (!m_isolines || !m_isolines.hasLabels || !m_isolines.lines || !m_isolines.lines.length) {
      m_labelFeature.data([]);
      return m_this;
    }
    var isoline = m_this.isoline,
      spacingFunc = isoline.get('labelSpacing'),
      offsetFunc = isoline.get('labelOffset'),
      labelViewport = isoline.get('labelViewport')(m_isolines.mesh),
      gcs = m_this.gcs(),
      map = m_this.layer().map(),
      mapgcs = map.gcs(),
      mapRotation = map.rotation(),
      mapSize = map.size(),
      labelData = [],
      maxSpacing = 0;
    m_isolines.lines.forEach(function (line, idx) {
      if (!line.label) {
        return;
      }
      var spacing = spacingFunc(line.value, line.value.position),
        offset = offsetFunc(line.value, line.value.position) || 0,
        dispCoor = map.gcsToDisplay(line, gcs),
        totalDistance = 0,
        dist,
        count,
        localSpacing,
        next,
        lineDistance,
        i,
        i2,
        f,
        g,
        pos,
        mapCoor;
      if (spacing <= 0 || isNaN(spacing)) {
        return;
      }
      maxSpacing = Math.max(spacing, maxSpacing);
      /* make offset in the range of [0, 1) with the default at 0.5 */
      offset = offset + 0.5 - Math.floor(offset + 0.5);
      dist = dispCoor.map(function (pt1, coorIdx) {
        if (!line.closed && coorIdx + 1 === dispCoor.length) {
          return 0;
        }
        var val = Math.sqrt(util.distance2dSquared(pt1, dispCoor[coorIdx + 1 < dispCoor.length ? coorIdx + 1 : 0]));
        totalDistance += val;
        return val;
      });
      count = Math.floor(totalDistance / spacing);
      if (!count) {
        return;
      }
      /* If we have any labels, compute map coordinates of the line and use
       * those for interpolating label positions */
      mapCoor = transform.transformCoordinates(gcs, mapgcs, line);
      localSpacing = totalDistance / count;
      next = localSpacing * offset;
      lineDistance = 0;
      for (i = 0; i < dispCoor.length; i += 1) {
        while (lineDistance + dist[i] >= next) {
          i2 = i + 1 === dispCoor.length ? 0 : i + 1;
          f = (next - lineDistance) / dist[i];
          g = 1 - f;
          next += localSpacing;
          if (labelViewport > 0) {
            pos = {
              x: dispCoor[i].x * g + dispCoor[i2].x * f,
              y: dispCoor[i].y * g + dispCoor[i2].y * f
            };
            if (pos.x < -labelViewport || pos.x > mapSize.width + labelViewport || pos.y < -labelViewport || pos.y > mapSize.height + labelViewport) {
              continue;
            }
          }
          labelData.push({
            x: mapCoor[i].x * g + mapCoor[i2].x * f,
            y: mapCoor[i].y * g + mapCoor[i2].y * f,
            z: mapCoor[i].z * g + mapCoor[i2].z * f,
            line: line,
            rotation: Math.atan2(dispCoor[i].y - dispCoor[i2].y, dispCoor[i].x - dispCoor[i2].x) - mapRotation
          });
        }
        lineDistance += dist[i];
      }
    });
    m_labelFeature.gcs(mapgcs);
    m_labelFeature.data(labelData);
    m_labelFeature.style('renderThreshold', maxSpacing * 2);
    m_lastLabelPositions = {
      zoom: map.zoom(),
      center: map.center(),
      rotation: mapRotation,
      size: mapSize,
      labelViewport: labelViewport,
      maxSpacing: maxSpacing,
      labelAutoUpdate: isoline.get('labelAutoUpdate')(m_isolines.mesh)
    };
    return m_this;
  };

  /**
   * Get the last map position that was used for generating labels.
   *
   * @returns {object} An object with the map `zoom` and `center` and the
   *    `labelViewport` used in generating labels.  The object may have no
   *    properties if there are no labels.
   */
  this.lastLabelPositions = function () {
    return Object.assign({}, m_lastLabelPositions);
  };

  /**
   * On a pan event, if labels exist and are set to autoupdate, recalculate
   * their positions and redraw them as needed.  Labels are redrawn if the
   * zoom level changes by at least 2 levels, or the map's center is moved
   * enough that there is a chance that the viewport is nearing the extent of
   * the generated labels.  The viewport calculation is conservative, as the
   * map could be rotated, changed size, or have other modifications.
   *
   * @returns {this}
   */
  this._updateLabelPositions = function () {
    var last = m_lastLabelPositions;
    if (!last || !last.labelAutoUpdate) {
      return m_this;
    }
    var map = m_this.layer().map(),
      zoom = map.zoom(),
      mapSize = map.size(),
      update = !!(Math.abs(zoom - last.zoom) >= 2);
    if (!update && last.labelViewport > 0) {
      /* Distance in scaled pixels between the map's current center and the
       * center when the labels were computed. */
      var lastDelta = Math.sqrt(util.distance2dSquared(map.gcsToDisplay(map.center()), map.gcsToDisplay(last.center))) * Math.pow(2, last.zoom - zoom);
      /* Half the viewport, less twice the maxSpacing, less any expansion of
       * the map. */
      var threshold = last.labelViewport / 2 - last.maxSpacing * 2 - Math.max(mapSize.width - last.size.width, mapSize.height - last.size.height, 0);
      update = update || lastDelta >= threshold;
    }
    if (update) {
      m_this.labelPositions().draw();
    }
    return m_this;
  };

  /**
   * Build.  Generate the isolines.  Create a line feature if necessary and
   * update it.
   *
   * @returns {this}
   */
  this._build = function () {
    m_isolines = m_this._createIsolines();
    if (m_isolines && m_isolines.lines && m_isolines.lines.length) {
      if (!m_lineFeature) {
        m_lineFeature = m_this.layer().createFeature('line', {
          selectionAPI: false,
          gcs: m_this.gcs(),
          visible: m_this.visible(undefined, true),
          style: {
            closed: function closed(d) {
              return d.closed;
            }
          }
        });
        m_this.dependentFeatures([m_lineFeature]);
      }
      var style = m_this.style();
      m_lineFeature.data(m_isolines.lines).style(['antialiasing', 'lineCap', 'lineJoin', 'miterLimit', 'strokeWidth', 'strokeStyle', 'strokeColor', 'strokeOffset', 'strokeOpacity'].reduce(function (acc, key) {
        if (key in style) {
          acc[key] = style[key];
        }
        return acc;
      }, {}));
      if (m_isolines.hasLabels) {
        if (!m_labelFeature) {
          if (!(registry.registries.features[m_this.layer().rendererName()] || {}).text) {
            var renderer = registry.rendererForFeatures(['text']);
            m_labelLayer = registry.createLayer('feature', m_this.layer().map(), {
              renderer: renderer
            });
            m_this.layer().addChild(m_labelLayer);
            m_this.layer().node().append(m_labelLayer.node());
          }
          m_labelFeature = (m_labelLayer || m_this.layer()).createFeature('text', {
            selectionAPI: false,
            gcs: m_this.gcs(),
            visible: m_this.visible(undefined, true),
            style: {
              text: function text(d) {
                return d.line.label;
              }
            }
          }).geoOn(geo_event.pan, m_this._updateLabelPositions);
        }
        textFeature.usedStyles.forEach(function (styleName) {
          if (styleName !== 'visible') {
            m_labelFeature.style(styleName, style[styleName]);
          }
        });
        m_this.dependentFeatures([m_lineFeature, m_labelFeature]);
      }
    } else if (m_lineFeature) {
      m_lineFeature.data([]);
    }
    m_this.buildTime().modified();
    /* Update label positions after setting the build time.  The labelPositions
     * method will build if necessary, and this prevents it from looping. */
    m_this.labelPositions();
    return m_this;
  };

  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() <= m_this.timestamp()) {
      m_this._build();
    }
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Redraw the object.
   *
   * @returns {object} The results of the superclass draw function.
   */
  this.draw = function () {
    var result = s_draw();
    if (m_lineFeature) {
      m_lineFeature.draw();
    }
    if (m_labelFeature) {
      m_labelFeature.draw();
    }
    return result;
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    if (m_labelFeature) {
      if (m_labelLayer || m_this.layer()) {
        (m_labelLayer || m_this.layer()).deleteFeature(m_labelFeature);
      }
      if (m_labelLayer && m_this.layer()) {
        m_this.layer().removeChild(m_labelLayer);
      }
    }
    if (m_lineFeature && m_this.layer()) {
      m_this.layer().deleteFeature(m_lineFeature);
    }
    m_labelFeature = null;
    m_labelLayer = null;
    m_lineFeature = null;
    m_this.dependentFeatures([]);
    s_exit();
  };

  /**
   * Initialize.
   *
   * @param {geo.isolineFeature.spec} arg The isoline feature specification.
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      opacity: 1.0,
      value: function value(d, i) {
        return m_this.position()(d, i).z;
      },
      rotateWithMap: true,
      rotation: _isolineFeature.rotationFunction(),
      strokeWidth: function strokeWidth(v, vi, d, di) {
        return d.level + 0.5;
      },
      strokeColor: {
        r: 0,
        g: 0,
        b: 0
      },
      textStrokeColor: {
        r: 1,
        g: 1,
        b: 1,
        a: 0.75
      },
      textStrokeWidth: 2,
      fontSize: '12px'
    }, arg.style === undefined ? {} : arg.style);
    m_this.style(defaultStyle);
    m_this.isoline(Object.assign({}, {
      count: 15,
      autofit: true,
      levels: [5, 5],
      label: function label(value) {
        return value.level >= 1;
      },
      labelSpacing: 200,
      labelViewport: 10000,
      labelAutoUpdate: true
    }, arg.mesh || {}, arg.contour || {}, arg.isoline || {}));
    if (arg.mesh || arg.contour || arg.isoline) {
      m_this.dataTime().modified();
    }
  };
  return this;
};

/**
 * Return a function that will rotate text labels in a specified orientation.
 * The results of this are intended to be used as the value of the `rotation`
 * style.
 *
 * @param {string} [mode] The rotation mode.  `higher` orients the top
 *   of the text to high values.  `lower` orients the top of the text to lower
 *   values.  `map` orients the top of the text so it is aligned to the isoline
 *   and biased toward the top of the map.  `screen` orients the top of the
 *   text so it is aligned to the isoline and biased toward the top of the
 *   display screen.
 * @param {geo.map} [map] The parent map.  Required for `screen` mode.
 * @returns {Function} A function for the rotation style.
 */
_isolineFeature.rotationFunction = function (mode, map) {
  var functionList = {
    higher: function higher(d) {
      return d.rotation;
    },
    lower: function lower(d) {
      return d.rotation + Math.PI;
    },
    map: function map(d) {
      var r = d.rotation,
        rt = util.wrapAngle(r, true);
      if (rt > Math.PI / 2 || rt < -Math.PI / 2) {
        r += Math.PI;
      }
      return r;
    },
    screen: function screen(d) {
      var r = d.rotation,
        rt = util.wrapAngle(r + map.rotation(), true);
      if (rt > Math.PI / 2 || rt < -Math.PI / 2) {
        r += Math.PI;
      }
      return r;
    }
  };
  return functionList[mode] || functionList.higher;
};
inherit(_isolineFeature, meshFeature);
module.exports = _isolineFeature;

/***/ }),

/***/ 5156:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var sceneObject = __webpack_require__(5402);
var feature = __webpack_require__(1275);
var checkRenderer = (__webpack_require__(1098).checkRenderer);
var rendererForFeatures = (__webpack_require__(1098).rendererForFeatures);
var rendererForAnnotations = (__webpack_require__(1098).rendererForAnnotations);

/**
 * Object specification for a layer.
 *
 * @typedef {object} geo.layer.spec
 * @property {number} [id] The id of the layer.  Defaults to a increasing
 *   sequence.
 * @property {geo.map} [map=null] Parent map of the layer.
 * @property {string|geo.renderer} [renderer] Renderer to associate with the
 *   layer.  If not specified, either `annotations` or `features` can be used
 *   to determine the renderer.  If a {@link geo.renderer} instance, the
 *   renderer is not recreated; not all renderers can be shared by multiple
 *   layers.
 * @property {boolean|string} [autoshareRenderer=true] If truthy and the
 *   renderer supports it, auto-share renderers between layers.  Currently,
 *   auto-sharing can only occur for webgl renderers and adjacent layers.  If
 *   `true`, sharing will only occur if the layers have the same opacity and it
 *   is 1 or 0 and any tile layers are below non-tile layers.  If `"more"`,
 *   sharing will occur for any adjacent layers that have the same opacity.
 *   Shared renderers has slightly different behavior than non-shared
 *   renderers: changing z-index may result in rerendering and be slightly
 *   slower; only one DOM canvas is used for all shared renderers.  Some
 *   features have slight z-stacking differences in shared versus non-shared
 *   renderers.
 * @property {HTMLElement} [canvas] If specified, use this canvas rather than
 *   a canvas associaied with the renderer directly.  Renderers may not support
 *   sharing a canvas.
 * @property {string[]|object} [annotations] A list of annotations that will be
 *   used on this layer, used to select a renderer.  Instead of a list, if
 *   this is an object, the keys are the annotation names, and the values are
 *   each a list of modes that will be used with that annotation.  See
 *   `featuresForAnnotations` more details.  This is ignored if `renderer` is
 *   specified.
 * @property {string[]} [features] A list of features that will be used on this
 *   layer, used to select a renderer.  Features are the basic feature names
 *   (e.g., `'quad'`), or the feature name followed by a required capability
 *   (e.g., `'quad.image'`).  This is ignored if `renderer` or `annotations` is
 *   specified.
 * @property {boolean} [active=true] Truthy if the layer has the `active` css
 *   class and may receive native mouse events.
 * @property {string} [attribution] An attribution string to display.
 * @property {number} [opacity=1] The layer opacity on a scale of [0-1].
 * @property {string} [name=''] A name for the layer for user convenience.  If
 *   specified, this is also the `id` property of the containing DOM element.
 * @property {boolean} [selectionAPI=true] Truthy if the layer can generate
 *   selection and other interaction events.
 * @property {boolean} [sticky=true] Truthy if the layer should navigate with
 *   the map.
 * @property {boolean} [visible=true] Truthy if the layer is visible.
 * @property {number} [zIndex] The z-index to assign to the layer (defaults to
 *   the index of the layer inside the map).
 */

/**
 * Create a new layer.
 *
 * @class
 * @alias geo.layer
 * @extends geo.sceneObject
 * @param {geo.layer.spec} [arg] Specification for the new layer.
 * @returns {geo.layer}
 */
var _layer = function layer(arg) {
  'use strict';

  if (!(this instanceof _layer)) {
    return new _layer(arg);
  }
  arg = arg || {};
  sceneObject.call(this, arg);
  var $ = __webpack_require__(5616);
  var timestamp = __webpack_require__(77);
  var renderer = __webpack_require__(2274);
  var createRenderer = (__webpack_require__(1098).createRenderer);
  var adjustLayerForRenderer = (__webpack_require__(1098).adjustLayerForRenderer);
  var geo_event = __webpack_require__(6409);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    m_id = arg.id === undefined ? _layer.newLayerId() : arg.id,
    m_name = arg.name === undefined ? '' : arg.name,
    m_map = arg.map === undefined ? null : arg.map,
    m_node = null,
    m_canvas = arg.canvas === undefined ? null : arg.canvas,
    m_renderer = arg.renderer instanceof renderer ? arg.renderer : null,
    m_initialized = false,
    m_rendererName = arg.renderer !== undefined ? arg.renderer instanceof renderer ? arg.renderer.api() : arg.renderer : arg.annotations ? rendererForAnnotations(arg.annotations) : rendererForFeatures(arg.features),
    m_autoshareRenderer = arg.autoshareRenderer === undefined ? true : arg.autoshareRenderer,
    m_dataTime = timestamp(),
    m_updateTime = timestamp(),
    m_sticky = arg.sticky === undefined ? true : arg.sticky,
    m_active = arg.active === undefined ? true : arg.active,
    m_opacity = arg.opacity === undefined ? 1 : arg.opacity,
    m_attribution = arg.attribution || null,
    m_visible = arg.visible === undefined ? true : arg.visible,
    m_selectionAPI = arg.selectionAPI === undefined ? true : arg.selectionAPI,
    m_zIndex;
  m_rendererName = checkRenderer(m_rendererName);
  if (!m_map) {
    throw new Error('Layers must be initialized on a map.');
  }

  /**
   * Get a list of sibling layers.  If no parent has been assigned to this
   * layer, assume that the map will be the parent.  This gets all of the
   * parent's children that are layer instances.
   *
   * @returns {geo.layer[]} A list of sibling layers.
   */
  function _siblingLayers() {
    return (m_this.parent() || m_this.map()).children().filter(function (child) {
      return child instanceof _layer;
    });
  }

  /**
   * Get the name of the renderer.
   *
   * @returns {string}
   */
  this.rendererName = function () {
    return m_rendererName;
  };

  /**
   * Get the setting of autoshareRenderer.
   *
   * @returns {boolean|string}
   */
  this.autoshareRenderer = function () {
    return m_autoshareRenderer;
  };

  /**
   * Get or set the z-index of the layer.  The z-index controls the display
   * order of the layers in much the same way as the CSS z-index property.
   *
   * @param {number} [zIndex] The new z-index, or undefined to return the
   *    current z-index.
   * @param {boolean} [allowDuplicate] When setting the z index, if this is
   *    truthy, allow other layers to have the same z-index.  Otherwise,
   *    ensure that other layers have distinct z-indices from this one.
   * @returns {number|this}
   */
  this.zIndex = function (zIndex, allowDuplicate) {
    if (zIndex === undefined) {
      return m_zIndex;
    }
    if (!allowDuplicate) {
      // if any extant layer has the same index, then we move all of those
      // layers up.  We do this in reverse order since, if two layers above
      // this one share a z-index, they will resolve to the layer insert order.
      _siblingLayers().reverse().forEach(function (child) {
        if (child !== m_this && child.zIndex() === zIndex) {
          child.zIndex(zIndex + 1);
        }
      });
    }
    if (zIndex !== m_zIndex) {
      m_zIndex = zIndex;
      m_node.css('z-index', m_zIndex);
      m_this.geoTrigger(geo_event.layerMove, {
        layer: m_this
      });
    }
    return m_this;
  };

  /**
   * Bring the layer above the given number of layers.  This will rotate the
   * current z-indices for this and the next `n` layers.
   *
   * @param {number} [n] The number of positions to move.
   * @returns {this}
   */
  this.moveUp = function (n) {
    var order,
      i,
      me = null,
      tmp,
      sign;

    // set the default
    if (n === undefined) {
      n = 1;
    }

    // set the sort direction that controls if we are moving up
    // or down the z-index
    sign = 1;
    if (n < 0) {
      sign = -1;
      n = -n;
    }

    // get a sorted list of layers
    order = _siblingLayers().sort(function (a, b) {
      return sign * (a.zIndex() - b.zIndex());
    });
    for (i = 0; i < order.length; i += 1) {
      if (me === null) {
        // loop until we get to the current layer
        if (order[i] === m_this) {
          me = i;
        }
      } else if (i - me <= n) {
        // swap the next n layers
        tmp = m_this.zIndex();
        m_this.zIndex(order[i].zIndex(), true);
        order[i].zIndex(tmp, true);
      } else {
        // all the swaps are done now
        break;
      }
    }
    return m_this;
  };

  /**
   * Bring the layer below the given number of layers.  This will rotate the
   * current z-indices for this and the previous `n` layers.
   *
   * @param {number} [n] The number of positions to move.
   * @returns {this}
   */
  this.moveDown = function (n) {
    if (n === undefined) {
      n = 1;
    }
    return m_this.moveUp(-n);
  };

  /**
   * Bring the layer to the top of the map layers.
   *
   * @returns {this}
   */
  this.moveToTop = function () {
    return m_this.moveUp(_siblingLayers().length - 1);
  };

  /**
   * Bring the layer to the bottom of the map layers.
   *
   * @returns {this}
   */
  this.moveToBottom = function () {
    return m_this.moveDown(_siblingLayers().length - 1);
  };

  /**
   * Get whether or not the layer is sticky (navigates with the map).
   *
   * @returns {boolean}
   */
  this.sticky = function () {
    return m_sticky;
  };

  /**
   * Get/Set whether or not the layer is active.  An active layer will receive
   * native mouse when the layer is on top.  Non-active layers will never
   * receive native mouse events.
   *
   * @param {boolean} [arg] If specified, the new `active` value.
   * @returns {boolean|this}
   */
  this.active = function (arg) {
    if (arg === undefined) {
      return m_active;
    }
    if (m_active !== arg) {
      m_active = arg;
      m_node.toggleClass('active', m_active);
    }
    return m_this;
  };

  /**
   * Get root node of the layer.
   *
   * @returns {HTMLDivElement}
   */
  this.node = function () {
    return m_node;
  };

  /**
   * Get/Set id of the layer.
   *
   * @param {string|null} [val] If `null`, generate a new layer id.  Otherwise,
   *    if specified, the new id of the layer.
   * @returns {string|this}
   */
  this.id = function (val) {
    if (val === undefined) {
      return m_id;
    }
    m_id = val === null ? _layer.newLayerId() : val;
    m_this.modified();
    return m_this;
  };

  /**
   * Get/Set name of the layer.
   *
   * @param {string} [val] If specified, the new name of the layer.
   * @returns {string|this}
   */
  this.name = function (val) {
    if (val === undefined) {
      return m_name;
    }
    m_name = val;
    m_node.attr('id', m_name);
    m_this.modified();
    return m_this;
  };

  /**
   * Get the map associated with this layer.
   *
   * @returns {geo.map} The map associated with the layer.
   */
  this.map = function () {
    return m_map;
  };

  /**
   * Get the renderer for the layer.
   *
   * @returns {geo.renderer} The renderer associated with the layer or `null`
   *    if there is no renderer.
   */
  this.renderer = function () {
    return m_renderer;
  };

  /**
   * Get/Set the renderer for the layer.
   *
   * @param {boolean} [val] If specified, update the renderer value.
   *    Otherwise, return the current instance.
   * @returns {geo.renderer|this} The renderer associated with the layer,
   *    `null`, or the current instance.
   */
  this._renderer = function (val) {
    if (val === undefined) {
      return m_renderer;
    }
    m_renderer = val;
    return m_this;
  };

  /**
   * Get canvas of the layer.
   *
   * @returns {HTMLCanvasElement} The canvas element associated with the layer.
   */
  this.canvas = function () {
    return m_canvas;
  };

  /**
   * Get/set the canvas of the layer.
   *
   * @param {boolean} [val] If specified, update the canvas value.  Otherwise,
   *    return the current instance.
   * @returns {HTMLCanvasElement|this} The canvas element associated with the
   *    layer or the current instance.
   */
  this._canvas = function (val) {
    if (val === undefined) {
      return m_canvas;
    }
    m_canvas = val;
    return m_this;
  };

  /**
   * Return last time data got changed.
   *
   * @returns {geo.timestamp} The data time.
   */
  this.dataTime = function () {
    return m_dataTime;
  };

  /**
   * Return the modified time for the last update that did something.
   *
   * @returns {geo.timestamp} The update time.
   */
  this.updateTime = function () {
    return m_updateTime;
  };

  /**
   * Get/Set if the layer has been initialized.
   *
   * @param {boolean} [val] If specified, update the initialized value.
   *    Otherwise, return the current instance.
   * @returns {boolean|this} Either the initialized value or this.
   */
  this.initialized = function (val) {
    if (val !== undefined) {
      m_initialized = val;
      return m_this;
    }
    return m_initialized;
  };

  /**
   * Transform coordinates from world coordinates into a local coordinate
   * system specific to the underlying renderer.  This method is exposed
   * to allow direct access the rendering context, but otherwise should
   * not be called directly.  The default implementation is the identity
   * operator.
   *
   * @param {geo.geoPosition} input World coordinates.
   * @returns {geo.geoPosition} Renderer coordinates.
   */
  this.toLocal = function (input) {
    return input;
  };

  /**
   * Transform coordinates from a local coordinate system to world coordinates.
   *
   * @param {geo.geoPosition} input Renderer coordinates.
   * @returns {geo.geoPosition} World coordinates.
   */
  this.fromLocal = function (input) {
    return input;
  };

  /**
   * Get or set the attribution html content that will displayed with the
   * layer.  By default, nothing will be displayed.  Note, this content is
   * **not** html escaped, so care should be taken when rendering user provided
   * content.
   *
   * @param {string?} arg An html fragment
   * @returns {string|this} Chainable as a setter
   */
  this.attribution = function (arg) {
    if (arg !== undefined) {
      m_attribution = arg;
      m_this.map().updateAttribution();
      return m_this;
    }
    return m_attribution;
  };

  /**
   * Get/Set visibility of the layer.
   *
   * @param {boolean} [val] If specified, change the visibility.  Otherwise,
   *    get it.
   * @returns {boolean|this} either the visibility (if getting) or the layer
   *    (if setting).
   */
  this.visible = function (val) {
    if (val === undefined) {
      return m_visible;
    }
    if (m_visible !== val) {
      m_visible = val;
      m_node.toggleClass('hidden', !m_visible);
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set selectionAPI of the layer.
   *
   * @param {boolean} [val] If specified, set the selectionAPI state, otherwise
   *    return it.
   * @returns {boolean|this} Either the selectionAPI state or the layer.
   */
  this.selectionAPI = function (val) {
    if (val === undefined) {
      return m_selectionAPI;
    }
    if (m_selectionAPI !== val) {
      m_selectionAPI = val;
    }
    return m_this;
  };

  /**
   * Init layer.
   *
   * @param {boolean} noEvents If a subclass of this intends to bind the
   *    resize, pan, and zoom events itself, set this flag to true to avoid
   *    binding them here.
   * @returns {this}
   */
  this._init = function (noEvents) {
    if (m_initialized) {
      return m_this;
    }
    m_map.node().append(m_node);

    /* Pass along the arguments, but not the map reference */
    var options = Object.assign({}, arg);
    delete options.map;
    if (m_renderer) {
      m_this._canvas(m_renderer.canvas());
    } else if (m_rendererName === null) {
      // if given a "null" renderer, then pass the layer element as the canvas
      m_this._renderer(null);
      m_this._canvas(m_node);
    } else if (m_canvas) {
      // Share context if we have valid one
      m_this._renderer(createRenderer(m_rendererName, m_this, m_canvas, options));
    } else {
      m_this._renderer(createRenderer(m_rendererName, m_this, undefined, options));
      m_this._canvas(m_renderer.canvas());
    }
    m_node.toggleClass('active', m_this.active());
    m_initialized = true;
    if (!noEvents) {
      // Bind events to handlers
      m_this.geoOn(geo_event.resize, function (event) {
        m_this._update({
          event: event
        });
      });
      m_this.geoOn(geo_event.pan, function (event) {
        m_this._update({
          event: event
        });
      });
      m_this.geoOn(geo_event.rotate, function (event) {
        m_this._update({
          event: event
        });
      });
      m_this.geoOn(geo_event.zoom, function (event) {
        m_this._update({
          event: event
        });
      });
    }
    return m_this;
  };

  /**
   * Clean up resources.
   */
  this._exit = function () {
    m_this.geoOff();
    if (m_renderer) {
      m_renderer._exit();
    }
    m_node.off();
    m_node.remove();
    arg = {};
    m_this._canvas(null);
    m_this._renderer(null);
    s_exit();
  };

  /**
   * Update layer.
   *
   * This is a stub that should be subclassed.
   *
   * @param {object} [arg] An object, possibly with an ``event`` key and value.
   * @returns {this}
   */
  this._update = function (arg) {
    return m_this;
  };

  /**
   * Return the width of the layer in pixels.
   *
   * @returns {number} The width of the parent map in pixels.
   */
  this.width = function () {
    return m_this.map().size().width;
  };

  /**
   * Return the height of the layer in pixels.
   *
   * @returns {number} The height of the parent map in pixels.
   */
  this.height = function () {
    return m_this.map().size().height;
  };

  /**
   * Get or set the current layer opacity.  The opacity is in the range [0-1].
   * An opacity of 0 is not the same as setting `visible(false)`, as
   * interactions can still occur with the layer.
   *
   * @param {number} [opacity] If specified, set the opacity.  Otherwise,
   *    return the opacity.
   * @returns {number|this} The current opacity or the current layer.
   */
  this.opacity = function (opacity) {
    if (opacity !== undefined) {
      m_opacity = opacity;
      m_node.css('opacity', m_opacity);
      return m_this;
    }
    return m_opacity;
  };

  // Create top level div for the layer
  m_node = $(document.createElement('div'));
  m_node.addClass('geojs-layer');
  m_node.attr('renderer', m_rendererName);
  if (m_name) {
    m_node.attr('id', m_name);
  }
  m_this.opacity(m_opacity);
  m_this.visible(m_visible);

  // set the z-index (this prevents duplication)
  if (arg.zIndex === undefined) {
    var maxZ = -1;
    _siblingLayers().forEach(function (child) {
      if (child.zIndex() !== undefined) {
        maxZ = Math.max(maxZ, child.zIndex());
      }
    });
    arg.zIndex = maxZ + 1;
  }
  m_this.zIndex(arg.zIndex);
  adjustLayerForRenderer('all', m_this);
  return m_this;
};

/**
 * Gets a new id number for a layer.
 * @protected
 * @instance
 * @returns {number}
 */
_layer.newLayerId = function () {
  'use strict';

  var currentId = 1;
  return function () {
    var id = currentId;
    currentId += 1;
    return id;
  };
}();

/**
 * General object specification for feature types.
 * @typedef {geo.layer.spec} geo.layer.createSpec
 * @extends {geo.layer.spec}
 * @property {string} [type='feature'] For feature compatibility with more than
 *    one kind of creatable layer
 * @property {object[]} [data=[]] The default data array to apply to each
 *    feature if none exists.
 * @property {string} [renderer='webgl'] The renderer to use.
 * @property {geo.feature.spec[]} [features=[]] Features to add to the layer.
 */

/**
 * Create a layer from an object.  Any errors in the creation
 * of the layer will result in returning null.
 * @param {geo.map} map The map to add the layer to
 * @param {geo.layer.createSpec} spec The layer specification.
 * @returns {geo.layer|null}
 */
_layer.create = function (map, spec) {
  'use strict';

  spec = spec || {};
  spec.type = spec.type || 'feature';
  spec.renderer = spec.renderer === undefined ? 'webgl' : spec.renderer;
  spec.renderer = checkRenderer(spec.renderer);
  if (!spec.renderer) {
    console.warn('Invalid renderer'); // eslint-disable-line no-console
    return null;
  }
  var layer = map.createLayer(spec.type, spec);
  if (!layer) {
    console.warn('Unable to create a layer'); // eslint-disable-line no-console
    return null;
  }
  if (spec.features) {
    // probably move this down to featureLayer eventually
    spec.features.forEach(function (f) {
      f.data = f.data || spec.data;
      f.feature = feature.create(layer, f);
    });
  }
  return layer;
};
inherit(_layer, sceneObject);
module.exports = _layer;

/***/ }),

/***/ 9281:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var timestamp = __webpack_require__(77);
var transform = __webpack_require__(5325);
var util = __webpack_require__(642);

/**
 * Line feature specification.
 *
 * @typedef {geo.feature.spec} geo.lineFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 * @property {object|Function} [line] Lines from the data.  Default is (data).
 *   Typically, the data is an array of lines, each of which is an array of
 *   points.  Only lines that have at least two points are rendered.  The
 *   position function is called for each point as `position(linePoint,
 *   pointIndex, lineEntry, lineEntryIndex)`.
 * @property {geo.lineFeature.styleSpec} [style] Style object with default
 *   style options.
 */

/**
 * Style specification for a line feature.
 *
 * @typedef {geo.feature.styleSpec} geo.lineFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {geo.geoColor|Function} [strokeColor] Color to stroke each line.
 *   The color can vary by point.
 * @property {number|Function} [strokeOpacity] Opacity for each line stroke.
 *   The opacity can vary by point.  Opacity is on a [0-1] scale.
 * @property {number|Function} [strokeWidth] The weight of the line stroke in
 *   pixels.  The width can vary by point.
 * @property {number|Function} [strokeOffset] This is a value from -1 (left) to
 *   1 (right), with 0 being centered.  This can vary by point.
 * @property {string|Function} [lineCap='butt'] One of 'butt', 'square', or
 *   'round'.  This can vary by point.
 * @property {string|Function} [lineJoin='miter'] One of 'miter', 'bevel',
 *   'round', or 'miter-clip'.  This can vary by point.
 * @property {boolean|Function} [closed=false] If true and the renderer
 *   supports it, connect the first and last points of a line if the line has
 *   more than two points.  This applies per line (if a function, it is called
 *   with `(lineEntry, lineEntryIndex)`.
 * @property {number|Function} [miterLimit=10] For lines of more than two
 *   segments that are mitered, if the miter length exceeds the `strokeWidth`
 *   divided by the sine of half the angle between segments, then a bevel join
 *   is used instead.  This is a single value that applies to all lines.  If a
 *   function, it is called with `(data)`.
 * @property {boolean|string|Function} [uniformLine=false] Boolean indicating
 *   if each line has a uniform style (uniform stroke color, opacity, and
 *   width).  Can vary by line.  A value of `'drop'` will modify rendered
 *   vertex order by dropping duplicates and setting later values to zero
 *   opacity.  This can be faster but makes it so updating the style array
 *   can no longer be used.
 * @property {number|Function} [antialiasing] Antialiasing distance in pixels.
 *   Values must be non-negative.  A value greater than 1 will produce a
 *   visible gradient.  This is a single value that applies to all lines.
 * @property {string|Function} [debug] If 'debug', render lines in debug mode.
 *   This is a single value that applies to all lines.
 * @property {number[]|Function} [origin] Origin in map gcs coordinates used
 *   for to ensure high precision drawing in this location.  When called as a
 *   function, this is passed the vertex positions as a single continuous array
 *   in map gcs coordinates.  It defaults to the first line's first vertex's
 *   position.
 */

/**
 * Create a new instance of class lineFeature.
 *
 * @class
 * @alias geo.lineFeature
 * @extends geo.feature
 * @param {geo.lineFeature.spec} arg
 * @returns {geo.lineFeature}
 */
var _lineFeature = function lineFeature(arg) {
  'use strict';

  if (!(this instanceof _lineFeature)) {
    return new _lineFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init,
    m_pointSearchTime = timestamp(),
    m_pointSearchInfo;
  this.featureType = 'line';
  this._subfeatureStyles = {
    lineCap: true,
    lineJoin: true,
    strokeColor: true,
    strokeOffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };

  /**
   * Get/set line accessor.
   *
   * @param {object|Function} [val] If not specified, return the current line
   *    accessor.  If specified, use this for the line accessor and return
   *    `this`.  If a function is given, the function is passed `(dataElement,
   *    dataIndex)` and returns an array of vertex elements.
   * @returns {object|Function|this} The current line accessor or this feature.
   */
  this.line = function (val) {
    if (val === undefined) {
      return m_this.style('line');
    } else {
      m_this.style('line', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set position accessor.
   *
   * @param {geo.geoPosition|Function} [val] If not specified, return the
   *    current position accessor.  If specified, use this for the position
   *    accessor and return `this`.  If a function is given, this is called
   *    with `(vertexElement, vertexIndex, dataElement, dataIndex)`.
   * @returns {geo.geoPosition|Function|this} The current position or this
   *    feature.
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Cache information needed for point searches.  The point search
   * information record is an array with one entry per line, each entry of
   * which is an array with one entry per line segment.  These each contain
   * an object with the end coordinates (`u`, `v`) of the segment in map gcs
   * coordinates and the square of the maximum half-width that needs to be
   * considered for the line (`r2`).
   *
   * @returns {object} The point search information record.
   */
  this._updatePointSearchInfo = function () {
    if (m_pointSearchTime.timestamp() >= m_this.dataTime().timestamp() && m_pointSearchTime.timestamp() >= m_this.timestamp()) {
      return m_pointSearchInfo;
    }
    m_pointSearchTime.modified();
    m_pointSearchInfo = [];
    var data = m_this.data(),
      line = m_this.line(),
      widthFunc = m_this.style.get('strokeWidth'),
      widthVal = util.isFunction(m_this.style('strokeWidth')) ? undefined : widthFunc(),
      posFunc = m_this.position(),
      closedFunc = m_this.style.get('closed'),
      closedVal = util.isFunction(m_this.style('closed')) ? undefined : closedFunc(),
      uniformFunc = m_this.style.get('uniformLine'),
      uniformVal = util.isFunction(m_this.style('uniformLine')) ? undefined : uniformFunc(),
      gcs = m_this.gcs(),
      mapgcs = m_this.layer().map().gcs(),
      onlyInvertedY = transform.onlyInvertedY(gcs, mapgcs);
    for (var index = 0; index < data.length; index += 1) {
      var d = data[index];
      var closed = closedVal === undefined ? closedFunc(d, index) : closedVal;
      var last = void 0,
        lasti = void 0,
        lastr = void 0,
        lastr2 = void 0,
        first = void 0,
        min = void 0,
        max = void 0,
        width = void 0;
      var record = [];
      var uniform = uniformVal === undefined ? uniformFunc(d, index) : uniformVal;
      var lineRecord = line(d, index);
      for (var j = 0; j < lineRecord.length; j += 1) {
        var current = lineRecord[j];
        var p = posFunc(current, j, d, index);
        if (onlyInvertedY) {
          p = {
            x: p.x,
            y: -p.y
          };
        } else if (gcs !== mapgcs) {
          p = transform.transformCoordinates(gcs, mapgcs, p);
        }
        if (min === undefined) {
          min = {
            x: p.x,
            y: p.y
          };
        }
        if (max === undefined) {
          max = {
            x: p.x,
            y: p.y
          };
        }
        if (p.x < min.x) {
          min.x = p.x;
        }
        if (p.x > max.x) {
          max.x = p.x;
        }
        if (p.y < min.y) {
          min.y = p.y;
        }
        if (p.y > max.y) {
          max.y = p.y;
        }
        if (!uniform || !j) {
          width = widthVal === undefined ? widthFunc(current, j, d, index) : widthVal;
        }
        var r = Math.ceil(width / 2) + 2;
        if (max.r === undefined || r > max.r) {
          max.r = r;
        }
        var r2 = r * r;
        if (last) {
          record.push({
            u: p,
            v: last,
            r: lastr > r ? lastr : r,
            r2: lastr2 > r2 ? lastr2 : r2,
            i: j,
            j: lasti
          });
        }
        last = p;
        lasti = j;
        lastr = r;
        lastr2 = r2;
        if (!first && closed) {
          first = {
            p: p,
            r: r,
            r2: r2,
            i: j
          };
        }
      }
      if (closed && first && (last.x !== first.p.x || last.y !== first.p.y)) {
        record.push({
          u: last,
          v: first.p,
          r: lastr > first.r ? lastr : first.r,
          r2: lastr2 > first.r2 ? lastr2 : first.r2,
          i: lasti,
          j: first.i
        });
      }
      record.min = min;
      record.max = max;
      m_pointSearchInfo.push(record);
    }
    return m_pointSearchInfo;
  };

  /**
   * Returns an array of datum indices that contain the given point.  This is a
   * slow implementation with runtime order of the number of vertices.  A point
   * is considered on a line segment if it is close to the line or either end
   * point.  Closeness is based on the maximum width of the line segment, and
   * is `ceil(maxwidth / 2) + 2` pixels.  This means that corner extensions
   * due to mitering may be outside of the selection area and that variable-
   * width lines will have a greater selection region than their visual size at
   * the narrow end.
   *
   * @param {geo.geoPosition} p point to search for.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of line indices, `found`:
   *    a list of lines that contain the specified coordinate, and `extra`: an
   *    object with keys that are line indices and values that are the first
   *    segment index for which the line was matched.
   */
  this.pointSearch = function (p, gcs) {
    var data = m_this.data(),
      indices = [],
      found = [],
      extra = {};
    if (!data || !data.length || !m_this.layer()) {
      return {
        found: found,
        index: indices,
        extra: extra
      };
    }
    m_this._updatePointSearchInfo();
    var map = m_this.layer().map();
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    var scale = map.unitsPerPixel(map.zoom()),
      scale2 = scale * scale,
      pt = transform.transformCoordinates(gcs, map.gcs(), p),
      strokeWidthFunc = m_this.style.get('strokeWidth'),
      strokeOpacityFunc = m_this.style.get('strokeOpacity'),
      lineFunc = m_this.line(),
      line,
      i,
      j,
      record;
    for (i = 0; i < m_pointSearchInfo.length; i += 1) {
      record = m_pointSearchInfo[i];
      line = null;
      for (j = 0; j < record.length; j += 1) {
        if (util.distance2dToLineSquared(pt, record[j].u, record[j].v) <= record[j].r2 * scale2) {
          if (!line) {
            line = lineFunc(data[i], i);
          }
          if ((strokeOpacityFunc(line[record[j].i], record[j].i, data[i], i) > 0 || strokeOpacityFunc(line[record[j].j], record[j].j, data[i], i) > 0) && (strokeWidthFunc(line[record[j].i], record[j].i, data[i], i) > 0 || strokeWidthFunc(line[record[j].j], record[j].j, data[i], i) > 0)) {
            found.push(data[i]);
            indices.push(i);
            extra[i] = j;
            break;
          }
        }
      }
    }
    return {
      found: found,
      index: indices,
      extra: extra
    };
  };

  /**
   * Returns lines that are contained in the given polygon.
   *
   * @param {geo.polygonObject} poly A polygon as an array of coordinates or an
   *    object with `outer` and optionally `inner` parameters.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include lines that are
   *    partially in the polygon, otherwise only include lines that are fully
   *    within the region.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of line indices,
   *    `found`: a list of lines within the polygon, and `extra`: an object
   *    with index keys containing an object with a `segment` key with a value
   *    indicating one of the line segments that is inside the polygon and
   *    `partial` key and a boolean value to indicate if the line is on the
   *    polygon's border.
   */
  this.polygonSearch = function (poly, opts, gcs) {
    var data = m_this.data(),
      indices = [],
      found = [],
      extra = {},
      min,
      max,
      map = m_this.layer().map(),
      strokeWidthFunc = m_this.style.get('strokeWidth'),
      strokeOpacityFunc = m_this.style.get('strokeOpacity'),
      lineFunc = m_this.line();
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    if (!poly.outer) {
      poly = {
        outer: poly,
        inner: []
      };
    }
    if (!data || !data.length || poly.outer.length < 3) {
      return {
        found: found,
        index: indices,
        extra: extra
      };
    }
    opts = opts || {};
    opts.partial = opts.partial || false;
    poly = {
      outer: transform.transformCoordinates(gcs, map.gcs(), poly.outer),
      inner: (poly.inner || []).map(function (inner) {
        return transform.transformCoordinates(gcs, map.gcs(), inner);
      })
    };
    poly.outer.forEach(function (p) {
      if (!min) {
        min = {
          x: p.x,
          y: p.y
        };
        max = {
          x: p.x,
          y: p.y
        };
      }
      if (p.x < min.x) {
        min.x = p.x;
      }
      if (p.x > max.x) {
        max.x = p.x;
      }
      if (p.y < min.y) {
        min.y = p.y;
      }
      if (p.y > max.y) {
        max.y = p.y;
      }
    });
    m_this._updatePointSearchInfo();
    var scale = map.unitsPerPixel(map.zoom());
    var i, j, record, u, v, r;
    for (i = 0; i < m_pointSearchInfo.length; i += 1) {
      record = m_pointSearchInfo[i];
      if (!record.max || record.max.x < min.x - record.max.r * scale || record.min.x > max.x + record.max.r * scale || record.max.y < min.y - record.max.r * scale || record.min.y > max.y + record.max.r * scale) {
        continue;
      }
      var inside = void 0,
        partial = void 0,
        line = void 0;
      for (j = 0; j < record.length; j += 1) {
        u = record[j].u;
        v = record[j].v;
        r = record[j].r;
        if (u.x < min.x - r * scale && v.x < min.x - r * scale || u.x > max.x + r * scale && v.x > max.x + r * scale || u.y < min.y - r * scale && v.y < min.y - r * scale || u.y > max.y + r * scale && v.y > max.y + r * scale) {
          continue;
        }
        if (!line) {
          line = lineFunc(data[i], i);
        }
        if (strokeOpacityFunc(line[record[j].i], record[j].i, data[i], i) <= 0 && strokeOpacityFunc(line[record[j].j], record[j].j, data[i], i) <= 0 || strokeWidthFunc(line[record[j].i], record[j].i, data[i], i) <= 0 && strokeWidthFunc(line[record[j].j], record[j].j, data[i], i) <= 0) {
          continue;
        }
        var dist0 = util.distanceToPolygon2d(u, poly),
          dist1 = util.distanceToPolygon2d(v, poly);
        if (dist0 > -r * scale && dist0 < r * scale || dist1 > -r * scale && dist1 < r & scale || dist0 * dist1 < 0) {
          partial = true;
          break;
        }
        if (util.crossedLineSegmentPolygon2d(u, v, poly)) {
          partial = true;
          break;
        }
        // if a point of the polygon is near the line formed by u-v, this is
        // also partial
        var r2scaled = r * r * scale * scale;
        for (var k = 0; k < poly.outer.length && !partial; k += 1) {
          partial = util.distance2dToLineSquared(poly.outer[k], u, v) < r2scaled;
        }
        for (var _k = 0; _k < poly.inner.length && !partial; _k += 1) {
          for (var l = 0; l < poly.inner[_k].length && !partial; l += 1) {
            partial = util.distance2dToLineSquared(poly.inner[_k][l], u, v) < r2scaled;
          }
        }
        if (partial) {
          break;
        }
        // if this isn't partial and the distance to the polygon is positive,
        // it is inside
        if (dist0 > 0) {
          inside = true;
        }
      }
      if (!opts.partial && inside && !partial || opts.partial && (inside || partial)) {
        indices.push(i);
        found.push(data[i]);
        extra[i] = {
          partial: partial,
          segment: j < m_pointSearchInfo[i].length ? j : 0
        };
      }
    }
    return {
      found: found,
      index: indices,
      extra: extra
    };
  };

  /**
   * Take a set of data, reduce the number of vertices per line using the
   * RamerDouglasPeucker algorithm, and use the result as the new data.
   * This changes the instance's data, the position accessor, and the line
   * accessor.
   *
   * @param {array} data A new data array.
   * @param {number} [tolerance] The maximum variation allowed in map.gcs
   *    units.  A value of zero will only remove perfectly collinear points.
   *    If not specified, this is set to a half display pixel at the map's
   *    current zoom level.
   * @param {Function} [posFunc] The function to
   *    get the position of each vertex.
   * @param {Function} [lineFunc] The function to get
   *    each line.
   * @returns {this}
   */
  this.rdpSimplifyData = function (data, tolerance, posFunc, lineFunc) {
    data = data || m_this.data();
    posFunc = posFunc || m_this.style.get('position');
    lineFunc = lineFunc || m_this.style.get('line');
    var map = m_this.layer().map(),
      mapgcs = map.gcs(),
      featuregcs = m_this.gcs(),
      closedFunc = m_this.style.get('closed');
    if (tolerance === undefined) {
      tolerance = map.unitsPerPixel(map.zoom()) * 0.5;
    }

    /* transform the coordinates to the map gcs */
    data = data.map(function (d, idx) {
      var lineItem = lineFunc(d, idx),
        pts = transform.transformCoordinates(featuregcs, mapgcs, lineItem.map(function (ld, lidx) {
          return posFunc(ld, lidx, d, idx);
        })),
        elem = util.rdpLineSimplify(pts, tolerance, closedFunc(d, idx), []);
      if (elem.length < 2 || elem.length === 2 && util.distance2dSquared(elem[0], elem[1]) < tolerance * tolerance) {
        elem = [];
      }
      elem = transform.transformCoordinates(mapgcs, featuregcs, elem);
      /* Copy element properties, as they might be used by styles */
      for (var key in d) {
        if (d.hasOwnProperty(key) && !(Array.isArray(d) && key >= 0 && key < d.length)) {
          elem[key] = d[key];
        }
      }
      return elem;
    });

    /* Set the reduced lines as the data and use simple accessors. */
    m_this.style('position', util.identityFunction);
    m_this.style('line', util.identityFunction);
    m_this.data(data);
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.lineFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      strokeWidth: 1.0,
      // Default to gold color for lines
      strokeColor: {
        r: 1.0,
        g: 0.8431372549,
        b: 0.0
      },
      strokeStyle: 'solid',
      strokeOpacity: 1.0,
      // Values of 2 and above appear smoothest.
      antialiasing: 2.0,
      closed: false,
      line: util.identityFunction,
      position: function position(d) {
        return Array.isArray(d) ? {
          x: d[0],
          y: d[1],
          z: d[2] || 0
        } : d;
      },
      origin: function origin(p) {
        return p.length >= 3 ? p.slice(0, 3) : [0, 0, 0];
      }
    }, arg.style === undefined ? {} : arg.style);
    if (arg.line !== undefined) {
      defaultStyle.line = arg.line;
    }
    if (arg.position !== undefined) {
      defaultStyle.position = arg.position;
    }
    m_this.style(defaultStyle);
    m_this.dataTime().modified();
    return m_this;
  };
  this._init(arg);
  return this;
};

/**
 * Create a lineFeature.
 *
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to
 * @param {geo.lineFeature.spec} spec The feature specification
 * @returns {geo.lineFeature|null} The created feature or `null` for failure.
 */
_lineFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'line';
  return feature.create(layer, spec);
};
_lineFeature.capabilities = {
  /* core feature name -- support in any manner */
  feature: 'line',
  /* support for solid-colored, constant-width lines */
  basic: 'line.basic',
  /* support for lines that vary in width and color */
  multicolor: 'line.multicolor'
};
inherit(_lineFeature, feature);
module.exports = _lineFeature;

/***/ }),

/***/ 6211:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var sceneObject = __webpack_require__(5402);

/**
 * Map specification.
 *
 * @typedef {object} geo.map.spec
 * @property {string} node DOM selector for the map container.
 * @property {string|geo.transform} [gcs='EPSG:3857'] The main coordinate
 *   system of the map (this is often web Mercator).
 * @property {string|geo.transform} [ingcs='EPSG:4326'] The default coordinate
 *   system of interface calls (this is often latitude and longitude).
 * @property {number} [unitsPerPixel=156543] GCS to pixel unit scaling at zoom
 *   0 (i.e., meters per pixel or degrees per pixel).  The actual default is
 *   `maxBounds.right - maxBounds.left` converted to `gcs` and then divided by
 *   `256`.
 * @property {object} [maxBounds] The maximum visible map bounds.
 * @property {number} [maxBounds.left=-180] The left bound.
 * @property {number} [maxBounds.right=180] The right bound.
 * @property {number} [maxBounds.bottom=-85.06] The bottom bound.  The default
 *   is actually the `left` value transformed to the map's `gcs` coordinate
 *   system.
 * @property {number} [maxBounds.top=85.06] The top bound.  The default is
 *   actually the `right` value transformed to the map's `gcs` coordinate
 *   system.
 * @property {number} [maxBounds.gcs=ingcs] The coordinate system for the
 *   bounds.
 * @property {number} [zoom=4] Initial zoom.
 * @property {object} [center] Initial map center.
 * @property {number} [center.x=0] Initial map center.
 * @property {number} [center.y=0] Initial map center.
 * @property {number} [rotation=0] Initial clockwise rotation in radians.
 * @property {number} [width] The map width (default node width).
 * @property {number} [height] The map height (default node height).
 * @property {number} [min=0] Minimum zoom level (though fitting to the
 *   viewport may make it so this is smaller than the smallest possible value).
 * @property {number} [max=16] Maximum zoom level.
 * @property {boolean} [discreteZoom=false] If `true`, only allow integer zoom
 *   levels.  `false` for any zoom level.
 * @property {boolean|Function} [allowRotation=true] `false` prevents rotation,
 *   `true` allows any rotation.  If a function, the function is called with a
 *   rotation (angle in radians) and returns a valid rotation.  This can be
 *   used to constrain the rotation to a range or specific values.
 * @property {geo.camera} [camera] The camera to control the view.
 * @property {geo.mapInteractor} [interactor] The UI event handler.  If
 *   `undefined`, a default interactor is created and used.  If `null`, no
 *   interactor is attached to the map.
 * @property {array} [animationQueue] An array used to synchronize animations.
 *   If specified, this should be an empty array or the same array as passed to
 *   other map instances.
 * @property {boolean} [autoResize=true] Adjust map size on window resize.
 * @property {boolean} [clampBoundsX=false] Prevent panning outside of the
 *   maximum bounds in the horizontal direction.
 * @property {boolean} [clampBoundsY=true] Prevent panning outside of the
 *   maximum bounds in the vertical direction.
 * @property {boolean} [clampZoom=true] Prevent zooming out so that the map
 *   area is smaller than the window.
 * @property {boolean|string} [autoshareRenderer] If specified, pass this value
 *   to layers when they are created.  See
 *   {@link geo.layer.spec#autoshareRenderer} for valid values.
 */

/**
 * Specification used with `map.create`.
 *
 * @typedef {geo.map.spec} geo.map.createSpec
 * @extends geo.map.spec
 * @property {object[]} [data=[]] The default data array to apply to each
 *      feature if none exists.
 * @property {geo.layer.spec[]} [layers=[]] Layers to create.
 */

/**
 * Creates a new map object.
 *
 * @class
 * @alias geo.map
 * @extends geo.sceneObject
 *
 * @param {geo.map.spec} arg Map specification
 * @returns {geo.map}
 */
var _map2 = function map(arg) {
  'use strict';

  if (!(this instanceof _map2)) {
    return new _map2(arg);
  }
  arg = arg || {};
  if (arg.node === undefined || arg.node === null) {
    console.warn('map creation requires a node'); // eslint-disable-line no-console
    return this;
  }
  sceneObject.call(this, arg);
  var camera = __webpack_require__(3578);
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var registry = __webpack_require__(1098);
  var geo_event = __webpack_require__(6409);
  var mapInteractor = __webpack_require__(7908);
  var uiLayer = __webpack_require__(4231);

  /**
   * Private member variables
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    // See https://en.wikipedia.org/wiki/Web_Mercator
    // phiMax = 180 / Math.PI * (2 * Math.atan(Math.exp(Math.PI)) - Math.PI / 2),
    m_node = $(arg.node),
    m_width = arg.width || m_node.width() || 512,
    m_height = arg.height || m_node.height() || 512,
    m_gcs = arg.gcs === undefined ? 'EPSG:3857' : arg.gcs,
    m_ingcs = arg.ingcs === undefined ? 'EPSG:4326' : arg.ingcs,
    m_center = {
      x: 0,
      y: 0
    },
    m_zoom = arg.zoom === undefined ? 4 : arg.zoom,
    m_rotation = arg.rotation ? arg.rotation : 0,
    m_fileReader = null,
    m_interactor = null,
    m_validZoomRange = {
      min: 0,
      max: 16,
      origMin: 0
    },
    m_transition = null,
    m_queuedTransition = null,
    m_discreteZoom = arg.discreteZoom ? true : false,
    m_allowRotation = typeof arg.allowRotation === 'function' ? arg.allowRotation : arg.allowRotation === undefined ? true : !!arg.allowRotation,
    m_maxBounds = arg.maxBounds || {},
    m_camera = arg.camera || camera(),
    m_unitsPerPixel,
    m_clampBoundsX,
    m_clampBoundsY,
    m_clampZoom,
    m_animationQueue = arg.animationQueue || [],
    m_autoResize = arg.autoResize === undefined ? true : arg.autoResize,
    m_autoshareRenderer = arg.autoshareRenderer,
    m_origin;

  /* Compute the maximum bounds on our map projection.  By default, x ranges
   * from [-180, 180] in the interface projection, and y matches the x range in
   * the map (not the interface) projection.  For images, this might be
   * [0, width] and [0, height] instead. */
  var mcx = ((m_maxBounds.left || 0) + (m_maxBounds.right || 0)) / 2,
    mcy = ((m_maxBounds.bottom || 0) + (m_maxBounds.top || 0)) / 2;
  m_maxBounds.left = transform.transformCoordinates(m_maxBounds.gcs || m_ingcs, m_gcs, {
    x: m_maxBounds.left !== undefined ? m_maxBounds.left : -180,
    y: mcy
  }).x;
  m_maxBounds.right = transform.transformCoordinates(m_maxBounds.gcs || m_ingcs, m_gcs, {
    x: m_maxBounds.right !== undefined ? m_maxBounds.right : 180,
    y: mcy
  }).x;
  m_maxBounds.top = m_maxBounds.top !== undefined ? transform.transformCoordinates(m_maxBounds.gcs || m_ingcs, m_gcs, {
    x: mcx,
    y: m_maxBounds.top
  }).y : m_maxBounds.right;
  m_maxBounds.bottom = m_maxBounds.bottom !== undefined ? transform.transformCoordinates(m_maxBounds.gcs || m_ingcs, m_gcs, {
    x: mcx,
    y: m_maxBounds.bottom
  }).y : m_maxBounds.left;
  m_unitsPerPixel = arg.unitsPerPixel || (m_maxBounds.right - m_maxBounds.left) / 256;
  m_camera.viewport = {
    width: m_width,
    height: m_height,
    left: m_node.offset().left,
    top: m_node.offset().top
  };
  arg.center = util.normalizeCoordinates(arg.center);
  m_clampBoundsX = arg.clampBoundsX === undefined ? false : arg.clampBoundsX;
  m_clampBoundsY = arg.clampBoundsY === undefined ? true : arg.clampBoundsY;
  m_clampZoom = arg.clampZoom === undefined ? true : arg.clampZoom;

  /**
   * Get/set the number of world space units per display pixel at the given
   * zoom level.
   *
   * @param {number} [zoom] The target zoom level.
   * @param {number?} [unit] If present, set the `unitsPerPixel` at the
   *   specified zoom level.  Otherwise return the current value.
   * @returns {number|this}
   */
  this.unitsPerPixel = function (zoom, unit) {
    zoom = zoom || 0;
    if (unit) {
      // get the units at level 0
      m_unitsPerPixel = Math.pow(2, zoom) * unit;

      // redraw all the things
      m_this.draw();
      return m_this;
    }
    return Math.pow(2, -zoom) * m_unitsPerPixel;
  };

  /**
   * Get/set the animation queue.  Two maps can share a single animation queue
   * to ensure synchronized animations.  When setting, the animation queue will
   * merge values from the existing queue into the new queue.
   *
   * @param {array} [queue] The animation queue to use.
   * @returns {array|this} The current animation queue or the current map.
   */
  this.animationQueue = function (queue) {
    if (queue === undefined) {
      return m_animationQueue;
    }
    if (queue !== m_animationQueue) {
      if (m_animationQueue.length) {
        /* If the specified queue already has data in, don't copy the 0th
         * element of the existing queue, since the 0th element is always the
         * actual requestAnimationFrame reference.  In this case, cancel the
         * existing requestAnimationFrame.  By using a property of window,
         * tests can override this if needed. */
        if (queue.length && queue[0] !== m_animationQueue[0]) {
          window['cancelAnimationFrame'](m_animationQueue[0]);
        }
        for (var i = queue.length ? 1 : 0; i < m_animationQueue.length; i += 1) {
          queue.push(m_animationQueue[i]);
        }
      }
      m_animationQueue = queue;
    }
    return m_this;
  };

  /**
   * Get/set the autoResize flag.
   *
   * @param {boolean} [autoResize] Truthy to automatically resize the map when
   *    the size of the browser window changes.
   * @returns {boolean|this} The current state of autoResize or the current map.
   */
  this.autoResize = function (autoResize) {
    if (autoResize === undefined) {
      return m_autoResize;
    }
    if (autoResize !== m_autoResize) {
      $(window).off('resize', resizeSelf);
      m_autoResize = autoResize;
      if (m_autoResize) {
        $(window).on('resize', resizeSelf);
      }
    }
    return m_this;
  };

  /**
   * Get/set the `clampBoundsX` setting.  If changed, adjust the bounds of the
   * map as needed.
   *
   * @param {boolean} [clamp] The new clamp value.
   * @returns {boolean|this}
   */
  this.clampBoundsX = function (clamp) {
    if (clamp === undefined) {
      return m_clampBoundsX;
    }
    if (clamp !== m_clampBoundsX) {
      m_clampBoundsX = !!clamp;
      m_this.pan({
        x: 0,
        y: 0
      });
    }
    return m_this;
  };

  /**
   * Get/set the `clampBoundsY` setting.  If changed, adjust the bounds of the
   * map as needed.
   *
   * @param {boolean} [clamp] The new clamp value.
   * @returns {boolean|this}
   */
  this.clampBoundsY = function (clamp) {
    if (clamp === undefined) {
      return m_clampBoundsY;
    }
    if (clamp !== m_clampBoundsY) {
      m_clampBoundsY = !!clamp;
      m_this.pan({
        x: 0,
        y: 0
      });
    }
    return m_this;
  };

  /**
   * Get/set the `clampZoom` setting.  If changed, adjust the bounds of the map
   * as needed.
   *
   * @param {boolean} [clamp] The new clamp value.
   * @returns {boolean|this}
   */
  this.clampZoom = function (clamp) {
    if (clamp === undefined) {
      return m_clampZoom;
    }
    if (clamp !== m_clampZoom) {
      m_clampZoom = !!clamp;
      reset_minimum_zoom();
      m_this.zoom(m_zoom);
    }
    return m_this;
  };

  /**
   * Get/set the `allowRotation` setting.  If changed, adjust the map as
   * needed.
   *
   * @param {boolean|Function} [allowRotation] The new `allowRotation` value.
   *    `false` prevents rotation, `true` allows any rotation.  If a function,
   *    the function is called with a rotation (angle in radians) and returns a
   *    valid rotation (this can be used to constrain the rotation to a range
   *    or to specific values).
   * @returns {boolean|Function|this}
   */
  this.allowRotation = function (allowRotation) {
    if (allowRotation === undefined) {
      return m_allowRotation;
    }
    if (typeof allowRotation !== 'function') {
      allowRotation = !!allowRotation;
    }
    if (allowRotation !== m_allowRotation) {
      m_allowRotation = allowRotation;
      m_this.rotation(m_rotation);
    }
    return m_this;
  };

  /**
   * Get the map's world coordinate origin in gcs coordinates.
   *
   * @returns {geo.geoPosition}
   */
  this.origin = function () {
    return Object.assign({}, m_origin);
  };

  /**
   * Get the camera.
   *
   * @returns {geo.camera}
   */
  this.camera = function () {
    return m_camera;
  };

  /**
   * Get or set the map gcs.  This is the coordinate system used in drawing the
   * map.
   *
   * @param {string} [arg] If `undefined`, return the current gcs.  Otherwise,
   *    a new value for the gcs.
   * @returns {string|this} A string used by {@link geo.transform}.
   */
  this.gcs = function (arg) {
    if (arg === undefined) {
      return m_gcs;
    }
    if (arg !== m_gcs) {
      var oldCenter = m_this.center(undefined, undefined);
      m_gcs = arg;
      reset_minimum_zoom();
      var newZoom = m_this._fix_zoom(m_zoom);
      if (newZoom !== m_zoom) {
        m_this.zoom(newZoom);
      }
      m_this.center(oldCenter, undefined);
    }
    return m_this;
  };

  /**
   * Get or set the map interface gcs.  This is the coordinate system used when
   * getting or setting map bounds, center, and other values.
   *
   * @param {string} [arg] If `undefined`, returtn the current interface gcs.
   *    Otherwise, a new value for the interface gcs.
   * @returns {string|this} A string used by {@link geo.transform}.
   */
  this.ingcs = function (arg) {
    if (arg === undefined) {
      return m_ingcs;
    }
    m_ingcs = arg;
    return m_this;
  };

  /**
   * Get root DOM node of the map.
   *
   * @returns {object}
   */
  this.node = function () {
    return m_node;
  };

  /**
   * Get/Set zoom level of the map.
   *
   * @param {number} [val] If `undefined`, return the current zoom level.
   *    Otherwise, the new zoom level to set.
   * @param {object} [origin] If present, specifies the center of the zoom;
   *    otherwise the map's display center is used.
   * @param {geo.geoPosition} origin.geo The gcs coordinates of the zoom
   *    center.
   * @param {geo.screenPosition} origin.map The display coordinates of the zoom
   *    center.
   * @param {boolean} [ignoreDiscreteZoom] If `true`, ignore the discreteZoom
   *    option when determining the new view.
   * @param {boolean} [ignoreClampBounds] If `true`, ignore the clampBounds
   *    option when determining the new view.
   * @param {boolean} [noTrigger] If truthy, do not trigger a pan or zoom
   *    event.  If 'pan', only trigger the zoom event.
   * @returns {number|this}
   * @fires geo.event.zoom
   * @fires geo.event.pan
   */
  this.zoom = function (val, origin, ignoreDiscreteZoom, ignoreClampBounds, noTrigger) {
    if (val === undefined) {
      return m_zoom;
    }
    var evt, bounds;
    /* If we are zooming around a point, ignore the clamp bounds */
    var aroundPoint = origin && (origin.mapgcs || origin.geo) && origin.map;
    if (aroundPoint) {
      ignoreClampBounds = true;
    }

    /* The ignoreDiscreteZoom flag is intended to allow non-integer zoom values
     * during animation. */
    val = m_this._fix_zoom(val, ignoreDiscreteZoom);
    if (val === m_zoom) {
      return m_this;
    }
    m_zoom = val;
    bounds = m_this.boundsFromZoomAndCenter(val, m_center, m_rotation, null, ignoreDiscreteZoom, ignoreClampBounds);
    m_this.modified();
    camera_bounds(bounds, m_rotation);
    evt = {
      zoomLevel: m_zoom,
      screenPosition: origin ? origin.map : undefined
    };
    if (!noTrigger || noTrigger === 'pan') {
      m_this.geoTrigger(geo_event.zoom, evt);
    }
    if (aroundPoint) {
      var shifted = m_this.gcsToDisplay(origin.mapgcs || origin.geo, origin.mapgcs ? null : undefined);
      m_this.pan({
        x: origin.map.x - shifted.x,
        y: origin.map.y - shifted.y
      }, ignoreDiscreteZoom, true, noTrigger);
    } else {
      m_this.pan({
        x: 0,
        y: 0
      }, ignoreDiscreteZoom, ignoreClampBounds, noTrigger);
    }
    return m_this;
  };

  /**
   * Set zoom level and center of the map.
   *
   * @param {number} zoom The new zoom level to set.
   * @param {geo.geoPosition} center The new center of the
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.  The center is
   *    converted from this gcs to the map projection.
   * @param {geo.geoPosition} origin.geo The gcs coordinates of the zoom
   *    center.
   * @param {geo.screenPosition} origin.map The display coordinates of the zoom
   *    center.
   * @param {boolean} [ignoreDiscreteZoom] If `true`, ignore the discreteZoom
   *    option when determining the new view.
   * @param {boolean} [ignoreClampBounds] If `true`, ignore the clampBounds
   *    option when determining the new view.
   * @param {boolean} [noTrigger] If truthy, do not trigger a pan or zoom
   *    event.
   * @returns {this}
   * @fires geo.event.zoom
   * @fires geo.event.pan
   */
  this.zoomAndCenter = function (zoom, center, gcs, ignoreDiscreteZoom, ignoreClampBounds, noTrigger) {
    this.zoom(zoom, undefined, ignoreDiscreteZoom, ignoreClampBounds, noTrigger || 'pan');
    this.center(center, gcs, ignoreDiscreteZoom, ignoreClampBounds, noTrigger);
    return this;
  };

  /**
   * Pan the map by a number of display pixels.
   *
   * @param {object} delta Amount to pan in display pixels.
   * @param {number} delta.x Horizontal distance on the display.
   * @param {number} delta.y Vertical distance on the display.
   * @param {boolean} [ignoreDiscreteZoom] If `true`, ignore the `discreteZoom`
   *    option when determining the new view.
   * @param {boolean|'limited'} [ignoreClampBounds] If `true` ignore the
   *    `clampBoundsX` and `clampBoundsY` options when determining the new
   *    view.  When `'limited'`, the `clampBoundsX` and `clampBoundsY` options
   *    are selectively enforced so that the map will not end up more out of
   *    bounds than its current state.
   * @param {boolean} [noTrigger] If truthy, do not trigger a pan event.
   * @returns {this}
   * @fires geo.event.pan
   */
  this.pan = function (delta, ignoreDiscreteZoom, ignoreClampBounds, noTrigger) {
    var evt = {
      screenDelta: delta
    };
    if (delta.x || delta.y) {
      var unit = m_this.unitsPerPixel(m_zoom);
      var sinr = Math.sin(m_rotation),
        cosr = Math.cos(m_rotation);
      m_camera.pan({
        x: (delta.x * cosr - -delta.y * sinr) * unit,
        y: (delta.x * sinr + -delta.y * cosr) * unit
      });
    }
    /* If m_clampBoundsX or m_clampBoundsY is true, clamp the pan */
    var bounds = m_camera.bounds;
    bounds = fix_bounds(bounds, m_rotation, ignoreClampBounds === 'limited' ? {
      x: delta.x,
      y: delta.y,
      unit: unit
    } : undefined, ignoreClampBounds === true);
    if (bounds !== m_camera.bounds) {
      var panPos = m_this.gcsToDisplay({
        x: m_camera.bounds.left,
        y: m_camera.bounds.top
      }, null);
      bounds = m_this.boundsFromZoomAndCenter(m_zoom, {
        x: (bounds.left + bounds.right) / 2,
        y: (bounds.top + bounds.bottom) / 2
      }, m_rotation, null, ignoreDiscreteZoom, true);
      camera_bounds(bounds, m_rotation);
      var clampPos = m_this.gcsToDisplay({
        x: m_camera.bounds.left,
        y: m_camera.bounds.top
      }, null);
      evt.screenDelta.x += clampPos.x - panPos.x;
      evt.screenDelta.y += clampPos.y - panPos.y;
    }
    m_center = m_camera.displayToWorld({
      x: m_width / 2,
      y: m_height / 2
    });
    if (!noTrigger) {
      m_this.geoTrigger(geo_event.pan, evt);
    }
    m_this.modified();
    return m_this;
  };

  /**
   * Get/set the map rotation.  The rotation is performed around the current
   * view center.  Rotation mostly ignores `clampBoundsX`, as the behavior
   * feels peculiar otherwise.
   *
   * @param {number} [rotation] Absolute angle in radians (positive is
   *    clockwise).
   * @param {object} [origin] If specified, rotate about this origin.
   * @param {geo.geoPosition} origin.geo The gcs coordinates of the
   *    rotation center.
   * @param {geo.screenPosition} origin.map The display coordinates of the
   *    rotation center.
   * @param {boolean} [ignoreRotationFunc] If `true`, don't constrain the
   *    rotation.
   * @returns {number|this}
   * @fires geo.event.rotate
   * @fires geo.event.pan
   */
  this.rotation = function (rotation, origin, ignoreRotationFunc) {
    if (rotation === undefined) {
      return m_rotation;
    }
    var aroundPoint = origin && origin.geo && origin.map;
    rotation = fix_rotation(rotation, ignoreRotationFunc);
    if (rotation === m_rotation) {
      return m_this;
    }
    m_rotation = rotation;
    var bounds = m_this.boundsFromZoomAndCenter(m_zoom, m_center, m_rotation, null, ignoreRotationFunc, true);
    m_this.modified();
    camera_bounds(bounds, m_rotation);
    var evt = {
      rotation: m_rotation,
      screenPosition: origin ? origin.map : undefined
    };
    m_this.geoTrigger(geo_event.rotate, evt);
    if (aroundPoint) {
      var shifted = m_this.gcsToDisplay(origin.geo);
      m_this.pan({
        x: origin.map.x - shifted.x,
        y: origin.map.y - shifted.y
      }, undefined, true);
    } else {
      m_this.pan({
        x: 0,
        y: 0
      }, undefined, true);
    }
    /* Changing the rotation can change our minimum zoom */
    reset_minimum_zoom();
    m_this.zoom(m_zoom, undefined, ignoreRotationFunc);
    return m_this;
  };

  /**
   * Get or set the center of the map in the given geographic coordinates.
   *
   * @param {geo.geoPosition} [coordinates] If specified, the new center of the
   *    map.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.  If setting the
   *    center, it is converted from this gcs to the map projection.  The
   *    returned center is converted from the map projection to this gcs.
   * @param {boolean} [ignoreDiscreteZoom] If `true`, ignore the `discreteZoom`
   *    option when determining the new view.
   * @param {boolean|'limited'} [ignoreClampBounds] If `true` ignore the
   *    `clampBoundsX` and `clampBoundsY` options when determining the new
   *    view.  When `'limited'`, the `clampBoundsX` and `clampBoundsY` options
   *    are selectively enforced so that the map will not end up more out of
   *    bounds than its current state.
   * @param {boolean} [noTrigger] If truthy, do not trigger a pan event.
   * @returns {geo.geoPosition|this}
   * @fires geo.event.pan
   */
  this.center = function (coordinates, gcs, ignoreDiscreteZoom, ignoreClampBounds, noTrigger) {
    var center;
    if (coordinates === undefined) {
      center = Object.assign({}, m_this.worldToGcs(m_center, gcs));
      return center;
    }

    // get the screen coordinates of the new center
    center = m_this.gcsToWorld(coordinates, gcs);
    camera_bounds(m_this.boundsFromZoomAndCenter(m_zoom, center, m_rotation, null, ignoreDiscreteZoom, ignoreClampBounds), m_rotation);
    m_this.modified();
    // trigger a pan event
    if (!noTrigger) {
      m_this.geoTrigger(geo_event.pan, {
        screenDelta: {
          x: 0,
          y: 0
        }
      });
    }
    return m_this;
  };

  /**
   * Add a layer to the map.
   *
   * @param {string} layerName The type of layer to add to the map.
   * @param {object} arg Parameters for the new layer.
   * @returns {geo.layer}
   * @fires geo.event.layerAdd
   */
  this.createLayer = function (layerName, arg) {
    arg = arg || {};
    if (m_this.autoshareRenderer() !== undefined) {
      arg = Object.assign({
        autoshareRenderer: m_this.autoshareRenderer()
      }, arg);
    }
    var newLayer = registry.createLayer(layerName, m_this, arg);
    if (newLayer) {
      m_this.addChild(newLayer);
      m_this.children().forEach(function (c) {
        if (c instanceof uiLayer) {
          c.moveToTop();
        }
      });
      newLayer._update();
      m_this.modified();
      m_this.geoTrigger(geo_event.layerAdd, {
        target: m_this,
        layer: newLayer
      });
    }
    return newLayer;
  };

  /**
   * Remove a layer from the map.
   *
   * @param {geo.layer?} layer Layer to remove from the map.
   * @returns {geo.layer}
   * @fires geo.event.layerRemove
   */
  this.deleteLayer = function (layer) {
    if (layer !== null && layer !== undefined) {
      layer._exit();
      m_this.removeChild(layer);
      m_this.modified();
      m_this.geoTrigger(geo_event.layerRemove, {
        target: m_this,
        layer: layer
      });
    }

    // Return deleted layer (similar to createLayer) as in the future
    // we may provide extension of this method to support deletion of
    // layer using id or some sort.
    return layer;
  };

  /**
   * Get or set the size of the map.
   *
   * @param {geo.screenSize} [arg] Size in pixels.
   * @returns {geo.screenSize|this} The size in pixels or the map object.
   * @fires geo.event.resize
   */
  this.size = function (arg) {
    if (arg === undefined) {
      return {
        width: m_width,
        height: m_height
      };
    }
    // store the original center and restore it after the resize
    var oldCenter = m_this.center();
    m_width = arg.width || m_width;
    m_height = arg.height || m_height;
    reset_minimum_zoom();
    var newZoom = m_this._fix_zoom(m_zoom);
    if (newZoom !== m_zoom) {
      m_this.zoom(newZoom);
    }
    m_this.camera().viewport = {
      width: m_width,
      height: m_height,
      left: m_node.offset().left,
      top: m_node.offset().top
    };
    m_this.center(oldCenter);
    m_this.geoTrigger(geo_event.resize, {
      target: m_this,
      width: m_width,
      height: m_height
    });
    m_this.modified();
    return m_this;
  };

  /**
   * Get the rotated size of the map.  This is the width and height of the
   * non-rotated area necessary to enclose the rotated area in pixels.
   *
   * @returns {geo.screenSize} The size that fits the rotated map.
   */
  this.rotatedSize = function () {
    if (!this.rotation()) {
      return {
        width: m_width,
        height: m_height
      };
    }
    var bds = rotate_bounds_center({
      x: 0,
      y: 0
    }, {
      width: m_width,
      height: m_height
    }, m_this.rotation());
    return {
      width: Math.abs(bds.right - bds.left),
      height: Math.abs(bds.top - bds.bottom)
    };
  };

  /**
   * Convert from gcs coordinates to map world coordinates.
   *
   * @param {geo.geoPosition|geo.geoPosition[]} c The input coordinate to
   *    convert.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.worldPosition|geo.worldPosition[]} World space coordinates.
   */
  this.gcsToWorld = function (c, gcs) {
    if (Array.isArray(c)) {
      return c.map(function (pt) {
        return m_this.gcsToWorld(pt, gcs);
      });
    }
    gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
    if (gcs !== m_gcs) {
      c = transform.transformCoordinates(gcs, m_gcs, c);
    }
    if (m_origin.x || m_origin.y || m_origin.z) {
      c = transform.affineForward({
        origin: m_origin
      }, [c])[0];
    } else if (!('z' in c)) {
      c = {
        x: c.x,
        y: c.y,
        z: 0
      };
    }
    return c;
  };

  /**
   * Convert from map world coordinates to gcs coordinates.
   *
   * @param {geo.worldPosition|geo.worldPosition[]} c The input coordinate to
   *    convert.
   * @param {string|geo.transform|null} [gcs] output gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.geoPosition|geo.geoPosition[]} GCS space coordinates.
   */
  this.worldToGcs = function (c, gcs) {
    if (Array.isArray(c)) {
      return c.map(function (pt) {
        return m_this.worldToGcs(pt, gcs);
      });
    }
    if (m_origin.x || m_origin.y || m_origin.z) {
      c = transform.affineInverse({
        origin: m_origin
      }, [c])[0];
    } else if (!('z' in c)) {
      c = {
        x: c.x,
        y: c.y,
        z: 0
      };
    }
    gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
    if (gcs !== m_gcs) {
      c = transform.transformCoordinates(m_gcs, gcs, c);
    }
    return c;
  };

  /**
   * Convert from gcs coordinates to display coordinates.  This is identical to
   * calling `gcsToWorld` and then `worldToDisplay`.
   *
   * @param {geo.geoPosition|geo.geoPosition[]} c The input coordinate to
   *    convert.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.screenPosition|geo.screenPosition[]} Display space
   *    coordinates.
   */
  this.gcsToDisplay = function (c, gcs) {
    c = m_this.gcsToWorld(c, gcs);
    return m_this.worldToDisplay(c);
  };

  /**
   * Convert from world coordinates to display coordinates using the attached
   * camera.
   *
   * @param {geo.worldPosition|geo.worldPosition[]} c The input coordinate to
   *    convert.
   * @returns {geo.screenPosition|geo.screenPosition[]} Display space
   *    coordinates.
   */
  this.worldToDisplay = function (c) {
    if (Array.isArray(c)) {
      return c.map(function (pt) {
        return m_camera.worldToDisplay(pt);
      });
    }
    return m_camera.worldToDisplay(c);
  };

  /**
   * Convert from display to gcs coordinates.  This is identical to calling
   * `displayToWorld` and then `worldToGcs`.
   *
   * @param {geo.screenPosition|geo.screenPosition[]} c The input display
   *    coordinate to convert.
   * @param {string|geo.transform|null} [gcs] Output gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.geoPosition|geo.geoPosition[]} GCS space coordinates.
   */
  this.displayToGcs = function (c, gcs) {
    c = m_this.displayToWorld(c); // done via camera
    return m_this.worldToGcs(c, gcs);
  };

  /**
   * Convert from display coordinates to world coordinates using the attached
   * camera.
   *
   * @param {geo.screenPosition|geo.screenPosition[]} c The input coordinate to
   *    convert.
   * @returns {geo.worldPosition|geo.worldPosition[]} World space coordinates.
   */
  this.displayToWorld = function (c) {
    if (Array.isArray(c)) {
      return c.map(function (pt) {
        return m_camera.displayToWorld(pt);
      });
    }
    return m_camera.displayToWorld(c);
  };

  /**
   * Redraw the map and all its layers.
   *
   * @returns {this} The map object.
   * @fires geo.event.draw
   * @fires geo.event.drawEnd
   */
  this.draw = function () {
    var i,
      layers = m_this.children();
    m_this.geoTrigger(geo_event.draw, {
      target: m_this
    });
    m_this._update();
    for (i = 0; i < layers.length; i += 1) {
      layers[i].draw();
    }
    m_this.geoTrigger(geo_event.drawEnd, {
      target: m_this
    });
    return m_this;
  };

  /**
   * Get, set, or create and set a file reader to a layer in the map to be used
   * as a drop target.
   *
   * @param {string|object} [readerOrName] `undefined` to get the current
   *    reader, an instance of a file reader to set the reader, or a name to
   *    create a file reader.
   * @param {object} [opts] options Parameters for creating a file reader when
   *    the reader is specified by name.  If this includes `layer`, use that
   *    layer, otherwise create a layer using these options.
   * @returns {geo.fileReader|this}
   */
  this.fileReader = function (readerOrName, opts) {
    if (readerOrName === undefined) {
      return m_fileReader;
    }
    if (typeof readerOrName === 'string') {
      opts = opts || {};
      if (!opts.layer) {
        opts.layer = m_this.createLayer('feature', Object.assign({}, opts));
      }
      opts.renderer = opts.layer.renderer().api();
      m_fileReader = registry.createFileReader(readerOrName, opts);
    } else {
      m_fileReader = readerOrName;
    }
    return m_this;
  };

  /**
   * Trigger an event when the browser is hidden or unhidden.
   *
   * See {@link geo.map.trackBrowserHidden}.
   */
  function handleBrowserHidden() {
    var hidden;
    if (typeof document.hidden !== 'undefined') {
      // Opera 12.10 and Firefox 18 and later support
      hidden = 'hidden';
    } else if (typeof document.msHidden !== 'undefined') {
      hidden = 'msHidden';
    } else if (typeof document.webkitHidden !== 'undefined') {
      hidden = 'webkitHidden';
    }
    m_this.geoTrigger(document[hidden] ? geo_event.hidden : geo_event.unhidden);
  }

  /**
   * Track when the browser tab is hidden or unhidden.
   *
   * Based on
   * https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API
   * as accessed on 2019-10-24.
   *
   * @param {boolean} [enable] If `false`, remove the event listener.
   */
  function trackBrowserHidden(enable) {
    var visibilityChange;
    if (typeof document.hidden !== 'undefined') {
      // Opera 12.10 and Firefox 18 and later support
      visibilityChange = 'visibilitychange';
    } else if (typeof document.msHidden !== 'undefined') {
      visibilityChange = 'msvisibilitychange';
    } else if (typeof document.webkitHidden !== 'undefined') {
      visibilityChange = 'webkitvisibilitychange';
    }
    document.removeEventListener(visibilityChange, handleBrowserHidden);
    if (enable !== false) {
      document.addEventListener(visibilityChange, handleBrowserHidden);
    }
  }

  /**
   * Initialize the map.
   *
   * @param {object} [arg] Optional arguments.
   * @returns {this} The map object.
   */
  this._init = function (arg) {
    if (m_node === undefined || m_node === null) {
      throw new Error('Map require DIV node');
    }
    if (m_node.data('data-geojs-map') && $.isFunction(m_node.data('data-geojs-map').exit)) {
      m_node.data('data-geojs-map').exit();
    }
    m_node.addClass('geojs-map');
    m_node.data('data-geojs-map', m_this);
    trackBrowserHidden();
    return m_this;
  };

  /**
   * Update map.  This updates all layers of the map.
   *
   * @param {object} [request] Optional information about the source of this
   *    update request.  This could be an event, for instance.  It is passed
   *    to individual layer's `_update` function.
   * @returns {this} The map object.
   */
  this._update = function (request) {
    var i,
      layers = m_this.children();
    for (i = 0; i < layers.length; i += 1) {
      layers[i]._update(request);
    }
    return m_this;
  };

  /**
   * Exit this map.  This removes all layers, destroys current interactor, and
   * empties the associated DOM node.
   */
  this.exit = function () {
    trackBrowserHidden(false);
    var i,
      layers = m_this.children();
    for (i = layers.length - 1; i >= 0; i -= 1) {
      layers[i]._exit();
      m_this.removeChild(layers[i]);
    }
    if (m_this.interactor()) {
      m_this.interactor().destroy();
      m_this.interactor(null);
    }
    // if the animation queue was shared, this clears it
    m_animationQueue = [];
    m_this.node().data('data-geojs-map', null);
    m_this.node().off('.geo');
    /* make sure the map node has nothing left in it */
    m_this.node().empty();
    $(window).off('resize', resizeSelf);
    s_exit();
  };

  /**
   * Get or set the map interactor.
   *
   * @param {geo.mapInteractor} [arg] If specified, the map interactor to set.
   * @returns {geo.mapInteractor|this} The current map interactor or the map
   *    object.
   */
  this.interactor = function (arg) {
    if (arg === undefined) {
      return m_interactor;
    }
    if (m_interactor && m_interactor !== arg) {
      m_interactor.destroy();
    }
    m_interactor = arg;

    // this makes it possible to set a null interactor
    // i.e. map.interactor(null);
    if (m_interactor) {
      /* If we set a map interactor, make sure we have a tabindex */
      if (!m_node.attr('tabindex')) {
        m_node.attr('tabindex', 0);
      }
      m_interactor.map(m_this);
    }
    return m_this;
  };

  /**
   * Get or set the min/max zoom range.
   *
   * @param {object} [arg] The zoom range.
   * @param {number} [arg.min] The minimum zoom level.
   * @param {number} [arg.max] The maximum zoom level.
   * @param {boolean} [noRefresh] If `true`, don't update the map if the zoom
   *    level has changed.
   * @returns {object|this} The current zoom range or the map object.  The
   *    `min` value is the minimum value that the map can go to based on the
   *    current dimensions and settings, the `origMin` value is the value that
   *    was specified via this function or when the map was created.
   */
  this.zoomRange = function (arg, noRefresh) {
    if (arg === undefined) {
      return Object.assign({}, m_validZoomRange);
    }
    if (arg.max !== undefined) {
      m_validZoomRange.max = arg.max;
    }
    if (arg.min !== undefined) {
      m_validZoomRange.min = m_validZoomRange.origMin = arg.min;
    }
    reset_minimum_zoom();
    if (!noRefresh) {
      m_this.zoom(m_zoom);
    }
    return m_this;
  };

  /**
   * Get the current transition or start an animated zoom/pan/rotate.  If a
   * second transition is requested while a transition is already in progress,
   * a new transition is created that is functionally from wherever the map has
   * moved to (possibly partway through the first transition) going to the end
   * point of the new transition.
   *
   * @param {object} [opts] Options for a transition, or `undefined` to get the
   *    current transition.
   * @param {geo.geoPosition} [opts.center] A new map center.
   * @param {number} [opts.zoom] A new map zoom level.
   * @param {geo.geoPosition} [opts.zoomOrigin] An origin to use when zooming
   *    to a new zoom level.
   * @param {number} [opts.rotation] A new map rotation.
   * @param {number} [opts.duration] Transition duration in milliseconds.
   * @param {Function} [opts.ease] Easing function for the transition.  This is
   *    in the style of a d3 easing function.
   * @param {Function} [opts.interp] Function to use when interpolating
   *    between values.  This gets passed two arrays, the start and end values
   *    for [`x`, `y`, `z` or `zoom`, `rotation`], and returns a function that,
   *    when passed a time value returns an array of the interpolated [`x`,
   *    `y`, `z` or `zoom`, `rotation`] values.
   * @param {boolean} [opts.zCoord] If `true`, convert zoom values to z values
   *    for interpolation.
   * @param {Function} [opts.done] If specified, call this function when a
   *    transition completes.  The function is called with an object that
   *    contains `cancel`: a boolean if the transition was canceled, `source`:
   *    a value based on what canceled a transition, `transition`: the current
   *    transition that just completed, `next`: a boolean if another transition
   *    follows immediately.
   * @param {boolean} [opts.endClamp] If `false`, the last center change
   *    will not clamp to the bounds and zoom values.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   *    Applies only to `opts.center` and to converting zoom values to height,
   *    if specified.
   * @param {number} [animTime] The animation frame time (from a
   *    `window.requestAnimationFrame` callback).  Used if a new transition is
   *    requested because the current transition has completed to keep things
   *    synchronized.
   * @returns {geo.map}
   * @fires geo.event.transitionstart
   * @fires geo.event.transitionend
   * @fires geo.event.transitioncancel
   */
  this.transition = function (opts, gcs, animTime) {
    if (opts === undefined) {
      return m_transition;
    }
    if (m_transition) {
      /* The queued transition needs to combine the current transition's
       * endpoint, any other queued transition, and the new transition to be
       * complete. */
      var transitionEnd = util.deepMerge({}, m_transition.end);
      if (transitionEnd.center && m_gcs !== m_ingcs) {
        transitionEnd.center = transform.transformCoordinates(m_gcs, m_ingcs, transitionEnd.center);
      }
      m_queuedTransition = Object.assign({}, transitionEnd || {}, m_queuedTransition || {}, opts);
      return m_this;
    }

    /* Basic linear interpolation between two values. */
    function interp1(p0, p1, t) {
      return p0 + (p1 - p0) * t;
    }
    /**
     * Generate an interpolation function that interpolates all array entries.
     *
     * @param {array} p0 An array of numbers to interpolate from.
     * @param {array} p1 An array of numbers to interpolate to.
     * @returns {Function} A function that, given `t`, returns an array of
     *      interpolated values.
     * @private
     */
    function defaultInterp(p0, p1) {
      return function (t) {
        var result = [];
        $.each(p0, function (idx) {
          result.push(interp1(p0[idx], p1[idx], t));
        });
        return result;
      };
    }
    var units = m_this.unitsPerPixel(0);

    // Transform zoom level into z-coordinate and inverse.
    function zoom2z(z) {
      return Math.pow(2, -(z + 1)) * units * m_height;
    }
    function z2zoom(z) {
      return -Math.log2(z / units / m_height) - 1;
    }
    var defaultOpts = {
      center: undefined,
      zoom: m_this.zoom(),
      rotation: m_this.rotation(),
      duration: 1000,
      ease: function ease(t) {
        return t;
      },
      interp: defaultInterp,
      done: null,
      zCoord: true
    };
    if (opts.center) {
      gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
      opts = util.deepMerge({}, opts);
      opts.center = util.normalizeCoordinates(opts.center);
      if (gcs !== m_gcs) {
        opts.center = transform.transformCoordinates(gcs, m_gcs, opts.center);
      }
    }
    opts = util.deepMerge({}, defaultOpts, opts);
    m_transition = {
      start: {
        center: m_this.center(undefined, null),
        zoom: m_this.zoom(),
        rotation: m_this.rotation()
      },
      end: {
        center: opts.center,
        zoom: m_this._fix_zoom(opts.zoom),
        rotation: fix_rotation(opts.rotation, undefined, true)
      },
      ease: opts.ease,
      zCoord: opts.zCoord,
      done: opts.done,
      duration: opts.duration,
      zoomOrigin: opts.zoomOrigin,
      endClamp: opts.endClamp
    };
    m_transition.interp = opts.interp([m_transition.start.center.x, m_transition.start.center.y, opts.zCoord ? zoom2z(m_transition.start.zoom) : m_transition.start.zoom, m_transition.start.rotation], [m_transition.end.center ? m_transition.end.center.x : m_transition.start.center.x, m_transition.end.center ? m_transition.end.center.y : m_transition.start.center.y, opts.zCoord ? zoom2z(m_transition.end.zoom) : m_transition.end.zoom, m_transition.end.rotation]);

    /**
     * Process an animation from during a transition.
     *
     * @param {number} time The animation frame time.  Used to ensure multiple
     *      transitions are smooth.
     * @private
     */
    function anim(time) {
      var done = m_transition.done,
        next = m_queuedTransition;
      if (m_transition.cancel === true) {
        /* Finish cancelling a transition. */
        m_this.geoTrigger(geo_event.transitioncancel, opts);
        if (done) {
          done({
            cancel: true,
            source: m_transition.cancelSource,
            transition: m_transition
          });
        }
        m_transition = null;
        /* There will only be a queuedTransition if it was created after this
         * transition was cancelled */
        if (m_queuedTransition) {
          next = m_queuedTransition;
          m_queuedTransition = null;
          m_this.transition(next, undefined, time);
        }
        return;
      }
      if (!m_transition.start.time) {
        m_transition.start.time = time;
        m_transition.end.time = time + opts.duration;
      }
      m_transition.time = time - m_transition.start.time;
      if (time >= m_transition.end.time || next) {
        if (!next) {
          if (m_transition.end.center) {
            var needZoom = m_zoom !== m_this._fix_zoom(m_transition.end.zoom);
            var noEndClamp = needZoom || opts.endClamp === false;
            m_this.center(m_transition.end.center, null, noEndClamp, noEndClamp);
          }
          m_this.zoom(m_transition.end.zoom, m_transition.zoomOrigin, opts.endClamp === false, opts.endClamp === false);
          m_this.rotation(fix_rotation(m_transition.end.rotation));
        }
        m_this.geoTrigger(geo_event.transitionend, opts);
        if (done) {
          done({
            next: !!next
          });
        }
        m_transition = null;
        if (m_queuedTransition) {
          next = m_queuedTransition;
          m_queuedTransition = null;
          m_this.transition(next, undefined, time);
        }
        return;
      }
      var z = m_transition.ease((time - m_transition.start.time) / opts.duration);
      var p = m_transition.interp(z);
      if (m_transition.zCoord) {
        p[2] = z2zoom(p[2]);
      }
      if (m_this._fix_zoom(p[2], true) === m_zoom) {
        m_this.center({
          x: p[0],
          y: p[1]
        }, null, true, true);
      } else {
        m_center = m_this.gcsToWorld({
          x: p[0],
          y: p[1]
        }, null);
        m_this.zoom(p[2], m_transition.zoomOrigin, true, true);
      }
      m_this.rotation(p[3], undefined, true);
      m_this.scheduleAnimationFrame(anim);
    }
    m_this.geoTrigger(geo_event.transitionstart, opts);
    if (geo_event.cancelNavigation) {
      m_transition = null;
      m_this.geoTrigger(geo_event.transitionend, opts);
      return m_this;
    } else if (geo_event.cancelAnimation) {
      // run the navigation synchronously
      opts.duration = 0;
      anim(0);
    } else if (animTime) {
      anim(animTime);
    } else {
      m_this.scheduleAnimationFrame(anim);
    }
    return m_this;
  };

  /**
   * Cancel any existing transition.  The transition will send a cancel event
   * at the next animation frame, but no further activity occurs.
   *
   * @param {string} [source] Optional cause of the cancel.  This can be any
   *    value, but something like `(method name).(action)` is recommended to
   *    allow other functions to determine the source and cause of the
   *    transition being canceled.
   * @returns {boolean} `true` if a transition was in progress.
   * @fires geo.event.transitioncancel
   */
  this.transitionCancel = function (source) {
    if (m_transition && (m_transition.cancel !== true || m_queuedTransition)) {
      m_transition.cancel = true;
      m_transition.cancelSource = source || m_transition.cancelSource || '';
      m_queuedTransition = null;
      return true;
    }
    return false;
  };

  /**
   * Get/set the locations of the current map edges.  When set, the left-top
   * and right-bottom corners are transformed to the map's gcs and then used
   * to set the bounds.
   *
   * @param {geo.geoBounds} [bds] The requested map bounds.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.  If setting the
   *    bounds, they are converted from this gcs to the map projection.  The
   *    returned bounds are converted from the map projection to this gcs.
   * @returns {geo.geoBounds} The actual new map bounds.
   */
  this.bounds = function (bds, gcs) {
    var nav;
    gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
    if (bds !== undefined) {
      if (gcs !== m_gcs) {
        var trans = transform.transformCoordinates(gcs, m_gcs, [{
          x: bds.left,
          y: bds.top
        }, {
          x: bds.right,
          y: bds.bottom
        }]);
        bds = {
          left: trans[0].x,
          top: trans[0].y,
          right: trans[1].x,
          bottom: trans[1].y
        };
      }
      bds = fix_bounds(bds, m_rotation);
      nav = m_this.zoomAndCenterFromBounds(bds, m_rotation, null);

      // This might have consequences in terms of bounds/zoom clamping.
      // What behavior do we expect from this method in that case?
      m_this.zoom(nav.zoom, undefined, undefined, undefined, 'pan');
      m_this.center(nav.center, null);
    }
    return m_this.boundsFromZoomAndCenter(m_zoom, m_center, m_rotation, gcs, true, true);
  };

  /**
   * Get/set the maximum view area of the map.  If the map wraps, this is the
   * unwrapped area.
   *
   * @param {geo.geoBounds} [bounds] The map bounds.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.  If setting the
   *    bounds, they are converted from this gcs to the map projection.  The
   *    returned bounds are converted from the map projection to this gcs.
   * @returns {geo.geoBounds|this} The map maximum bounds or the map object.
   */
  this.maxBounds = function (bounds, gcs) {
    gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
    if (bounds === undefined) {
      return {
        left: transform.transformCoordinates(m_gcs, gcs, {
          x: m_maxBounds.left,
          y: 0
        }).x,
        right: transform.transformCoordinates(m_gcs, gcs, {
          x: m_maxBounds.right,
          y: 0
        }).x,
        bottom: transform.transformCoordinates(m_gcs, gcs, {
          x: 0,
          y: m_maxBounds.bottom
        }).y,
        top: transform.transformCoordinates(m_gcs, gcs, {
          x: 0,
          y: m_maxBounds.top
        }).y
      };
    }
    var cx = ((bounds.left || 0) + (bounds.right || 0)) / 2,
      cy = ((bounds.bottom || 0) + (bounds.top || 0)) / 2;
    if (bounds.left !== undefined) {
      m_maxBounds.left = transform.transformCoordinates(gcs, m_gcs, {
        x: bounds.left,
        y: cy
      }).x;
    }
    if (bounds.right !== undefined) {
      m_maxBounds.right = transform.transformCoordinates(gcs, m_gcs, {
        x: bounds.right,
        y: cy
      }).x;
    }
    if (bounds.bottom !== undefined) {
      m_maxBounds.bottom = transform.transformCoordinates(gcs, m_gcs, {
        x: cx,
        y: bounds.bottom
      }).y;
    }
    if (bounds.top !== undefined) {
      m_maxBounds.top = transform.transformCoordinates(gcs, m_gcs, {
        x: cx,
        y: bounds.top
      }).y;
    }
    reset_minimum_zoom();
    m_this.zoom(m_zoom);
    m_this.pan({
      x: 0,
      y: 0
    });
    return m_this;
  };

  /**
   * Get the corners of the map.  Since the map can be rotated, this is
   * necessarily not the same as the overall bounds, which is the orthogonal
   * bounding box.
   *
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.  If setting the
   *    bounds, they are converted from this gcs to the map projection.  The
   *    returned bounds are converted from the map projection to this gcs.
   * @returns {geo.geoPosition[]} The corners of the map in the order
   *    upper-left, upper-right, lower-right, lower-left.
   */
  this.corners = function (gcs) {
    return [m_this.displayToGcs({
      x: 0,
      y: 0
    }, gcs), m_this.displayToGcs({
      x: m_width,
      y: 0
    }, gcs), m_this.displayToGcs({
      x: m_width,
      y: m_height
    }, gcs), m_this.displayToGcs({
      x: 0,
      y: m_height
    }, gcs)];
  };

  /**
   * Get the center zoom level necessary to display the given bounds.
   *
   * @param {geo.geoBounds} bounds The requested map bounds.  `right` must be
   *    greater than `left` and `bottom` must be greater than `top` in the
   *    map's gcs (after conversion from the provided gcs).
   * @param {number} rotation Rotation in clockwise radians.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.zoomAndCenter}
   */
  this.zoomAndCenterFromBounds = function (bounds, rotation, gcs) {
    var center, zoom;
    gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
    if (gcs !== m_gcs) {
      var trans = transform.transformCoordinates(gcs, m_gcs, [{
        x: bounds.left,
        y: bounds.top
      }, {
        x: bounds.right,
        y: bounds.bottom
      }]);
      bounds = {
        left: trans[0].x,
        top: trans[0].y,
        right: trans[1].x,
        bottom: trans[1].y
      };
    }
    if (bounds.left >= bounds.right || bounds.bottom >= bounds.top) {
      throw new Error('Invalid bounds provided');
    }

    // calculate the zoom to fit the bounds
    zoom = m_this._fix_zoom(calculate_zoom(bounds, rotation));

    // clamp bounds if necessary
    bounds = fix_bounds(bounds, rotation);

    /* This relies on having the map projection coordinates be uniform
     * regardless of location.  If not, the center will not be correct. */
    // calculate new center
    center = {
      x: (bounds.left + bounds.right) / 2 - m_origin.x,
      y: (bounds.top + bounds.bottom) / 2 - m_origin.y
    };
    if (gcs !== m_gcs) {
      center = transform.transformCoordinates(m_gcs, gcs, center);
    }
    return {
      zoom: zoom,
      center: center
    };
  };

  /**
   * Get the bounds that will be displayed with the given zoom and center.
   *
   * Note: the bounds may not have the requested zoom and center due to map
   * restrictions.
   *
   * @param {number} zoom The requested zoom level.
   * @param {geo.geoPosition} center The requested center.
   * @param {number} rotation The requested rotation in clockwise radians.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the interface
   *    gcs, `null` to use the map gcs, or any other transform.
   * @param {boolean} [ignoreDiscreteZoom] If `true`, ignore the `discreteZoom`
   *    option when determining the new view.
   * @param {boolean} [ignoreClampBounds] If `true` and `clampBoundsX` or
   *    `clampBoundsY` is set, allow the bounds to be less clamped.
   *    The map's `maxBounds` can be shifted so that they lie no further than
   *    the center of the bounds (rather than being forced to be at the edge).
   * @returns {geo.geoBounds}
   */
  this.boundsFromZoomAndCenter = function (zoom, center, rotation, gcs, ignoreDiscreteZoom, ignoreClampBounds) {
    var width, height, halfw, halfh, bounds, units;
    gcs = gcs === null ? m_gcs : gcs === undefined ? m_ingcs : gcs;
    // preprocess the arguments
    zoom = m_this._fix_zoom(zoom, ignoreDiscreteZoom);
    units = m_this.unitsPerPixel(zoom);
    center = m_this.gcsToWorld(center, null);

    // get half the width and height in world coordinates
    width = m_width * units;
    height = m_height * units;
    halfw = width / 2;
    halfh = height / 2;

    // calculate the bounds.  This is only valid if the map projection has
    // uniform units in each direction.  If not, then worldToGcs should be
    // used.

    if (rotation) {
      center.x += m_origin.x;
      center.y += m_origin.y;
      bounds = rotate_bounds_center(center, {
        width: width,
        height: height
      }, rotation);
      // correct the bounds when clamping is enabled
      bounds.width = width;
      bounds.height = height;
      bounds = fix_bounds(bounds, rotation, undefined, ignoreClampBounds);
    } else {
      bounds = {
        left: center.x - halfw + m_origin.x,
        right: center.x + halfw + m_origin.x,
        bottom: center.y - halfh + m_origin.y,
        top: center.y + halfh + m_origin.y
      };
      // correct the bounds when clamping is enabled
      bounds = fix_bounds(bounds, 0, undefined, ignoreClampBounds);
    }
    if (gcs !== m_gcs) {
      var bds = transform.transformCoordinates(m_gcs, gcs, [[bounds.left, bounds.top], [bounds.right, bounds.bottom]]);
      bounds = {
        left: bds[0][0],
        top: bds[0][1],
        right: bds[1][0],
        bottom: bds[1][1]
      };
    }
    /* Add the original width and height of the viewport before rotation. */
    bounds.width = width;
    bounds.height = height;
    return bounds;
  };

  /**
   * Get/set the discrete zoom flag.  If `true`, the map will snap to integer
   * zoom levels.
   *
   * @param {boolean} [discreteZoom] If specified, the new discrete zoom flag.
   * @returns {boolean|this} The current discrete zoom flag or the map object.
   */
  this.discreteZoom = function (discreteZoom) {
    if (discreteZoom === undefined) {
      return m_discreteZoom;
    }
    discreteZoom = discreteZoom ? true : false;
    if (m_discreteZoom !== discreteZoom) {
      m_discreteZoom = discreteZoom;
      if (m_discreteZoom) {
        m_this.zoom(Math.round(m_this.zoom()));
      }
      if (m_this.interactor()) {
        m_this.interactor().options({
          discreteZoom: m_discreteZoom
        });
      }
    }
    return m_this;
  };

  /**
   * Get the layers contained in the map.
   * Alias of {@link geo.sceneObject#children}.
   * @method
   */
  this.layers = this.children;

  /**
   * Compare two layers by zIndex.  If the zIndex is the same, the order in the
   * parent element is used.  If the two layers don't have the same parent (for
   * instance, one layer isn't attached to the map), layers in the map are
   * sorted below detached layers.
   *
   * @param {geo.layer} a First layer to compare.
   * @param {geo.layer} b Second layer to compare.
   * @returns {number} Positive if `a` is above `b`.
   */
  function layerZIndexSort(a, b) {
    var az = a.zIndex(),
      bz = b.zIndex();
    if (az !== bz) {
      return az - bz;
    }
    var an = a.node()[0],
      bn = b.node()[0],
      ap = an && an.parentNode,
      bp = bn && bn.parentNode;
    if (ap && bp && ap === bp) {
      var nodes = Array.from(ap.children),
        ai = nodes.indexOf(an),
        bi = nodes.indexOf(bn);
      if (ai >= 0 && bi >= 0) {
        return ai - bi;
      }
    }
    return ap ? -1 : bp ? 1 : 0;
  }

  /**
   * Get the layers contained in the map sorted by zIndex.  If two layers have
   * the same zIndex, they are returned in creation order.
   *
   * @returns {geo.layer[]}
   */
  this.sortedLayers = function () {
    return m_this.children().sort(layerZIndexSort);
  };

  /**
   * Get a sorted list of {@link geo.sceneObject} including all children.  The
   * list always includes specified objects.  Children immediately follow their
   * parents.  Siblings may be separated by children of preceding siblings.
   *
   * @param {geo.sceneObject[]} [objects] A list of objects for which the
   *    a combined list of dependents is generated.  If not specified, the
   *    sorted list of layers is used.
   * @returns {geo.sceneObject[]} A list of object and dependents.
   */
  this.listSceneObjects = function (objects) {
    var objectList = [];
    objects = objects || m_this.sortedLayers();
    objects.forEach(function (object) {
      if (objectList.indexOf(object) < 0) {
        objectList.push(object);
        if (object.children) {
          var children = object.children();
          if (children.length) {
            objectList = objectList.concat(m_this.listSceneObjects(children));
          }
        }
      }
    });
    return objectList;
  };

  /**
   * Update the attribution notice displayed on the bottom right corner of
   * the map.  The content of this notice is managed by individual layers.
   * This method queries all of the visible layers and joins the individual
   * attribution notices into a single element.  By default, this method
   * is called on each of the following events:
   *
   *   {@link geo.event.layerAdd}
   *   {@link geo.event.layerRemove}
   *
   * In addition, layers should call this method when their own attribution
   * notices have changed.  Users, in general, should not need to call this.
   *
   * @returns {this} Chainable.
   */
  this.updateAttribution = function () {
    // clear any existing attribution content
    m_this.node().find('.geo-attribution').remove();

    // generate a new attribution node
    var $a = $('<div/>').addClass('geo-attribution').on('mousedown', function (evt) {
      evt.stopPropagation();
    });

    // append content from each layer
    m_this.children().forEach(function (layer) {
      var content = layer.attribution();
      if (content) {
        $('<span/>').addClass('geo-attribution-layer').html(content).appendTo($a);
      }
    });

    /* Only add the element if there is at least one attribution */
    if ($('span', $a).length) {
      $a.appendTo(m_this.node());
    }
    return m_this;
  };

  /**
   * Get a screen-shot of all or some of the canvas layers of map.  Note that
   * webGL layers are rerendered, even if
   *   `window.overrideContextAttributes.preserveDrawingBuffer = true;`
   * is set before creating the map object.  Chrome, at least, may not keep the
   * drawing buffers if the tab loses focus (and returning focus won't
   * necessarily rerender).
   *
   * @param {geo.layer|geo.layer[]|false|object} [layers] Either a layer, a
   *    list of layers, falsy to get all layers, or an object that contains
   *    optional values of `layers`, `type`, `encoderOptions`, and additional
   *    values listed in the `opts` parameter (this last form allows a single
   *    argument for the function).
   * @param {string} [type] See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
   *    canvas.toDataURL}.  Use `'canvas'` to return the canvas element (this
   *    can be used to get the results as a blob, which can be faster for some
   *    operations but is not supported as widely).
   * @param {number} [encoderOptions] See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
   *    canvas.toDataURL}.
   * @param {object} [opts] Additional screenshot options.
   * @param {false|string|CanvasRenderingContext2D.fillStyle} [opts.background]
   *    If `false` or `null`, don't prefill the background.  Otherwise, a css
   *    color or `CanvasRenderingContext2D.fillStyle` to fill the initial
   *    canvas.  This could match the background of the browser page, for
   *    instance.  Default is 'white'.
   * @param {boolean|'idle'} [opts.wait] If `'idle'`, wait for the map to
   *    be idle and one additional animation frame to occur.  If truthy, wait
   *    for an animation frame to occur.  Otherwise, take the screenshot as
   *    soon as possible.
   * @param {boolean|null} [opts.attribution] If `null` or unspecified,
   *    include the attribution only if all layers are used.  If false, never
   *    include the attribution.  If `true`, always include it.
   * @param {HTMLElement[]|string[]} [opts.html] A list of additional HTML
   *    elements, selectors, or jQuery elements to render on top of the map.
   *    These are rendered in order, with the last one topmost.
   * @returns {jQueryDeferred} A jQuery Deferred object.  The done function
   *    receives either a data URL or an `HTMLCanvasElement` with the result.
   * @fires geo.event.screenshot.ready
   */
  this.screenshot = function (layers, type, encoderOptions, opts) {
    var defer;
    if (layers && !Array.isArray(layers) && !layers.renderer) {
      type = type || layers.type;
      encoderOptions = encoderOptions || layers.encoderOptions;
      opts = opts || layers;
      layers = layers.layers;
    }
    opts = opts || {};
    /* if asked to wait, return a Deferred that will do so, calling the
     * screenshot function without waiting once it is done. */
    if (opts.wait) {
      var optsWithoutWait = Object.assign({}, opts, {
        wait: false
      });
      defer = $.Deferred();
      var waitForRAF = function waitForRAF() {
        window.requestAnimationFrame(function () {
          defer.resolve();
        });
      };
      if (opts.wait === 'idle') {
        m_this.onIdle(waitForRAF);
      } else {
        waitForRAF();
      }
      return defer.then(function () {
        return m_this.screenshot(layers, type, encoderOptions, optsWithoutWait);
      });
    }
    defer = $.when();
    // ensure layers is a list of all the layers we want to include
    if (!layers) {
      layers = m_this.layers();
      if (opts.attribution === null || opts.attribution === undefined) {
        opts.attribution = true;
      }
    } else if (!Array.isArray(layers)) {
      layers = [layers];
    }
    // filter to only the included layers
    layers = layers.filter(function (l) {
      return m_this.layers().indexOf(l) >= 0 && l.opacity() > 0 && (!l.visible || l.visible());
    });
    // sort layers by z-index
    layers = layers.sort(layerZIndexSort);
    // create a new canvas element
    var result = document.createElement('canvas');
    result.width = m_width;
    result.height = m_height;
    var context = result.getContext('2d');
    // optionally start with a white or custom background
    if (opts.background !== false && opts.background !== null) {
      var background = opts.background;
      if (opts.background === undefined) {
        /* If we are using the map's current background, start with white as a
         * fallback, then fill with the backgrounds of all parents and the map
         * node.  Since each may be partially transparent, this is required to
         * match the web page's color.  It won't use background patterns. */
        context.fillStyle = 'white';
        context.fillRect(0, 0, result.width, result.height);
        m_this.node().parents().get().reverse().forEach(function (elem) {
          background = window.getComputedStyle(elem).backgroundColor;
          if (background && background !== 'transparent') {
            context.fillStyle = background;
            context.fillRect(0, 0, result.width, result.height);
          }
        });
        background = window.getComputedStyle(m_this.node()[0]).backgroundColor;
      }
      if (background && background !== 'transparent') {
        context.fillStyle = background;
        context.fillRect(0, 0, result.width, result.height);
      }
    }
    // for each layer, copy to our new canvas.
    layers.forEach(function (layer) {
      var opacity = layer.opacity();
      layer.node().children('canvas').each(function () {
        var canvasElem = $(this);
        defer = defer.then(function () {
          if (layer.renderer() && layer.renderer().api() === 'webgl') {
            layer.renderer()._renderFrame();
          }
          drawLayerImageToContext(context, opacity, canvasElem, canvasElem[0], layer.node().css('mix-blend-mode'));
        });
      });
      if ((layer.node().children().not('canvas').length || !layer.node().children().length) && (!layer.renderer() || layer.renderer().api() !== 'webgl')) {
        defer = defer.then(function () {
          return util.htmlToImage(layer.node(), 1).done(function (img) {
            drawLayerImageToContext(context, 1, $([]), img, layer.node().css('mix-blend-mode'));
          });
        });
      }
    });
    if (opts.attribution) {
      m_this.node().find('.geo-attribution').each(function () {
        var attrElem = $(this);
        defer = defer.then(function () {
          return util.htmlToImage(attrElem, 1).done(function (img) {
            drawLayerImageToContext(context, 1, $([]), img);
          });
        });
      });
    }
    if (opts.html) {
      $(opts.html).each(function () {
        var attrElem = $(this);
        defer = defer.then(function () {
          return util.htmlToImage(attrElem, 1).done(function (img) {
            drawLayerImageToContext(context, 1, $([]), img, attrElem.css('mix-blend-mode'));
          });
        });
      });
    }
    defer = defer.then(function () {
      var canvas = result;
      if (type !== 'canvas') {
        try {
          result = result.toDataURL(type, encoderOptions);
        } catch (err) {
          console.warn('Failed to convert screenshot to output', err); // eslint-disable-line no-console
          var failure = $.Deferred();
          failure.reject();
          return failure;
        }
      }
      m_this.geoTrigger(geo_event.screenshot.ready, {
        canvas: canvas,
        screenshot: result
      });
      return result;
    });
    return defer;
  };

  /**
   * Instead of each function using `window.requestAnimationFrame`, schedule
   * all such frames through this function.  This allows the callbacks to be
   * reordered or removed as needed and reduces overhead in Chrome a small
   * amount.  Also, if the animation queue is shared between map instances, the
   * callbacks will be called in a single time slice, providing better
   * synchronization.
   *
   * @param {Function} callback Function to call during the animation frame.
   *    It is called with an animation epoch, exactly as
   *    `requestAnimationFrame`.
   * @param {boolean|'remove'} [action] Falsy to only add the callback if
   *    it is not already scheduled.  `'remove'` to remove the callback (use
   *    this instead of `cancelAnimationFrame`).  Any other truthy value moves
   *    the callback to the end of the list.
   * @returns {number?} An integer as returned by
   *    `window.requestAnimationFrame`.
   */
  this.scheduleAnimationFrame = function (callback, action) {
    if (!m_animationQueue.length) {
      /* By referring to requestAnimationFrame as a property of window, versus
       * explicitly using window.requestAnimationFrame, we prevent the
       * stripping of 'window' off of the reference and allow our tests to
       * override this if needed. */
      m_animationQueue.push(window['requestAnimationFrame'](processAnimationFrame));
    }
    var pos = m_animationQueue.indexOf(callback, 1);
    if (pos >= 0) {
      if (!action) {
        return undefined;
      }
      m_animationQueue.splice(pos, 1);
      if (action === 'remove') {
        return undefined;
      }
    }
    m_animationQueue.push(callback);
    return m_animationQueue[0];
  };

  /**
   * Return the nearest valid zoom level to the requested zoom.
   * @param {number} zoom A zoom level to adjust to current settings
   * @param {boolean} [ignoreDiscreteZoom] If `true`, ignore the `discreteZoom`
   *    option when determining the new view.
   * @returns {number} The zoom level clamped to the allowed zoom range and
   *    with other settings applied.
   * @private
   */
  this._fix_zoom = function (zoom, ignoreDiscreteZoom) {
    zoom = Math.round(zoom * 1e6) / 1e6;
    zoom = Math.max(Math.min(m_validZoomRange.max, zoom), m_validZoomRange.min);
    if (m_discreteZoom && !ignoreDiscreteZoom) {
      zoom = Math.round(zoom);
      if (zoom < m_validZoomRange.min) {
        zoom = Math.ceil(m_validZoomRange.min);
      }
    }
    return zoom;
  };

  /**
   * Get or set the setting of autoshareRenderer.
   *
   * @param {boolean|string|null} [arg] If specified, the new value for
   *   autoshareRender that gets passed to created layers.  `null` will clear
   *   the value.
   * @returns {boolean|string|this}
   */
  this.autoshareRenderer = function (arg) {
    if (arg === undefined) {
      return m_autoshareRenderer;
    }
    m_autoshareRenderer = arg === null ? undefined : arg;
    return m_this;
  };

  /* Report the current version on the map object. */
  this._version = __webpack_require__(4081);
  /* Link to the main library */
  this._geo = __webpack_require__(2257);

  /**
   * Draw a layer image to a canvas context.  The layer's opacity and transform
   * are applied.  This is used as part of making a screenshot.
   *
   * @param {CanvasRenderingContext2D} context The 2d canvas context to draw
   *    into.
   * @param {number} opacity The opacity in the range [0, 1].
   * @param {object} elem A jQuery element that might have a transform.
   * @param {HTMLImageElement} img The image or canvas to draw to the canvas.
   * @param {string} [mixBlendMode] the mix-blend-mode used to add this layer.
   * @private
   */
  function drawLayerImageToContext(context, opacity, elem, img, mixBlendMode) {
    context.globalAlpha = opacity;
    if (mixBlendMode) {
      context.globalCompositeOperation = mixBlendMode;
    }
    var transform = elem.css('transform');
    // if the canvas is being transformed, apply the same transformation
    if (transform && transform.substr(0, 7) === 'matrix(') {
      context.setTransform.apply(context, transform.substr(7, transform.length - 8).split(',').map(parseFloat));
    } else {
      context.setTransform(1, 0, 0, 1, 0, 0);
    }
    context.drawImage(img, 0, 0);
    context.globalCompositeOperation = 'source-over';
  }

  /**
   * Service the callback during an animation frame.  This uses splice to modify
   * the `animationQueue` to allow multiple map instances to share the queue.
   * @private
   */
  function processAnimationFrame() {
    var queue = m_animationQueue.splice(0, m_animationQueue.length);

    /* The first entry is the reference to the window.requestAnimationFrame. */
    for (var i = 1; i < queue.length; i += 1) {
      try {
        queue[i].apply(m_this, arguments);
      } catch (err) {
        console.error(err); // eslint-disable-line no-console
      }
    }
  }

  /*
   * The following are some private methods for interacting with the camera.
   * In order to hide the complexity of dealing with map aspect ratios,
   * clamping behavior, resetting zoom levels on resize, etc. from the
   * layers, the map handles camera movements directly.  This requires
   * passing all camera movement events through the map initially.  The
   * map uses these methods to fix up the events according to the constraints
   * of the display and passes the event to the layers.
   */
  /**
   * Calculate the scaling factor to fit the given map bounds into the viewport
   * with the correct aspect ratio.
   *
   * @param {geo.geoBounds} bounds A desired bounds.
   * @returns {object} Multiplicative aspect ratio correction with x and y
   *    values.
   * @private
   */
  function camera_scaling(bounds) {
    var width = bounds.right - bounds.left,
      height = bounds.top - bounds.bottom,
      ar_bds = Math.abs(width / height),
      ar_vp = m_width / m_height,
      sclx,
      scly;
    if (ar_bds > ar_vp) {
      // fit left and right
      sclx = 1;

      // grow top and bottom
      scly = ar_bds / ar_vp;
    } else {
      // fit top and bottom
      scly = 1;

      // grow left and right
      sclx = ar_vp / ar_bds;
    }
    return {
      x: sclx,
      y: scly
    };
  }

  /**
   * Adjust a set of bounds based on a rotation.  If a rotation exists, the
   * returned bounds are typically larger than the source bounds.
   *
   * @param {geo.geoBounds} bounds Bounds to adjust.
   * @param {number} rotation Angle in radians (positive is clockwise).
   * @returns {geo.geoBounds}
   * @private
   */
  function rotate_bounds(bounds, rotation) {
    if (rotation) {
      var center = {
        x: (bounds.left + bounds.right) / 2,
        y: (bounds.top + bounds.bottom) / 2
      };
      var size = {
        width: Math.abs(bounds.left - bounds.right),
        height: Math.abs(bounds.top - bounds.bottom)
      };
      bounds = rotate_bounds_center(center, size, rotation);
    }
    return bounds;
  }

  /**
   * Generate a set of bounds based on a center point, a width and height, and
   * a rotation.
   *
   * @param {geo.geoPosition} center
   * @param {object} size Size of the screen in map gcs.
   * @param {number} size.width
   * @param {number} size.height
   * @param {number} rotation Angle in radians (positive is clockwise).
   * @returns {geo.geoBounds}
   * @private
   */
  function rotate_bounds_center(center, size, rotation) {
    // calculate the half width and height
    var width = size.width / 2,
      height = size.height / 2;
    var sinr = Math.sin(rotation),
      cosr = Math.cos(rotation);
    var ul = {},
      ur = {},
      ll = {},
      lr = {};
    ul.x = center.x + -width * cosr - -height * sinr;
    ul.y = center.y + -width * sinr + -height * cosr;
    ur.x = center.x + width * cosr - -height * sinr;
    ur.y = center.y + width * sinr + -height * cosr;
    ll.x = center.x + -width * cosr - height * sinr;
    ll.y = center.y + -width * sinr + height * cosr;
    lr.x = center.x + width * cosr - height * sinr;
    lr.y = center.y + width * sinr + height * cosr;
    return {
      left: Math.min(ul.x, ur.x, ll.x, lr.x),
      right: Math.max(ul.x, ur.x, ll.x, lr.x),
      bottom: Math.min(ul.y, ur.y, ll.y, lr.y),
      top: Math.max(ul.y, ur.y, ll.y, lr.y)
    };
  }

  /**
   * Calculate the minimum zoom level to fit the given bounds inside the view
   * port using the view port size, the given bounds, and the number of units
   * per pixel.  The method sets the valid zoom bounds as well as the current
   * zoom level to be within that range.
   *
   * @param {geo.geoBounds} bounds Bounds to fit to the screen.
   * @param {number} [rotation] Rotation in radians.  If unspecified, use the
   *    current map rotation.
   * @returns {number} The necessary zoom level.
   * @private
   */
  function calculate_zoom(bounds, rotation) {
    if (rotation === undefined) {
      rotation = m_rotation;
    }
    bounds = rotate_bounds(bounds, rotation);
    // compare the aspect ratios of the viewport and bounds
    var scl = camera_scaling(bounds),
      z;
    if (scl.y > scl.x) {
      // left to right matches exactly
      // center map vertically and have blank borders on the
      // top and bottom (or repeat tiles)
      z = -Math.log2(Math.abs(bounds.right - bounds.left) * scl.x / (m_width * m_unitsPerPixel));
    } else {
      // top to bottom matches exactly, blank border on the
      // left and right (or repeat tiles)
      z = -Math.log2(Math.abs(bounds.top - bounds.bottom) * scl.y / (m_height * m_unitsPerPixel));
    }
    return z;
  }

  /**
   * Reset the minimum zoom level given the current window size.
   * @private
   */
  function reset_minimum_zoom() {
    if (m_clampZoom) {
      m_validZoomRange.min = Math.max(m_validZoomRange.origMin, calculate_zoom(m_maxBounds));
    } else {
      m_validZoomRange.min = m_validZoomRange.origMin;
    }
  }

  /**
   * Return a valid rotation angle.
   *
   * @param {number} rotation Proposed rotation.
   * @param {boolean} [ignoreRotationFunc] If truthy and rotations are allowed,
   *    allow any rotation.  Otherwise, the rotation is passed through the
   *    `allowRotation` function.
   * @param {boolean} [noRangeLimit] If falsy, ensure that the rotation is in
   *    the range [0, 2*PI).  If it is very close to zero, it is snapped to
   *    zero.  If true, the rotation can have any value.
   * @returns {number} the validated rotation
   * @private
   */
  function fix_rotation(rotation, ignoreRotationFunc, noRangeLimit) {
    if (!m_allowRotation) {
      return 0;
    }
    if (!ignoreRotationFunc && typeof m_allowRotation === 'function') {
      rotation = m_allowRotation(rotation);
    }
    /* Ensure that the rotation is in the range [0, 2pi) */
    if (!noRangeLimit) {
      var range = Math.PI * 2;
      rotation = rotation % range + (rotation >= 0 ? 0 : range);
      if (Math.min(Math.abs(rotation), Math.abs(rotation - range)) < 0.00001) {
        rotation = 0;
      }
    }
    return rotation;
  }

  /**
   * Return the nearest valid bounds maintaining the width and height.  Does
   * nothing if `clampBoundsX` and `clampBoundsY` are false.  If a delta is
   * specified, will only clamp if the out-of-bounds condition would be worse.
   * If `ignoreClampBounds` is true, clamping is applied only to prevent more
   * than half the image from being off screen.
   *
   * @param {geo.geoBounds} bounds The new bounds to apply in map gcs
   *    coordinates.
   * @param {number} [rotation] The angle of rotation in radians.  May be falsy
   *    to have no rotation.
   * @param {object} [delta] If present, the shift in position in screen
   *    coordinates.  Bounds will only be adjusted if the bounds would be
   *    more out of position after the shift.
   * @param {number} delta.x
   * @param {number} delta.y
   * @param {number} delta.unit Units per pixel at the current zoom level.
   * @param {boolean} [ignoreClampBounds] If `true` and `clampBoundsX` or
   *    `clampBoundsY` are set, allow the bounds to be less clamped.
   *    Specifically, the map's `maxBounds` can be shifted so that they lie no
   *    further than the center of the bounds (rather than being forced to be
   *    at the edge).
   * @returns {geo.geoBounds} The adjusted bounds.  This may be the same object
   *    passed in `bounds`.
   * @private
   */
  function fix_bounds(bounds, rotation, delta, ignoreClampBounds) {
    if (!m_clampBoundsX && !m_clampBoundsY) {
      return bounds;
    }
    var dx,
      dy,
      maxBounds = m_maxBounds;
    if (rotation) {
      maxBounds = Object.assign({}, m_maxBounds);
      /* When rotated, expand the maximum bounds so that they will allow the
       * corners to be visible.  We know the rotated bounding box, plus the
       * original maximum bounds.  To fit the corners of the maximum bounds, we
       * can expand the total bounds by the same factor that the rotated
       * bounding box is expanded from the non-rotated bounding box (for a
       * small rotation, this is sin(rotation) * (original bounding box height)
       * in the width).  This feels like appropriate behaviour with one of the
       * two bounds clamped.  With both, it seems mildly peculiar. */
      var bw = Math.abs(bounds.right - bounds.left),
        bh = Math.abs(bounds.top - bounds.bottom),
        absinr = Math.abs(Math.sin(rotation)),
        abcosr = Math.abs(Math.cos(rotation)),
        ow,
        oh;
      if (bounds.width && bounds.height) {
        ow = bounds.width;
        oh = bounds.height;
      } else if (Math.abs(absinr - abcosr) < 0.0005) {
        /* If we are close to a 45 degree rotation, it is ill-determined to
         * compute the original (pre-rotation) bounds width and height.  In
         * this case, assume that we are using the map's aspect ratio. */
        if (m_width && m_height) {
          var aspect = Math.abs(m_width / m_height);
          var fac = Math.pow(1 + Math.pow(aspect, 2), 0.5);
          ow = Math.max(bw, bh) / fac;
          oh = ow * aspect;
        } else {
          /* Fallback if we don't have width or height */
          ow = bw * abcosr;
          oh = bh * absinr;
        }
      } else {
        /* Compute the pre-rotation (original) bounds width and height */
        ow = (abcosr * bw - absinr * bh) / (abcosr * abcosr - absinr * absinr);
        oh = (abcosr * bh - absinr * bw) / (abcosr * abcosr - absinr * absinr);
      }
      /* Our maximum bounds are expanded based on the projected length of a
       * tilted side of the original bounding box in the rotated bounding box.
       * To handle all rotations, take the minimum difference in width or
       * height. */
      var bdx = bw - Math.max(abcosr * ow, absinr * oh),
        bdy = bh - Math.max(abcosr * oh, absinr * ow);
      maxBounds.left -= bdx;
      maxBounds.right += bdx;
      maxBounds.top += bdy;
      maxBounds.bottom -= bdy;
    }
    if (ignoreClampBounds) {
      maxBounds = {
        left: maxBounds.left - (bounds.right - bounds.left) / 2,
        right: maxBounds.right + (bounds.right - bounds.left) / 2,
        top: maxBounds.top - (bounds.bottom - bounds.top) / 2,
        bottom: maxBounds.bottom + (bounds.bottom - bounds.top) / 2
      };
    }
    if (m_clampBoundsX) {
      if (bounds.right - bounds.left > maxBounds.right - maxBounds.left) {
        dx = maxBounds.left - (bounds.right - bounds.left - (maxBounds.right - maxBounds.left)) / 2 - bounds.left;
      } else if (bounds.left < maxBounds.left) {
        dx = maxBounds.left - bounds.left;
      } else if (bounds.right > maxBounds.right) {
        dx = maxBounds.right - bounds.right;
      }
      if (dx && (!delta || delta.x * dx > 0)) {
        if (delta && Math.abs(dx) > Math.abs(delta.x * delta.unit)) {
          dx = Math.abs(delta.x * delta.unit) * dx / Math.abs(dx);
        }
        bounds = {
          left: bounds.left += dx,
          right: bounds.right += dx,
          top: bounds.top,
          bottom: bounds.bottom
        };
      }
    }
    if (m_clampBoundsY) {
      if (bounds.top - bounds.bottom > maxBounds.top - maxBounds.bottom) {
        dy = maxBounds.bottom - (bounds.top - bounds.bottom - (maxBounds.top - maxBounds.bottom)) / 2 - bounds.bottom;
      } else if (bounds.top > maxBounds.top) {
        dy = maxBounds.top - bounds.top;
      } else if (bounds.bottom < maxBounds.bottom) {
        dy = maxBounds.bottom - bounds.bottom;
      }
      if (dy && (!delta || -delta.y * dy > 0)) {
        if (delta && Math.abs(dy) > Math.abs(delta.y * delta.unit)) {
          dy = Math.abs(delta.y * delta.unit) * dy / Math.abs(dy);
        }
        bounds = {
          top: bounds.top += dy,
          bottom: bounds.bottom += dy,
          left: bounds.left,
          right: bounds.right
        };
      }
    }
    return bounds;
  }

  /**
   * Call the camera bounds method with the given bounds, but correct for the
   * viewport aspect ratio.
   *
   * @param {geo.geoBounds} bounds The bounds for the camera.  If a rotation
   *    is specified, the bounds need to also contain the map gcs width and
   *    height.
   * @param {number} [rotation] The map rotation in radians.
   * @private
   */
  function camera_bounds(bounds, rotation) {
    m_camera.rotation = rotation || 0;
    /* When dealing with rotation, use the original width and height of the
     * bounds, as the rotation will have expanded them. */
    if (bounds.width && bounds.height && rotation) {
      var cx = (bounds.left + bounds.right) / 2,
        cy = (bounds.top + bounds.bottom) / 2;
      m_camera.viewFromCenterSizeRotation({
        x: cx,
        y: cy
      }, bounds, rotation);
    } else {
      m_camera.bounds = bounds;
    }
    /* Update the center to what was set. */
    m_center = {
      x: (m_camera.bounds.left + m_camera.bounds.right) / 2,
      y: (m_camera.bounds.top + m_camera.bounds.bottom) / 2
    };
  }

  /**
   * Resize the map based on the size of the associated DOM node.
   * @private
   */
  function resizeSelf() {
    m_this.size({
      width: m_node.width(),
      height: m_node.height()
    });
  }

  /*
   * All the methods are now defined.  From here, we are initializing all
   * internal variables and event handlers.
   */

  this._init(arg);

  // set up drag/drop handling
  this.node().on('dragover.geo', function (e) {
    var evt = e.originalEvent;
    if (m_this.fileReader()) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = 'copy';
    }
  }).on('drop.geo', function (e) {
    var evt = e.originalEvent,
      reader = m_this.fileReader(),
      i,
      file;
    function done() {
      m_this.draw();
    }
    if (reader) {
      evt.stopPropagation();
      evt.preventDefault();
      for (i = 0; i < evt.dataTransfer.files.length; i += 1) {
        file = evt.dataTransfer.files[i];
        if (reader.canRead(file)) {
          reader.read(file, done); // to do: trigger event on done
        }
      }
    }
  });

  /*
   * The map coordinates for the default world map, where c = half
   * circumference at equator in meters, o = origin:
   *   (-c, c) + o                   (c, c) + o
   *            (center.x, center.y) + o            <-- center of viewport
   *   (-c, -c) + o                  (c, -c) + o
   */
  // Set the world origin
  m_origin = {
    x: 0,
    y: 0
  };

  // Fix the zoom level (minimum and initial)
  this.zoomRange(arg, true);
  m_zoom = this._fix_zoom(m_zoom);
  m_rotation = fix_rotation(m_rotation);
  // Now update to the correct center and zoom level
  this.center(Object.assign({}, arg.center || m_center), undefined);
  if (arg.interactor !== null) {
    this.interactor(arg.interactor || mapInteractor({
      discreteZoom: m_discreteZoom
    }));
  }
  if (m_autoResize) {
    $(window).on('resize', resizeSelf);
  }

  // attach attribution updates to layer events
  m_this.geoOn([geo_event.layerAdd, geo_event.layerRemove], m_this.updateAttribution);
  return this;
};

/**
 * Create a map from an object.  Any errors in the creation
 * of the map will result in returning `null`.
 *
 * @param {geo.map.createSpec} spec The map creation specification.
 * @returns {geo.map|null}
 */
_map2.create = function (spec) {
  'use strict';

  var _map = _map2(spec),
    layer = __webpack_require__(5156);

  /* If the spec is bad, we still end up with an object, but it won't have a
   * zoom function */
  if (!_map || !_map.zoom) {
    console.warn('Could not create map.'); // eslint-disable-line no-console
    return null;
  }
  spec.data = spec.data || [];
  spec.layers = spec.layers || [];
  spec.layers.forEach(function (l) {
    l.data = l.data || spec.data;
    l.layer = layer.create(_map, l);
  });
  return _map;
};
inherit(_map2, sceneObject);
module.exports = _map2;

/***/ }),

/***/ 7908:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var object = __webpack_require__(1338);
var util = __webpack_require__(642);
var Mousetrap = __webpack_require__(7549);

/**
 * Map Interactor specification.
 *
 * @typedef {object} geo.mapInteractor.spec
 * @property {number} [throttle=30] Mouse events are throttled so that an event
 *      occurs no more often that this number of milliseconds.
 * @property {boolean|number} [discreteZoom=false] If `true`, only allow
 *      discrete (integer) zoom levels and debounce with a 400 ms delay.  If a
 *      positive number, debounce zoom events with the given delay in
 *      milliseconds.
 * @property {geo.actionRecord[]} [actions] The list of available actions.  See
 *      the code for the full default list.
 * @property {object} [click] An object specifying if click events should be
 *      handled.
 * @property {boolean} [click.enabled=true] Truthy to enable click events.
 * @property {object} [click.buttons] An object with button names (`left`,
 *      `right`, `middle`), each of which is a boolean which indicates if that
 *      button triggers a click event.
 * @property {number} [click.duration=0] If a positive number, the mouse up
 *      event must occur within this time in milliseconds of the mouse down
 *      event for it to be considered a click.
 * @property {boolean|number} [click.cancelOnMove=true] If true, don't generate
 *      click events if the mouse moved at all.  If a positive number, the
 *      distance at which to cancel click events when the mouse moves.
 * @property {object} [keyboard] An object describing which keyboard events are
 *      handled.
 * @property {object} [keyboard.actions] An object with different actions that
 *      are trigger by the keyboard.  Each key is the event that is triggered,
 *      with the values a list of keys that trigger the event.  See the code
 *      for the defaults.
 * @property {object} [keyboard.meta] Keyboard events can generate actions of
 *      different magnitudes.  This is an object with keys of `0`, `1`, and
 *      `2`, corresponding to small, medium, and large actions.  Each entry is
 *      an object with keys of the meta keys that are required to be down or
 *      up for that scale action to trigger.  If the value of the meta key is
 *      truthy, it must be down.  If `false`, it must be up.
 * @property {string[]} [keyboard.metakeyMouseEvents] A list of meta keys
 * that, when typed singly, trigger a repeat of the last mousemove or
 *      actionmove event so that listeners can  update metakey information.
 * @property {boolean} [keyboard.focusHighlight=true] If truthy, when the map
 *      gains focus, a highlight style is shown around it.  This gives an
 *      indicator that keyboard events will affect the map, but may not be
 *      visually desirable.
 * @property {boolean} [alwaysTouch=false] If true, add touch support even if
 *      the browser doesn't apepar to be touch-aware.
 * @property {number} [wheelScaleX=1] A scale multiplier for horizontal wheel
 *      interactions.
 * @property {number} [wheelScaleY=1] A scale multiplier for vertical wheel
 *      interactions.
 * @property {number} [zoomScale=1] This affects how far the mouse must be
 *      dragged to zoom one level.  Roughly, the mouse must move `zoomScale` *
 *      120 pixels per level.
 * @property {number} [rotateWheelScale=0.105] When the mouse wheel is used for
 *      rotation, this is the number of radians per wheel step.
 * @property {number} [zoomrotateMinimumRotation=0.087] The minimum angle of
 *      rotation in radians before a `geo_action.zoomrotate` action will allow
 *      rotation.  Set to 0 to always include rotation.
 * @property {number} [zoomrotateReverseRotation=0.698] The minimum angle of
 *      rotation (in radians) before the `geo_action.zoomrotate` action will
 *      reverse the rotation direction.  This helps reduce chatter when zooms
 *      and pans are combined with rotations.
 * @property {number} [zoomrotateMinimumZoom=0.05] The minimum zoom factor
 *      change (increasing or desceasing) before the `geo_action.zoomrotate`
 *      action will allow zoom.  Set to 0 to always include zoom.
 * @property {number} [zoomrotateMinimumPan=5] The minimum number of pixels
 *      before the `geo_action.zoomrotate` action will allow panning.  Set to 0
 *      to always include panning.
 * @property {number} [touchPanDelay=50] The touch pan delay prevents a touch
 *      pan event from immediately following a rotate (including zoom) event.
 *      No touch pan event is processed within this number of milliseconds of a
 *      non-pan touch event.
 * @property {object} [momentum] Enable momentum when panning and zooming.
 * @property {boolean} [momentum.enabled=true] Truthy to allow momentum.
 * @property {number} [momentum.maxSpeed=2.5] Maximum animation speed.
 * @property {number} [momentum.minSpeed=0.01] Animations stop when they drop
 *      below this speed.
 * @property {number} [momentum.stopTime=250] If the mouse hasn't moved in this
 *      many milliseconds, don't apply momentum.  The movement is a separate
 *      action from the preceding movement.
 * @property {number} [momentum.drag=0.01] Drag coefficient; larger values slow
 *      down faster.
 * @property {string[]} [momentum.actions] A list of actions on which to apply
 *      momentum.  Defaults to pan and zoom.
 * @property {object} [spring] Enable spring clamping to screen edges.
 * @property {boolean} [spring.enabled=true] Truthy to allow edge spring back.
 * @property {number} [spring.springConstant=0.00005] Higher values spring back
 *      faster.
 * @property {object} [zoomAnimation] Enable zoom animation for both discrete
 *      and continuous zoom.
 * @property {boolean} [zoomAnimation.enabled=true] Truthy to allow zoom
 *      animation.
 * @property {number} [zoomAnimation.duration=500] The time it takes for the
 *      final zoom to be reached.
 * @property {Function} [zoomAnimation.ease] The easing function for the zoom.
 *      The default is `(2 - t) * t`.
 */

/**
 * The state of the mouse.
 *
 * @typedef {object} geo.mouseState
 * @property {geo.screenPosition} page Mouse position relative to the page.
 * @property {geo.geoPosition} map Mouse position relative to the map.
 * @property {geo.geoPosition} geo Mouse position in map interface gcs.
 * @property {geo.geoPosition} mapgcs Mouse position in map gcs
 * @property {object} buttons Which mouse buttons are down.
 * @property {boolean} buttons.left State of the left mouse button.
 * @property {boolean} buttons.right State of the right mouse button.
 * @property {boolean} buttons.middle State of the middle mouse button.
 * @property {object} modifiers Which modifier keys are down.
 * @property {boolean} modifiers.alt State of the alt key.
 * @property {boolean} modifiers.ctrl State of the ctrl key.
 * @property {boolean} modifiers.shift State of the shift key.
 * @property {boolean} modifiers.meta State of the meta key.
 * @property {number} time Time (epoch ms) the event was captured.
 * @property {number} deltaTime Time elapsed (ms) since the last mouse event.
 * @property {geo.screenPosition} velocity Mouse speed in pixels/ms.
 */

/**
 * The mapInteractor class is responsible for handling raw events from the
 * browser and interpreting them as map navigation interactions.  This class
 * will call the navigation methods on the connected map, which will make
 * modifications to the camera directly.
 *
 * @class
 * @alias geo.mapInteractor
 * @extends geo.object
 * @param {geo.mapInterator.spec} args Interactor specification object.
 * @returns {geo.mapInteractor}
 */
var _mapInteractor = function mapInteractor(args) {
  'use strict';

  if (!(this instanceof _mapInteractor)) {
    return new _mapInteractor(args);
  }
  object.call(this);
  var $ = __webpack_require__(5616);
  var geo_event = __webpack_require__(6409);
  var geo_action = __webpack_require__(8695);
  var throttle = (__webpack_require__(642).throttle);
  var debounce = (__webpack_require__(642).debounce);
  var actionMatch = (__webpack_require__(642).actionMatch);
  var quadFeature = __webpack_require__(3842);
  var m_options,
    m_this = this,
    m_mouse,
    m_keyHandler,
    m_boundKeys,
    m_touchHandler,
    m_state,
    m_nextStateId = 0,
    m_queue,
    $node,
    m_selectionLayer = null,
    m_selectionQuad,
    m_paused = false,
    // if m_clickMaybe is not false, it contains the x, y, and buttons that
    // were present when the mouse down event occurred.
    m_clickMaybe = false,
    m_clickMaybeTimeout,
    m_callZoom = function m_callZoom() {};

  // Helper method to calculate the speed from a velocity
  function calcSpeed(v) {
    var x = v.x,
      y = v.y;
    return Math.sqrt(x * x + y * y);
  }

  // copy the options object with defaults
  m_options = util.deepMerge({}, {
    throttle: 30,
    discreteZoom: false,
    /* There should only be one action with any specific combination of event
     * and modifiers.  When that event and modifiers occur, the specified
     * action is triggered.  The event and modifiers fields can either be a
     * simple string or an object with multiple entries with each entry set
     * to true, false, or undefined.  If an object, all values that are
     * truthy must match, all values that are false must not match, and all
     * other values that are falsy are ignored.
     *   Available actions:
     * see geo_action list
     *   Available events:
     * left, right, middle, wheel
     *   Available modifiers:
     * shift, ctrl, alt, meta
     *   Useful fields:
     * action: the name of the action.  Multiple events may trigger the same
     *    action.
     * input: the name of the input or an object with input names for keys
     *    and boolean values that indicates the combination of events that
     *    trigger this action.
     * modifiers: the name of a modifier or an object with modifier names for
     *    keys and boolean values that indicates the combination of modifiers
     *    that trigger this action.
     * selectionRectangle: truthy if a selection rectangle should be shown
     *    during the action.  This can be the name of an event that will be
     *    triggered when the selection is complete.
     * selectionConstraint: if a function and a selection rectangle is being
     *    drawn, this is a function that takes (mousexy, originxy, state)
     *    with the coordinates objects with x, y in display coordinates.
     *    The function returns a modified x, y for the mouse coordinates, or
     *    undefined for no change.
     * name: a string that can be used to reference this action.
     * owner: a string that can be used to reference this action.
     */
    actions: [{
      action: geo_action.pan,
      input: 'left',
      modifiers: {
        shift: false,
        ctrl: false
      },
      owner: 'geo.mapInteractor',
      name: 'button pan'
    }, {
      action: geo_action.zoom,
      input: 'right',
      modifiers: {
        shift: false,
        ctrl: false
      },
      owner: 'geo.mapInteractor',
      name: 'button zoom'
    }, {
      action: geo_action.zoom,
      input: 'wheel',
      modifiers: {
        shift: false
      },
      owner: 'geo.mapInteractor',
      name: 'wheel zoom'
    }, {
      action: geo_action.rotate,
      input: 'left',
      modifiers: {
        shift: false,
        ctrl: true
      },
      owner: 'geo.mapInteractor',
      name: 'button rotate'
    }, {
      action: geo_action.rotate,
      input: 'wheel',
      modifiers: {
        shift: true,
        ctrl: false
      },
      owner: 'geo.mapInteractor',
      name: 'wheel rotate'
    }, {
      action: geo_action.select,
      input: 'left',
      modifiers: {
        shift: true,
        ctrl: true
      },
      selectionRectangle: geo_event.select,
      owner: 'geo.mapInteractor',
      name: 'drag select'
    }, {
      action: geo_action.zoomselect,
      input: 'left',
      modifiers: {
        shift: true,
        ctrl: false
      },
      selectionRectangle: geo_event.zoomselect,
      owner: 'geo.mapInteractor',
      name: 'drag zoom'
    }, {
      action: geo_action.unzoomselect,
      input: 'right',
      modifiers: {
        shift: true,
        ctrl: false
      },
      selectionRectangle: geo_event.unzoomselect,
      owner: 'geo.mapInteractor',
      name: 'drag unzoom'
    }, {
      action: geo_action.pan,
      input: 'pan',
      owner: 'geo.mapInteractor',
      name: 'touch pan'
    }, {
      action: geo_action.zoomrotate,
      input: 'rotate',
      owner: 'geo.mapInteractor',
      name: 'touch zoom and rotate'
    }, {
      action: geo_action.pan,
      input: 'middle',
      modifiers: {
        shift: false,
        ctrl: false
      },
      owner: 'geo.mapInteractor',
      name: 'button pan'
    }],
    click: {
      enabled: true,
      buttons: {
        left: true,
        right: true,
        middle: true
      },
      duration: 0,
      cancelOnMove: true
    },
    keyboard: {
      actions: {
        /* Specific actions can be disabled by removing them from this object
         * or setting an empty list as the key bindings.  Additional actions
         * can be added to the dictionary, each of which gets a list of key
         * bindings.  See Mousetrap documentation for special key names. */
        'zoom.in': ['plus', 'shift+plus', 'shift+ctrl+plus', '=', 'shift+=', 'shift+ctrl+='],
        'zoom.out': ['-', 'shift+-', 'shift+ctrl+-', '_', 'shift+_', 'shift+ctrl+_'],
        'zoom.0': ['1'],
        'zoom.3': ['2'],
        'zoom.6': ['3'],
        'zoom.9': ['4'],
        'zoom.12': ['5'],
        'zoom.15': ['6'],
        'zoom.18': ['7'],
        'pan.left': ['left', 'shift+left', 'shift+ctrl+left'],
        'pan.right': ['right', 'shift+right', 'shift+ctrl+right'],
        'pan.up': ['up', 'shift+up', 'shift+ctrl+up'],
        'pan.down': ['down', 'shift+down', 'shift+ctrl+down'],
        'rotate.ccw': ['<', 'shift+<', 'shift+ctrl+<', '.', 'shift+.', 'shift+ctrl+.'],
        'rotate.cw': ['>', 'shift+>', 'shift+ctrl+>', ',', 'shift+,', 'shift+ctrl+,'],
        'rotate.0': ['0']
      },
      meta: {
        /* the metakeys that are down during a key event determine the
         * magnitude of the action, where 0 is the default small action
         * (1-pixel pan, small zoom, small rotation), 1 is a middle-sized
         * action, and 2 is the largest action.  Metakeys that aren't listed
         * are ignored.  Metakeys include shift, ctrl, alt, and meta (alt is
         * either the alt or option key, and meta is either windows or
         * command). */
        0: {
          shift: false,
          ctrl: false
        },
        1: {
          shift: true,
          ctrl: true
        },
        2: {
          shift: true,
          ctrl: false
        }
      },
      /* This is a list of meta keys that when typed singly trigger a repeat
       * of the last mousemove or actionmove event so that listeners can
       * update metakey information. */
      metakeyMouseEvents: ['shift', 'ctrl', 'shift+ctrl', 'shift+alt', 'shift+meta'],
      /* if focusHighlight is truthy, then a class is added to the map such
       * that when the map gets focus, it is indicated inside the border of
       * the map -- browsers usually show focus on the outside, which isn't
       * useful if the map is full window.  It might be desirable to change
       * this so it is only present if the focus is reached via the keyboard
       * (which would probably require detecting keyup events). */
      focusHighlight: true
    },
    /* Set alwaysTouch to false to only add touch support on devices that
     * report touch support.  Set to true to add touch support on all
     * devices. */
    alwaysTouch: false,
    wheelScaleX: 1,
    wheelScaleY: 1,
    zoomScale: 1,
    rotateWheelScale: 6 * Math.PI / 180,
    /* The minimum angle of rotation (in radians) before the
     * geo_action.zoomrotate action will allow rotation.  Set to 0 to always
     * include rotation. */
    zoomrotateMinimumRotation: 5.0 * Math.PI / 180,
    /* The minimum angle of rotation (in radians) before the
     * geo_action.zoomrotate action will reverse the rotation direction.
     * This helps reduce chatter when zooms and pans are combined with
     * rotations. */
    zoomrotateReverseRotation: 4.0 * Math.PI / 180,
    /* The minimum zoom factor change (increasing or decreasing) before the
     * geo_action.zoomrotate action will allow zoom.  Set to 0 to always
     * include zoom. */
    zoomrotateMinimumZoom: 0.05,
    /* The minimum number of pixels before the geo_action.zoomrotate action
     * will allow panning.  Set to 0 to always include panning. */
    zoomrotateMinimumPan: 5,
    /* The touch pan delay prevents a touch pan event from immediately
     * following a rotate (including zoom) event.  No touch pan event is
     * processed within this number of milliseconds of a non-pan touch
     * event. */
    touchPanDelay: 50,
    momentum: {
      enabled: true,
      maxSpeed: 2.5,
      minSpeed: 0.01,
      stopTime: 250,
      drag: 0.01,
      actions: [geo_action.pan, geo_action.zoom]
    },
    spring: {
      enabled: false,
      springConstant: 0.00005
    },
    zoomAnimation: {
      enabled: true,
      duration: 500,
      ease: function ease(t) {
        return (2 - t) * t;
      }
    }
  }, args || {});
  /* We don't want to merge the original arrays with arrays passed in the args,
   * so override that as necessary for actions. */
  if (args && args.actions) {
    m_options.actions = util.deepMerge([], args.actions);
  }
  if (args && args.momentum && args.momentum.actions) {
    m_options.momentum.actions = util.deepMerge([], args.momentum.actions);
  }
  if (args && args.keyboard && args.keyboard.actions !== undefined) {
    m_options.keyboard.actions = util.deepMerge({}, args.keyboard.actions);
  }

  // default mouse object
  m_mouse = {
    page: {
      x: 0,
      y: 0
    },
    // mouse position relative to the page
    map: {
      x: 0,
      y: 0
    },
    // mouse position relative to the map
    geo: {
      x: 0,
      y: 0
    },
    // mouse position in map interface gcs
    mapgcs: {
      x: 0,
      y: 0
    },
    // mouse position in map gcs
    // mouse button status
    buttons: {
      left: false,
      right: false,
      middle: false
    },
    // keyboard modifier status
    modifiers: {
      alt: false,
      ctrl: false,
      shift: false,
      meta: false
    },
    // time the event was captured
    time: new Date(),
    // time elapsed since the last mouse event
    deltaTime: 1,
    // pixels/ms
    velocity: {
      x: 0,
      y: 0
    }
  };

  /*
   * The interactor state determines what actions are taken in response to
   * core browser events.
   *
   * i.e.
   *  {
   *    'action': geo_action.pan,    * an ongoing pan event
   *    'origin': {...},       * mouse object at the start of the action
   *    'delta': {x: *, y: *} // mouse movement since action start
   *                           * not including the current event
   *  }
   *
   *  {
   *    'action': geo_action.zoom,   * an ongoing zoom event
   *    ...
   *  }
   *
   *  {
   *    'action': geo_action.rotate,   * an ongoing rotate event
   *    'origin': {...},       * mouse object at the start of the action
   *    'delta': {x: *, y: *} // mouse movement since action start
   *                           * not including the current event
   *  }
   *
   *  {
   *    'acton': geo_action.select,
   *    'origin': {...},
   *    'delta': {x: *, y: *}
   *  }
   *
   *  {
   *    'action': geo_action.momentum,
   *    'origin': {...},
   *    'handler': function () { }, // called in animation loop
   *    'timer': animate loop timer
   *  }
   */
  m_state = {};

  /**
   * Store queued map navigation commands (due to throttling) here
   * {
   *   kind: 'move' | 'wheel',  // what kind of mouse action triggered this
   *   method: function () {},  // the throttled method
   *   scroll: {x: ..., y: ...} // accumulated scroll wheel deltas
   * }
   */
  m_queue = {};

  /**
   * Process keys that we've captured.  Metakeys determine the magnitude of
   * the action.
   *
   * @param {string} action The basic action to take.
   * @param {object} evt The event with metakeys.
   * @param {object} keys Keys used to trigger the event.  `keys.simulated` is
   *    true if artificially triggered.
   * @fires geo.event.keyaction
   */
  this._handleKeys = function (action, evt, keys) {
    if (keys && keys.simulated === true) {
      evt = keys;
    }
    var meta = m_options.keyboard.meta || {
        0: {}
      },
      map = m_this.map(),
      mapSize = map.size(),
      actionBase = action,
      actionValue = '',
      value,
      factor,
      move = {};
    for (value in meta) {
      if (meta.hasOwnProperty(value)) {
        if ((meta[value].shift === undefined || evt.shiftKey === !!meta[value].shift) && (meta[value].ctrl === undefined || evt.ctrlKey === !!meta[value].ctrl) && (meta[value].alt === undefined || evt.altKey === !!meta[value].alt) && (meta[value].meta === undefined || evt.metaKey === !!meta[value].meta)) {
          factor = value;
        }
      }
    }
    if (factor === undefined) {
      /* metakeys don't match, so don't trigger an event. */
      return;
    }
    evt.stopPropagation();
    evt.preventDefault();
    if (action.indexOf('.') >= 0) {
      actionBase = action.substr(0, action.indexOf('.'));
      actionValue = action.substr(action.indexOf('.') + 1);
    }
    switch (actionBase) {
      case 'zoom':
        switch (actionValue) {
          case 'in':
            move.zoomDelta = [0.05, 0.25, 1][factor];
            break;
          case 'out':
            move.zoomDelta = -[0.05, 0.25, 1][factor];
            break;
          default:
            if (!isNaN(parseFloat(actionValue))) {
              move.zoom = parseFloat(actionValue);
            }
            break;
        }
        break;
      case 'pan':
        switch (actionValue) {
          case 'down':
            move.panY = -Math.max(1, [0, 0.05, 0.5][factor] * mapSize.height);
            break;
          case 'left':
            move.panX = Math.max(1, [0, 0.05, 0.5][factor] * mapSize.width);
            break;
          case 'right':
            move.panX = -Math.max(1, [0, 0.05, 0.5][factor] * mapSize.width);
            break;
          case 'up':
            move.panY = Math.max(1, [0, 0.05, 0.5][factor] * mapSize.height);
            break;
        }
        break;
      case 'rotate':
        switch (actionValue) {
          case 'ccw':
            move.rotationDelta = [1, 5, 90][factor] * Math.PI / 180;
            break;
          case 'cw':
            move.rotationDelta = -[1, 5, 90][factor] * Math.PI / 180;
            break;
          default:
            if (!isNaN(parseFloat(actionValue))) {
              move.rotation = parseFloat(actionValue);
            }
            break;
        }
        break;
    }
    map.geoTrigger(geo_event.keyaction, {
      move: move,
      action: action,
      factor: factor,
      event: evt
    });
    if (move.cancel) {
      return;
    }
    if (move.zoom !== undefined) {
      map.zoom(move.zoom);
    } else if (move.zoomDelta) {
      map.zoom(map.zoom() + move.zoomDelta);
    }
    if (move.rotation !== undefined) {
      map.rotation(move.rotation);
    } else if (move.rotationDelta) {
      map.rotation(map.rotation() + move.rotationDelta);
    }
    if (move.panX || move.panY) {
      map.pan({
        x: move.panX || 0,
        y: move.panY || 0
      });
    }
  };

  /**
   * Check if this browser has touch support.
   * Copied from https://github.com/hammerjs/touchemulator under the MIT
   * license.
   *
   * @returns {boolean} `true` if there is touch support.
   */
  this.hasTouchSupport = function () {
    return 'ontouchstart' in window ||
    // touch events
    window.TouchEvent || window.DocumentTouch && document instanceof window.DocumentTouch || (navigator.msMaxTouchPoints || navigator.maxTouchPoints) > 1; // pointer events
  };

  /**
   * Handle touch events.
   *
   * @param {object} evt The touch event.
   */
  this._handleTouch = function (evt) {
    var endIfBound = false;
    if (evt.pointerType === 'mouse' && m_touchHandler.touchSupport) {
      endIfBound = true;
    }
    if (evt.type === 'hammer.input') {
      if (m_touchHandler.lastEventType === 'pan' && evt.pointers.length !== 1) {
        endIfBound = true;
        m_touchHandler.lastEventType = null;
      } else {
        return;
      }
    }
    var evtType = /^(.*)(start|end|move|tap)$/.exec(evt.type);
    if (!evtType || evtType.length !== 3) {
      endIfBound = true;
    }
    if (endIfBound) {
      if (m_state.boundDocumentHandlers && m_touchHandler.lastEvent) {
        m_this._handleMouseUpDocument(m_touchHandler.lastEvent);
      }
      return;
    }
    evt.which = evtType[1];
    var time = new Date().valueOf();
    if (evt.which === 'pan' && m_touchHandler.lastEventType !== 'pan' && time - m_touchHandler.lastTime < m_options.touchPanDelay) {
      return;
    }
    m_touchHandler.lastTime = time;
    m_touchHandler.lastEventType = evt.which;
    m_touchHandler.lastEvent = evt;
    /* convert touch events to have page locations */
    if (evt.pageX === undefined && evt.center !== undefined && evt.center.x !== undefined) {
      evt.pageX = evt.center.x;
      evt.pageY = evt.center.y;
    }
    /* start events should occur *before* the triggering delta.  By using the
     * mouse handlers, we get all of the action properties we expect (and
     * actions can be changed or defined as we see fit). */
    if (evtType[2] === 'start') {
      m_this._handleMouseDown(evt);
      m_this._setClickMaybe(false);
      if (m_state.boundDocumentHandlers) {
        $(document).on('mousemove.geojs', m_this._handleMouseUpDocument);
      }
    }
    /* start and move events both trigger a movement */
    if (evtType[2] === 'start' || evtType[2] === 'move') {
      if (m_state.boundDocumentHandlers) {
        m_this._handleMouseMoveDocument(evt);
      } else {
        m_this._handleMouseMove(evt);
      }
    }
    if (evtType[2] === 'end' || evtType[2] === 'cancel') {
      if (m_state.boundDocumentHandlers) {
        m_this._handleMouseUpDocument(evt);
      } else {
        m_this._handleMouseUp(evt);
      }
      m_touchHandler.lastEvent = null;
    }
    /* tap events are represented as a mouse left button down and up. */
    if (evtType[2] === 'tap' && !m_state.boundDocumentHandlers) {
      evt.which = 1;
      m_touchHandler.lastEventType = null;
      m_this._handleMouseDown(evt);
      m_this._handleMouseUp(evt);
      m_touchHandler.lastEventType = evtType[2];
    }
  };

  /**
   * Repeat a mousemove or actionmove event with new metakey information.
   *
   * @param {event} [evt] A Mousetrap event with the key change.
   * @fires geo.event.mousemove
   * @fires geo.event.actionmove
   */
  this._repeatMouseMoveEvent = function (evt) {
    if (!m_mouse || !m_mouse.modifiers) {
      return;
    }
    var old = {
      alt: m_mouse.modifiers.alt,
      ctrl: m_mouse.modifiers.ctrl,
      meta: m_mouse.modifiers.meta,
      shift: m_mouse.modifiers.shift
    };
    m_this._getMouseModifiers(evt);
    if (m_mouse.modifiers.alt === old.alt && m_mouse.modifiers.ctrl === old.ctrl && m_mouse.modifiers.meta === old.meta && m_mouse.modifiers.shift === old.shift) {
      return;
    }
    if (m_state.boundDocumentHandlers) {
      m_this.map().geoTrigger(geo_event.actionmove, {
        state: m_this.state(),
        mouse: m_this.mouse(),
        event: evt
      });
    } else {
      m_this.map().geoTrigger(geo_event.mousemove, m_this.mouse());
    }
  };

  /**
   * Retrigger a mouse movement with the current mouse state.
   * @fires geo.event.mousemove
   */
  this.retriggerMouseMove = function () {
    m_this.map().geoTrigger(geo_event.mousemove, m_this.mouse());
  };

  /**
   * Connects events to a map.  If the map is not set, then this does nothing.
   * @returns {this}
   */
  this._connectEvents = function () {
    if (!m_options.map) {
      return m_this;
    }

    // prevent double binding to DOM elements
    m_this._disconnectEvents();

    // store the connected element
    $node = $(m_options.map.node());

    // set methods related to asynchronous event handling
    m_this._handleMouseWheel = throttled_wheel();
    m_callZoom = debounced_zoom();

    // catalog what inputs we are using
    util.adjustActions(m_options.actions);
    var usedInputs = {};
    ['right', 'pan', 'rotate'].forEach(function (input) {
      usedInputs[input] = m_options.actions.some(function (action) {
        return action.input[input];
      });
    });
    // add event handlers
    $node.on('wheel.geojs', m_this._handleMouseWheel);
    $node.on('mousemove.geojs', m_this._handleMouseMove);
    $node.on('mousedown.geojs', m_this._handleMouseDown);
    $node.on('mouseup.geojs', m_this._handleMouseUp);
    // Disable dragging images and such
    $node.on('dragstart', function () {
      return false;
    });
    if (usedInputs.right) {
      $node.on('contextmenu.geojs', function () {
        return false;
      });
    }

    // bind keyboard events
    if (m_options.keyboard && m_options.keyboard.actions) {
      m_keyHandler = Mousetrap($node[0]);
      var bound = [];
      for (var keyAction in m_options.keyboard.actions) {
        if (m_options.keyboard.actions.hasOwnProperty(keyAction)) {
          m_keyHandler.bind(m_options.keyboard.actions[keyAction], function (action) {
            return function (evt, keys) {
              m_this._handleKeys(action, evt, keys);
            };
          }(keyAction));
          bound = bound.concat(m_options.keyboard.actions[keyAction]);
        }
      }
      if (m_options.keyboard.metakeyMouseEvents) {
        m_options.keyboard.metakeyMouseEvents.forEach(function (meta) {
          m_keyHandler.bind(meta, m_this._repeatMouseMoveEvent, 'keydown');
          m_keyHandler.bind(meta, m_this._repeatMouseMoveEvent, 'keyup');
          bound.push(meta);
        });
      }
      m_boundKeys = bound;
    }
    $node.toggleClass('highlight-focus', !!(m_boundKeys && m_boundKeys.length && m_options.keyboard.focusHighlight));
    // bind touch events
    if ((m_this.hasTouchSupport() || m_options.alwaysTouch) && (usedInputs.pan || usedInputs.rotate)) {
      // webpack expects optional dependencies to be wrapped in a try-catch
      var Hammer;
      try {
        Hammer = __webpack_require__(7606);
        if (!Hammer || !Hammer.Manager) {
          Hammer = undefined;
        }
      } catch (_error) {}
      if (Hammer !== undefined) {
        var recog = [],
          touchEvents = ['hammer.input'];
        if (usedInputs.rotate) {
          recog.push([Hammer.Rotate, {
            enable: true
          }]);
          touchEvents = touchEvents.concat(['rotatestart', 'rotateend', 'rotatemove']);
        }
        if (usedInputs.pan) {
          recog.push([Hammer.Pan, {
            direction: Hammer.DIRECTION_ALL
          }]);
          touchEvents = touchEvents.concat(['panstart', 'panend', 'panmove']);
        }
        /* Always handle tap events.  Reject double taps. */
        recog.push([Hammer.Tap, {
          event: 'doubletap',
          taps: 2
        }]);
        recog.push([Hammer.Tap, {
          event: 'singletap'
        }, undefined, ['doubletap']]);
        touchEvents = touchEvents.concat(['singletap']);
        var hammerParams = {
          recognizers: recog,
          preventDefault: true
        };
        m_touchHandler = {
          manager: new Hammer.Manager($node[0], hammerParams),
          touchSupport: m_this.hasTouchSupport(),
          lastTime: 0
        };
        m_touchHandler.manager.get('doubletap').recognizeWith('singletap');
        touchEvents.forEach(function (touchEvent) {
          m_touchHandler.manager.on(touchEvent, m_this._handleTouch);
        });
      }
    }
    return m_this;
  };

  /**
   * Disconnects events to a map.  If the map is not set, then this does
   * nothing.
   * @returns {this}
   */
  this._disconnectEvents = function () {
    if (m_boundKeys) {
      if (m_keyHandler) {
        m_keyHandler.unbind(m_boundKeys);
      }
      m_boundKeys = null;
      m_keyHandler = null;
    }
    if (m_touchHandler) {
      m_touchHandler.manager.destroy();
      m_touchHandler = null;
    }
    if ($node) {
      $node.off('.geojs');
      $node = null;
    }
    m_this._handleMouseWheel = function () {};
    m_callZoom = function m_callZoom() {};
    return m_this;
  };

  /**
   * Get or set the map for this interactor, adds draw region layer if needed.
   *
   * @param {geo.map} [val] Either a new map object for `undefined` to return
   *    the current map object.
   * @returns {geo.map|this} Either the current map object or the
   *    mapInteractor class instance.
   */
  this.map = function (val) {
    if (val !== undefined) {
      m_options.map = val;
      m_this._connectEvents();
      return m_this;
    }
    return m_options.map;
  };

  /**
   * Gets/sets the options object for the interactor.
   *
   * @param {geo.mapInteractor.spec} opts Options to set.
   * @returns {geo.mapInteractor.spec|this}
   */
  this.options = function (opts) {
    if (opts === undefined) {
      return Object.assign({}, m_options);
    }
    Object.assign(m_options, opts);

    // reset event handlers for new options
    m_this._connectEvents();
    return m_this;
  };

  /**
   * Stores the current mouse position from an event.
   *
   * @param {jQuery.Event} evt JQuery event with the mouse position.
   */
  this._getMousePosition = function (evt) {
    if (evt.pageX === undefined || evt.pageY === undefined) {
      return;
    }
    var offset = $node.offset(),
      dt,
      t;
    t = new Date().valueOf();
    dt = t - m_mouse.time;
    m_mouse.time = t;
    m_mouse.deltaTime = dt;
    m_mouse.velocity = {
      x: (evt.pageX - m_mouse.page.x) / dt,
      y: (evt.pageY - m_mouse.page.y) / dt
    };
    m_mouse.page = {
      x: evt.pageX,
      y: evt.pageY
    };
    m_mouse.map = {
      x: evt.pageX - offset.left,
      y: evt.pageY - offset.top
    };
    try {
      m_mouse.geo = m_this.map().displayToGcs(m_mouse.map);
      m_mouse.mapgcs = m_this.map().displayToGcs(m_mouse.map, null);
    } catch (e) {
      // catch georeferencing problems and move on
      m_mouse.geo = m_mouse.mapgcs = null;
    }
  };

  /**
   * Stores the current mouse button state in the m_mouse object.
   *
   * @param {jQuery.Event} evt The event that trigger the mouse action.
   */
  this._getMouseButton = function (evt) {
    if (evt.buttons === undefined && evt.which === undefined) {
      return;
    }
    for (var prop in m_mouse.buttons) {
      if (m_mouse.buttons.hasOwnProperty(prop)) {
        m_mouse.buttons[prop] = false;
      }
    }
    /* If the event buttons are specified, use them in preference to the
     * evt.which for determining which buttons are down.  buttons is a bitfield
     * and therefore can represent more than one button at a time. */
    if (evt.buttons !== undefined) {
      m_mouse.buttons.left = !!(evt.buttons & 1);
      m_mouse.buttons.right = !!(evt.buttons & 2);
      m_mouse.buttons.middle = !!(evt.buttons & 4);
    } else if (evt.type !== 'mouseup') {
      /* If we don't evt.buttons, fall back to which, but not on mouseup. */
      switch (evt.which) {
        case 1:
          m_mouse.buttons.left = true;
          break;
        case 2:
          m_mouse.buttons.middle = true;
          break;
        case 3:
          m_mouse.buttons.right = true;
          break;
      }
    }
    /* When handling touch events, evt.which can be a string, in which case
     * handle a "button" with that name -- a non-integer string will not
     * evaluate as being between 1 and 3. */
    if (evt.which && !(evt.which >= 1 && evt.which <= 3)) {
      m_mouse.buttons[evt.which] = true;
    }
  };

  /**
   * Stores the current keyboard modifiers from an event in the m_mouse
   * object.
   *
   * @param {jQuery.Event} evt JQuery event with the keyboard modifiers.
   */
  this._getMouseModifiers = function (evt) {
    m_mouse.modifiers.alt = evt.altKey;
    m_mouse.modifiers.ctrl = evt.ctrlKey;
    m_mouse.modifiers.meta = evt.metaKey;
    m_mouse.modifiers.shift = evt.shiftKey;
  };

  /**
   * Compute a selection information object.
   *
   * @private
   * @returns {geo.brushSelection}
   */
  this._getSelection = function () {
    var origin = m_state.origin,
      mouse = m_this.mouse(),
      map = m_this.map(),
      display = {},
      gcs = {};
    var mousexy = mouse.map;
    if (m_state.actionRecord && util.isFunction(m_state.actionRecord.selectionConstraint)) {
      var constraint = m_state.actionRecord.selectionConstraint(mouse.mapgcs, origin.mapgcs);
      mousexy = constraint ? map.gcsToDisplay(constraint.pos, null) : mousexy;
    } else if (mouse.modifiers.shift) {
      var width = Math.pow(Math.abs((mousexy.x - origin.map.x) * (mousexy.y - origin.map.y)), 0.5);
      mousexy = {
        x: origin.map.x + Math.sign(mousexy.x - origin.map.x) * width,
        y: origin.map.y + Math.sign(mousexy.y - origin.map.y) * width
      };
    }
    // Get the display coordinates
    display.upperLeft = {
      x: Math.min(origin.map.x, mousexy.x),
      y: Math.min(origin.map.y, mousexy.y)
    };
    display.lowerRight = {
      x: Math.max(origin.map.x, mousexy.x),
      y: Math.max(origin.map.y, mousexy.y)
    };
    display.upperRight = {
      x: display.lowerRight.x,
      y: display.upperLeft.y
    };
    display.lowerLeft = {
      x: display.upperLeft.x,
      y: display.lowerRight.y
    };

    // Get the gcs coordinates
    gcs.upperLeft = map.displayToGcs(display.upperLeft, null);
    gcs.lowerRight = map.displayToGcs(display.lowerRight, null);
    gcs.upperRight = map.displayToGcs(display.upperRight, null);
    gcs.lowerLeft = map.displayToGcs(display.lowerLeft, null);
    m_selectionQuad.data([{
      ul: gcs.upperLeft,
      ur: gcs.upperRight,
      ll: gcs.lowerLeft,
      lr: gcs.lowerRight
    }]);
    m_selectionQuad.draw();
    return {
      display: display,
      gcs: gcs,
      mouse: mouse,
      origin: Object.assign({}, m_state.origin)
    };
  };

  /**
   * Immediately cancel an ongoing action.
   *
   * @param {string?} action The action type, if `null` cancel any action.
   * @param {boolean} [keepQueue] If truthy, keep the queue event if an action
   *    is canceled.
   * @returns {boolean} Set if an action was canceled.
   */
  this.cancel = function (action, keepQueue) {
    var out;
    if (!action) {
      out = !!m_state.action;
    } else {
      out = m_state.action === action;
    }
    if (out) {
      // cancel any queued interaction events
      if (!keepQueue) {
        m_queue = {};
      }
      clearState();
    }
    return out;
  };

  /**
   * Set the value of whether a click is possible.  Cancel any outstanding
   * timer for this process.
   *
   * @param {false|object} value If `false`, there is no chance of a future
   *    click.  If an object with coordinates and the mouse button state,
   *    a click is possible if the same button is released nearby.
   */
  this._setClickMaybe = function (value) {
    m_clickMaybe = value;
    if (m_clickMaybeTimeout) {
      window.clearTimeout(m_clickMaybeTimeout);
      m_clickMaybeTimeout = null;
    }
  };

  /**
   * Handle event when a mouse button is pressed.
   *
   * @param {jQuery.Event} evt The event that triggered this.
   * @fires geo.event.brushstart
   * @fires geo.event.actiondown
   * @fires geo.event.mousedown
   */
  this._handleMouseDown = function (evt) {
    var action, actionRecord;
    if (m_paused) {
      return;
    }
    /* In some scenarios, we get both a tap event and then, somewhat later, a
     * set of mousedown/mouseup events.  Ignore the spurious down/up set if we
     * just handled a tap. */
    if (m_touchHandler && m_touchHandler.lastEventType === 'tap' && new Date().valueOf() - m_touchHandler.lastTime < 1000) {
      return;
    }
    m_this._getMousePosition(evt);
    m_this._getMouseButton(evt);
    m_this._getMouseModifiers(evt);
    m_this.map().geoTrigger(geo_event.mousedown, m_this.mouse());
    if (m_options.click.enabled && (!m_mouse.buttons.left || m_options.click.buttons.left) && (!m_mouse.buttons.right || m_options.click.buttons.right) && (!m_mouse.buttons.middle || m_options.click.buttons.middle)) {
      m_this._setClickMaybe({
        x: m_mouse.page.x,
        y: m_mouse.page.y,
        buttons: Object.assign({}, m_mouse.buttons)
      });
      if (m_options.click.duration > 0) {
        m_clickMaybeTimeout = window.setTimeout(function () {
          m_clickMaybe = false;
          m_clickMaybeTimeout = null;
        }, m_options.click.duration);
      }
    }
    actionRecord = actionMatch(m_mouse.buttons, m_mouse.modifiers, m_options.actions);
    action = (actionRecord || {}).action;
    var map = m_this.map();
    // cancel transitions and momentum on click
    map.transitionCancel('_handleMouseDown' + (action ? '.' + action : ''));
    m_this.cancel(geo_action.momentum);
    m_mouse.velocity = {
      x: 0,
      y: 0
    };
    if (action) {
      // cancel any ongoing interaction queue
      m_queue = {
        kind: 'move'
      };

      // store the state object
      m_nextStateId += 1;
      m_state = {
        action: action,
        actionRecord: actionRecord,
        origin: util.deepMerge({}, m_mouse),
        initialZoom: map.zoom(),
        initialRotation: map.rotation(),
        initialEventRotation: evt.rotation,
        stateId: m_nextStateId,
        delta: {
          x: 0,
          y: 0
        }
      };
      if (actionRecord.selectionRectangle) {
        // Make sure the old selection layer is gone.
        if (m_selectionLayer) {
          m_selectionLayer.clear();
          map.deleteLayer(m_selectionLayer);
          m_selectionLayer = null;
        }
        m_selectionLayer = map.createLayer('feature', {
          features: [quadFeature.capabilities.color],
          autoshareRenderer: false
        });
        m_selectionQuad = m_selectionLayer.createFeature('quad', {
          gcs: map.gcs()
        });
        m_selectionQuad.style({
          opacity: 0.25,
          color: {
            r: 0.3,
            g: 0.3,
            b: 0.3
          }
        });
        map.geoTrigger(geo_event.brushstart, m_this._getSelection());
      }
      map.geoTrigger(geo_event.actiondown, {
        state: m_this.state(),
        mouse: m_this.mouse(),
        event: evt
      });

      // bind temporary handlers to document
      if (m_options.throttle > 0) {
        $(document).on('mousemove.geojs', throttle(m_options.throttle, m_this._handleMouseMoveDocument));
      } else {
        $(document).on('mousemove.geojs', m_this._handleMouseMoveDocument);
      }
      $(document).on('mouseup.geojs', m_this._handleMouseUpDocument);
      m_state.boundDocumentHandlers = true;
    }
  };

  /**
   * Handle mouse move event.
   *
   * @param {jQuery.Event} evt The event that triggered this.
   * @fires geo.event.mousemove
   */
  this._handleMouseMove = function (evt) {
    if (m_paused) {
      return;
    }
    if (m_state.boundDocumentHandlers) {
      // If currently performing a navigation action, the mouse
      // coordinates will be captured by the document handler.
      return;
    }
    if (m_options.click.cancelOnMove && m_clickMaybe) {
      m_this._setClickMaybe(false);
    }
    m_this._getMousePosition(evt);
    m_this._getMouseButton(evt);
    m_this._getMouseModifiers(evt);
    if (m_clickMaybe) {
      return;
    }
    m_this.map().geoTrigger(geo_event.mousemove, m_this.mouse());
  };

  /**
   * Handle the zoomrotate action.
   *
   * @param {object} evt The mouse event that triggered this.
   */
  this._handleZoomrotate = function (evt) {
    /* Only zoom if we have once exceeded the initial zoom threshold. */
    var deltaZoom = Math.log2(evt.scale);
    if (!m_state.zoomrotateAllowZoom && deltaZoom && Math.abs(deltaZoom) >= Math.log2(1 + m_options.zoomrotateMinimumZoom)) {
      if (m_options.zoomrotateMinimumZoom) {
        m_state.initialZoom -= deltaZoom;
      }
      m_state.zoomrotateAllowZoom = true;
    }
    if (m_state.zoomrotateAllowZoom && deltaZoom) {
      var zoom = m_state.initialZoom + deltaZoom;
      m_this.map().zoom(zoom, m_state.origin);
    }
    /* Only rotate if we have once exceeded the initial rotation threshold.  The
     * first time this happens (if the threshold is greater than zero), set the
     * start of rotation to the current position, so that there is no sudden
     * jump. */
    var deltaTheta = (evt.rotation - m_state.initialEventRotation) * Math.PI / 180;
    if (!m_state.zoomrotateAllowRotation && deltaTheta && Math.abs(deltaTheta) >= m_options.zoomrotateMinimumRotation) {
      if (m_options.zoomrotateMinimumRotation) {
        m_state.initialEventRotation = evt.rotation;
        deltaTheta = 0;
      }
      m_state.zoomrotateAllowRotation = true;
    }
    if (m_state.zoomrotateAllowRotation) {
      var theta = m_state.initialRotation + deltaTheta;
      /* Compute the delta in the range of [-PI, PI). */
      deltaTheta = util.wrapAngle(theta - m_this.map().rotation());
      /* If we reverse direction, don't rotate until some threshold is
       * exceeded.  This helps prevent rotation bouncing while panning. */
      if (deltaTheta && (deltaTheta * (m_state.lastRotationDelta || 0) >= 0 || Math.abs(deltaTheta) >= m_options.zoomrotateReverseRotation)) {
        m_this.map().rotation(theta, m_state.origin);
        m_state.lastRotationDelta = deltaTheta;
      }
    }
    /* Only pan if we have once exceed the initial pan threshold. */
    var panOrigin = m_state.origin.page;
    if (m_state.initialEventGeo) {
      var offset = $node.offset();
      panOrigin = m_this.map().gcsToDisplay(m_state.initialEventGeo);
      panOrigin.x += offset.left;
      panOrigin.y += offset.top;
    }
    var x = evt.pageX,
      deltaX = x - panOrigin.x,
      y = evt.pageY,
      deltaY = y - panOrigin.y,
      deltaPan2 = deltaX * deltaX + deltaY * deltaY;
    if (!m_state.zoomrotateAllowPan && deltaPan2 && deltaPan2 >= m_options.zoomrotateMinimumPan * m_options.zoomrotateMinimumPan) {
      if (m_options.zoomrotateMinimumPan) {
        deltaX = deltaY = 0;
        m_state.initialEventGeo = m_this.mouse().geo;
      } else {
        m_state.initialEventGeo = m_state.origin.geo;
      }
      m_state.zoomrotateAllowPan = true;
    }
    if (m_state.zoomrotateAllowPan && (deltaX || deltaY)) {
      m_this.map().pan({
        x: deltaX,
        y: deltaY
      });
    }
  };

  /**
   * Handle mouse move event on the document (temporary bindings).
   *
   * @param {jQuery.Event} evt The event that triggered this.
   * @fires geo.event.brush
   * @fires geo.event.actionmove
   */
  this._handleMouseMoveDocument = function (evt) {
    var dx, dy, selectionObj;

    // If the map has been disconnected, we do nothing.
    if (!m_this.map()) {
      return;
    }
    if (m_paused || m_queue.kind !== 'move') {
      return;
    }
    m_this._getMousePosition(evt);
    m_this._getMouseButton(evt);
    m_this._getMouseModifiers(evt);

    /* Only cancel possible clicks on move if we actually moved */
    if (m_options.click.cancelOnMove) {
      if (m_clickMaybe.x === undefined || m_clickMaybe.y === undefined) {
        m_this._setClickMaybe(false);
      } else if (m_options.click.cancelOnMove === true && (m_mouse.page.x !== m_clickMaybe.x || m_mouse.page.y !== m_clickMaybe.y)) {
        m_this._setClickMaybe(false);
      } else {
        var dist = Math.sqrt(Math.pow(m_mouse.page.x - m_clickMaybe.x, 2) + Math.pow(m_mouse.page.y - m_clickMaybe.y, 2));
        if (dist >= m_options.click.cancelOnMove) {
          m_this._setClickMaybe(false);
        }
      }
    }
    if (m_clickMaybe) {
      return;
    }
    if (!m_state.action) {
      // This shouldn't happen
      console.log('WARNING: Invalid state in mapInteractor.'); // eslint-disable-line no-console
      return;
    }

    // calculate the delta from the origin point to avoid
    // accumulation of floating point errors
    dx = m_mouse.map.x - m_state.origin.map.x - m_state.delta.x;
    dy = m_mouse.map.y - m_state.origin.map.y - m_state.delta.y;
    m_state.delta.x += dx;
    m_state.delta.y += dy;
    if (m_state.action === geo_action.pan) {
      m_this.map().pan({
        x: dx,
        y: dy
      }, undefined, 'limited');
    } else if (m_state.action === geo_action.zoom) {
      m_callZoom(-dy * m_options.zoomScale / 120, m_state);
    } else if (m_state.action === geo_action.rotate) {
      var cx, cy;
      if (m_state.origin.rotation === undefined) {
        cx = m_state.origin.map.x - m_this.map().size().width / 2;
        cy = m_state.origin.map.y - m_this.map().size().height / 2;
        m_state.origin.rotation = m_this.map().rotation() - Math.atan2(cy, cx);
      }
      cx = m_mouse.map.x - m_this.map().size().width / 2;
      cy = m_mouse.map.y - m_this.map().size().height / 2;
      m_this.map().rotation(m_state.origin.rotation + Math.atan2(cy, cx));
    } else if (m_state.action === geo_action.zoomrotate) {
      m_this._handleZoomrotate(evt);
    } else if (m_state.actionRecord.selectionRectangle) {
      // Get the bounds of the current selection
      selectionObj = m_this._getSelection();
      m_this.map().geoTrigger(geo_event.brush, selectionObj);
    }
    m_this.map().geoTrigger(geo_event.actionmove, {
      state: m_this.state(),
      mouse: m_this.mouse(),
      event: evt
    });

    // Prevent default to stop text selection in particular
    evt.preventDefault();
  };

  /**
   * Clear the action state, but remember if we have bound document handlers.
   * @private
   */
  function clearState() {
    m_state = {
      boundDocumentHandlers: m_state.boundDocumentHandlers
    };
  }

  /**
   * Use interactor options to modify the mouse velocity by momentum
   * or spring equations depending on the current map state.
   * @private
   * @param {object} v Current velocity in pixels / millisecond.
   * @param {number} deltaT The time delta.
   * @returns {object} New velocity.
   */
  function modifyVelocity(v, deltaT) {
    deltaT = deltaT <= 0 ? 30 : deltaT;
    var sf = springForce();
    var speed = calcSpeed(v);
    var vx = v.x / speed;
    var vy = v.y / speed;
    speed = speed * Math.exp(-m_options.momentum.drag * deltaT);

    // |force| + |velocity| < c <- stopping condition
    if (calcSpeed(sf) * deltaT + speed < m_options.momentum.minSpeed) {
      return null;
    }
    if (speed > 0) {
      vx = vx * speed;
      vy = vy * speed;
    } else {
      vx = 0;
      vy = 0;
    }
    return {
      x: vx - sf.x * deltaT,
      y: vy - sf.y * deltaT
    };
  }

  /**
   * Get the spring force for the current map bounds.
   * @private
   * @returns {object} The spring force.
   */
  function springForce() {
    var xplus,
      // force to the right
      xminus,
      // force to the left
      yplus,
      // force to the top
      yminus; // force to the bottom

    if (!m_options.spring.enabled) {
      return {
        x: 0,
        y: 0
      };
    }
    // get screen coordinates of corners
    var maxBounds = m_this.map().maxBounds(undefined, null);
    var ul = m_this.map().gcsToDisplay({
      x: maxBounds.left,
      y: maxBounds.top
    }, null);
    var lr = m_this.map().gcsToDisplay({
      x: maxBounds.right,
      y: maxBounds.bottom
    }, null);
    var c = m_options.spring.springConstant;
    // Arg... map needs to expose the canvas size
    var width = m_this.map().node().width();
    var height = m_this.map().node().height();
    xplus = c * Math.max(0, ul.x);
    xminus = c * Math.max(0, width - lr.x);
    yplus = c * Math.max(0, ul.y) / 2;
    yminus = c * Math.max(0, height - lr.y) / 2;
    return {
      x: xplus - xminus,
      y: yplus - yminus
    };
  }

  /**
   * Based on the screen coordinates of a selection, zoom or unzoom and
   * recenter.
   *
   * @private
   * @param {string} action Either `geo_action.zoomselect` or
   *    `geo_action.unzoomselect`.
   * @param {object} lowerLeft The x and y coordinates of the lower left corner
   *    of the zoom rectangle.
   * @param {object} upperRight The x and y coordinates of the upper right
   *    corner of the zoom rectangle.
   */
  this._zoomFromSelection = function (action, lowerLeft, upperRight) {
    if (action !== geo_action.zoomselect && action !== geo_action.unzoomselect) {
      return;
    }
    if (lowerLeft.x === upperRight.x || lowerLeft.y === upperRight.y) {
      return;
    }
    var zoom,
      center,
      map = m_this.map(),
      mapsize = map.size();
    /* To arbitrarily handle rotation and projection, we center the map at the
     * central coordinate of the selection and set the zoom level such that the
     * four corners are just barely on the map.  When unzooming (zooming out),
     * we ensure that the previous view is centered in the selection but use
     * the maximal size for the zoom factor. */
    var scaling = {
      x: Math.abs((upperRight.x - lowerLeft.x) / mapsize.width),
      y: Math.abs((upperRight.y - lowerLeft.y) / mapsize.height)
    };
    if (action === geo_action.zoomselect) {
      center = map.displayToGcs({
        x: (lowerLeft.x + upperRight.x) / 2,
        y: (lowerLeft.y + upperRight.y) / 2
      }, null);
      zoom = map.zoom() - Math.log2(Math.max(scaling.x, scaling.y));
    } else {
      /* unzoom */
      /* To make the existing visible map entirely within the selection
       * rectangle, this would be changed to Math.min instead of Math.max of
       * the scaling factors.  This felt wrong, though. */
      zoom = map.zoom() + Math.log2(Math.max(scaling.x, scaling.y));
      /* Record the current center.  Later, this is panned to the center of the
       * selection rectangle. */
      center = map.center(undefined, null);
    }
    /* When discrete zoom is enable, always round down.  We have to do this
     * explicitly, as otherwise we may zoom too far and the selection will not
     * be completely visible. */
    if (map.discreteZoom()) {
      zoom = Math.floor(zoom);
    }
    map.zoom(zoom);
    if (action === geo_action.zoomselect) {
      map.center(center, null);
    } else {
      var newcenter = map.gcsToDisplay(center, null);
      map.pan({
        x: (lowerLeft.x + upperRight.x) / 2 - newcenter.x,
        y: (lowerLeft.y + upperRight.y) / 2 - newcenter.y
      });
    }
  };

  /**
   * Handle event when a mouse button is unpressed on the document.
   * Removes temporary bindings.
   *
   * @param {jQuery.Event} evt The event that triggered this.
   * @fires geo.event.brushend
   * @fires geo.event.actionselection
   * @fires geo.event.actionup
   * @fires geo.event.mouseup
   * @fires geo.event.select
   * @fires geo.event.zoomselect
   * @fires geo.event.unzoomselect
   */
  this._handleMouseUpDocument = function (evt) {
    var selectionObj, oldAction;
    if (m_paused) {
      return;
    }

    // cancel queued interactions
    m_queue = {};
    m_this._setClickMaybe(false);
    m_this._getMouseButton(evt);
    m_this._getMouseModifiers(evt);

    // unbind temporary handlers on document
    $(document).off('.geojs');
    m_state.boundDocumentHandlers = false;
    if (m_mouse.buttons.right) {
      evt.preventDefault();
    }
    if (m_state.actionRecord && m_state.actionRecord.selectionRectangle) {
      m_this._getMousePosition(evt);
      selectionObj = m_this._getSelection();
      m_selectionLayer.clear();
      m_this.map().deleteLayer(m_selectionLayer);
      m_selectionLayer = null;
      m_selectionQuad = null;
      m_this.map().geoTrigger(geo_event.brushend, selectionObj);
      if (m_state.actionRecord.selectionRectangle !== true) {
        m_this.map().geoTrigger(m_state.actionRecord.selectionRectangle, selectionObj);
      }
      m_this._zoomFromSelection(m_state.action, selectionObj.display.lowerLeft, selectionObj.display.upperRight);
      m_this.map().geoTrigger(geo_event.actionselection, {
        state: m_this.state(),
        mouse: m_this.mouse(),
        event: evt,
        lowerLeft: selectionObj.display.lowerLeft,
        upperRight: selectionObj.display.upperRight
      });
    }
    m_this.map().geoTrigger(geo_event.actionup, {
      state: m_this.state(),
      mouse: m_this.mouse(),
      event: evt
    });

    // reset the interactor state
    oldAction = m_state.action;
    clearState();

    // if momentum is enabled, start the action here
    if (m_options.momentum.enabled && m_options.momentum.actions.includes(oldAction)) {
      var t = new Date().valueOf();
      var dt = t - m_mouse.time + m_mouse.deltaTime;
      if (t - m_mouse.time < m_options.momentum.stopTime) {
        m_mouse.velocity.x *= m_mouse.deltaTime / dt;
        m_mouse.velocity.y *= m_mouse.deltaTime / dt;
        m_mouse.deltaTime = dt;
      } else {
        m_mouse.velocity.x = m_mouse.velocity.y = 0;
      }
      m_this.springBack(true, oldAction);
    }
  };

  /**
   * Handle event when a mouse button is unpressed.
   *
   * @param {jQuery.Event} evt The event that triggered this.
   */
  this._handleMouseUp = function (evt) {
    if (m_paused) {
      return;
    }
    m_this._getMouseButton(evt);
    if (m_clickMaybe) {
      m_this._handleMouseClick(evt);
    }
    var details = m_this.mouse();
    details.buttonsDown = m_clickMaybe.buttons;
    m_this.map().geoTrigger(geo_event.mouseup, details);
  };

  /**
   * Handle event when a mouse click is detected.  A mouse click is a simulated
   * event that occurs when the time between a mouse down and mouse up
   * is less than the configured duration and (optionally) if no mousemove
   * events were triggered in the interim.
   *
   * @param {jQuery.Event} evt The event that triggered this.
   * @fires geo.event.mouseup
   */
  this._handleMouseClick = function (evt) {
    /* Cancel a selection if it is occurring */
    if (m_state.actionRecord && m_state.actionRecord.selectionRectangle) {
      m_selectionLayer.clear();
      m_this.map().deleteLayer(m_selectionLayer);
      m_selectionLayer = null;
      m_selectionQuad = null;
      m_state.action = m_state.actionRecord = null;
    }
    m_this._getMouseButton(evt);
    m_this._getMouseModifiers(evt);

    // cancel any ongoing pan action
    m_this.cancel(geo_action.pan);

    // unbind temporary handlers on document
    $(document).off('.geojs');
    m_state.boundDocumentHandlers = false;
    // add information about the button state to the event information
    var details = m_this.mouse();
    details.buttonsDown = m_clickMaybe.buttons;
    details.evt = evt;

    // reset click detector variable
    m_this._setClickMaybe(false);
    // fire a click event
    m_this.map().geoTrigger(geo_event.mouseclick, details);
  };

  /**
   * Private wrapper around the map zoom method that is debounced to support
   * discrete zoom interactions.
   *
   * @returns {Function} A function to handle zooms that debounces such
   *    events.  This function is passed the zoom level and the mouse state.
   */
  function debounced_zoom() {
    var deltaZ = 0,
      delay = 400,
      origin,
      startZoom,
      targetZoom;
    function accum(dz, org) {
      var map = m_this.map(),
        zoom;
      origin = util.deepMerge({}, org);
      deltaZ += dz;
      if (targetZoom === undefined) {
        startZoom = targetZoom = map.zoom();
      }
      targetZoom += dz;

      // Respond to debounced events when they add up to a change in the
      // discrete zoom level.
      if (map && Math.abs(deltaZ) >= 1 && m_options.discreteZoom && !m_options.zoomAnimation.enabled) {
        zoom = Math.round(deltaZ + map.zoom());

        // delta is what is left over from the zoom delta after the new zoom
        // value
        deltaZ = deltaZ + map.zoom() - zoom;
        map.zoom(zoom, origin);
      }
    }
    function apply() {
      var map = m_this.map(),
        zoom;
      if (map) {
        if (m_options.zoomAnimation.enabled) {
          zoom = targetZoom;
          if (m_options.discreteZoom) {
            zoom = Math.round(zoom);
            if (zoom === startZoom && targetZoom !== startZoom) {
              zoom = startZoom + (targetZoom > startZoom ? 1 : -1);
            }
          }
          zoom = Math.round(map._fix_zoom(zoom) * 1e6) / 1e6;
          if (zoom !== map.zoom()) {
            map.transitionCancel('debounced_zoom.' + geo_action.zoom);
            map.transition({
              zoom: zoom,
              zoomOrigin: origin,
              duration: m_options.zoomAnimation.duration,
              ease: m_options.zoomAnimation.ease,
              done: function done(status) {
                status = status || {};
                var zoomRE = new RegExp('\\.' + geo_action.zoom + '$');
                if (!status.next && (!status.cancel || ('' + status.source).search(zoomRE) < 0)) {
                  targetZoom = undefined;
                }
                /* If we were animating the zoom, if the zoom is continuous, just
                 * stop where we are.  If using discrete zoom, we need to make
                 * sure we end up discrete.  However, we don't want to do that if
                 * the next action is further zooming. */
                if (m_options.discreteZoom && status.cancel && status.transition && status.transition.end && ('' + status.source).search(zoomRE) < 0) {
                  map.zoom(status.transition.end.zoom, status.transition.end.zoomOrigin);
                }
              }
            });
          } else {
            targetZoom = undefined;
          }
        } else {
          zoom = deltaZ + map.zoom();
          if (m_options.discreteZoom) {
            // round off the zoom to an integer and throw away the rest
            zoom = Math.round(zoom);
          }
          map.zoom(zoom, origin);
        }
      }
      deltaZ = 0;
    }
    if (m_options.discreteZoom !== true && m_options.discreteZoom > 0) {
      delay = m_options.discreteZoom;
    }
    if ((m_options.discreteZoom === true || m_options.discreteZoom > 0) && !m_options.zoomAnimation.enabled) {
      return debounce(delay, false, apply, accum);
    } else {
      return function (dz, org) {
        if (!dz && targetZoom === undefined) {
          return;
        }
        accum(dz, org);
        apply();
      };
    }
  }

  /**
   * Attaches wrapped methods for accumulating fast mouse wheel events and
   * throttling map interactions.
   * @private
   *
   * @returns {Function} A function that takes a jQuery.Event for mouse wheel
   *    actions.
   * @fires geo.event.actionwheel
   */
  function throttled_wheel() {
    var my_queue = {};
    function accum(evt) {
      var dx, dy;
      if (m_paused) {
        return;
      }
      if (my_queue !== m_queue) {
        my_queue = {
          kind: 'wheel',
          scroll: {
            x: 0,
            y: 0
          }
        };
        m_queue = my_queue;
      }
      evt.preventDefault();

      // try to normalize deltas using the wheel event standard:
      //   https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent
      evt.deltaFactor = 1;
      if (evt.originalEvent.deltaMode === 1) {
        // DOM_DELTA_LINE -- estimate line height
        evt.deltaFactor = 40;
      } else if (evt.originalEvent.deltaMode === 2) {
        // DOM_DELTA_PAGE -- get window height
        evt.deltaFactor = $(window).height();
      }

      // prevent NaN's on legacy browsers
      dx = evt.originalEvent.deltaX || 0;
      dy = evt.originalEvent.deltaY || 0;

      // scale according to the options
      dx = dx * m_options.wheelScaleX * evt.deltaFactor / 120;
      dy = dy * m_options.wheelScaleY * evt.deltaFactor / 120;
      my_queue.scroll.x += dx;
      my_queue.scroll.y += dy;
    }
    function wheel(evt) {
      var zoomFactor, action, actionRecord;

      // If the current queue doesn't match the queue passed in as an argument,
      // assume it was cancelled and do nothing.
      if (my_queue !== m_queue) {
        return;
      }

      // perform the map navigation event
      m_this._getMousePosition(evt);
      m_this._getMouseButton(evt);
      m_this._getMouseModifiers(evt);
      actionRecord = actionMatch({
        wheel: true
      }, m_mouse.modifiers, m_options.actions);
      action = (actionRecord || {}).action;
      if (action) {
        // if we were moving because of momentum or a transition, cancel it and
        // recompute where the mouse action is occurring.
        var recompute = m_this.map().transitionCancel('wheel.' + action);
        recompute |= m_this.cancel(geo_action.momentum, true);
        if (recompute) {
          m_mouse.geo = m_this.map().displayToGcs(m_mouse.map);
          m_mouse.mapgcs = m_this.map().displayToGcs(m_mouse.map, null);
        }
        switch (action) {
          case geo_action.pan:
            m_this.map().pan({
              x: m_queue.scroll.x,
              y: m_queue.scroll.y
            }, undefined, 'limited');
            break;
          case geo_action.zoom:
            zoomFactor = -m_queue.scroll.y;
            m_callZoom(zoomFactor, m_mouse);
            break;
          case geo_action.rotate:
            m_this.map().rotation(m_this.map().rotation() + m_queue.scroll.y * m_options.rotateWheelScale, m_mouse);
            break;
        }
        m_this.map().geoTrigger(geo_event.actionwheel, {
          state: m_this.state(),
          mouse: m_this.mouse(),
          eventData: evt
        });
      }

      // reset the queue
      m_queue = {};
    }
    if (m_options.throttle > 0) {
      return throttle(m_options.throttle, false, wheel, accum);
    } else {
      return function (evt) {
        accum(evt);
        wheel(evt);
      };
    }
  }

  /**
   * Handle mouse wheel event.  (Defined inside _connectEvents).
   */
  this._handleMouseWheel = function () {};

  /**
   * Start up a spring back action when the map bounds are out of range.
   * Not to be user callable.
   * @protected
   *
   * @param {boolean} initialVelocity Truthy if the mouse's current velocity
   *    should be used as the initial velocity.  False to assume no initial
   *    velocity.
   * @param {object} origAction The original action that started the spring
   *    back.  If this was a zoom action, the spring back includes zoom;
   *    otherwise it only includes panning.
   */
  this.springBack = function (initialVelocity, origAction) {
    if (m_state.action === geo_action.momentum) {
      return;
    }
    if (!initialVelocity) {
      m_mouse.velocity = {
        x: 0,
        y: 0
      };
    }
    m_state.origAction = origAction;
    m_state.action = geo_action.momentum;
    m_state.origin = m_this.mouse();
    m_state.momentum = m_this.mouse();
    m_state.start = new Date();
    m_state.handler = function () {
      var v, s, last, dt;
      if (m_state.action !== geo_action.momentum || !m_this.map() || m_this.map().transition()) {
        // cancel if a new action was performed
        return;
      }
      // Not sure the correct way to do this.  We need the delta t for the
      // next time step...  Maybe use a better interpolator and the time
      // parameter from requestAnimationFrame.
      dt = Math.min(m_state.momentum.deltaTime, 30);
      last = m_state.start.valueOf();
      m_state.start = new Date();
      v = modifyVelocity(m_state.momentum.velocity, m_state.start - last);

      // stop panning when the speed is below the threshold
      if (!v) {
        clearState();
        return;
      }
      s = calcSpeed(v);
      if (s > m_options.momentum.maxSpeed) {
        s = m_options.momentum.maxSpeed / s;
        v.x = v.x * s;
        v.y = v.y * s;
      }
      if (!isFinite(v.x) || !isFinite(v.y)) {
        v.x = 0;
        v.y = 0;
      }
      m_state.momentum.velocity.x = v.x;
      m_state.momentum.velocity.y = v.y;
      switch (m_state.origAction) {
        case geo_action.zoom:
          var dy = m_state.momentum.velocity.y * dt;
          m_callZoom(-dy * m_options.zoomScale / 120, m_state);
          break;
        default:
          m_this.map().pan({
            x: m_state.momentum.velocity.x * dt,
            y: m_state.momentum.velocity.y * dt
          }, undefined, 'limited');
          break;
      }
      if (m_state.handler) {
        m_this.map().scheduleAnimationFrame(m_state.handler);
      }
    };
    if (m_state.handler) {
      m_this.map().scheduleAnimationFrame(m_state.handler);
    }
  };

  /**
   * Public method that unbinds all events.
   */
  this.destroy = function () {
    m_this._disconnectEvents();
    if (m_this.map()) {
      $(m_this.map().node()).removeClass('highlight-focus');
    }
    m_this.map(null);
  };

  /**
   * Get current mouse information.
   *
   * @returns {object} The current mouse state.
   */
  this.mouse = function () {
    return util.deepMerge({}, m_mouse);
  };

  /**
   * Get/set current keyboard information.
   *
   * @param {object} [newValue] Either a object with new options for the
   *    keyboard actions or `undefined` to get the current options.
   * @returns {object|this} Either the current keyboard options or this
   *    mapInteractor class instance.
   */
  this.keyboard = function (newValue) {
    if (newValue === undefined) {
      return util.deepMerge({}, m_options.keyboard || {});
    }
    return m_this.options({
      keyboard: newValue
    });
  };

  /**
   * Get the current interactor state.
   *
   * @returns {geo.interactorState}
   */
  this.state = function () {
    return util.deepMerge({}, m_state);
  };

  /**
   * Get or set the pause state of the interactor, which ignores all native
   * mouse and keyboard events.
   *
   * @param {boolean} [value] The pause state to set or undefined to return
   *    the current state.
   * @returns {boolean|this} The current pause state or this class instance.
   */
  this.pause = function (value) {
    if (value === undefined) {
      return m_paused;
    }
    m_paused = !!value;
    return m_this;
  };

  /**
   * Add an action to the list of handled actions.
   *
   * @param {object} action An object defining the action.  This must have
   *    action and input properties, and may have modifiers, name, and owner.
   *    Use action, name, and owner to make this entry distinct if it will need
   *    to be removed later.
   * @param {boolean} [toEnd] The action is added at the beginning of the
   *    actions list unless truthy.  Earlier actions prevent later actions with
   *    similar input and modifiers.
   */
  this.addAction = function (action, toEnd) {
    if (!action || !action.action || !action.input) {
      return;
    }
    util.addAction(m_options.actions, action, toEnd);
    if (m_options.map && m_options.actions.some(function (action) {
      return action.input.right;
    })) {
      $node.off('contextmenu.geojs');
      $node.on('contextmenu.geojs', function () {
        return false;
      });
    }
  };

  /**
   * Check if an action is in the actions list.  An action matches if the
   * action, name, and owner match.  A null or undefined value will match all
   * actions.  If using an action object, this is the same as passing
   * (action.action, action.name, action.owner).
   *
   * @param {object|string} action Either an action object or the name of an
   *    action.
   * @param {string} name Optional name associated with the action.
   * @param {string} owner Optional owner associated with the action.
   * @returns {object|null} The first matching action or null.
   */
  this.hasAction = function (action, name, owner) {
    return util.hasAction(m_options.actions, action, name, owner);
  };

  /**
   * Remove all matching actions.  Actions are matched as with hasAction.
   *
   * @param {object|string} action Either an action object or the name of an
   *    action.
   * @param {string} name Optional name associated with the action.
   * @param {string} owner Optional owner associated with the action.
   * @returns {number} The number of actions that were removed.
   */
  this.removeAction = function (action, name, owner) {
    var removed = util.removeAction(m_options.actions, action, name, owner);
    if (m_options.map && !m_options.actions.some(function (action) {
      return action.input.right;
    })) {
      $node.off('contextmenu.geojs');
    }
    return removed;
  };

  /**
   * Simulate a DOM mouse event on connected map.  Not all options are required
   * for every event type.
   *
   * @param {string} type Event type `mousemove`, `mousedown`, `mouseup`, etc.
   *    `keyboard` is treated separately from other types.
   * @param {object} options Options for the simulated event.
   * @param {boolean} [options.shift] A boolean if a `keyboard` event has the
   *    shift key down or explicitly up.
   * @param {boolean} [options.shiftKey] Alternate name to `shift`.
   * @param {boolean} [options.ctrl] A boolean if a `keyboard` event has the
   *    control key down or explicitly up.
   * @param {boolean} [options.ctrlKey] Alternate name to `ctrl`.
   * @param {boolean} [options.alt] A boolean if a `keyboard` event has the
   *    alt key down or explicitly up.
   * @param {boolean} [options.altKey] Alternate name to `alt`.
   * @param {boolean} [options.meta] A boolean if a `keyboard` event has the
   *    meta key down or explicitly up.
   * @param {boolean} [options.metaKey] Alternate name to `meta`.
   * @param {string} [options.keys] A Mousetrap-style key sequence string for
   *    `keyboard` events.
   * @param {geo.screenPosition} [options.page] The position of the event on
   *    the window.  Overridden by `map`.
   * @param {geo.screenPosition} [options.map] The position of the event on the
   *    map in pixels relative to the map's div.
   * @param {geo.screenPosition} [options.center] The position of a touch
   *    event center relative to the window.
   * @param {string} [options.button] One of `left`, `middle`, or `right` for
   *    mouse events.
   * @param {string} [options.modifiers] A space-separated list of metakeys
   *    that are down on mouse events.
   * @param {geo.screenPosition} [options.wheelDelta] The amount the wheel
   *    moved in both directions for wheel events.  One step is often 20 units
   *    of movement.
   * @param {number} [options.wheelMode] The wheel delta mode.  See
   *    https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent .
   * @param {boolean} [options.touch] `truthy` if this is a touch event.
   * @param {number} [options.rotation] Touch event rotation in degrees.
   * @param {number} [options.scale] Touch event scale.  Initial events should
   *    have a scale of 1; subsequent events should increase or decrease this
   *    to simulate spread and pinch actions.
   * @param {number[]} [options.pointers] A list of pointer numbers involved in
   *    a touch event.  Pointers are number from one up, so `[1]` is the first
   *    touch point, `[1, 2]` are two touch points, and `[2]` is when the first
   *    point was released but the second is still touching.
   * @param {string} [options.pointerType] `mouse` if this is a mouse action
   *    rather than a touch action.
   * @returns {mapInteractor}
   */
  this.simulateEvent = function (type, options) {
    var evt, page, offset, which, buttons;
    if (!m_this.map()) {
      return m_this;
    }
    if (type === 'keyboard' && m_keyHandler) {
      /* Mousetrap passes through the keys we send, but not an event object,
       * so we construct an artificial event object as the keys, and use that.
       */
      var keys = {
        shiftKey: options.shift || options.shiftKey || false,
        ctrlKey: options.ctrl || options.ctrlKey || false,
        altKey: options.alt || options.altKey || false,
        metaKey: options.meta || options.metaKey || false,
        toString: function toString() {
          return options.keys;
        },
        stopPropagation: function stopPropagation() {},
        preventDefault: function preventDefault() {},
        simulated: true
      };
      m_keyHandler.trigger(keys, options.event);
      return m_this;
    }
    page = options.page || {};
    if (options.map) {
      offset = $node.offset();
      page.x = options.map.x + offset.left;
      page.y = options.map.y + offset.top;
    }
    if (options.button === 'left') {
      which = 1;
      buttons = 1;
    } else if (options.button === 'right') {
      which = 3;
      buttons = 2;
    } else if (options.button === 'middle') {
      which = 2;
      buttons = 4;
    }
    options.modifiers = options.modifiers || [];
    options.wheelDelta = options.wheelDelta || {};
    evt = $.Event(type, {
      pageX: page.x,
      pageY: page.y,
      which: which,
      buttons: buttons,
      altKey: options.modifiers.indexOf('alt') >= 0,
      ctrlKey: options.modifiers.indexOf('ctrl') >= 0,
      metaKey: options.modifiers.indexOf('meta') >= 0,
      shiftKey: options.modifiers.indexOf('shift') >= 0,
      center: options.center,
      rotation: options.touch ? options.rotation || 0 : options.rotation,
      scale: options.touch ? options.scale || 1 : options.scale,
      pointers: options.pointers,
      pointerType: options.pointerType,
      originalEvent: {
        deltaX: options.wheelDelta.x,
        deltaY: options.wheelDelta.y,
        deltaMode: options.wheelMode,
        preventDefault: function preventDefault() {},
        stopPropagation: function stopPropagation() {},
        stopImmediatePropagation: function stopImmediatePropagation() {}
      }
    });
    if (options.touch && m_touchHandler) {
      m_this._handleTouch(evt);
    } else {
      $node.trigger(evt);
    }
    if (type.indexOf('.geojs') >= 0) {
      $(document).trigger(evt);
    }
    return m_this;
  };
  this._connectEvents();
  return this;
};
inherit(_mapInteractor, object);
module.exports = _mapInteractor;

/***/ }),

/***/ 2225:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var pointFeature = __webpack_require__(7541);

/**
 * Object specification for a marker feature.
 *
 * @typedef {geo.feature.spec} geo.markerFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 * @property {geo.markerFeature.styleSpec} [style] Style object with default
 *   style options.
 */

/**
 * Style specification for a marker feature.
 *
 * @typedef {geo.feature.styleSpec} geo.markerFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {number|Function} [radius=6.25] Radius of each marker in pixels.
 *   This includes the stroke width if `strokeOffset` is -1, excludes it if
 *   `strokeOffset` is 1, and includes half the stroke width if `strokeOffset`
 *    is 0.  Note that is `radiusIncludesStroke` is `false`, this never
 *   includes the stroke width.
 * @property {geo.geoColor|Function} [strokeColor] Color to stroke each marker.
 * @property {number|Function} [strokeOpacity=1] Opacity for each marker's
 *   stroke.  Opacity is on a [0-1] scale.  Set this or `strokeWidth` to zero
 *   to not have a stroke.
 * @property {number|Function} [strokeWidth=1.25] The weight of the marker's
 *   stroke in pixels.  Set this or `strokeOpacity` to zero to not have a
 *   stroke.
 * @property {number|Function} [strokeOffset=-1] The position of the stroke
 *   compared to the radius.  This can only be -1, 0, or 1 (the sign of the
 *   value is used).
 * @property {boolean|Function} [radiusIncludesStroke=true] If truthy or
 *   undefined, the `radius` includes the `strokeWidth` based on the
 *   `strokeOffset`.  If defined and falsy, the radius does not include the
 *   `strokeWidth`.
 * @property {geo.geoColor|Function} [fillColor] Color to fill each marker.
 * @property {number|Function} [fillOpacity=1] Opacity for each marker.
 *   Opacity is on a [0-1] scale.  Set to zero to have no fill.
 * @property {number|Function} [symbol=0] One of the predefined symbol numbers.
 *   This is one of `geo.markerFeature.symbols`.
 * @property {number|number[]|Function} [symbolValue=0] A value the affects the
 *   appearance of the symbol.  Some symbols can take an array of numbers.
 * @property {number|Function} [rotation=0] The rotation of the symbol in
 *   clockwise radians.
 * @property {geo.markerFeature.scaleMode|Function} [scaleWithZoom='none'] This
 *   determines if the fill, stroke, or both scale with zoom.  If set, the
 *   values for radius and strokeWidth are the values at zoom-level zero.
 * @property {boolean|Function} [rotateWithMap=false] If truthy, rotate symbols
 *   with the map.  If falsy, symbol orientation is absolute.
 * @property {number[]|Function} [origin] Origin in map gcs coordinates used
 *   to ensure high precision drawing in this location.  When called as a
 *   function, this is passed the maker positions as a single continuous array
 *   in map gcs coordinates.  It defaults to the first marker's position.
 */

/**
 * Create a new instance of class markerFeature.
 *
 * @class
 * @alias geo.markerFeature
 * @extends geo.feature
 * @param {geo.markerFeature.spec} arg
 * @returns {geo.markerFeature}
 */
var _markerFeature = function markerFeature(arg) {
  'use strict';

  if (!(this instanceof _markerFeature)) {
    return new _markerFeature(arg);
  }
  arg = arg || {};
  pointFeature.call(this, arg);
  var timestamp = __webpack_require__(77);
  var util = __webpack_require__(642);
  var KDBush = __webpack_require__(4279);
  KDBush = KDBush.__esModule ? KDBush.default : KDBush;

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init,
    m_rangeTree = null,
    m_rangeTreeTime = timestamp(),
    m_maxFixedRadius = 0,
    m_maxZoomRadius = 0,
    m_maxZoomStroke = 0;
  this.featureType = 'marker';

  /**
   * Update the current range tree object.  Should be called whenever the
   * data changes.
   */
  this._updateRangeTree = function () {
    if (m_rangeTreeTime.timestamp() >= m_this.dataTime().timestamp() && m_rangeTreeTime.timestamp() >= m_this.timestamp()) {
      return;
    }
    var pts,
      position,
      radius = m_this.style.get('radius'),
      strokeWidth = m_this.style.get('strokeWidth'),
      radiusIncludesStroke = m_this.style.get('radiusIncludesStroke'),
      strokeOffset = m_this.style.get('strokeOffset'),
      scaleWithZoom = m_this.style.get('scaleWithZoom');
    position = m_this.position();
    m_maxFixedRadius = 0;
    m_maxZoomRadius = 0;
    m_maxZoomStroke = 0;

    // create an array of positions in geo coordinates
    pts = m_this.data().map(function (d, i) {
      var pt = position(d, i);
      var swz = scaleWithZoom(d, i);
      var r = radius(d, i),
        s = strokeWidth(d, i),
        so = Math.sign(strokeOffset(d, i));
      var ris = radiusIncludesStroke(d, i);
      ris = ris === undefined ? true : ris;
      var rwiths = ris ? r + s * (so + 1) / 2 : r + s,
        // radius with stroke
        rwos = ris ? r + s * (so - 1) / 2 : r; // radius without stroke
      swz = _markerFeature.scaleMode[swz] || (swz >= 1 && swz <= 3 ? swz : 0);
      switch (swz) {
        case _markerFeature.scaleMode.stroke:
          if (rwos > m_maxFixedRadius) {
            m_maxFixedRadius = rwos;
          }
          if (s > m_maxZoomStroke) {
            m_maxZoomStroke = s;
          }
          break;
        case _markerFeature.scaleMode.fill:
        case _markerFeature.scaleMode.all:
          if (rwiths > m_maxZoomRadius) {
            m_maxZoomRadius = rwiths;
          }
          break;
        default:
          if (rwiths > m_maxFixedRadius) {
            m_maxFixedRadius = rwiths;
          }
          break;
      }
      return [pt.x, pt.y];
    });
    m_rangeTree = new KDBush(pts.length);
    var _iterator = _createForOfIteratorHelper(pts),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          x = _step$value[0],
          y = _step$value[1];
        m_rangeTree.add(x, y);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    m_rangeTree.finish();
    m_rangeTreeTime.modified();
  };

  /**
   * Determine an approximate maximum radius based on the zoom factor.
   *
   * @param {number} zoom The zoom level.
   * @returns {number} The maximum radius.  May be somewhat larger than the
   *   actual maximum.
   */
  this._approximateMaxRadius = function (zoom) {
    m_this._updateRangeTree();
    var zoomFactor = Math.pow(2, zoom);
    return Math.max(m_maxFixedRadius + m_maxZoomStroke * zoomFactor, m_maxZoomRadius * zoomFactor);
  };

  /**
   * Returns an array of datum indices that contain the given marker.
   *
   * @param {geo.geoPosition} p marker to search for.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of marker indices, and
   *    `found`: a list of markers that contain the specified coordinate.
   */
  this.pointSearch = function (p, gcs) {
    var min,
      max,
      data,
      idx = [],
      found = [],
      ifound = [],
      fgcs = m_this.gcs(),
      // this feature's gcs
      corners,
      radius = m_this.style.get('radius'),
      strokeWidth = m_this.style.get('strokeWidth'),
      radiusIncludesStroke = m_this.style.get('radiusIncludesStroke'),
      strokeOffset = m_this.style.get('strokeOffset'),
      scaleWithZoom = m_this.style.get('scaleWithZoom');
    data = m_this.data();
    if (!data || !data.length) {
      return {
        found: [],
        index: []
      };
    }

    // We need to do this before we find corners, since the max radius is
    // determined then
    m_this._updateRangeTree();
    var map = m_this.layer().map();
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    var pt = map.gcsToDisplay(p, gcs),
      zoom = map.zoom(),
      zoomFactor = Math.pow(2, zoom),
      maxr = this._approximateMaxRadius(zoom);

    // check all corners to make sure we handle rotations
    corners = [map.displayToGcs({
      x: pt.x - maxr,
      y: pt.y - maxr
    }, fgcs), map.displayToGcs({
      x: pt.x + maxr,
      y: pt.y - maxr
    }, fgcs), map.displayToGcs({
      x: pt.x - maxr,
      y: pt.y + maxr
    }, fgcs), map.displayToGcs({
      x: pt.x + maxr,
      y: pt.y + maxr
    }, fgcs)];
    min = {
      x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };
    max = {
      x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };

    // Find markers inside the bounding box
    idx = m_rangeTree.range(min.x, min.y, max.x, max.y);
    idx = Uint32Array.from(idx).sort();
    // Filter by circular region
    idx.forEach(function (i) {
      var d = data[i],
        rad = radius(data[i], i),
        swz = scaleWithZoom(data[i], i),
        so = strokeOffset(data[i], i),
        s = swz ? strokeWidth(data[i], i) : 0;
      var ris = radiusIncludesStroke(d, i);
      ris = ris === undefined ? true : ris;
      var rwos = ris ? rad + s * (so - 1) / 2 : rad; // radius without stroke
      rad = rwos + s;
      var p = m_this.position()(d, i),
        dx,
        dy,
        rad2;
      swz = _markerFeature.scaleMode[swz] || (swz >= 1 && swz <= 3 ? swz : 0);
      switch (swz) {
        case _markerFeature.scaleMode.fill:
          rad = rwos * zoomFactor + s;
          break;
        case _markerFeature.scaleMode.stroke:
          rad = rwos + s * zoomFactor;
          break;
        case _markerFeature.scaleMode.all:
          rad *= zoomFactor;
          break;
      }
      if (rad) {
        rad2 = rad * rad;
        p = map.gcsToDisplay(p, fgcs);
        dx = p.x - pt.x;
        dy = p.y - pt.y;
        if (dx * dx + dy * dy <= rad2) {
          found.push(d);
          ifound.push(i);
        }
      }
    });
    return {
      found: found,
      index: ifound
    };
  };

  /**
   * Returns an array of datum indices that are contained in the given polygon.
   * This does not take clustering into account.
   *
   * @param {geo.polygonObject} poly A polygon as an array of coordinates or an
   *    object with `outer` and optionally `inner` parameters.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include markers that are
   *    partially in the polygon, otherwise only include markers that are fully
   *    within the region.  If 'center', only markers whose centers are inside
   *    the polygon are returned.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of marker indices,
   *    `found`: a list of markers within the polygon, and `extra`: an object
   *    with index keys containing an object with a `partial` key and a boolean
   *    value to indicate if the marker is on the polygon's border and a
   *    `distance` key to indicate how far within the polygon the marker is
   *    located.
   */
  this.polygonSearch = function (poly, opts, gcs) {
    var fgcs = m_this.gcs(),
      // this feature's gcs
      found = [],
      ifound = [],
      extra = {},
      map = m_this.layer().map(),
      data = m_this.data(),
      radius = m_this.style.get('radius'),
      strokeWidth = m_this.style.get('strokeWidth'),
      radiusIncludesStroke = m_this.style.get('radiusIncludesStroke'),
      strokeOffset = m_this.style.get('strokeOffset'),
      scaleWithZoom = m_this.style.get('scaleWithZoom'),
      idx,
      min,
      max,
      corners,
      zoom = map.zoom(),
      zoomFactor = Math.pow(2, zoom),
      maxr = this._approximateMaxRadius(zoom);
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    if (!poly.outer) {
      poly = {
        outer: poly,
        inner: []
      };
    }
    if (poly.outer.length < 3 || !data || !data.length) {
      return {
        found: [],
        index: [],
        extra: {}
      };
    }
    opts = opts || {};
    opts.partial = opts.partial || false;
    poly = {
      outer: map.gcsToDisplay(poly.outer, gcs),
      inner: (poly.inner || []).map(function (inner) {
        return map.gcsToDisplay(inner, gcs);
      })
    };
    poly.outer.forEach(function (p) {
      if (!min) {
        min = {
          x: p.x,
          y: p.y
        };
        max = {
          x: p.x,
          y: p.y
        };
      }
      if (p.x < min.x) {
        min.x = p.x;
      }
      if (p.x > max.x) {
        max.x = p.x;
      }
      if (p.y < min.y) {
        min.y = p.y;
      }
      if (p.y > max.y) {
        max.y = p.y;
      }
    });
    // We need to do this before we find corners, since the max radius is
    // determined then
    m_this._updateRangeTree();
    corners = [map.displayToGcs({
      x: min.x - maxr,
      y: min.y - maxr
    }, fgcs), map.displayToGcs({
      x: max.x + maxr,
      y: min.y - maxr
    }, fgcs), map.displayToGcs({
      x: max.x + maxr,
      y: max.y + maxr
    }, fgcs), map.displayToGcs({
      x: min.x - maxr,
      y: max.y + maxr
    }, fgcs)];
    min = {
      x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };
    max = {
      x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };
    // Find markers inside the bounding box.  Only these could be in the polygon
    idx = m_rangeTree.range(min.x, min.y, max.x, max.y);
    /* sort by index.  This had been
     *  idx.sort((a, b) => a - b);
     * but this requires continual casting from int to str and back, so using
     * a Uint32Array is faster, though potentially limits the maximum number of
     * markers. */
    idx = Uint32Array.from(idx).sort();
    // filter markers within the polygon
    idx.forEach(function (i) {
      var d = data[i];
      var p = m_this.position()(d, i);
      var rad = radius(d, i),
        swz = scaleWithZoom(d, i);
      var so = strokeOffset(d, i),
        s = swz ? strokeWidth(d, i) : 0;
      var ris = radiusIncludesStroke(d, i);
      ris = ris === undefined ? true : ris;
      var rwos = ris ? rad + s * (so - 1) / 2 : rad; // radius without stroke
      swz = _markerFeature.scaleMode[swz] || (swz >= 1 && swz <= 3 ? swz : 0);
      rad = rwos + s;
      switch (swz) {
        case _markerFeature.scaleMode.fill:
          rad = rwos * zoomFactor + s;
          break;
        case _markerFeature.scaleMode.stroke:
          rad = rwos + s * zoomFactor;
          break;
        case _markerFeature.scaleMode.all:
          rad *= zoomFactor;
          break;
      }
      if (rad) {
        p = map.gcsToDisplay(p, fgcs);
        var dist = util.distanceToPolygon2d(p, poly);
        if (dist >= rad || dist >= 0 && opts.partial === 'center' || dist >= -rad && opts.partial && opts.partial !== 'center') {
          found.push(d);
          ifound.push(i);
          extra[i] = {
            partial: dist < rad,
            distance: dist
          };
        }
      }
    });
    return {
      found: found,
      index: ifound,
      extra: extra
    };
  };

  /**
   * Initialize.
   *
   * @param {geo.markerFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    arg = util.deepMerge({}, {
      style: Object.assign({}, {
        radius: 6.25,
        radiusIncludesStroke: true,
        strokeColor: {
          r: 0.851,
          g: 0.604,
          b: 0.0
        },
        strokeOffset: -1.0,
        strokeOpacity: 1.0,
        strokeWidth: 1.25,
        fillColor: {
          r: 1.0,
          g: 0.839,
          b: 0.439
        },
        fillOpacity: 0.8,
        symbol: 0,
        symbolValue: 0,
        rotation: 0,
        scaleWithZoom: _markerFeature.scaleMode.none,
        rotateWithMap: false
        // position and origin are the same as the pointFeature
      }, arg && arg.style === undefined ? {} : arg.style)
    }, arg);
    s_init.call(m_this, arg);
    return m_this;
  };
  return m_this;
};

/**
 * Create a markerFeature from an object.
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to
 * @param {geo.markerFeature.spec} spec The object specification
 * @returns {geo.markerFeature|null}
 */
_markerFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'marker';
  return feature.create(layer, spec);
};
_markerFeature.capabilities = {
  /* core feature name -- support in any manner */
  feature: 'marker'
};
_markerFeature.primitiveShapes = pointFeature.primitiveShapes;

/**
 * Marker symbols
 * @enum {number}
 */
_markerFeature.symbols = {
  // for circle (alias ellipse), the symbolValue is the ratio of the minor to
  // major axes.  Range (0, infinity)
  circle: 0,
  ellipse: 0,
  flowerBase: 1,
  flowerMax: 16,
  // for triangle, the symbolValue is the ratio of the base to the other sides.
  // Ranges (0, 2)
  triangle: 16,
  diamond: 17,
  starBase: 17,
  starMax: 16,
  // for square (alias rectangle), the symbolValue is the ratio of the minor to
  // major axes.  Range (0, infinity)
  square: 32,
  rectangle: 32,
  // for crosses, the symbolValue is the width of the arm compared to the
  // length of the cross
  crossBase: 33,
  crossMax: 16,
  // for ovals, the symbolValue is the ratio of the minor to major axes.  Range
  // (0, 1]
  oval: 48,
  jackBase: 49,
  jackMax: 16,
  // for drops, the symbol value is the ratio of the arc to the main radius.
  // Range (0, 1]
  drop: 64,
  dropBase: 65,
  dropMax: 16,
  // for arrow, the symbol value is an array of up to four values:
  //   headWidth : the ratio of the head width to the radius.  Range (0, 1].
  //     Default 2/3.
  //   headLength : the ratio of head length to the diameter.  Range (0, 1].
  //     Default 1/2.
  //   stemWidth : the ratio of the stem width to the head width.  Range
  //     [0, 1].  Default 1/3.
  //   sweep : a boolean; if true the back of head is swept; if false the back
  //     of the head is square.  Default false.
  arrow: 80,
  arrowBase: 81,
  arrowMax: 16,
  length: 96
  // possible other symbols:
  // half inner stellations (bowtie/hourglass), hash (#), inner curved shapes
};
['flower', 'star', 'cross', 'jack', 'drop', 'arrow'].forEach(function (key) {
  for (var i = 2; i <= _markerFeature.symbols[key + 'Max']; i += 1) {
    _markerFeature.symbols[key + i] = _markerFeature.symbols[key + 'Base'] - 2 + i;
  }
});

/**
 * Marker scale modes
 * @enum {number}
 */
_markerFeature.scaleMode = {
  none: 0,
  fill: 1,
  stroke: 2,
  all: 3
};
inherit(_markerFeature, pointFeature);
module.exports = _markerFeature;

/***/ }),

/***/ 6124:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Mesh feature specification.
 *
 * @typedef {geo.feature.spec} geo.meshFeature.spec
 * @extends geo.feature.spec
 * @property {object[]} [data=[]] An array of arbitrary objects used to
 *    construct the feature.
 * @property {geo.feature.styleSpec} [style] An object that contains style
 *    values for the feature.
 * @property {geo.meshFeature.meshSpec} [mesh] The mesh specification for the
 *    feature.
 */

/**
 * A mesh formed by a set of triangular or square elements or a
 * squarely-connected grid that is of rectangular extent.  The grid can be
 * regularly spaced or have arbitrary position coordinates for each node.  All
 * of these properties can be functions, which get passed `data`.
 *
 * @typedef {object} geo.meshFeature.meshSpec
 * @property {number[]|Array.<number[]>} [elements] If specified, a list of
 *      indices into the data array that form elements.  If this is an array of
 *      arrays, each subarray must have at least either 3 values for triangular
 *      elements or 4 values for square elements.  If this is a single array,
 *      the data indices are of all elements are packed one after another and
 *      the `elementPacking` property is used to determine element shape.  If
 *      this `null` or `undefined`, a rectangular grid of squares is used based
 *      on `gridWidth` and `gridHeight` or an implicit version of those
 *      parameters.
 * @property {string} [elementPacking='auto'] If `elements` is provided as a
 *      single array, this determines the shape of the elements.  It is one of
 *      `auto`, `triangle`, or `square`.  `triangle` uses triplets of values to
 *      define elements.  `square` uses quads of values.  `auto` is identical
 *      to `triangle` unless `elements`'s length is a multiple of 4 and *not* a
 *      multiple of 3, in which case it is the same as `square`.
 * @property {number} [gridWidth] The number of data columns in the grid.  If
 *      this is not specified and `gridHeight` is given, this is the number of
 *      data elements divided by `gridHeight`.  If neither `gridWidth` nor
 *      `gridHeight` are specified, the squareroot of the number of data
 *      elements is used.  If both are specified, some data could be unused.
 *      Ignored if `elements` is used.
 * @property {number} [gridHeight] The number of data rows in the grid.  If
 *      this is not specified and `gridWidth` is given, this is the number of
 *      data elements divided by `gridWidth`.  If neither `gridWidth` not
 *      `gridHeight` are specified, the squareroot of the number of data
 *      elements is used.  If both are specified, some data could be unused.
 *      Ignored if `elements` is used.
 * @property {number} [x0] The x coordinate of the 0th data point.  If `null`
 *      or `undefined`, the coordinate is taken from the `position` style.
 *      Ignored if `elements` is used.
 * @property {number} [y0] The y coordinate of the 0th data point.  If `null`
 *      or `undefined`, the coordinate is taken from the `position` style.
 *      Ignored if `elements` is used.
 * @property {number} [dx] The distance in the x direction between the 0th and
 *      1st data point.  This may be positive or negative.  If 0, `null`, or
 *      `undefined`, the coordinate is taken from the `position` style.
 *      Ignored if `elements` is used.
 * @property {number} [dy] The distance in the y direction between the 0th and
 *      `gridWidth`th data point.  This may be positive or negative.  If 0,
 *      `null`, or `undefined`, the coordinate is taken from the `position`
 *      style.  Ignored if `elements` is used.
 * @property {boolean} [wrapLongitude=true] If truthy and `position` is not
 *      used (`elements` is not used and `x0`, `y0`, `dx`, and `dy` are all set
 *      appropriately), assume the x coordinates are longitude and should be
 *      adjusted to be within -180 to 180.  If the data spans 180 degrees, the
 *      points or squares that straddle the meridian will be duplicated to
 *      ensure that the map is covered from -180 to 180 as appropriate.  Set
 *      this to `false` if using a non-longitude x coordinate.
 */

/**
 * A set of elements and their associated positions for a mesh.
 *
 * @typedef {object} geo.meshFeature.meshInfo
 * @property {string} shape One of `'triangle'` or `'square'`.  If `square`,
 *      each pair of elements is one square.  These elements have vertices v00,
 *      v01, v02, v10, v11, v12.  The square is formed via v00-v01-v10-v11-v00.
 *      For `triangle`, each element stands alone.
 * @property {number[]} elements A packed array of indices into the `pos` array
 *      defining the elements.  Each sequential three values forms a triangle.
 * @property {number[]} elementIndex An array that has one value for each
 *      triplet of values in the `elements` array.  The value is the 0-based
 *      index of the element that can be used to correspond it to element-based
 *      parameters.
 * @property {number[]} index An array that references which data index is
 *      associated with each vertex.
 * @property {number[]} pos A packed array of coordinates in the interface gcs
 *      for the vertices.  This is in the order x0, y0, z0, x1, y1, z2, x2, ...
 * @property {number} numberVertices the number of vertices in the mesh.
 * @property {number} numberElementsthe number of elements (squares or
 *      triangles) in the mesh.
 * @property {number} verticesPerElement 3 for triangles, 6 for squares.
 */

/**
 * Create a new instance of class meshFeature.  This should be the parent of a
 * more usable feature class.
 *
 * @class
 * @alias geo.meshFeature
 * @extends geo.feature
 *
 * @param {geo.meshFeature.spec} arg
 * @returns {this}
 */
var _meshFeature = function meshFeature(arg) {
  'use strict';

  if (!(this instanceof _meshFeature)) {
    return new _meshFeature(arg);
  }
  var util = __webpack_require__(642);
  arg = arg || {};
  feature.call(this, arg);
  var m_this = this,
    s_init = this._init,
    m_mesh = {};
  this.featureType = 'mesh';

  /**
   * Get/Set mesh accessor.
   *
   * @param {string|geo.meshFeature.meshSpec} [specOrProperty] If `undefined`,
   *    return the current mesh specification.  If a string is specified,
   *    either get or set the named mesh property.  If an object is given, set
   *    or update the specification with the specified parameters.
   * @param {object} [value] If `specOrProperty` is a string, set that property
   *    to `value`.  If `undefined`, return the current value of the named
   *    property.
   * @returns {geo.meshFeature.meshSpec|object|this} The current mesh
   *    specification, the value of a named mesh property, or this mesh object.
   */
  this.mesh = function (specOrProperty, value) {
    if (specOrProperty === undefined) {
      return m_mesh;
    }
    if (typeof specOrProperty === 'string' && value === undefined) {
      return m_mesh[specOrProperty];
    }
    if (value === undefined) {
      var mesh = Object.assign({}, {
        gridWidth: function gridWidth() {
          if (specOrProperty.gridHeight) {
            return Math.floor(m_this.data().length / specOrProperty.gridHeight);
          }
          return Math.floor(Math.sqrt(m_this.data().length));
        },
        gridHeight: function gridHeight() {
          if (specOrProperty.gridWidth) {
            return Math.floor(m_this.data().length / specOrProperty.gridWidth);
          }
          return Math.floor(Math.sqrt(m_this.data().length));
        }
      }, m_mesh, specOrProperty);
      m_mesh = mesh;
    } else {
      m_mesh[specOrProperty] = value;
    }
    m_this.modified();
    return m_this;
  };

  /**
   * A uniform getter that always returns a function even for constant values.
   * If undefined input, return all the mesh values as an object.
   *
   * @function mesh_DOT_get
   * @memberof geo.meshFeature
   * @instance
   * @param {string|undefined} key The name of the mesh key or `undefined` to
   *    return an object with all keys as functions.
   * @returns {object|Function} A function related to the key, or an object
   *    with all mesh keys, each of which is a function.
   */
  this.mesh.get = function (key) {
    if (key === undefined) {
      var all = {},
        k;
      for (k in m_mesh) {
        if (m_mesh.hasOwnProperty(k)) {
          all[k] = m_this.mesh.get(k);
        }
      }
      return all;
    }
    return util.ensureFunction(m_mesh[key]);
  };

  /**
   * Get/Set position accessor.  This is identical to getting or setting the
   * `position` style.
   *
   * @param {array|Function} [val] If specified, set the position style.  If
   *    `undefined`, return the current value.
   * @returns {array|Function|this} Either the position style or this.
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Create a set of vertices and elements from a mesh specification.
   *
   * This currently takes a set of `vertexValueFuncs` to determine which
   * vertices are used (shown) and values at those vertices.  It could be
   * extended with `elementValueFuncs`.
   *
   * @param {object} [vertexValueFuncs] A dictionary where the keys are the
   *    names of properties to include in the results and the values are
   *    functions that are evaluated at each vertex with the arguments
   *    `(data[idx], idx, position)`.  If a key is named `used`, then its
   *    function is passed `(data[idx], idx)` and if it returns a falsy value
   *    for a data point, the vertex associated with that data point is removed
   *    from the resultant mesh.
   * @param {object} [elementValueFuncs] A dictionary where the keys are the
   *    names of properties to include in the results and the values are
   *    functions that are evaluated at each element with the arguments
   *    `(data[idx], idx)`.  If a key is named `used`, then its function is
   *    passed `(data[idx], idx)` and if it returns a falsy value for a data
   *    point, the triangle or square associated with that data point is
   *    removed from the resultant mesh.
   * @returns {geo.meshFeature.meshInfo} An object with the mesh information.
   */
  this._createMesh = function (vertexValueFuncs, elementValueFuncs) {
    vertexValueFuncs = vertexValueFuncs || {};
    elementValueFuncs = elementValueFuncs || {};
    var i,
      i3,
      j,
      k,
      idx,
      numPts,
      usedPts,
      usePos,
      item,
      key,
      data = m_this.data(),
      posFunc = m_this.position(),
      posVal,
      elements = m_this.mesh.get('elements')(data),
      elementPacking = m_this.mesh.get('elementPacking')(data),
      gridW = m_this.mesh.get('gridWidth')(data),
      gridH = m_this.mesh.get('gridHeight')(data),
      wrapLongitude = m_this.mesh.get('wrapLongitude')(data),
      x0 = m_this.mesh.get('x0')(data),
      y0 = m_this.mesh.get('y0')(data),
      dx = m_this.mesh.get('dx')(data),
      dy = m_this.mesh.get('dy')(data),
      calcX,
      calcCol,
      skipColumn,
      x,
      origI,
      /* used for wrapping */
      gridWorig = gridW,
      /* can be different when wrapping */
      result = {
        shape: 'square',
        elements: [],
        elementIndex: []
      };
    /* If we are using a grid, calculate the elements and positions. */
    if (!elements) {
      if (Object.keys(vertexValueFuncs).length) {
        if (gridW * gridH > data.length) {
          gridH = Math.floor(data.length / gridW);
        }
      } else if (Object.keys(elementValueFuncs).length) {
        if ((gridW - 1) * (gridH - 1) > data.length) {
          gridH = Math.floor(data.length / (gridW - 1)) + 1;
        }
      }
      /* If we are not using the position values (we are using x0, y0, dx, dy),
       * and wrapLongitude is turned on, and the position spans 180 degrees,
       * duplicate one or two columns of points at opposite ends of the map. */
      usePos = x0 === null || x0 === undefined || y0 === null || y0 === undefined || !dx || !dy;
      wrapLongitude = !!(wrapLongitude === undefined || wrapLongitude);
      if (!usePos && wrapLongitude && (x0 < -180 || x0 > 180 || x0 + dx * (gridW - 1) < -180 || x0 + dx * (gridW - 1) > 180) && dx > -180 && dx < 180 && dx * (gridW - 1) < 360 + 1e-4) {
        calcX = [];
        calcCol = [];
        for (i = 0; i < gridW; i += 1) {
          x = x0 + i * dx;
          while (x < -180) {
            x += 360;
          }
          while (x > 180) {
            x -= 360;
          }
          if (i && Math.abs(x - calcX[calcX.length - 1]) > 180) {
            if (x > calcX[calcX.length - 1]) {
              calcX.push(x - 360);
              calcX.push(calcX[calcX.length - 2] + 360);
              calcCol.push(i);
              calcCol.push(i + 1);
            } else {
              calcX.push(x + 360);
              calcX.push(calcX[calcX.length - 2] - 360);
              calcCol.push(i);
              calcCol.push(i + 1);
            }
            skipColumn = i;
          }
          calcX.push(x);
          calcCol.push(i);
        }
        gridW += 2;
        if (Math.abs(Math.abs(gridWorig * dx) - 360) < 0.01) {
          gridW += 1;
          x = x0 + gridWorig * dx;
          while (x < -180) {
            x += 360;
          }
          while (x > 180) {
            x -= 360;
          }
          calcX.push(x);
          calcCol.push(0);
        }
      }
      /* Calculate the value for point */
      numPts = gridW * gridH;
      if (skipColumn !== undefined) {
        result.index = new Array(numPts);
        for (i = 0; i < numPts; i += 1) {
          j = Math.floor(i / gridW);
          origI = i - j * gridW;
          origI += origI > skipColumn ? -2 : 0;
          if (origI >= gridWorig) {
            origI -= gridWorig;
          }
          origI += j * gridWorig;
          result.index[i] = origI;
        }
      }
      /* Create triangles */
      for (j = idx = 0; j < gridH - 1; j += 1, idx += 1) {
        for (i = 0; i < gridW - 1; i += 1, idx += 1) {
          if (i !== skipColumn) {
            result.elements.push(idx);
            result.elements.push(idx + 1);
            result.elements.push(idx + gridW);
            result.elements.push(idx + gridW + 1);
            result.elements.push(idx + gridW);
            result.elements.push(idx + 1);
            result.elementIndex.push(j * (gridW - 1) + (calcCol ? calcCol[i] : i));
            result.elementIndex.push(j * (gridW - 1) + (calcCol ? calcCol[i] : i));
          }
        }
      }
    } else {
      /* use defined elements */
      var hasSubArray = elements.length && Array.isArray(elements[0]);
      if (elementPacking === 'square' || elementPacking !== 'triangle' && (!hasSubArray && !(elements.length % 4) && elements.length % 3 || hasSubArray && elements[0].length === 4)) {
        result.shape = 'square';
        if (hasSubArray) {
          for (i = 0; i < elements.length; i += 1) {
            result.elements.push(elements[i][0]);
            result.elements.push(elements[i][1]);
            result.elements.push(elements[i][3]);
            result.elements.push(elements[i][2]);
            result.elements.push(elements[i][3]);
            result.elements.push(elements[i][1]);
            result.elementIndex.push(i);
            result.elementIndex.push(i);
          }
        } else {
          for (i = j = 0; i < elements.length - 3; i += 4, j += 1) {
            result.elements.push(elements[i]);
            result.elements.push(elements[i + 1]);
            result.elements.push(elements[i + 3]);
            result.elements.push(elements[i + 2]);
            result.elements.push(elements[i + 3]);
            result.elements.push(elements[i + 1]);
            result.elementIndex.push(j);
            result.elementIndex.push(j);
          }
        }
      } else {
        result.shape = 'triangle';
        if (hasSubArray) {
          for (i = 0; i < elements.length; i += 1) {
            result.elements.push(elements[i][0]);
            result.elements.push(elements[i][1]);
            result.elements.push(elements[i][2]);
            result.elementIndex.push(i);
          }
        } else {
          result.elements = elements.slice(0, elements.length - elements.length % 3);
          for (i = j = 0; i < elements.length - 2; i += 3, j += 1) {
            result.elementIndex.push(j);
          }
        }
      }
      numPts = data.length;
      usePos = true;
    }
    /* If we have an `elementValueFuncs.used` function, remove any unused
     * elements.  Unused vertices are removed later. */
    result.verticesPerElement = result.shape === 'triangle' ? 3 : 6;
    var vpe = result.verticesPerElement;
    if (elementValueFuncs.used) {
      var used = new Array(result.elementIndex[result.elementIndex.length - 1] + 1);
      for (i = 0; i < used.length; i += 1) {
        used[i] = elementValueFuncs.used(data[i], i);
      }
      for (i = 0; i < result.elementIndex.length; i += 1) {
        if (!used[result.elementIndex[i]]) {
          break;
        }
      }
      if (i < result.elementIndex.length) {
        for (j = i; i < result.elementIndex.length; i += 1) {
          if (used[result.elementIndex[i]]) {
            result.elementIndex[j] = result.elementIndex[i];
            for (k = 0; k < 3; k += 1) {
              result.elements[j * 3 + k] = result.elements[i * 3 + k];
            }
            j += 1;
          }
        }
        result.elements.splice(j * 3);
        result.elementIndex.splice(j);
      }
    }
    /* If we have a `vertexValueFuncs.used` function, remove any unused
     * vertices.  Then, remove any elements that have a vertex that can't be
     * used.  This could leave vertices that are unused by any element, but
     * they are removed later. */
    if (vertexValueFuncs.used) {
      for (i = 0; i < numPts; i += 1) {
        idx = result.index ? result.index[i] : i;
        if (!vertexValueFuncs.used(data[idx], idx)) {
          break;
        }
      }
      if (i !== numPts) {
        usedPts = i;
        var remap = new Array(numPts);
        for (j = 0; j < usedPts; j += 1) {
          remap[j] = j;
        }
        remap[usedPts] = -1;
        if (!result.index) {
          result.index = new Array(data.length);
          for (j = 0; j < data.length; j += 1) {
            result.index[j] = j;
          }
        }
        for (i = usedPts + 1; i < numPts; i += 1) {
          idx = result.index[i];
          if (vertexValueFuncs.used(data[idx], idx)) {
            remap[i] = usedPts;
            result.index[usedPts] = result.index[i];
            usedPts += 1;
          } else {
            remap[i] = -1;
          }
        }
        result.index.splice(usedPts);
        for (i = k = 0; i < result.elements.length; i += vpe) {
          for (j = 0; j < vpe; j += 1) {
            if (remap[result.elements[i + j]] < 0) {
              break;
            }
            result.elements[k + j] = remap[result.elements[i + j]];
          }
          if (j === vpe) {
            result.elementIndex[Math.floor(k / 3)] = result.elementIndex[Math.floor(i / 3)];
            if (vpe === 6) {
              result.elementIndex[Math.floor(k / 3) + 1] = result.elementIndex[Math.floor(i / 3) + 1];
            }
            k += vpe;
          }
        }
        result.elements.splice(k);
        result.elementIndex.splice(Math.floor(k / 3));
        numPts = usedPts;
      }
    }
    /* Remove unused vertices -- this could be disabled to save time.  It
     * cannot be applied if skipColumn is defined, as in that case some
     * vertices are used multiple times but with different coordinates.  We
     * could also do this when vertexValueFuncs.used is used, but that usually
     * has a much smaller reduction in values and isn't worth the time. */
    if (elementValueFuncs.used && skipColumn === undefined) {
      var vertexMap = new Array(numPts);
      var oldindex = result.index;
      result.index = [];
      for (i = 0; i < result.elements.length; i += 1) {
        k = result.elements[i];
        if (vertexMap[k] === undefined) {
          vertexMap[k] = result.index.length;
          result.index.push(oldindex ? oldindex[k] : k);
        }
        result.elements[i] = vertexMap[k];
      }
      numPts = result.index.length;
    }
    /* Get point locations and store them in a packed array */
    result.pos = new Array(numPts * 3);
    for (key in vertexValueFuncs) {
      if (key !== 'used' && vertexValueFuncs.hasOwnProperty(key)) {
        result[key] = new Array(numPts);
      }
    }
    for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
      idx = result.index ? result.index[i] : i;
      item = data[idx];
      if (usePos) {
        posVal = posFunc(item, idx);
        result.pos[i3] = posVal.x;
        result.pos[i3 + 1] = posVal.y;
        result.pos[i3 + 2] = posVal.z || 0;
      } else {
        if (skipColumn === undefined) {
          result.pos[i3] = x0 + dx * (idx % gridW);
        } else {
          result.pos[i3] = calcX[i % gridW];
        }
        result.pos[i3 + 1] = y0 + dy * Math.floor(idx / gridW);
        result.pos[i3 + 2] = 0;
        posVal = {
          x: result.pos[i3],
          y: result.pos[i3 + 1],
          z: result.pos[i3 + 2]
        };
      }
      for (key in vertexValueFuncs) {
        if (key !== 'used' && vertexValueFuncs.hasOwnProperty(key)) {
          result[key][i] = vertexValueFuncs[key](item, idx, posVal);
        }
      }
    }
    for (key in elementValueFuncs) {
      if (key !== 'used' && elementValueFuncs.hasOwnProperty(key)) {
        var func = elementValueFuncs[key];
        result[key] = new Array(result.elementIndex.length);
        for (i = 0; i < result.elementIndex.length; i += 1) {
          idx = result.elementIndex[i];
          item = data[idx];
          result[key][i] = func(item, idx);
        }
      }
    }
    result.numVertices = numPts;
    result.numElements = result.elements.length / result.verticesPerElement;
    return result;
  };

  /**
   * Initialize.
   *
   * @param {geo.meshFeature.spec} arg The mesh feature specification.
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);

    /* Initialize from arguments */
    arg = arg || {};
    var style = Object.assign({}, {
      position: function position(d) {
        return Array.isArray(d) ? {
          x: d[0],
          y: d[1],
          z: d[2] || 0
        } : d;
      }
    }, arg.style || {});
    m_this.mesh(arg.mesh || {});
    m_this.style(style);
  };
  return this;
};
inherit(_meshFeature, feature);
module.exports = _meshFeature;

/***/ }),

/***/ 1338:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);
var lastInternalId = 0;

/**
 * Create a new instance of class object.
 *
 * @class
 * @alias geo.object
 * @extends geo.timestamp
 * @returns {geo.object}
 */
var _object = function object() {
  'use strict';

  if (!(this instanceof _object)) {
    return new _object();
  }
  var util = __webpack_require__(642);
  var m_this = this,
    m_internalId = ++lastInternalId,
    m_eventHandlers = {},
    m_idleHandlers = [],
    m_promiseCount = 0;

  /**
   * Bind a handler that will be called one time when all internal promises are
   * resolved.  If there are no outstanding promises, this is invoked
   * synchronously.
   *
   * @param {Function} handler A function taking no arguments.
   * @returns {this}
   */
  this.onIdle = function (handler) {
    if (m_promiseCount) {
      m_idleHandlers.push(handler);
    } else {
      handler();
    }
    return m_this;
  };

  /**
   * Getter for the idle state.  Read only.
   *
   * @property {boolean} idle `true` if the object is idle (`onIdle` would call
   *    a handler immediately).
   * @name geo.object#idle
   */
  Object.defineProperty(this, 'idle', {
    get: function get() {
      return !m_promiseCount;
    },
    configurable: true
  });

  /**
   * Private getter for the number of outstanding promises.
   *
   * @property {number} _promises The number of outstanding promises.  If this
   *    is zero, the object is idle.
   * @name geo.object#_promises
   */
  Object.defineProperty(this, '_promises', {
    get: function get() {
      return m_promiseCount;
    },
    configurable: true
  });

  /**
   * Add a new promise object preventing idle event handlers from being called
   * until it is resolved.
   *
   * @param {Promise} promise A promise object.
   * @returns {this}
   */
  this.addPromise = function (promise) {
    // called on any resolution of the promise
    function onDone() {
      if (promise._geojsTracked && promise._geojsTracked[m_internalId]) {
        m_promiseCount -= 1;
        delete promise._geojsTracked[m_internalId];
      }
      if (!m_promiseCount) {
        m_idleHandlers.splice(0, m_idleHandlers.length).forEach(function (handler) {
          handler();
        });
      }
    }
    if (!promise._geojsTracked) {
      promise._geojsTracked = {};
    }
    if (!promise._geojsTracked[m_internalId]) {
      promise._geojsTracked[m_internalId] = true;
      m_promiseCount += 1;
    }
    if (promise.always) {
      promise.always(onDone);
    } else {
      promise.then(onDone, onDone);
    }
    return m_this;
  };

  /**
   * Mark a promise as no longer required to resolve before the idle state is
   * reached.
   *
   * @param {Promise} promise A promise object.
   * @returns {this}
   */
  this.removePromise = function (promise) {
    if (promise._geojsTracked && promise._geojsTracked[m_internalId]) {
      m_promiseCount -= 1;
      delete promise._geojsTracked[m_internalId];
      if (!m_promiseCount) {
        m_idleHandlers.splice(0, m_idleHandlers.length).forEach(function (handler) {
          handler();
        });
      }
    }
    return m_this;
  };

  /**
   * Bind an event handler to this object.
   *
   * @param {string} event An event from {@link geo.event} or a user-defined
   *   value.
   * @param {Function} handler A function that is called when `event` is
   *   triggered.  The function is passed a {@link geo.event} object.
   * @returns {this}
   */
  this.geoOn = function (event, handler) {
    if (Array.isArray(event)) {
      event.forEach(function (e) {
        m_this.geoOn(e, handler);
      });
      return m_this;
    }
    if (!util.isFunction(handler)) {
      console.warn('Handler for ' + event + ' is not a function', handler, m_this); // eslint-disable-line no-console
      return m_this;
    }
    if (!m_eventHandlers.hasOwnProperty(event)) {
      m_eventHandlers[event] = [];
    }
    m_eventHandlers[event].push(handler);
    return m_this;
  };

  /**
   * Bind an event handler to this object that will fire once and then
   * deregister itself.
   *
   * @param {string} event An event from {@link geo.event} or a user-defined
   *   value.
   * @param {Function} handler A function that is called when `event` is
   *   triggered.  The function is passed a {@link geo.event} object.
   * @returns {Function} The actual bound handler.  This is a wrapper around
   *   the handler that was passed to the function.
   */
  this.geoOnce = function (event, handler) {
    var _wrapper = function wrapper(args) {
      m_this.geoOff(event, _wrapper);
      handler.call(m_this, args);
    };
    m_this.geoOn(event, _wrapper);
    return _wrapper;
  };

  /**
   * Report if an event handler is bound to this object.
   *
   * @param {string|string[]} event An event or list of events to check.
   * @param {Function} [handler] A function that might be bound.  If
   *   `undefined`, this will report `true` if there is any handler for the
   *   specified event.
   * @returns {boolean} true if any of the specified events are bound to the
   *   specified handler.
   */
  this.geoIsOn = function (event, handler) {
    if (Array.isArray(event)) {
      return event.some(function (e) {
        return m_this.geoIsOn(e, handler);
      });
    }
    return (m_eventHandlers[event] || []).some(function (h) {
      return h === handler || handler === undefined;
    });
  };

  /**
   * Trigger an event (or events) on this object and call all handlers.
   *
   * @param {string|string[]} event An event or list of events from
   *   {@link geo.event} or defined by the user.
   * @param {object} [args] Additional information to add to the
   *   {@link geo.event} object passed to the handlers.
   * @returns {this}
   */
  this.geoTrigger = function (event, args) {
    // if we have an array of events, recall with single events
    if (Array.isArray(event)) {
      event.forEach(function (e) {
        m_this.geoTrigger(e, args);
      });
      return m_this;
    }

    // append the event type to the argument object
    args = args || {};
    args.event = event;
    if (m_eventHandlers.hasOwnProperty(event)) {
      m_eventHandlers[event].forEach(function (handler) {
        try {
          handler.call(m_this, args);
        } catch (err) {
          console.warn('Event handler for ' + event + ' threw an error', err); // eslint-disable-line no-console
        }
      });
    }
    return m_this;
  };

  /**
   * Remove handlers from one event or an array of events.  If no event is
   * provided all handlers will be removed.
   *
   * @param {string|string[]} [event] An event or a list of events from
   *   {@link geo.event} or defined by the user, or `undefined` to remove all
   *   events (in which case `arg` is ignored).
   * @param {(function|function[])?} [arg] A function or array of functions to
   *   remove from the events or a falsy value to remove all handlers from the
   *   events.
   * @returns {this}
   */
  this.geoOff = function (event, arg) {
    if (event === undefined) {
      m_eventHandlers = {};
      m_idleHandlers = [];
      m_promiseCount = 0;
      // assign a new id so that adding and removing promises behave properly
      m_internalId = ++lastInternalId;
    }
    if (Array.isArray(event)) {
      event.forEach(function (e) {
        m_this.geoOff(e, arg);
      });
      return m_this;
    }
    if (!arg) {
      m_eventHandlers[event] = [];
    } else if (Array.isArray(arg)) {
      arg.forEach(function (handler) {
        m_this.geoOff(event, handler);
      });
      return m_this;
    }
    if (m_eventHandlers.hasOwnProperty(event)) {
      m_eventHandlers[event] = m_eventHandlers[event].filter(function (f) {
        return f !== arg;
      });
    }
    return m_this;
  };

  /**
   * Report the current event handlers.
   *
   * @returns {object} An object with all of the event handlers.
   */
  this._eventHandlers = function () {
    return m_eventHandlers;
  };

  /**
   * Free all resources and destroy the object.
   */
  this._exit = function () {
    m_this.geoOff();
  };
  timestamp.call(this);
  this.modified();
  return this;
};
inherit(_object, timestamp);
module.exports = _object;

/***/ }),

/***/ 4880:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var tileLayer = __webpack_require__(9264);
var registry = __webpack_require__(1098);
var quadFeature = __webpack_require__(3842);
var util = __webpack_require__(642);

/**
 * Object specification for an OSM layer.
 *
 * @typedef {geo.tileLayer.spec} geo.osmLayer.spec
 * @extends {geo.tileLayer.spec}
 * @property {number} [mapOpacity] If specified, and `opacity` is not
 *   specified, use this as the layer opacity.
 * @property {string} [source] If specified, use the predefined tile source
 *   (see {@link geo.osmLayer.tileSources}).
 * @property {string} [crossDomain='anonymous'] Image CORS attribute.  This is
 *   used for the `crossorigin` property when loading images.
 */

/**
 * Create a new instance of osmLayer.  This is a {@link geo.tileLayer} with
 * an OSM url and attribution defaults and with the tiles centered on the
 * origin.
 *
 * @class
 * @alias geo.osmLayer
 * @extends geo.tileLayer
 *
 * @param {geo.osmLayer.spec} [arg] Specification for the layer.
 */
var _osmLayer = function osmLayer(arg) {
  var imageTile = __webpack_require__(4912);
  if (!(this instanceof _osmLayer)) {
    return new _osmLayer(arg);
  }
  arg = arg || {};
  if (arg.mapOpacity !== undefined && arg.opacity === undefined) {
    arg = Object.assign({}, arg);
    arg.opacity = arg.mapOpacity;
  }
  arg = util.deepMerge({}, this.constructor.defaults, _osmLayer.tileSources[this.constructor.defaults.source] || {}, _osmLayer.tileSources[arg.source] || {},
  // don't name the layer based on the source
  {
    name: ''
  }, arg);
  tileLayer.call(this, arg);
  var m_this = this;

  /* mapOpacity is just another name for the layer opacity. */
  this.mapOpacity = this.opacity;

  /**
   * Returns an instantiated imageTile object with the given indices.  This
   * method always returns a new tile object.  Use `_getTileCached` to use
   * the caching layer.
   *
   * @param {object} index The tile index.
   * @param {number} index.x
   * @param {number} index.y
   * @param {number} index.level
   * @param {object} source The tile index used for constructing the url.
   * @param {number} source.x
   * @param {number} source.y
   * @param {number} source.level
   * @returns {geo.tile}
   */
  this._getTile = function (index, source) {
    var urlParams = source || index;
    return imageTile({
      index: index,
      size: {
        x: m_this._options.tileWidth,
        y: m_this._options.tileHeight
      },
      queue: m_this._queue,
      overlap: m_this._options.tileOverlap,
      scale: m_this._options.tileScale,
      url: m_this._options.url.call(m_this, urlParams.x, urlParams.y, Math.max(urlParams.level || 0, Math.min(0, m_this._options.minLevel || 0)), m_this._options.subdomains),
      crossDomain: m_this._options.crossDomain
    });
  };

  /**
   * Get or set a defined tile source.  Tile sources are defined in
   *  {@link geo.osmLayer.tileSources}.
   *
   * @param {string} [source] The name of a defined tile source or `undefined`
   *    get the current named tile source, if any.
   * @returns {string|undefined|this} Either the name of the current tile
   *    source, if any.  Returns `this` when setting the source.
   */
  this.source = function (source) {
    if (source === undefined) {
      for (var key in _osmLayer.tileSources) {
        if (_osmLayer.tileSources[key].url === m_this.url()) {
          return key;
        }
      }
      return;
    }
    if (_osmLayer.tileSources[source]) {
      m_this.url(_osmLayer.tileSources[source].url);
      m_this.subdomains(_osmLayer.tileSources[source].subdomains || 'abc');
      m_this.attribution(_osmLayer.tileSources[source].attribution || '');
      m_this._options.maxLevel = _osmLayer.tileSources[source].maxLevel || 18;
      m_this._options.minLevel = _osmLayer.tileSources[source].minLevel || 0;
    }
    return m_this;
  };
};

/**
 * This object contains the default options used to initialize the osmLayer.
 */
_osmLayer.defaults = Object.assign({}, tileLayer.defaults, {
  tileOffset: function tileOffset(level) {
    var s = Math.pow(2, level - 1) * 256;
    return {
      x: s,
      y: s
    };
  },
  url: '',
  source: 'osm'
});

/* Stamen's website (http://maps.stamen.com) as of 2019-08-28 says that the
 * maps they host may be used free of charge.  For http access, use a url like
 * http://{s}.tile.stamen.com/toner-lite/{z}/{x}/{y}.png */
var StamenAttribution = 'Map tiles by <a href="http://stamen.com">Stamen ' + 'Design</a>, under <a href="http://creativecommons.org/licenses/by/3.0">' + 'CC BY 3.0</a>. Data by <a href="http://openstreetmap.org">OpenStreetMap' + '</a>, under <a href="http://www.openstreetmap.org/copyright">ODbL</a>.';

/* Per Carto's website regarding basemap attribution: https://carto.com/help/working-with-data/attribution/#basemaps */
var CartoAttribution = '<a href="https://carto.com"> Carto</a> ' + 'Contributors <a href="https://www.openstreetmap.org/"> OpenStreetMap</a>';

/**
 * This is a list of known tile sources.  It can be added to via
 * `geo.osmLayer.tilesource[<key>] = <object>`, where the object has `url`,
 * `attribution`, `subdomains`, `minLevel`, and `maxLevel` defined.
 *
 * @type {object}
 */
_osmLayer.tileSources = {
  'dark-matter-with-labels': {
    url: ' https://{s}.basemaps.cartocdn.com/rastertiles/dark_all/{z}/{x}/{y}.png',
    attribution: CartoAttribution,
    name: 'Carto Dark Matter With Labels',
    minLevel: 0,
    maxLevel: 18
  },
  'dark-matter-without-labels': {
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/dark_nolabels/{z}/{x}/{y}.png',
    attribution: CartoAttribution,
    name: 'Carto Dark Matter Without Labels',
    minLevel: 0,
    maxLevel: 18
  },
  'nationalmap-relief': {
    url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/tile/{z}/{y}/{x}',
    attribution: 'Tile data from <a href="https://basemap.nationalmap.gov/">USGS</a>',
    name: 'National Map Shaded Relief',
    minLevel: 0,
    maxLevel: 16
  },
  'nationalmap-satellite': {
    url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}',
    attribution: 'Tile data from <a href="https://basemap.nationalmap.gov/">USGS</a>',
    name: 'National Map Satellite',
    minLevel: 0,
    maxLevel: 16
  },
  'nationalmap-satellite-topo': {
    url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}',
    attribution: 'Tile data from <a href="https://basemap.nationalmap.gov/">USGS</a>',
    name: 'National Map Satellite and Topo',
    minLevel: 0,
    maxLevel: 16
  },
  'nationalmap-topo': {
    url: 'https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}',
    attribution: 'Tile data from <a href="https://basemap.nationalmap.gov/">USGS</a>',
    name: 'National Map Topo',
    minLevel: 0,
    maxLevel: 16
  },
  osm: {
    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    attribution: 'Tile data &copy; <a href="https://osm.org/copyright">' + 'OpenStreetMap</a> contributors',
    name: 'OpenStreetMap',
    subdomains: 'abc',
    minLevel: 0,
    maxLevel: 19
  },
  'positron-with-labels': {
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}.png',
    attribution: CartoAttribution,
    name: 'Carto Positron With Labels',
    minLevel: 0,
    maxLevel: 18
  },
  'positron-without-labels': {
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/light_nolabels/{z}/{x}/{y}.png',
    attribution: CartoAttribution,
    name: 'Carto Positron Without Labels',
    minLevel: 0,
    maxLevel: 18
  },
  'stamen-terrain': {
    url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}.png',
    attribution: StamenAttribution,
    name: 'Stamen Terrain',
    subdomains: 'abcd',
    minLevel: 0,
    maxLevel: 14
  },
  'stamen-terrain-background': {
    url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}.png',
    attribution: StamenAttribution,
    name: 'Stamen Terrain Background',
    subdomains: 'abcd',
    minLevel: 0,
    maxLevel: 14
  },
  'stamen-toner': {
    url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/toner/{z}/{x}/{y}.png',
    attribution: StamenAttribution,
    name: 'Stamen Toner',
    subdomains: 'abcd',
    minLevel: 0,
    maxLevel: 20
  },
  'stamen-toner-lite': {
    url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}.png',
    attribution: StamenAttribution,
    name: 'Stamen Toner Lite',
    subdomains: 'abcd',
    minLevel: 0,
    maxLevel: 20
  },
  'voyager-with-labels': {
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}.png',
    attribution: CartoAttribution,
    name: 'Carto Voyager With Labels',
    minLevel: 0,
    maxLevel: 18
  },
  'voyager-without-labels': {
    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}.png',
    attribution: CartoAttribution,
    name: 'Carto Voyager Without Labels',
    minLevel: 0,
    maxLevel: 18
  }
};
inherit(_osmLayer, tileLayer);
/* By default, ask to support image quads.  If the user needs full
 * reprojection, they will need to require the
 * quadFeature.capabilities.imageFull feature */
registry.registerLayer('osm', _osmLayer, [quadFeature.capabilities.image]);
module.exports = _osmLayer;

/***/ }),

/***/ 2266:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Specification for pathFeature.
 *
 * @typedef {geo.feature.spec} geo.pathFeature.spec
 * @extends {geo.feature.spec}
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 */

/**
 * Style specification for a path feature.
 *
 * The style for components of the stroke are passed `(dataElement,
 * dataIndex)`, where the result applies to the stroke between that data
 * element and the following element (at index `dataIndex + `).
 *
 * @typedef {geo.feature.styleSpec} geo.pathFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {boolean|Function} [stroke=true] True to stroke the path.
 * @property {geo.geoColor|Function} [strokeColor='white'] Color to stroke each
 *   path.
 * @property {number|Function} [strokeOpacity=1] Opacity for each path's
 *   stroke.  Opacity is on a [0-1] scale.
 * @property {number|Function} [strokeWidth=1] The weight of the path's stroke
 *   in pixels.
 */

/**
 * Create a new instance of class pathFeature.
 *
 * @class
 * @alias geo.pathFeature
 * @extends geo.feature
 * @param {geo.pathFeature.spec} arg
 * @returns {geo.pathFeature}
 */
var _pathFeature = function pathFeature(arg) {
  'use strict';

  if (!(this instanceof _pathFeature)) {
    return new _pathFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);
  var m_this = this,
    s_init = this._init;
  this.featureType = 'path';

  /**
   * Get/Set position.
   *
   * @param {Function|geo.geoPosition} [val] If not specified, return the
   *    position accessor.  Otherwise, change the position accessor.
   * @returns {this|Function}
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    }
    if (val !== m_this.style('position')) {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.pathFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      strokeWidth: 1,
      strokeColor: {
        r: 1.0,
        g: 1.0,
        b: 1.0
      },
      position: function position(d) {
        return Array.isArray(d) ? {
          x: d[0],
          y: d[1],
          z: d[2] || 0
        } : d;
      }
    }, arg.style === undefined ? {} : arg.style);
    if (arg.position !== undefined) {
      defaultStyle.position = arg.position;
    }
    m_this.style(defaultStyle);
    if (defaultStyle.position) {
      m_this.position(defaultStyle.position);
    }
    m_this.dataTime().modified();
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_pathFeature, feature);
module.exports = _pathFeature;

/***/ }),

/***/ 7761:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var util = __webpack_require__(642);

/**
 * Pixelmap feature specification.
 *
 * @typedef {geo.feature.spec} geo.pixelmapFeature.spec
 * @extends geo.feature.spec
 * @property {string|Function|HTMLImageElement} [url] URL of a pixel map or an
 *   HTML Image element.  The rgb data is interpreted as an index of the form
 *   0xbbggrr.  The alpha channel is ignored.  An index of 0xffffff is treated
 *   as a no-data value for hit-tests.
 * @property {geo.geoColor|Function} [color] The color that should be used
 *   for each data element.  Data elements correspond to the indices in the
 *   pixel map. If an index is larger than the number of data elements, it will
 *   be transparent.  If there is more data than there are indices, it is
 *   ignored.
 * @property {geo.geoPosition|Function} [position] Position of the image.
 *   Default is (data).  The position is an Object which specifies the corners
 *   of the quad: ll, lr, ur, ul.  At least two opposite corners must be
 *   specified.  The corners do not have to physically correspond to the order
 *   specified, but rather correspond to that part of the image map.  If a
 *   corner is unspecified, it will use the x coordinate from one adjacent
 *   corner, the y coordinate from the other adjacent corner, and the average z
 *   value of those two corners.  For instance, if ul is unspecified, it is
 *   {x: ll.x, y: ur.y}.  Note that each quad is rendered as a pair of
 *   triangles: (ll, lr, ul) and (ur, ul, lr).  Nothing special is done for
 *   quads that are not convex or quads that have substantially different
 *   transformations for those two triangles.
 */

/**
 * Create a new instance of class pixelmapFeature
 *
 * @class
 * @alias geo.pixelmapFeature
 * @param {geo.pixelmapFeature.spec} arg Options object.
 * @extends geo.feature
 * @returns {geo.pixelmapFeature}
 */

var _pixelmapFeature = function pixelmapFeature(arg) {
  'use strict';

  if (!(this instanceof _pixelmapFeature)) {
    return new _pixelmapFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_update = this._update,
    m_modifiedIndexRange,
    s_init = this._init;
  this.featureType = 'pixelmap';

  /**
   * Get/Set position accessor.
   *
   * @param {geo.geoPosition|Function} [val] If not specified, return the
   *    current position accessor.  If specified, use this for the position
   *    accessor and return `this`.  See {@link geo.quadFeature.position} for
   *    for details on this position.
   * @returns {geo.geoPosition|Function|this}
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else if (val !== m_this.style('position')) {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set url accessor.
   *
   * @param {string|Function} [val] If not specified, return the current url
   *    accessor.  If specified, use this for the url accessor and return
   *    `this`.
   * @returns {string|Function|this}
   */
  this.url = function (val) {
    if (val === undefined) {
      return m_this.style('url');
    } else if (val !== m_this.style('url')) {
      m_this.m_srcImage = m_this.m_info = undefined;
      m_this.style('url', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set color accessor.
   *
   * @param {geo.geoColor|Function} [val] The new color map accessor or
   *    `undefined` to get the current accessor.
   * @returns {geo.geoColor|Function|this}
   */
  this.color = function (val) {
    if (val === undefined) {
      return m_this.style('color');
    } else if (val !== m_this.style('color')) {
      m_this.style('color', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Mark that an index's data value (and hence its color) has changed without
   * marking all of the data array as changed.  If this function is called
   * without any parameters, it clears the tracked changes.
   *
   * @param {number} [idx] The lowest data index that has changed.  If
   *    `undefined`, return the current tracked changed range.
   * @param {number|'clear'} [idx2] If an index was specified in `idx` and
   *    this is specified, the highest index (inclusive) that has changed.  If
   *    returning the tracked changed range and this is `clear`, clear the
   *    tracked range.
   * @returns {this|number[]} When returning a range, this is the lowest and
   *    highest index values that have changed (inclusive), so their range is
   *    `[0, data.length)`.
   */
  this.indexModified = function (idx, idx2) {
    if (idx === undefined) {
      var range = m_modifiedIndexRange;
      if (idx2 === 'clear') {
        m_modifiedIndexRange = undefined;
      }
      return range;
    }
    m_this.modified();
    if (m_modifiedIndexRange === undefined) {
      m_modifiedIndexRange = [idx, idx];
    }
    if (idx < m_modifiedIndexRange[0]) {
      m_modifiedIndexRange[0] = idx;
    }
    if ((idx2 || idx) > m_modifiedIndexRange[1]) {
      m_modifiedIndexRange[1] = idx2 || idx;
    }
    return m_this;
  };

  /**
   * Update.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.buildTime().timestamp() <= m_this.dataTime().timestamp() || m_this.updateTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Get the maximum index value from the pixelmap.  This is a value present in
   * the pixelmap.
   *
   * @returns {number?} The maximum index value.
   */
  this.maxIndex = function () {
    if (m_this.m_info) {
      /* This isn't just m_info.mappedColors.length - 1, since there
       * may be more data than actual indices. */
      if (m_this.m_info.maxIndex === undefined) {
        m_this.m_info.maxIndex = 0;
        for (var idx in m_this.m_info.mappedColors) {
          if (m_this.m_info.mappedColors.hasOwnProperty(idx)) {
            m_this.m_info.maxIndex = Math.max(m_this.m_info.maxIndex, idx);
          }
        }
      }
      return m_this.m_info.maxIndex;
    }
    return undefined;
  };

  /**
   * Given the loaded pixelmap image, create a canvas the size of the image.
   * Compute a color for each distinct index and recolor the canvas based on
   * these colors, then draw the resultant image as a quad.
   *
   * @fires geo.event.pixelmap.prepared
   */
  this._computePixelmap = function () {};

  /**
   * Build.  Fetches the image if necessary.
   *
   * @returns {this}
   */
  this._build = function () {
    /* Set the build time at the start of the call.  A build can result in
     * drawing a quad, which can trigger a full layer update, which in turn
     * checks if this feature is built.  Setting the build time avoids calling
     * this a second time. */
    if (!m_this.m_srcImage) {
      var src = m_this.style.get('url')();
      if (util.isReadyImage(src)) {
        /* we have an already loaded image, so we can just use it. */
        m_this.m_srcImage = src;
        m_this._computePixelmap();
      } else if (src) {
        var defer = $.Deferred(),
          prev_onload,
          prev_onerror;
        if (src instanceof Image) {
          /* we have an unloaded image.  Hook to the load and error callbacks
           * so that when it is loaded we can use it. */
          m_this.m_srcImage = src;
          prev_onload = src.onload;
          prev_onerror = src.onerror;
        } else {
          /* we were given a url, so construct a new image */
          m_this.m_srcImage = new Image();
          // Only set the crossOrigin parameter if this is going across origins.
          if (src.indexOf(':') >= 0 && src.indexOf('/') === src.indexOf(':') + 1) {
            m_this.m_srcImage.crossOrigin = m_this.style.get('crossDomain')() || 'anonymous';
          }
        }
        m_this.m_srcImage.onload = function () {
          if (prev_onload) {
            prev_onload.apply(m_this, arguments);
          }
          /* Only use this image if our pixelmap hasn't changed since we
           * attached our handler */
          if (m_this.style.get('url')() === src) {
            m_this.m_info = undefined;
            m_this._computePixelmap();
          }
          defer.resolve();
        };
        m_this.m_srcImage.onerror = function () {
          if (prev_onerror) {
            prev_onerror.apply(m_this, arguments);
          }
          defer.reject();
        };
        defer.promise(m_this);
        m_this.layer().addPromise(m_this);
        if (!(src instanceof Image)) {
          m_this.m_srcImage.src = src;
        }
      }
    } else if (m_this.m_info) {
      m_this._computePixelmap();
    } else {
      m_this._computePixelmap();
    } // else we need to regenerate the images for canvas
    m_this.buildTime().modified();
    return m_this;
  };

  /**
   * Given the results of the quad search, determine which pixel index is
   * found.
   *
   * @param {object} result An object with `index`: a list of quad indices,
   *    `found`: a list of quads that contain the specified coordinate, and
   *    `extra`: an object with keys that are quad indices and values that are
   *    objects with `basis.x` and `basis.y`, values from 0 - 1 relative to
   *    interior of the quad.
   * @returns {geo.feature.searchResult} An object with a list of features and
   *    feature indices that are located at the specified point.
   */
  this._pointSearchProcess = function (result) {
    // use the last index by preference, since for tile layers, this is the
    // topmosttile
    var idxIdx = result.index.length - 1;
    for (; idxIdx >= 0; idxIdx -= 1) {
      if (result.extra[result.index[idxIdx]]._quad && result.extra[result.index[idxIdx]]._quad.image) {
        var img = result.extra[result.index[idxIdx]]._quad.image;
        if (result.extra[result.index[idxIdx]]._quad.m_srcImage) {
          img = result.extra[result.index[idxIdx]]._quad.m_srcImage;
        }
        var basis = result.extra[result.index[idxIdx]].basis;
        var x = Math.floor(basis.x * img.width);
        var y = Math.floor(basis.y * img.height);
        var canvas = document.createElement('canvas');
        canvas.width = canvas.height = 1;
        var context = canvas.getContext('2d');
        context.drawImage(img, x, y, 1, 1, 0, 0, 1, 1);
        var pixel = context.getImageData(0, 0, 1, 1).data;
        var idx = pixel[0] + pixel[1] * 256 + pixel[2] * 256 * 256;
        if (idx === 16777215) {
          continue;
        }
        result = {
          index: [idx],
          found: [m_this.data()[idx]]
        };
        return result;
      }
    }
    return {
      index: [],
      found: []
    };
  };

  /**
   * Initialize.
   *
   * @param {geo.pixelmapFeature.spec} arg
   * @returns {this}
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var style = Object.assign({}, {
      color: function color(d, idx) {
        return {
          r: (idx & 0xFF) / 255,
          g: (idx >> 8 & 0xFF) / 255,
          b: (idx >> 16 & 0xFF) / 255,
          a: 1
        };
      },
      position: util.identityFunction
    }, arg.style === undefined ? {} : arg.style);
    if (arg.position !== undefined) {
      style.position = arg.position;
    }
    if (arg.url !== undefined) {
      style.url = arg.url;
    }
    if (arg.color !== undefined) {
      style.color = arg.color;
    }
    m_this.style(style);
    m_this.dataTime().modified();
    if (arg.quadFeature) {
      m_this.m_srcImage = true;
      m_this._computePixelmap();
    }
    return m_this;
  };
  return this;
};

/**
 * Create a pixelmapFeature from an object.
 *
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to
 * @param {geo.pixelmapFeature.spec} spec The object specification
 * @returns {geo.pixelmapFeature|null}
 */
_pixelmapFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'pixelmap';
  return feature.create(layer, spec);
};
_pixelmapFeature.capabilities = {
  /* core feature name -- support in any manner */
  feature: 'pixelmap',
  /* support for image-based lookup */
  lookup: 'pixelmap.lookup'
};
inherit(_pixelmapFeature, feature);
module.exports = _pixelmapFeature;

/***/ }),

/***/ 534:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var tileLayer = __webpack_require__(9264);
var registry = __webpack_require__(1098);
var quadFeature = __webpack_require__(3842);
var pixelmapFeature = __webpack_require__(7761);
var util = __webpack_require__(642);

/**
 * Object specification for a pixelmap layer.
 *
 * @typedef {geo.tileLayer.spec} geo.pixelmapLayer.spec
 * @extends {geo.tileLayer.spec}
 * @property {geo.geoColor|Function} [color] The color that should be used
 *   for each data element.  Data elements correspond to the indices in the
 *   pixel map. If an index is larger than the number of data elements, it will
 *   be transparent.  If there is more data than there are indices, it is
 *   ignored.
 * @property {object} [style] An optional style object that could contain
 *   `color` or other style values.
 * @property {array} [data] A new data array.
 * @property {string} [crossDomain='anonymous'] Image CORS attribute.  This is
 *   used for the `crossorigin` property when loading images.
 */

/**
 * Create a new instance of pixelmapLayer.  This is a {@link geo.tileLayer} with
 * an OSM url and attribution defaults and with the tiles centered on the
 * origin.
 *
 * @class
 * @alias geo.pixelmapLayer
 * @extends geo.tileLayer
 *
 * @param {geo.pixelmapLayer.spec} [arg] Specification for the layer.
 */
var _pixelmapLayer = function pixelmapLayer(arg) {
  var imageTile = __webpack_require__(4912);
  if (!(this instanceof _pixelmapLayer)) {
    return new _pixelmapLayer(arg);
  }
  arg = arg || {};
  /* Don't extend data from args -- it can be very slow */
  var argdata;
  if (arg.data) {
    argdata = arg.data;
    delete arg.data;
  }
  arg = util.deepMerge({}, this.constructor.defaults, arg);
  tileLayer.call(this, arg);
  var s_init = this._init,
    m_pixelmapFeature,
    m_this = this;

  /**
   * Returns an instantiated imageTile object with the given indices.  This
   * method always returns a new tile object.  Use `_getTileCached` to use
   * the caching layer.
   *
   * @param {object} index The tile index.
   * @param {number} index.x
   * @param {number} index.y
   * @param {number} index.level
   * @param {object} source The tile index used for constructing the url.
   * @param {number} source.x
   * @param {number} source.y
   * @param {number} source.level
   * @returns {geo.tile}
   */
  this._getTile = function (index, source) {
    var urlParams = source || index;
    return imageTile({
      index: index,
      size: {
        x: m_this._options.tileWidth,
        y: m_this._options.tileHeight
      },
      queue: m_this._queue,
      overlap: m_this._options.tileOverlap,
      scale: m_this._options.tileScale,
      url: m_this._options.url.call(m_this, urlParams.x, urlParams.y, Math.max(urlParams.level || 0, Math.min(0, m_this._options.minLevel || 0)), m_this._options.subdomains),
      crossDomain: m_this._options.crossDomain
    });
  };

  /**
   * Initialize.
   *
   * @returns {this} The current layer.
   */
  this._init = function () {
    // Call super class init
    s_init.apply(m_this, arguments);
    m_this.nearestPixel(true, true);
    var pixelmapArgs = {
      quadFeature: m_this.features()[0]
    };
    if (arg.style) {
      pixelmapArgs.style = arg.style;
    }
    if (arg.color) {
      pixelmapArgs.color = arg.color;
    }
    m_pixelmapFeature = m_this.createFeature('pixelmap', pixelmapArgs);
    if (argdata) {
      m_pixelmapFeature.data(argdata);
    }
    m_this.style = m_pixelmapFeature.style;
    m_this.data = m_pixelmapFeature.data;
    m_this.indexModified = m_pixelmapFeature.indexModified;
    var s_dataTimeModified = m_this.dataTime().modified;
    m_this.dataTime().modified = function () {
      m_pixelmapFeature.dataTime().modified();
      return s_dataTimeModified();
    };
    ['modified', 'geoOn', 'geoOff', 'geoOnce'].forEach(function (funcName) {
      var superFunc = m_this[funcName];
      m_this[funcName] = function () {
        if (!Array.isArray(arguments[0])) {
          m_pixelmapFeature[funcName].apply(this, arguments);
        }
        return superFunc.apply(this, arguments);
      };
    });
    return m_this;
  };
  return m_this;
};

/**
 * This object contains the default options used to initialize the
 * pixelmapLayer.
 */
_pixelmapLayer.defaults = Object.assign({}, tileLayer.defaults, {
  features: [quadFeature.capabilities.image, pixelmapFeature.capabilities.lookup],
  tileOffset: function tileOffset(level) {
    var s = Math.pow(2, level - 1) * 256;
    return {
      x: s,
      y: s
    };
  },
  url: ''
});
inherit(_pixelmapLayer, tileLayer);
/* By default, ask to support image quads.  If the user needs full
 * reprojection, they will need to require the
 * quadFeature.capabilities.imageFull feature */
registry.registerLayer('pixelmap', _pixelmapLayer, [quadFeature.capabilities.image]);
module.exports = _pixelmapLayer;

/***/ }),

/***/ 7541:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Object specification for a point feature.
 *
 * @typedef {geo.feature.spec} geo.pointFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 * @property {geo.pointFeature.styleSpec} [style] Style object with default
 *   style options.
 * @property {boolean|geo.pointFeature.clusteringSpec} [clustering=false]
 *   Enable point clustering.
 * @property {string} [primitiveShape='auto'] For the webgl renderer, select
 *   the primitive shape.  This is one of `pointFeature.primitiveShapes`:
 *   `'auto'`, `'sprite'`, `'triangle'`, or `'square'`.  `sprite` uses the
 *   least memory but has a maximum size dependent on the GPU, `triangle` is
 *   fastest if the vertex shader is the bottleneck, and `square` is fastest if
 *   the fragment shader is the bottleneck.  `auto` will use `sprite` unless
 *   the largest point exceeds the size that can be rendered via GL points, and
 *   then it will switch to `triangle`.  The computation for `auto` uses some
 *   time, so using a specific primitive could be faster.
 * @property {boolean} [dynamicDraw=false] For the webgl renderer, if this is
 *   truthy, webgl source buffers can be modified and updated directly.
 *   truthy, webgl source buffers can be modified and updated directly.  This
 *   is not strictly necessary, as it is just a recommendation for the GPU.
 */

/**
 * Style specification for a point feature.
 *
 * @typedef {geo.feature.styleSpec} geo.pointFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {number|Function} [radius=5] Radius of each point in pixels.  This
 *   is the fill radius inside of the stroke.
 * @property {boolean|Function} [stroke=true] True to stroke point.
 * @property {geo.geoColor|Function} [strokeColor] Color to stroke each point.
 * @property {number|Function} [strokeOpacity=1] Opacity for each point's
 *   stroke.  Opacity is on a [0-1] scale.
 * @property {number|Function} [strokeWidth=1.25] The weight of the point's
 *   stroke in pixels.
 * @property {boolean|Function} [fill=true] True to fill point.
 * @property {geo.geoColor|Function} [fillColor] Color to fill each point.
 * @property {number|Function} [fillOpacity=1] Opacity for each point.  Opacity
 *   is on a [0-1] scale.
 * @property {number[]|Function} [origin] Origin in map gcs coordinates used
 *   for to ensure high precision drawing in this location.  When called as a
 *   function, this is passed the point positions as a single continuous array
 *   in map gcs coordinates.  It defaults to the first point's position.
 */

/**
 * Point clustering specification.
 *
 * @typedef {object} geo.pointFeature.clusteringSpec
 * @property {number} [radius=10] This is size in pixels that determines how
 *   close points need to be to each other to be clustered.
 * @property {number} [maxZoom=18] Never cluster above this zoom level.  For a
 *   point feature associated with a layer and a map, this will default to the
 *   map's zoomRange().max value.
 */

/**
 * Create a new instance of class pointFeature.
 *
 * @class
 * @alias geo.pointFeature
 * @extends geo.feature
 * @param {geo.pointFeature.spec} arg
 * @returns {geo.pointFeature}
 */
var _pointFeature = function pointFeature(arg) {
  'use strict';

  if (!(this instanceof _pointFeature)) {
    return new _pointFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);
  var timestamp = __webpack_require__(77);
  var ClusterGroup = __webpack_require__(5966);
  var geo_event = __webpack_require__(6409);
  var util = __webpack_require__(642);
  var KDBush = __webpack_require__(4279);
  KDBush = KDBush.__esModule ? KDBush.default : KDBush;

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init,
    m_rangeTree = null,
    m_rangeTreeTime = timestamp(),
    s_data = this.data,
    m_maxRadius = 0,
    m_clustering = arg.clustering,
    m_clusterTree = null,
    m_allData = [],
    m_lastZoom = null,
    m_ignoreData = false; // flag to ignore data() calls made locally

  this.featureType = 'point';

  /**
   * Get/Set clustering option.
   *
   * @param {boolean|geo.pointFeature.clusteringSpec} [val] If not specified,
   *   return the current value.  If specified and falsy, turn off clustering.
   *   If `true`, use a default clustering with `radius` set to `0.01`.
   *   Otherwise, turn on clustering with these options.
   * @returns {geo.pointFeature.clusteringSpec|boolean|this}
   */
  this.clustering = function (val) {
    if (val === undefined) {
      return m_clustering;
    }
    if (m_clustering && !val) {
      // Throw out the cluster tree and reset the data
      m_clusterTree = null;
      m_clustering = false;
      s_data(m_allData);
    } else if (val && m_clustering !== val) {
      // Generate the cluster tree
      m_clustering = val;
      m_this._clusterData();
    }
    return m_this;
  };

  /**
   * Generate the clustering tree from positions.  This might be async in the
   * future.
   */
  this._clusterData = function () {
    if (!m_clustering) {
      // clustering is not enabled, so this is a no-op
      return;
    }

    // set clustering options to default if an options argument wasn't supplied
    var opts = m_clustering === true ? {
      radius: 10
    } : m_clustering;
    if (!opts.maxZoom && this.layer() && this.layer().map()) {
      opts = Object.assign({}, opts);
      opts.maxZoom = this.layer().map().zoomRange().max;
    }

    // generate the cluster tree from the raw data
    var position = m_this.position();
    var map = m_this.layer().map(),
      scrCenter = map.gcsToDisplay(map.center(undefined, null), null),
      center = map.displayToGcs(scrCenter, m_this.gcs()),
      offset = map.displayToGcs({
        x: scrCenter.x + opts.radius,
        y: scrCenter.y
      }, m_this.gcs()),
      radiusInGcsAtZoom = Math.pow(Math.pow(offset.y - center.y, 2) + Math.pow(offset.x - center.x, 2), 0.5),
      zoom = map.zoom(),
      radiusInGcsAtZoom0 = radiusInGcsAtZoom * Math.pow(2, zoom);
    opts = Object.assign({}, opts, {
      radius: radiusInGcsAtZoom0
    });
    m_clusterTree = new ClusterGroup(opts);
    m_allData.forEach(function (d, i) {
      // for each point in the data set normalize the coordinate
      // representation and add the point to the cluster tree
      var pt = util.normalizeCoordinates(position(d, i));
      pt.index = i;
      m_clusterTree.addPoint(pt);
    });

    // reset the last zoom state and trigger a redraw at the current zoom level
    m_lastZoom = null;
    m_this._handleZoom(map.zoom());
  };

  /**
   * Handle zoom events for clustering.  This keeps track of the last
   * clustering level, and only regenerates the displayed points when the
   * zoom level changes.
   *
   * @param {number} zoom The new zoom level.
   */
  this._handleZoom = function (zoom) {
    // get the current zoom level rounded down
    var z = Math.floor(zoom);
    if (!m_clustering || z === m_lastZoom) {
      // short cut when there is nothing to do
      return;
    }

    // store the current zoom level privately
    m_lastZoom = z;
    var points = m_clusterTree.points(z);
    var clusters = m_clusterTree.clusters(z);
    var data = new Array(points.length + clusters.length);
    for (var pidx = 0; pidx < points.length; pidx += 1) {
      data[pidx] = m_allData[points[pidx].index];
    }

    // append the clusters at the current level
    for (var cidx = 0, didx = points.length; cidx < clusters.length; cidx += 1, didx += 1) {
      var d = clusters[cidx];
      // mark the datum as a cluster for accessor methods
      d.__cluster = true;
      data[didx] = d;
    }

    // prevent recomputing the clustering and set the new data array
    m_ignoreData = true;
    m_this.data(data);
  };

  /**
   * Get/Set position.
   *
   * @param {Function|geo.geoPosition} [val] If not specified, return the
   *    position accessor, which is guaranteed to be a function.  If specified,
   *    wrap the value in an function that handles clustering if it is enabled
   *    and set the position accessor to that function.
   * @returns {this|Function}
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else {
      var isFunc = util.isFunction(val);
      m_this.style('position', function (d, i) {
        if (d !== null && d !== undefined && d.__cluster) {
          return d;
        } else if (isFunc) {
          return val(d, i);
        } else {
          return val;
        }
      });
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Update the current range tree object.  Should be called whenever the
   * data changes.
   */
  this._updateRangeTree = function () {
    if (m_rangeTreeTime.timestamp() >= m_this.dataTime().timestamp() && m_rangeTreeTime.timestamp() >= m_this.timestamp()) {
      return;
    }
    var pts,
      position,
      radius = m_this.style.get('radius'),
      stroke = m_this.style.get('stroke'),
      strokeWidth = m_this.style.get('strokeWidth');
    position = m_this.position();
    m_maxRadius = 0;

    // create an array of positions in geo coordinates
    pts = m_this.data().map(function (d, i) {
      var pt = position(d, i);

      // store the maximum point radius
      m_maxRadius = Math.max(m_maxRadius, radius(d, i) + (stroke(d, i) ? strokeWidth(d, i) : 0));
      return [pt.x, pt.y];
    });
    m_rangeTree = new KDBush(pts.length);
    var _iterator = _createForOfIteratorHelper(pts),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          x = _step$value[0],
          y = _step$value[1];
        m_rangeTree.add(x, y);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    m_rangeTree.finish();
    m_rangeTreeTime.modified();
  };

  /**
   * Returns an array of datum indices that contain the given point.
   * Largely adapted from wigglemaps pointQuerier:
   * https://github.com/dotskapes/wigglemaps/blob/cf5bed3fbfe2c3e48d31799462a80c564be1fb60/src/query/PointQuerier.js
   * This does not take into account clustering.
   *
   * @param {geo.geoPosition} p point to search for.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of point indices, and
   *    `found`: a list of points that contain the specified coordinate.
   */
  this.pointSearch = function (p, gcs) {
    var min,
      max,
      data,
      idx = [],
      found = [],
      ifound = [],
      map,
      pt,
      fgcs = m_this.gcs(),
      // this feature's gcs
      corners,
      fill = m_this.style.get('fill'),
      stroke = m_this.style.get('stroke'),
      strokeWidth = m_this.style.get('strokeWidth'),
      radius = m_this.style.get('radius');
    data = m_this.data();
    if (!data || !data.length) {
      return {
        found: [],
        index: []
      };
    }

    // We need to do this before we find corners, since the max radius is
    // determined then
    m_this._updateRangeTree();
    map = m_this.layer().map();
    pt = map.gcsToDisplay(p, gcs);
    // check all corners to make sure we handle rotations
    corners = [map.displayToGcs({
      x: pt.x - m_maxRadius,
      y: pt.y - m_maxRadius
    }, fgcs), map.displayToGcs({
      x: pt.x + m_maxRadius,
      y: pt.y - m_maxRadius
    }, fgcs), map.displayToGcs({
      x: pt.x - m_maxRadius,
      y: pt.y + m_maxRadius
    }, fgcs), map.displayToGcs({
      x: pt.x + m_maxRadius,
      y: pt.y + m_maxRadius
    }, fgcs)];
    min = {
      x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };
    max = {
      x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };

    // Find points inside the bounding box
    idx = m_rangeTree.range(min.x, min.y, max.x, max.y);
    idx = Uint32Array.from(idx).sort();
    // Filter by circular region
    idx.forEach(function (i) {
      var d = data[i],
        hasstroke = stroke(data[i], i);
      if (!hasstroke && !fill(data[i], i)) {
        return;
      }
      var p = m_this.position()(d, i),
        dx,
        dy,
        rad,
        rad2;
      rad = radius(data[i], i);
      rad += hasstroke ? strokeWidth(data[i], i) : 0;
      if (rad) {
        rad2 = rad * rad;
        p = map.gcsToDisplay(p, fgcs);
        dx = p.x - pt.x;
        dy = p.y - pt.y;
        if (dx * dx + dy * dy <= rad2) {
          found.push(d);
          ifound.push(i);
        }
      }
    });
    return {
      found: found,
      index: ifound
    };
  };

  /**
   * Returns an array of datum indices that are contained in the given polygon.
   * This does not take clustering into account.
   *
   * @param {geo.polygonObject} poly A polygon as an array of coordinates or an
   *    object with `outer` and optionally `inner` parameters.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include points that are
   *    partially in the polygon, otherwise only include points that are fully
   *    within the region.  If 'center', only points whose centers are inside
   *    the polygon are returned.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of point indices,
   *    `found`: a list of points within the polygon, and `extra`: an object
   *    with index keys containing an object with a `partial` key and a boolean
   *    value to indicate if the point is on the polygon's border and a
   *    `distance` key to indicate how far within the polygon the point is
   *    located.
   */
  this.polygonSearch = function (poly, opts, gcs) {
    var fgcs = m_this.gcs(),
      // this feature's gcs
      found = [],
      ifound = [],
      extra = {},
      map = m_this.layer().map(),
      data = m_this.data(),
      fill = m_this.style.get('fill'),
      stroke = m_this.style.get('stroke'),
      strokeWidth = m_this.style.get('strokeWidth'),
      radius = m_this.style.get('radius'),
      idx,
      min,
      max,
      corners;
    if (!poly.outer) {
      poly = {
        outer: poly,
        inner: []
      };
    }
    if (poly.outer.length < 3 || !data || !data.length) {
      return {
        found: [],
        index: [],
        extra: {}
      };
    }
    opts = opts || {};
    opts.partial = opts.partial || false;
    poly = {
      outer: map.gcsToDisplay(poly.outer, gcs),
      inner: (poly.inner || []).map(function (inner) {
        return map.gcsToDisplay(inner, gcs);
      })
    };
    poly.outer.forEach(function (p) {
      if (!min) {
        min = {
          x: p.x,
          y: p.y
        };
        max = {
          x: p.x,
          y: p.y
        };
      }
      if (p.x < min.x) {
        min.x = p.x;
      }
      if (p.x > max.x) {
        max.x = p.x;
      }
      if (p.y < min.y) {
        min.y = p.y;
      }
      if (p.y > max.y) {
        max.y = p.y;
      }
    });
    // We need to do this before we find corners, since the max radius is
    // determined then
    m_this._updateRangeTree();
    corners = [map.displayToGcs({
      x: min.x - m_maxRadius,
      y: min.y - m_maxRadius
    }, fgcs), map.displayToGcs({
      x: max.x + m_maxRadius,
      y: min.y - m_maxRadius
    }, fgcs), map.displayToGcs({
      x: max.x + m_maxRadius,
      y: max.y + m_maxRadius
    }, fgcs), map.displayToGcs({
      x: min.x - m_maxRadius,
      y: max.y + m_maxRadius
    }, fgcs)];
    min = {
      x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };
    max = {
      x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
      y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
    };
    // Find points inside the bounding box.  Only these could be in the polygon
    idx = m_rangeTree.range(min.x, min.y, max.x, max.y);
    // sort by index
    idx = Uint32Array.from(idx).sort();
    // filter points within the polygon
    idx.forEach(function (i) {
      var d = data[i],
        hasstroke = stroke(data[i], i);
      if (!hasstroke && !fill(data[i], i)) {
        return;
      }
      var p = m_this.position()(d, i);
      var rad = radius(data[i], i);
      rad += hasstroke ? strokeWidth(data[i], i) : 0;
      if (rad) {
        p = map.gcsToDisplay(p, fgcs);
        var dist = util.distanceToPolygon2d(p, poly);
        if (dist >= rad || dist >= 0 && opts.partial === 'center' || dist >= -rad && opts.partial && opts.partial !== 'center') {
          found.push(d);
          ifound.push(i);
          extra[i] = {
            partial: dist < rad,
            distance: dist
          };
        }
      }
    });
    return {
      found: found,
      index: ifound,
      extra: extra
    };
  };

  /**
   * Overloaded data method that updates the internal range tree on write.
   * Get/Set the data array for the feature.
   *
   * @param {array} [data] A new data array or `undefined` to return the
   *    existing array.
   * @returns {array|this}
   */
  this.data = function (data) {
    if (data === undefined) {
      return s_data();
    }
    if (!m_ignoreData) {
      m_allData = data;
    }
    if (m_clustering && !m_ignoreData) {
      m_this._clusterData();
    } else {
      s_data(data);
    }
    m_ignoreData = false;
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.pointFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var defaultStyle = util.deepMerge({}, {
      radius: 5.0,
      stroke: true,
      strokeColor: {
        r: 0.851,
        g: 0.604,
        b: 0.0
      },
      strokeWidth: 1.25,
      strokeOpacity: 1.0,
      fillColor: {
        r: 1.0,
        g: 0.839,
        b: 0.439
      },
      fill: true,
      fillOpacity: 0.8,
      position: function position(d) {
        return Array.isArray(d) ? {
          x: d[0],
          y: d[1],
          z: d[2] || 0
        } : d;
      },
      origin: function origin(p) {
        return p.length >= 3 ? p.slice(0, 3) : [0, 0, 0];
      }
    }, arg.style === undefined ? {} : arg.style);
    if (arg.position !== undefined) {
      defaultStyle.position = arg.position;
    }
    m_this.style(defaultStyle);
    if (defaultStyle.position) {
      m_this.position(defaultStyle.position);
    }
    m_this.dataTime().modified();

    // bind to the zoom handler for point clustering
    m_this.geoOn(geo_event.zoom, function (evt) {
      m_this._handleZoom(evt.zoomLevel);
    });
    return m_this;
  };
  return m_this;
};

/**
 * Create a pointFeature from an object.
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to
 * @param {geo.pointFeature.spec} spec The object specification
 * @returns {geo.pointFeature|null}
 */
_pointFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'point';
  return feature.create(layer, spec);
};
_pointFeature.capabilities = {
  /* core feature name -- support in any manner */
  feature: 'point',
  /* support for stroke properties */
  stroke: 'point.stroke'
};

/**
 * Support primitive shapes
 * @enum {string}
 */
_pointFeature.primitiveShapes = {
  auto: 'auto',
  sprite: 'sprite',
  triangle: 'triangle',
  square: 'square'
};
inherit(_pointFeature, feature);
module.exports = _pointFeature;

/***/ }),

/***/ 6645:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var transform = __webpack_require__(5325);

/**
 * Polygon feature specification.
 *
 * @typedef {geo.feature.spec} geo.polygonFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 * @property {geo.polygon|Function} [polygon] Polygons from the data.  Default
 *   (data).
 * @property {geo.polygonFeature.styleSpec} [style] Style object with default
 *   style options.
 */

/**
 * Style specification for a polygon pattern.
 *
 * @typedef {geo.polygonPattern} geo.polygonPattern
 * @property {geo.geoColor} [fillColor] RGBA fill color.  Default is polygon
 *   strokeColor and strokeOpacity.
 * @property {geo.geoColor} [strokeColor] RGBA stroke color.  Default is
 *   polygon fillColor and fillOpacity.
 * @property {number} [strokeWidth=1.25] The weight of the pattern marker's
 *   stroke in pixels.  Set this or A on strokeFill to zero to not have a
 *   stroke.
 * @property {number} [strokeOffset=-1] The position of the stroke compared to
 *   the pattern radius.  This can only be -1, 0, or 1 (the sign of the value
 *   is used).
 * @property {boolean} [radiusIncludesStroke=true] If truthy or undefined, the
 *   `radius` includes the `strokeWidth` based on the `strokeOffset`.  If
 *   defined and falsy, the radius does not include the `strokeWidth`.
 * @property {number} [symbol=0] One of the predefined symbol numbers.  This is
 *   one of `geo.markerFeature.symbols`.
 * @property {number|number[]} [symbolValue=0] A value the affects the
 *   appearance of the symbol.  Some symbols can take an array of numbers.
 * @property {number} [rotation=0] The rotation of the symbol in clockwise
 *   radians.
 * @property {geo.markerFeature.scaleMode} [scaleWithZoom='none'] This
 *   determines if the fill, stroke, or both scale with zoom.  If set, the
 *   values for radius and strokeWidth are the values at zoom-level zero.
 * @property {boolean} [rotateWithMap=false] If truthy, rotate symbols with the
 *   map.  If falsy, symbol orientation is absolute.
 * @property {number} [radius=6.25] Radius of each marker in pixels.   This
 *   includes the stroke width if `strokeOffset` is -1, excludes it if
 *   `strokeOffset` is 1, and includes half the stroke width if `strokeOffset`
 *   is 0.  Note that is `radiusIncludesStroke` is `false`, this never
 *   includes the stroke width.
 * @property {number} [spacing=20] Spacing in pixels between pattern symbols;
 *   scaled if either radius or strokeWidth is scaled.  If positive, patterns
 *   are on a square grid.  If negative, patterns are on a triangular grid.
 * @property {number[]} [origin=[0, 0]] Origin of the pattern.
 */

/**
 * Style specification for a polygon feature.
 *
 * @typedef {geo.lineFeature.styleSpec} geo.polygonFeature.styleSpec
 * @extends geo.lineFeature.styleSpec
 * @property {boolean|Function} [fill=true] True to fill polygon.
 * @property {geo.geoColor|Function} [fillColor] Color to fill each polygon.
 *   The color can vary by vertex.
 * @property {number|Function} [fillOpacity] Opacity for each polygon.  The
 *   opacity can vary by vertex.  Opacity is on a [0-1] scale.
 * @property {boolean|Function} [stroke=false] True to stroke polygon.
 * @property {boolean|Function} [uniformPolygon=false] Boolean indicating if
 *   each polygon has a uniform style (uniform fill color, fill opacity, stroke
 *   color, and stroke opacity).  Can vary by polygon.
 * @property {boolean|Function} [closed=true] Ignored.  Always `true`.
 * @property {number[]|Function} [origin] Origin in map gcs coordinates used
 *   for to ensure high precision drawing in this location.  When called as a
 *   function, this is passed an array of items, each of which has a vertices
 *   property that is a single continuous array in map gcs coordinates.  It
 *   defaults to the first polygon's first vertex's position.
 * @property {geo.polygonPattern|Function} [pattern] Pattern to apply to each
 *   polygon.  Each polygon can be distinct, but the pattern is uniform across
 *   any one polygon.
 */

/**
 * Create a new instance of class polygonFeature.
 *
 * @class
 * @alias geo.polygonFeature
 * @extends geo.feature
 * @param {geo.polygonFeature.spec} arg
 * @returns {geo.polygonFeature}
 */
var _polygonFeature = function polygonFeature(arg) {
  'use strict';

  if (!(this instanceof _polygonFeature)) {
    return new _polygonFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);
  var util = __webpack_require__(642);

  /**
   * @private
   */
  var m_this = this,
    m_lineFeature,
    s_init = this._init,
    s_exit = this._exit,
    s_data = this.data,
    s_draw = this.draw,
    s_modified = this.modified,
    s_style = this.style,
    m_coordinates = [];
  this.featureType = 'polygon';
  this._subfeatureStyles = {
    fillColor: true,
    fillOpacity: true,
    lineCap: true,
    lineJoin: true,
    strokeColor: true,
    strokeOffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };

  /**
   * Get/set data.
   *
   * @param {object} [arg] if specified, use this for the data and return the
   *    feature.  If not specified, return the current data.
   * @returns {geo.polygonFeature|object}
   */
  this.data = function (arg) {
    var ret = s_data(arg);
    if (arg !== undefined) {
      m_coordinates = getCoordinates();
      m_this._checkForStroke();
    }
    return ret;
  };

  /**
   * Get the internal coordinates whenever the data changes.  Also compute the
   * extents of the outside of each polygon for faster checking if points are
   * in the polygon.
   *
   * @private
   * @param {object[]} [data] The data to process.
   * @param {Function} [posFunc] The function to
   *    get the position of each vertex.
   * @param {Function} [polyFunc] The function to
   *    get each polygon.
   * @returns {geo.polygonObject[]} An array of polygon positions.  Each has
   *    `outer` and `inner` if it has any coordinates, or is `undefined`.
   */
  function getCoordinates(data, posFunc, polyFunc) {
    var fcs = m_this.gcs(),
      mapgcs = m_this.layer().map().gcs();
    data = data || m_this.data();
    posFunc = posFunc || m_this.style.get('position');
    polyFunc = polyFunc || m_this.style.get('polygon');
    var coordinates = data.map(function (d, i) {
      var poly = polyFunc(d, i);
      if (!poly) {
        return undefined;
      }
      var outer, inner, range, coord, x, y, mapouter, mapinner, maprange;
      coord = poly.outer || (Array.isArray(poly) ? poly : []);
      outer = new Array(coord.length);
      for (var j = 0; j < coord.length; j += 1) {
        outer[j] = posFunc.call(m_this, coord[j], j, d, i);
        x = outer[j].x;
        y = outer[j].y;
        if (!j) {
          range = {
            min: {
              x: x,
              y: y
            },
            max: {
              x: x,
              y: y
            }
          };
        } else {
          if (x < range.min.x) {
            range.min.x = x;
          }
          if (y < range.min.y) {
            range.min.y = y;
          }
          if (x > range.max.x) {
            range.max.x = x;
          }
          if (y > range.max.y) {
            range.max.y = y;
          }
        }
      }
      inner = (poly.inner || []).map(function (hole) {
        coord = hole || [];
        var trans = new Array(coord.length);
        for (var _j = 0; _j < coord.length; _j += 1) {
          trans[_j] = posFunc.call(m_this, coord[_j], _j, d, i);
        }
        return trans;
      });
      mapouter = transform.transformCoordinates(fcs, mapgcs, outer);
      mapinner = inner.map(function (part) {
        return transform.transformCoordinates(fcs, mapgcs, part);
      });
      for (var _j2 = 0; _j2 < mapouter.length; _j2 += 1) {
        x = mapouter[_j2].x;
        y = mapouter[_j2].y;
        if (!_j2) {
          maprange = {
            min: {
              x: x,
              y: y
            },
            max: {
              x: x,
              y: y
            }
          };
        } else {
          if (x < maprange.min.x) {
            maprange.min.x = x;
          }
          if (y < maprange.min.y) {
            maprange.min.y = y;
          }
          if (x > maprange.max.x) {
            maprange.max.x = x;
          }
          if (y > maprange.max.y) {
            maprange.max.y = y;
          }
        }
      }
      return {
        outer: outer,
        inner: inner,
        range: range,
        mapouter: mapouter,
        mapinner: mapinner,
        maprange: maprange
      };
    });
    return coordinates;
  }

  /**
   * Get the set of normalized polygon coordinates.
   *
   * @returns {geo.polygonObject[]} An array of polygon positions.  Each has
   *    `outer` and `inner` if it has any coordinates, or is `undefined`.
   */
  this.polygonCoordinates = function () {
    return m_coordinates;
  };

  /**
   * Get the style for the stroke of the polygon.  Since polygons can have
   * holes, the number of stroke lines may not be the same as the number of
   * polygons.  If the style for a stroke is a function, this calls the
   * appropriate value for the polygon.  Any style set for a stroke line should
   * be wrapped in this function.
   *
   * @param {(object|function)?} styleValue The polygon's style value used for
   *    the stroke.  This should be m_this.style(<name of style>) and not
   *    m_this.style.get(<name of style>), as the result is more efficient if
   *    the style is not a function.
   * @returns {object|Function} A style that can be used for the stroke.
   * @private
   */
  function linePolyStyle(styleValue) {
    if (util.isFunction(styleValue)) {
      return function (d) {
        return styleValue(d[0], d[1], d[2], d[3]);
      };
    } else {
      return styleValue;
    }
  }

  /**
   * Get/set polygon accessor.
   *
   * @param {object|Function} [val] If not specified, return the current
   *    polygon accessor.  If specified, use this for the polygon accessor and
   *    return `this`.  If a function is given, the function is passed
   *    `(dataElement, dataIndex)` and returns a {@link geo.polygon}.
   * @returns {object|Function|this} The current polygon accessor or this
   *    feature.
   */
  this.polygon = function (val) {
    if (val === undefined) {
      return m_this.style('polygon');
    } else {
      m_this.style('polygon', val);
      m_this.dataTime().modified();
      m_this.modified();
      m_coordinates = getCoordinates();
    }
    return m_this;
  };

  /**
   * Get/Set position accessor.
   *
   * @param {geo.geoPosition|Function} [val] If not specified, return the
   *    current position accessor.  If specified, use this for the position
   *    accessor and return `this`.  If a function is given, this is called
   *    with `(vertexElement, vertexIndex, dataElement, dataIndex)`.
   * @returns {geo.geoPosition|this} The current position or this feature.
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
      m_coordinates = getCoordinates();
    }
    return m_this;
  };

  /**
   * Point search method for selection api.  Returns markers containing the
   * given point.
   *
   * @param {geo.geoPosition} coordinate point to search for.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of polygon indices, and
   *    `found`: a list of polygons that contain the specified coordinate.
   */
  this.pointSearch = function (coordinate, gcs) {
    var found = [],
      indices = [],
      irecord = {},
      data = m_this.data(),
      map = m_this.layer().map();
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    var pt = transform.transformCoordinates(gcs, map.gcs(), coordinate);
    m_coordinates.forEach(function (coord, i) {
      var inside = util.pointInPolygon(pt, coord.mapouter, coord.mapinner, coord.maprange);
      if (inside) {
        indices.push(i);
        irecord[i] = true;
        found.push(data[i]);
      }
    });
    if (m_lineFeature) {
      var lineFound = m_lineFeature.pointSearch(coordinate);
      lineFound.found.forEach(function (lineData) {
        if (lineData.length && lineData[0].length === 4 && !irecord[lineData[0][3]]) {
          indices.push(lineData[0][3]);
          irecord[lineData[0][3]] = true;
          found.push(data[lineData[0][3]]);
        }
      });
    }
    return {
      index: indices,
      found: found
    };
  };

  /**
   * Returns polygons that are contained in the given polygon.  This could fail
   * to return polygons that are less than their stroke width outside of the
   * specified polygon and whose vertices are not near the selected polygon.
   *
   * @param {geo.polygonObject} poly A polygon as an array of coordinates or an
   *    object with `outer` and optionally `inner` parameters.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include polygons that are
   *    partially in the polygon, otherwise only include polygons that are fully
   *    within the region.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of polygon indices,
   *    `found`: a list of polygons within the polygon, and `extra`: an object
   *    with index keys containing an object with a `partial` key and a boolean
   *    value to indicate if the polygon is on the specified polygon's border.
   */
  this.polygonSearch = function (poly, opts, gcs) {
    var data = m_this.data(),
      indices = [],
      found = [],
      extra = {},
      min,
      max,
      origPoly = poly,
      irecord = {},
      map = m_this.layer().map();
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    if (!poly.outer) {
      poly = {
        outer: poly,
        inner: []
      };
    }
    if (!data || !data.length || poly.outer.length < 3) {
      return {
        found: found,
        index: indices,
        extra: extra
      };
    }
    opts = opts || {};
    opts.partial = opts.partial || false;
    poly = {
      outer: transform.transformCoordinates(gcs, map.gcs(), poly.outer),
      inner: (poly.inner || []).map(function (inner) {
        return transform.transformCoordinates(gcs, map.gcs(), inner);
      })
    };
    poly.outer.forEach(function (p) {
      if (!min) {
        min = {
          x: p.x,
          y: p.y
        };
        max = {
          x: p.x,
          y: p.y
        };
      }
      if (p.x < min.x) {
        min.x = p.x;
      }
      if (p.x > max.x) {
        max.x = p.x;
      }
      if (p.y < min.y) {
        min.y = p.y;
      }
      if (p.y > max.y) {
        max.y = p.y;
      }
    });
    m_coordinates.forEach(function (coord, idx) {
      if (!coord.mapouter.length || coord.maprange && (coord.maprange.max.x < min.x || coord.maprange.min.x > max.x || coord.maprange.max.y < min.y || coord.maprange.min.y > max.y)) {
        return;
      }
      var inside, partial;
      // do something similar to the line's polygonSearch
      for (var r = -1; r < coord.mapinner.length && !partial; r += 1) {
        var record = r < 0 ? coord.mapouter : coord.mapinner[r];
        for (var i = 0, len = record.length, j = len - 1; i < len; j = i, i += 1) {
          var dist0 = util.distanceToPolygon2d(record[i], poly),
            dist1 = util.distanceToPolygon2d(record[j], poly);
          if (dist0 * dist1 < 0) {
            partial = true;
            break;
          }
          if (util.crossedLineSegmentPolygon2d(record[i], record[j], poly)) {
            partial = true;
            break;
          }
          if (dist0 > 0) {
            inside = true;
          }
        }
      }
      // check if the selection polygon is inside of this polygon.  Any point
      // is sufficient as otherwise the previous crossing test would have been
      // triggered.
      if (!inside && !partial && util.pointInPolygon(poly.outer[0], coord.mapouter, coord.mapinner, coord.maprange)) {
        partial = true;
      }
      if (!opts.partial && inside && !partial || opts.partial && (inside || partial)) {
        indices.push(idx);
        found.push(data[idx]);
        extra[idx] = {
          partial: partial
        };
        irecord[idx] = true;
      }
    });
    if (m_lineFeature) {
      var lineFound = m_lineFeature.polygonSearch(origPoly, opts);
      lineFound.found.forEach(function (lineData, idx) {
        if (lineData.length && lineData[0].length === 4) {
          if (!irecord[lineData[0][3]]) {
            indices.push(lineData[0][3]);
            irecord[lineData[0][3]] = true;
            found.push(data[lineData[0][3]]);
            extra[lineFound.index[idx]] = {
              partial: false
            };
          }
          if (lineFound.extra[lineFound.index[idx]].partial) {
            extra[lineFound.index[idx]].partial = true;
          }
        }
      });
    }
    return {
      found: found,
      index: indices,
      extra: extra
    };
  };

  /**
   * Get/Set style used by the feature.  This calls the super function, then
   * checks if strokes are required.
   *
   * See the <a href="#.styleSpec">style specification
   * <code>styleSpec</code></a> for available styles.
   *
   * @param {string|object} [arg1] If `undefined`, return the current style
   *    object.  If a string and `arg2` is undefined, return the style
   *    associated with the specified key.  If a string and `arg2` is defined,
   *    set the named style to the specified value.  Otherwise, extend the
   *    current style with the values in the specified object.
   * @param {*} [arg2] If `arg1` is a string, the new value for that style.
   * @returns {object|this} Either the entire style object, the value of a
   *    specific style, or the current class instance.
   */
  this.style = function (arg1, arg2) {
    var result = s_style.apply(m_this, arguments);
    if (arg1 !== undefined && (typeof arg1 !== 'string' || arg2 !== undefined)) {
      m_this._checkForStroke();
    }
    return result;
  };
  this.style.get = s_style.get;

  /**
   * Get an outer or inner loop of a polygon and return the necessary data to
   * use it for a closed polyline.
   *
   * @param {object} item the polygon.
   * @param {number} itemIndex the index of the polygon
   * @param {Array} loop the inner or outer loop.
   * @returns {Array} the loop with the data necessary to send to the position
   *    function for each vertex.
   */
  this._getLoopData = function (item, itemIndex, loop) {
    var line = [],
      i;
    for (i = 0; i < loop.length; i += 1) {
      line.push([loop[i], i, item, itemIndex]);
    }
    return line;
  };

  /**
   * Check if we need to add a line feature to the layer, and update it as
   * necessary.
   */
  this._checkForStroke = function () {
    if (s_style('stroke') === false) {
      if (m_lineFeature && m_this.layer()) {
        m_this.layer().deleteFeature(m_lineFeature);
        m_lineFeature = null;
        m_this.dependentFeatures([]);
      }
      return;
    }
    if (!m_this.layer()) {
      return;
    }
    if (!m_lineFeature) {
      m_lineFeature = m_this.layer().createFeature('line', {
        selectionAPI: false,
        gcs: m_this.gcs(),
        visible: m_this.visible(undefined, true),
        dynamicDraw: true
      });
      m_this.dependentFeatures([m_lineFeature]);
    }
    var polyStyle = m_this.style(),
      strokeOpacity;
    if (util.isFunction(polyStyle.stroke) || !polyStyle.stroke) {
      var strokeFunc = m_this.style.get('stroke'),
        strokeOpacityFunc = m_this.style.get('strokeOpacity');
      strokeOpacity = function strokeOpacity(d) {
        return strokeFunc(d[2], d[3]) ? strokeOpacityFunc(d[0], d[1], d[2], d[3]) : 0;
      };
    } else {
      strokeOpacity = linePolyStyle(polyStyle.strokeOpacity);
    }
    m_lineFeature.style({
      antialiasing: linePolyStyle(polyStyle.antialiasing),
      closed: true,
      lineCap: linePolyStyle(polyStyle.lineCap),
      lineJoin: linePolyStyle(polyStyle.lineJoin),
      miterLimit: linePolyStyle(polyStyle.miterLimit),
      strokeWidth: linePolyStyle(polyStyle.strokeWidth),
      strokeStyle: linePolyStyle(polyStyle.strokeStyle),
      strokeColor: linePolyStyle(polyStyle.strokeColor),
      strokeOffset: linePolyStyle(polyStyle.strokeOffset),
      strokeOpacity: strokeOpacity,
      uniformLine: linePolyStyle(polyStyle.uniformPolygon)
    });
    var data = m_this.data(),
      posVal = m_this.style('position');
    if (data !== m_lineFeature._lastData || posVal !== m_lineFeature._lastPosVal) {
      var lineData = [],
        i,
        polygon,
        loop,
        posFunc = m_this.style.get('position'),
        polyFunc = m_this.style.get('polygon');
      for (i = 0; i < data.length; i += 1) {
        polygon = polyFunc(data[i], i);
        if (!polygon) {
          continue;
        }
        loop = polygon.outer || (Array.isArray(polygon) ? polygon : []);
        if (loop.length >= 2) {
          lineData.push(m_this._getLoopData(data[i], i, loop));
          if (polygon.inner) {
            polygon.inner.forEach(function (loop) {
              if (loop.length >= 2) {
                lineData.push(m_this._getLoopData(data[i], i, loop));
              }
            });
          }
        }
      }
      m_lineFeature.position(function (d, i, item, itemIndex) {
        return posFunc(d[0], d[1], d[2], d[3]);
      });
      m_lineFeature.data(lineData);
      m_lineFeature._lastData = data;
      m_lineFeature._lastPosVal = posVal;
    }
  };

  /**
   * Redraw the object.
   *
   * @returns {object} The results of the superclass draw function.
   */
  this.draw = function () {
    var result = s_draw();
    if (m_lineFeature) {
      m_lineFeature.draw();
    }
    return result;
  };

  /**
   * Update the timestamp to the next global timestamp value.  Mark
   * sub-features as modified, too.
   *
   * @returns {object} The results of the superclass modified function.
   */
  this.modified = function () {
    var result = s_modified();
    if (m_lineFeature) {
      m_lineFeature.modified();
    }
    return result;
  };

  /**
   * Take a set of data, reduce the number of vertices per polygon using the
   * RamerDouglasPeucker algorithm, and use the result as the new data.
   * This changes the instance's data, the position accessor, and the polygon
   * accessor.
   *
   * @param {array} data A new data array.
   * @param {number} [tolerance] The maximum variation allowed in map.gcs
   *    units.  A value of zero will only remove perfectly collinear points.
   *    If not specified, this is set to a half display pixel at the map's
   *    current zoom level.
   * @param {Function} [posFunc] The function to
   *    get the position of each vertex.
   * @param {Function} [polyFunc] The function to
   *    get each polygon.
   * @param {boolean} [returnData] If truthy, return the new data array
   *    rather than modifying the feature.
   * @returns {this|array}
   */
  this.rdpSimplifyData = function (data, tolerance, posFunc, polyFunc, returnData) {
    var map = m_this.layer().map(),
      mapgcs = map.gcs(),
      featuregcs = m_this.gcs(),
      coordinates = getCoordinates(data, posFunc, polyFunc);
    if (tolerance === undefined) {
      tolerance = map.unitsPerPixel(map.zoom()) * 0.5;
    }

    /* transform the coordinates to the map gcs */
    coordinates = coordinates.map(function (poly) {
      return {
        outer: transform.transformCoordinates(featuregcs, mapgcs, poly.outer),
        inner: poly.inner.map(function (hole) {
          return transform.transformCoordinates(featuregcs, mapgcs, hole);
        })
      };
    });
    data = data.map(function (d, idx) {
      var poly = coordinates[idx],
        elem = {};
      /* Copy element properties, as they might be used by styles */
      for (var key in d) {
        if (d.hasOwnProperty(key) && !(Array.isArray(d) && key >= 0 && key < d.length)) {
          elem[key] = d[key];
        }
      }
      if (poly && poly.outer.length >= 3) {
        // discard degenerate holes before anything else
        elem.inner = poly.inner.filter(function (hole) {
          return hole.length >= 3;
        });
        // simplify the outside of the polygon without letting it cross holes
        elem.outer = util.rdpLineSimplify(poly.outer, tolerance, true, elem.inner);
        if (elem.outer.length >= 3) {
          var allButSelf = elem.inner.slice();
          // simplify holes without crossing other holes or the outside
          elem.inner.map(function (hole, idx) {
            allButSelf[idx] = elem.outer;
            var result = util.rdpLineSimplify(hole, tolerance, true, allButSelf);
            allButSelf[idx] = result;
            return result;
          }).filter(function (hole) {
            return hole.length >= 3;
          });
          // transform coordinates back to the feature gcs
          elem.outer = transform.transformCoordinates(mapgcs, featuregcs, elem.outer);
          elem.inner = elem.inner.map(function (hole) {
            return transform.transformCoordinates(mapgcs, featuregcs, hole);
          });
        } else {
          elem.outer = elem.inner = [];
        }
      } else {
        elem.outer = [];
      }
      return elem;
    });
    if (returnData) {
      return data;
    }

    /* Set the reduced polygons as the data and use simple accessors. */
    m_this.style('position', util.identityFunction);
    m_this.style('polygon', util.identityFunction);
    m_this.data(data);
    return m_this;
  };

  /**
   * If the selectionAPI is on, then setting
   * `this.geoOn(geo.event.feature.mouseover_order, this.mouseOverOrderClosestBorder)`
   * will make it so that the mouseon events prefer the polygon with the
   * closet border, including hole edges.
   *
   * @param {geo.event} evt The event; this should be triggered from
   *    {@link geo.event.feature.mouseover_order}.
   */
  this.mouseOverOrderClosestBorder = function (evt) {
    var data = evt.feature.data(),
      map = evt.feature.layer().map(),
      pt = transform.transformCoordinates(map.ingcs(), evt.feature.gcs(), evt.mouse.geo),
      coor = evt.feature.polygonCoordinates(),
      dist = {};
    evt.over.index.forEach(function (di, idx) {
      var poly = coor[di],
        mindist;
      poly.outer.forEach(function (line1, pidx) {
        var line2 = poly.outer[(pidx + 1) % poly.outer.length];
        var dist = util.distance2dToLineSquared(pt, line1, line2);
        if (mindist === undefined || dist < mindist) {
          mindist = dist;
        }
      });
      poly.inner.forEach(function (inner) {
        inner.forEach(function (line1, pidx) {
          var line2 = inner[(pidx + 1) % inner.length];
          var dist = util.distance2dToLineSquared(pt, line1, line2);
          if (mindist === undefined || dist < mindist) {
            mindist = dist;
          }
        });
      });
      dist[di] = mindist;
    });
    evt.over.index.sort(function (i1, i2) {
      return dist[i1] - dist[i2];
    }).reverse();
    // this isn't necessary, but ensures that other event handlers have
    // consistent information
    evt.over.index.forEach(function (di, idx) {
      evt.over.found[idx] = data[di];
    });
  };

  /**
   * Return the polygons as a polygon list: an array of polygons, each of which
   * is an array of polylines, each of which is an array of points, each of
   * which is a 2-tuple of numbers.
   *
   * @param {geo.util.polyop.spec} [opts] Ignored.
   * @returns {geo.polygonList} A list of polygons.
   */
  this.toPolygonList = function (opts) {
    var polyFunc = m_this.style.get('polygon');
    var posFunc = m_this.style.get('position');
    return m_this.data().map(function (d, i) {
      var polygon = polyFunc(d, i);
      var outer = polygon.outer || (Array.isArray(polygon) ? polygon : []);
      if (outer.length < 3) {
        return [];
      }
      var resp = [outer.map(function (p, j) {
        var pos = posFunc(p, j, d, i);
        return [pos.x, pos.y];
      })];
      if (polygon.inner) {
        polygon.inner.forEach(function (h) {
          resp.push(h.map(function (p, j) {
            var pos = posFunc(p, j, d, i);
            return [pos.x, pos.y];
          }));
        });
      }
      return resp;
    });
  };

  /**
   * Set the data, position accessor, and polygon accessor to use a list of
   * polygons.
   *
   * @param {geo.polygonList} poly A list of polygons.
   * @param {geo.util.polyop.spec} [opts] Ignored.
   * @returns {this}
   */
  this.fromPolygonList = function (poly, opts) {
    m_this.style({
      position: function position(p) {
        return {
          x: p[0],
          y: p[1]
        };
      },
      polygon: function polygon(p) {
        return {
          outer: p[0],
          inner: p.slice(1)
        };
      }
    });
    m_this.data(poly);
    return m_this;
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    if (m_lineFeature && m_this.layer()) {
      m_this.layer().deleteFeature(m_lineFeature);
      m_lineFeature = null;
      m_this.dependentFeatures([]);
    }
    s_exit();
  };

  /**
   * Initialize.
   *
   * @param {geo.polygonFeature.spec} arg An object with options for the
   *    feature.
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var style = Object.assign({}, {
      // default style
      fill: true,
      fillColor: {
        r: 0.0,
        g: 0.5,
        b: 0.5
      },
      fillOpacity: 1.0,
      stroke: false,
      strokeWidth: 1.0,
      strokeStyle: 'solid',
      strokeColor: {
        r: 0.0,
        g: 1.0,
        b: 1.0
      },
      strokeOpacity: 1.0,
      polygon: util.identityFunction,
      position: function position(d) {
        return Array.isArray(d) ? {
          x: d[0],
          y: d[1],
          z: d[2] || 0
        } : d;
      },
      origin: function origin(items) {
        for (var i = 0; i < items.length; i += 1) {
          if (items[i].vertices.length >= 3) {
            return items[i].vertices.slice(0, 3);
          }
        }
        return [0, 0, 0];
      }
    }, arg.style === undefined ? {} : arg.style);
    if (arg.polygon !== undefined) {
      style.polygon = arg.polygon;
    }
    if (arg.position !== undefined) {
      style.position = arg.position;
    }
    m_this.style(style);
    m_this._checkForStroke();
  };

  /* Don't call _init here -- let subclasses call it */
  return this;
};

/**
 * Create a polygonFeature from an object.
 *
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to
 * @param {geo.polygonFeature.spec} spec The object specification
 * @returns {geo.polygonFeature|null}
 */
_polygonFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'polygon';
  return feature.create(layer, spec);
};
_polygonFeature.capabilities = {
  /* core feature name -- support in any manner */
  feature: 'polygon'
};
inherit(_polygonFeature, feature);
module.exports = _polygonFeature;

/***/ }),

/***/ 3842:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Quad position specification
 *
 * @typedef {object} geo.quadFeature.position
 * @property {geo.geoPosition} [ul] Upper left coordinate.
 * @property {geo.geoPosition} [ur] Upper right coordinate.
 * @property {geo.geoPosition} [ll] Lower left coordinate.
 * @property {geo.geoPosition} [lr] Lower right coordinate.
 * @property {object} [crop] Image tile crop size in image pixels.  Areas
 *   beyond the width ``x`` and height ``y`` are transparent. ``left``,
 *   ``top``, ``right``, ``bottom`` extract a specific part of the image tile
 *   as the source and expand it to fill the conceptual space before any crop
 *   width and height are applied.
 * @property {number} [crop.x] Width of image after crop.
 * @property {number} [crop.y] Height of image after crop.
 * @property {number} [crop.left] Left coordinate of image source.
 * @property {number} [crop.top] Top coordinate of image source.
 * @property {number} [crop.right] Right coordinate of image source.
 * @property {number} [crop.bottom] Bottom coordinate of image source.
 */

/**
 * Quad feature specification.
 *
 * @typedef {geo.feature.spec} geo.quadFeature.spec
 * @extends geo.feature.spec
 * @property {geo.quadFeature.position|Function} [position] Position of the
 *   quad.  Default is (data).  The position specifies the corners of the quad:
 *   ll, lr, ur, ul.  At least two opposite corners must be specified.   The
 *   corners do not have to physically correspond to the order specified, but
 *   rather correspond to that part of an image or video (if there is one).  If
 *   a corner is unspecified, it will use the x coordinate from one adjacent
 *   corner, the y coordinate from the other adjacent corner, and the average
 *   z value of those two corners.  For instance, if ul is unspecified, it is
 *   {x: ll.x, y: ur.y}.  Note that each quad is rendered as a pair of
 *   triangles: (ll, lr, ul) and (ur, ul, lr).  Nothing special is done for
 *   quads that are not convex or quads that have substantially different
 *   transformations for those two triangles.
 * @property {boolean} [cacheQuads=true] If truthy, a set of internal
 *   information is stored on each data item in the _cachedQuad attribute.  If
 *   this is falsy, the data item is not altered.  If the data (positions,
 *   opacity, etc.) of individual quads will change, set this to `false` or
 *   call `cacheUpdate` on the data item or for all data.
 * @property {geo.quadFeature.styleSpec} [style] Style object with default
 *   style options.
 * @property {boolean|number} [nearestPixel] If true, image quads are
 *   rendered with near-neighbor sampling.  If false, with interpolated
 *   sampling.  If a number, interpolate at that zoom level or below and
 *   nearest neighbor at that zoom level or above.
 */

/**
 * Style specification for a quad feature.
 *
 * @typedef {geo.feature.styleSpec} geo.quadFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {geo.geoColor|Function} [color] Color for quads without images.
 *   Default is white (`{r: 1, g: 1, b: 1}`).
 * @property {number|Function} [opacity=1] Opacity for the quads.
 * @property {number|Function} [depth=0] Default z-coordinate for positions
 *   that don't explicitly specify one.
 * @property {boolean|Function} [drawOnAsyncResourceLoaded=true] Redraw quads
 *   when images or videos are loaded after initial render.
 * @property {Image|string|Function} [image] Image for each data item.  If
 *   falsy and `video` is also falsy, the quad is a solid color.  Default is
 *   (data).image.
 * @property {HTMLVideoElement|string|Function} [video] Video for each data
 *   item.  If falsy and `image` is also falsy, the quad is a solid color.
 *   Default is (data).video.
 * @property {boolean|Function} [delayRenderWhenSeeking=true] If any video has a
 *   truthy value and is seeking, delaying rendering the entire feature.  This
 *   prevents blinking when seeking a playing video, but may cause stuttering
 *   when there are multiple videos.
 * @property {geo.geoColor|Function} [previewColor=null] If specified, a color
 *   to show on image and video quads while waiting for the image or video to
 *   load.
 * @property {Image|string|Function} [previewImage=null] If specified, an image
 *   to show on image quads while waiting for the quad-specific image to load.
 *   This will only be shown if it (the preview image) is already loaded.
 */

/**
 * Create a new instance of class quadFeature.
 *
 * @class
 * @alias geo.quadFeature
 * @param {geo.quadFeature.spec} arg Options object.
 * @extends geo.feature
 * @returns {geo.quadFeature}
 */
var _quadFeature = function quadFeature(arg) {
  'use strict';

  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  if (!(this instanceof _quadFeature)) {
    return new _quadFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init,
    m_cacheQuads,
    m_nearestPixel = arg.nearestPixel,
    m_nextQuadId = 0,
    m_images = [],
    m_videos = [],
    m_quads;
  this.featureType = 'quad';

  /**
   * Track a list of object->object mappings.  The mappings are kept in a list.
   * This marks all known mappings as unused.  If they are not marked as used
   * before `_objectListEnd` is called, that function will remove them.
   *
   * @param {array} list The list of mappings.
   */
  this._objectListStart = function (list) {
    $.each(list, function (idx, item) {
      item.used = false;
    });
  };

  /**
   * Get the value from a list of object->object mappings.  If the key object
   * is not present, return `undefined`.  If found, the entry is marked as
   * being in use.
   *
   * @param {array} list The list of mappings.
   * @param {object} entry The key to search for.
   * @returns {object} The associated object or undefined.
   */
  this._objectListGet = function (list, entry) {
    for (var i = 0; i < list.length; i += 1) {
      if (list[i].entry === entry) {
        list[i].used = true;
        return list[i].value;
      }
    }
    return undefined;
  };

  /**
   * Add a new object to a list of object->object mappings.  The key object
   * should not exist, or this will create a duplicate.  The new entry is
   * marked as being in use.
   *
   * @param {array} list The list of mappings.
   * @param {object} entry The key to add.
   * @param {object} value The value to store with the entry.
   */
  this._objectListAdd = function (list, entry, value) {
    list.push({
      entry: entry,
      value: value,
      used: true
    });
  };

  /**
   * Remove all unused entries from a list of object->object mappings.
   *
   * @param {array} list The list of mappings.
   */
  this._objectListEnd = function (list) {
    for (var i = list.length - 1; i >= 0; i -= 1) {
      if (!list[i].used) {
        list.splice(i, 1);
      }
    }
  };

  /**
   * Point search method for selection api.  Returns markers containing the
   * given point.
   *
   * @param {geo.geoPosition} coordinate Coordinate in input gcs to check if it
   *    is located in any quad.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} An object with `index`: a list of quad indices, `found`:
   *    a list of quads that contain the specified coordinate, and `extra`: an
   *    object with keys that are quad indices and values that are objects with
   *    `basis.x` and `basis.y`, values from 0 - 1 relative to interior of the
   *    quad.
   */
  this.pointSearch = function (coordinate, gcs) {
    var found = [],
      indices = [],
      extra = {},
      poly1 = [{}, {}, {}, {}],
      poly2 = [{}, {}, {}, {}],
      order1 = [0, 1, 2, 0],
      order2 = [1, 2, 3, 1],
      data = m_this.data(),
      map = m_this.layer().map(),
      i,
      coordbasis;
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    coordinate = transform.transformCoordinates(gcs, map.gcs(), coordinate);
    if (!m_quads) {
      m_this._generateQuads();
    }
    $.each([m_quads.clrQuads, m_quads.imgQuads, m_quads.vidQuads], function (idx, quadList) {
      quadList.forEach(function (quad, idx) {
        for (i = 0; i < order1.length; i += 1) {
          poly1[i].x = quad.pos[order1[i] * 3];
          poly1[i].y = quad.pos[order1[i] * 3 + 1];
          poly1[i].z = quad.pos[order1[i] * 3 + 2];
          poly2[i].x = quad.pos[order2[i] * 3];
          poly2[i].y = quad.pos[order2[i] * 3 + 1];
          poly2[i].z = quad.pos[order2[i] * 3 + 2];
        }
        if (util.pointInPolygon(coordinate, poly1) || util.pointInPolygon(coordinate, poly2)) {
          indices.push(quad.idx);
          found.push(data[quad.idx]);
          /* If a point is in the quad (based on pointInPolygon, above), check
           * where in the quad it is located.  We want to output coordinates
           * where the upper-left is (0, 0) and the lower-right is (1, 1). */
          coordbasis = util.pointToTriangleBasis2d(coordinate, poly1[0], poly1[1], poly1[2]);
          if (!coordbasis || coordbasis.x + coordbasis.y > 1) {
            coordbasis = util.pointToTriangleBasis2d(coordinate, poly2[2], poly2[1], poly2[0]);
            if (coordbasis) {
              /* In the second triangle, (0, 0) is upper-right, (1, 0) is
               * upper-left, and (0, 1) is lower-right.  Invert x to get to
               * the desired output coordinates. */
              coordbasis.x = 1 - coordbasis.x;
            }
          } else {
            /* In the first triangle, (0, 0) is lower-left, (1, 0) is lower-
             * right, and (0, 1) is upper-left.  Invert y to get to the
             * desired output coordinates. */
            coordbasis.y = 1 - coordbasis.y;
          }
          if (coordbasis) {
            if (quad.crop && quad.crop.x !== undefined && quad.crop.y !== undefined && (coordbasis.x >= quad.crop.x || coordbasis.y >= quad.crop.y)) {
              indices.pop();
              found.pop();
              return;
            }
            extra[quad.idx] = {
              basis: coordbasis,
              _quad: quad
            };
          }
        }
      });
    });
    return {
      index: indices,
      found: found,
      extra: extra
    };
  };

  /**
   * Get/Set position.
   *
   * @memberof geo.quadFeature
   * @param {object|Function} [val] Object or function that returns the
   *    position of each quad.  `undefined` to get the current position value.
   * @returns {geo.quadFeature|this}
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else {
      m_this.style('position', util.ensureFunction(val));
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Given a data item and its index, fetch its position and ensure we have
   * complete information for the quad.  This generates missing corners and z
   * values.
   *
   * @param {Function} posFunc A function to call to get the position of a data
   *   item.  It is passed (d, i).
   * @param {Function} depthFunc A function to call to get the z-value of a
   *   data item.  It is passed (d, i).
   * @param {object} d A data item.  Used to fetch position and possibly depth.
   * @param {number} i The index within the data.  Used to fetch position and
   *   possibly depth.
   * @returns {object|undefined} Either an object with all four corners, or
   *   `undefined` if no such object can be generated.  The coordinates have
   *   been converted to map coordinates.
   */
  this._positionToQuad = function (posFunc, depthFunc, d, i) {
    var initPos = posFunc.call(m_this, d, i);
    if ((!initPos.ll || !initPos.ur) && (!initPos.ul || !initPos.lr)) {
      return;
    }
    var gcs = m_this.gcs(),
      map_gcs = m_this.layer().map().gcs(),
      pos = {};
    $.each(['ll', 'lr', 'ul', 'ur'], function (idx, key) {
      if (initPos[key] !== undefined) {
        pos[key] = {};
        if (initPos[key].x === undefined) {
          pos[key] = [initPos[key][0], initPos[key][1], initPos[key][2]];
        } else {
          pos[key] = [initPos[key].x, initPos[key].y, initPos[key].z];
        }
        if (pos[key][2] === undefined) {
          pos[key][2] = depthFunc.call(m_this, d, i);
        }
        if (gcs !== map_gcs && gcs !== false) {
          pos[key] = transform.transformCoordinates(gcs, map_gcs, pos[key]);
        }
      }
    });
    pos.ll = pos.ll || [pos.ul[0], pos.lr[1], (pos.ul[2] + pos.lr[2]) / 2];
    pos.lr = pos.lr || [pos.ur[0], pos.ll[1], (pos.ur[2] + pos.ll[2]) / 2];
    pos.ur = pos.ur || [pos.lr[0], pos.ul[1], (pos.lr[2] + pos.ul[2]) / 2];
    pos.ul = pos.ul || [pos.ll[0], pos.ur[1], (pos.ll[2] + pos.ur[2]) / 2];
    return pos;
  };

  /**
   * Renderers can subclass this when needed.
   *
   * This is called when a video qaud may have changed play state.
   * @param {object} quad The quad record that triggered this.
   * @param {jQuery.Event} [evt] The event that triggered this.
   */
  this._checkQuadUpdate = function (quad, evt) {};

  /**
   * Convert the current data set to a set of 3 arrays: quads that are a solid
   * color, quads that have an image, and quads that have a video.  All quads
   * are objects with pos (a 12 value array containing 4 three-dimensional
   * position coordinates), and opacity.  Color quads also have a color.  Image
   * quads may have an image element if the image is loaded.  If it isn't, this
   * element will be missing.  For preview images, the image quad will have a
   * reference to the preview element that may later be removed.  If a preview
   * color is used, the quad will be in both lists, but may be removed from the
   * color quad list once the image is loaded.  Video quads may have a video
   * element if the video is loaded.
   *
   * The value for origin is one of an ll corner from one of the quads with the
   * smallest sum of diagonals.  The assumption is that, if using the origin to
   * improve precision, the smallest quads are the ones most in need of this
   * benefit.
   *
   * @returns {object} An object with `clrQuads`, `imgQuads`, and `vidQuads`,
   *   each of which is an array; and `origin`, which is a triplet that is
   *   guaranteed to be one of the quads' corners for a quad with the smallest
   *   sum of diagonal lengths.
   */
  this._generateQuads = function () {
    var posFunc = m_this.position(),
      imgFunc = m_this.style.get('image'),
      vidFunc = m_this.style.get('video'),
      delayFunc = m_this.style.get('delayRenderWhenSeeking'),
      colorFunc = m_this.style.get('color'),
      depthFunc = m_this.style.get('depth'),
      opacityFunc = m_this.style.get('opacity'),
      loadedFunc = m_this.style.get('drawOnAsyncResourceLoaded'),
      previewColorFunc = m_this.style.get('previewColor'),
      previewImageFunc = m_this.style.get('previewImage'),
      data = m_this.data(),
      clrQuads = [],
      imgQuads = [],
      vidQuads = [],
      origin = [0, 0, 0],
      origindiag2,
      diag2;
    /* Keep track of images that we are using.  This prevents creating
     * additional Image elements for repeated urls. */
    m_this._objectListStart(m_images);
    m_this._objectListStart(m_videos);
    $.each(data, function (i, d) {
      if (d._cachedQuad) {
        diag2 = d._cachedQuad.diag2;
        if (origindiag2 === undefined || d._cachedQuad.diag2 && d._cachedQuad.diag2 < origindiag2) {
          origin = d._cachedQuad.ll;
          origindiag2 = d._cachedQuad.diag2;
        }
        if (d._cachedQuad.clrquad) {
          clrQuads.push(d._cachedQuad.clrquad);
        }
        if (d._cachedQuad.imgquad) {
          if (d._cachedQuad.imageEntry) {
            m_this._objectListGet(m_images, d._cachedQuad.imageEntry);
          }
          imgQuads.push(d._cachedQuad.imgquad);
        }
        if (d._cachedQuad.vidquad) {
          if (d._cachedQuad.videoEntry) {
            m_this._objectListGet(m_videos, d._cachedQuad.videoEntry);
          }
          vidQuads.push(d._cachedQuad.vidquad);
        }
        return;
      }
      var quad,
        reload,
        image,
        video,
        prev_onload,
        prev_onerror,
        defer,
        pos,
        img,
        vid,
        opacity,
        previewColor,
        previewImage,
        quadinfo = {};
      pos = m_this._positionToQuad(posFunc, depthFunc, d, i);
      opacity = opacityFunc.call(m_this, d, i);
      if (pos === undefined || !opacity || opacity < 0) {
        return;
      }
      diag2 = Math.pow(pos.ll[0] - pos.ur[0], 2) + Math.pow(pos.ll[1] - pos.ur[1], 2) + Math.pow(pos.ll[2] - pos.ur[0], 2) + Math.pow(pos.lr[0] - pos.ur[0], 2) + Math.pow(pos.lr[1] - pos.ur[1], 2) + Math.pow(pos.lr[2] - pos.ur[0], 2);
      quadinfo.diag2 = diag2;
      quadinfo.ll = pos.ll;
      if (origindiag2 === undefined || diag2 && diag2 < origindiag2) {
        origin = pos.ll;
        origindiag2 = diag2;
      }
      pos = [pos.ll[0], pos.ll[1], pos.ll[2], pos.lr[0], pos.lr[1], pos.lr[2], pos.ul[0], pos.ul[1], pos.ul[2], pos.ur[0], pos.ur[1], pos.ur[2]];
      quad = {
        idx: i,
        pos: pos,
        opacity: opacity,
        zOffset: d.zOffset
      };
      if (d.reference) {
        quad.reference = d.reference;
      }
      if (d.crop) {
        quad.crop = d.crop;
      }
      img = imgFunc.call(m_this, d, i);
      vid = img ? null : vidFunc.call(m_this, d, i);

      // Check for texture data (Uint8Array with width/height) - WebGL only
      if (d.texture && d.texture.data && d.texture.width && d.texture.height) {
        // Create a custom image object for vgl.texture
        var textureImage = {
          width: d.texture.width,
          height: d.texture.height,
          type: d.texture.type || 'RGBA',
          data: d.texture.data
        };
        quad.imageTexture = textureImage; // Store as imageTexture for WebGL
        imgQuads.push(quad);
        quadinfo.imgquad = quad;
      } else if (img) {
        quadinfo.imageEntry = img;
        /* Handle image quads */
        image = m_this._objectListGet(m_images, img);
        if (image === undefined) {
          if (img instanceof Image || img instanceof HTMLCanvasElement) {
            image = img;
          } else {
            image = new Image();
            image.src = img;
          }
          m_this._objectListAdd(m_images, img, image);
        }
        if (util.isReadyImage(image) || image instanceof HTMLCanvasElement) {
          quad.image = image;
        } else {
          previewColor = undefined;
          previewImage = previewImageFunc.call(m_this, d, i);
          if (previewImage && util.isReadyImage(previewImage)) {
            quad.image = previewImage;
          } else {
            previewColor = previewColorFunc.call(m_this, d, i);
            quad.color = util.convertColor(previewColor);
            if (quad.color && quad.color.r !== undefined && quad.color.g !== undefined && quad.color.b !== undefined) {
              clrQuads.push(quad);
              quadinfo.clrquad = quad;
            } else {
              previewColor = undefined;
            }
          }
          reload = loadedFunc.call(m_this, d, i);
          if (reload) {
            // add a promise to the layer if this image might complete
            defer = util.isReadyImage(image, true) ? null : $.Deferred();
            prev_onload = image.onload;
            image.onload = function () {
              if (previewColor !== undefined) {
                if (clrQuads.includes(quad)) {
                  clrQuads.splice(clrQuads.indexOf(quad), 1);
                }
                delete quadinfo.clrquad;
              }
              quad.image = image;
              m_this.dataTime().modified();
              m_this.modified();
              m_this._update();
              m_this.layer().draw();
              if (defer) {
                defer.resolve();
              }
              if (prev_onload) {
                return prev_onload.apply(m_this, arguments);
              }
            };
            prev_onerror = image.onerror;
            image.onerror = function () {
              if (defer) {
                defer.reject();
              }
              if (prev_onerror) {
                return prev_onerror.apply(m_this, arguments);
              }
            };
            if (defer) {
              m_this.layer().addPromise(defer.promise());
            }
          } else if (previewColor === undefined && !quad.image) {
            /* the image isn't ready and we don't want to reload, so don't add
             * it to the list of image quads */
            return;
          }
        }
        imgQuads.push(quad);
        quadinfo.imgquad = quad;
      } else if (vid) {
        /* Handle video quads */
        quadinfo.videoEntry = vid;
        video = m_this._objectListGet(m_videos, vid);
        if (video === undefined) {
          if (vid instanceof HTMLVideoElement) {
            video = vid;
          } else {
            video = document.createElement('video');
            video.src = vid;
          }
          m_this._objectListAdd(m_videos, vid, video);
          /* monitor some media events that may indicate a change of play state
           * or seeking */
          $(video).off('.geojsvideo').on('seeking.geojsvideo canplay.geojsvideo pause.geojsvideo playing.geojsvideo', function (evt) {
            m_this._checkQuadUpdate(quad, evt);
          });
        }
        quad.delayRenderWhenSeeking = delayFunc.call(m_this, d, i);
        if (quad.delayRenderWhenSeeking === undefined) {
          quad.delayRenderWhenSeeking = true;
        }
        if (util.isReadyVideo(video)) {
          quad.video = video;
        } else {
          previewColor = previewColorFunc.call(m_this, d, i);
          quad.color = util.convertColor(previewColor);
          if (quad.color && quad.color.r !== undefined && quad.color.g !== undefined && quad.color.b !== undefined) {
            clrQuads.push(quad);
            quadinfo.clrquad = quad;
          } else {
            previewColor = undefined;
          }
          reload = loadedFunc.call(m_this, d, i);
          if (reload) {
            // add a promise to the layer if this video might load
            defer = util.isReadyVideo(video, true) ? null : $.Deferred();
            prev_onload = video.onloadeddata;
            video.onloadeddata = function () {
              if (previewColor !== undefined) {
                if (clrQuads.includes(quad)) {
                  clrQuads.splice(clrQuads.indexOf(quad), 1);
                }
                delete quadinfo.clrquad;
              }
              quad.video = video;
              m_this.dataTime().modified();
              m_this.modified();
              m_this._update();
              m_this.layer().draw();
              if (defer) {
                defer.resolve();
              }
              if (prev_onload) {
                return prev_onload.apply(m_this, arguments);
              }
            };
            prev_onerror = video.onerror;
            video.onerror = function () {
              if (defer) {
                defer.reject();
              }
              if (prev_onerror) {
                return prev_onerror.apply(m_this, arguments);
              }
            };
            if (defer) {
              m_this.layer().addPromise(defer.promise());
            }
          } else if (previewColor === undefined && !quad.video) {
            /* the video isn't ready and we don't want to reload, so don't add
             * it to the list of video quads */
            return;
          }
        }
        vidQuads.push(quad);
        quadinfo.vidquad = quad;
      } else {
        /* Handle color quads */
        quad.color = util.convertColor(colorFunc.call(m_this, d, i));
        if (!quad.color || quad.color.r === undefined || quad.color.g === undefined || quad.color.b === undefined) {
          /* if we can't resolve the color, don't make a quad */
          return;
        }
        clrQuads.push(quad);
        quadinfo.clrquad = quad;
      }
      if (quadinfo.clrquad) {
        m_nextQuadId += 1;
        quadinfo.clrquad.quadId = m_nextQuadId;
      }
      if (quadinfo.imgquad) {
        m_nextQuadId += 1;
        quadinfo.imgquad.quadId = m_nextQuadId;
      }
      if (quadinfo.vidquad) {
        m_nextQuadId += 1;
        quadinfo.vidquad.quadId = m_nextQuadId;
      }
      if (m_cacheQuads !== false) {
        d._cachedQuad = quadinfo;
      }
    });
    m_this._objectListEnd(m_images);
    m_this._objectListEnd(m_videos);
    m_quads = {
      clrQuads: clrQuads,
      imgQuads: imgQuads,
      vidQuads: vidQuads,
      origin: new Float32Array(origin)
    };
    return m_quads;
  };

  /**
   * If the data has changed and caching has been used, update one or all data
   * items by clearing their caches and updating the modified flag.
   *
   * @param {number|object} [indexOrData] If not specified, clear all quad
   *    caches.  If a number, clear that index-numbered entry from the data
   *    array.  Otherwise, clear the matching entry in the data array.
   * @returns {this}
   */
  this.cacheUpdate = function (indexOrData) {
    if (indexOrData === undefined || indexOrData === null) {
      $.each(m_this.data(), function (idx, entry) {
        if (entry._cachedQuad) {
          delete entry._cachedQuad;
        }
      });
    } else {
      if (isFinite(indexOrData)) {
        indexOrData = m_this.data()[indexOrData];
      }
      if (indexOrData._cachedQuad) {
        delete indexOrData._cachedQuad;
      }
    }
    m_this.modified();
    return m_this;
  };

  /**
   * Get the HTML video element associated with a data item.
   *
   * @param {number|object} indexOrData If a number, use that entry in the data
   *    array, otherwise this must be a value in the data array.  If caching is
   *    used, this is much more efficient.
   * @returns {HTMLVideoElement|null}
   */
  this.video = function (indexOrData) {
    var video, index;
    if (isFinite(indexOrData)) {
      indexOrData = m_this.data()[indexOrData];
    }
    if (indexOrData._cachedQuad) {
      video = (indexOrData._cachedQuad.vidquad || {}).video;
    } else {
      if (!m_quads) {
        m_this._generateQuads();
      }
      index = m_this.data().indexOf(indexOrData);
      if (index >= 0) {
        /* If we don't cache the quad, we don't maintain a direct link between
         * a data element and the video (partly because videos could be shared
         * between multiple quads).  Instead, the video will be in the
         * last-used object list with a reference to the video value of the
         * data entry. */
        video = m_this._objectListGet(m_videos, m_this.style.get('video')(indexOrData, index));
      }
    }
    if (video instanceof HTMLVideoElement) {
      return video;
    }
    return null;
  };

  /**
   * Get/Set nearestPixel value.
   *
   * @param {boolean|number} [val] If not specified, return the current value.
   *    If true, image quads are rendered with near-neighbor sampling.  If
   *    false, with interpolated sampling.  If a number, interpolate at that
   *    zoom level or below and nearest neighbor at that zoom level or above.
   * @returns {boolean|number|this}
   */
  this.nearestPixel = function (val) {
    if (val === undefined) {
      return m_nearestPixel;
    } else {
      m_nearestPixel = val;
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.quadFeature.spec} arg Options for the feature.
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    m_cacheQuads = arg.cacheQuads !== false;
    var style = Object.assign({}, {
      color: {
        r: 1.0,
        g: 1,
        b: 1
      },
      opacity: 1,
      depth: 0,
      drawOnAsyncResourceLoaded: true,
      previewColor: null,
      previewImage: null,
      image: function image(d) {
        return d.image;
      },
      video: function video(d) {
        return d.video;
      },
      position: util.identityFunction
    }, arg.style === undefined ? {} : arg.style);
    if (arg.position !== undefined) {
      style.position = util.ensureFunction(arg.position);
    }
    m_this.style(style);
    m_this.dataTime().modified();
  };
  return m_this;
};

/**
 * Create a quadFeature from an object.
 *
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to.
 * @param {geo.quadFeature.spec} spec The object specification.
 * @returns {geo.quadFeature|null}
 */
_quadFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'quad';
  return feature.create(layer, spec);
};
_quadFeature.capabilities = {
  /* support for solid-colored quads */
  color: 'quad.color',
  /* support for parallelogram image quads */
  image: 'quad.image',
  /* support for cropping quad images */
  imageCrop: 'quad.imageCrop',
  /* support for fixed-scale quad images */
  imageFixedScale: 'quad.imageFixedScale',
  /* support for arbitrary quad images */
  imageFull: 'quad.imageFull',
  /* support for canvas elements as content in image quads */
  canvas: 'quad.canvas',
  /* support for parallelogram video quads */
  video: 'quad.video',
  /* support for raw texture data */
  texture: 'quad.texture'
};
inherit(_quadFeature, feature);
module.exports = _quadFeature;

/***/ }),

/***/ 1098:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var geo_action = __webpack_require__(8695);
var util = __webpack_require__(1949);
var widgets = {
  dom: {}
};
var layers = {};
var layerDefaultFeatures = {};
var renderers = {};
var features = {};
var featureCapabilities = {};
var fileReaders = {};
var rendererLayerAdjustments = {};
var annotations = {};
var registry = {};

/**
 * Register a new file reader type.
 *
 * @alias geo.registerFileReader
 * @param {string} name Name of the reader to register.  If the name already
 *      exists, the class creation function is replaced.
 * @param {Function} func Class creation function.
 */
registry.registerFileReader = function (name, func) {
  fileReaders[name] = func;
};

/**
 * Create a new file reader.
 *
 * @alias geo.createFileReader
 * @param {string} name Name of the reader to create.
 * @param {object} opts Options for the new reader.
 * @returns {geo.fileReader|null} The new reader or null if no such name is
 *      registered.
 */
registry.createFileReader = function (name, opts) {
  if (fileReaders.hasOwnProperty(name)) {
    return fileReaders[name](opts);
  }
  return null;
};

/**
 * Register a new renderer type.
 *
 * @alias geo.registerRenderer
 * @param {string} name Name of the renderer to register.  If the name already
 *      exists, the class creation function is replaced.
 * @param {Function} func Class creation function.
 */
registry.registerRenderer = function (name, func) {
  renderers[name] = func;
};

/**
 * Create new instance of the renderer.
 *
 * @alias geo.createRenderer
 * @param {string} name Name of the renderer to create.
 * @param {geo.layer} layer The layer associated with the renderer.
 * @param {HTMLCanvasElement} [canvas] A canvas object to share between
 *      renderers.
 * @param {object} [options] Options for the new renderer.
 * @returns {geo.renderer|null} The new renderer or null if no such name is
 *      registered.
 */
registry.createRenderer = function (name, layer, canvas, options) {
  if (renderers.hasOwnProperty(name)) {
    var ren = renderers[name]({
      layer: layer,
      canvas: canvas,
      options: options
    });
    ren._init();
    return ren;
  }
  return null;
};

/**
 * Check if the named renderer is supported.  If not, display a warning and get
 * the name of a fallback renderer.  Ideally, we would pass a list of desired
 * features, and, if the renderer is unavailable, this would choose a fallback
 * that would support those features.
 *
 * @alias geo.checkRenderer
 * @param {string|null} name Name of the desired renderer.
 * @param {boolean} [noFallback] If truthy, don't recommend a fallback.
 * @returns {string|null|false} The name of the renderer that should be used
 *      or false if no valid renderer can be determined.
 */
registry.checkRenderer = function (name, noFallback) {
  if (name === null) {
    return name;
  }
  if (renderers.hasOwnProperty(name)) {
    var ren = renderers[name];
    if (!ren.supported || ren.supported()) {
      return ren.apiname || name;
    }
    if (!ren.fallback || noFallback) {
      return false;
    }
    var fallback = registry.checkRenderer(ren.fallback(), true);
    if (fallback !== false) {
      console.warn(name + ' renderer is unavailable, using ' + fallback + ' renderer instead'); // eslint-disable-line no-console
    }
    return fallback;
  }
  return false;
};

/**
 * Check if there is a renderer that is supported and supports a list of
 * features.  If not, display a warning.  This picks the first renderer that
 * supports all of the listed features.
 *
 * @alias geo.rendererForFeatures
 * @param {string[]|undefined} featureList A list of features that will be used
 *      with this renderer.  Features are the basic feature names (e.g.,
 *      `'quad'`), or the feature name followed by a required capability (e.g.,
 *      `'quad.image'`).  If more than one feature or more than one capability
 *      of a feature is required, include each feature and capability
 *      combination in the list (e.g., `['quad.image', 'plane']`).  If no
 *      capability is specified for a feature (or that feature was registered
 *      without a capability object), then the feature will match regardless of
 *      capabilities.
 * @returns {string|null|false} The name of the renderer that should be used
 *      or false if no valid renderer can be determined.
 */
registry.rendererForFeatures = function (featureList) {
  var preferredRenderers = ['webgl', 'canvas', 'svg', 'vtkjs', null];
  var renderer, ridx, feature, fidx, capability, available;
  for (ridx = 0; ridx < preferredRenderers.length; ridx += 1) {
    renderer = preferredRenderers[ridx];
    if (registry.checkRenderer(renderer, true) === false) {
      continue;
    }
    if (!featureList) {
      return renderer;
    }
    if (!features[renderer]) {
      continue;
    }
    available = true;
    for (fidx = 0; fidx < featureList.length; fidx += 1) {
      feature = featureList[fidx];
      capability = null;
      if (feature.indexOf('.') >= 0) {
        capability = feature;
        feature = feature.substr(0, feature.indexOf('.'));
      }
      if (features[renderer][feature] === undefined) {
        available = false;
        break;
      }
      if (capability && featureCapabilities[renderer][feature] && !featureCapabilities[renderer][feature][capability]) {
        available = false;
        break;
      }
    }
    if (available) {
      return renderer;
    }
  }
  console.warn('There is no renderer available for the feature list "' + (featureList || []).join(', ') + '".'); // eslint-disable-line no-console
  return false;
};

/**
 * Register a new feature type.
 *
 * @alias geo.registerFeature
 * @param {string} category The feature category -- this is the renderer name.
 * @param {string} name The feature name.
 * @param {Function} func A function to call to create the feature.
 * @param {object|undefined} capabilities A map of capabilities that this
 *      feature supports.  If the feature is implemented with different
 *      capabilities in multiple categories (renderers), then the feature
 *      should expose a simple dictionary of supported and unsupported
 *      features.  For instance, the quad feature has color quads, image quads,
 *      and image quads that support full transformations.  The capabilities
 *      should be defined in the base feature in a capabilities object so that
 *      they can be referenced by that rather than an explicit string.
 * @returns {object} if this feature replaces an existing one, this was the
 *      feature that was replaced.  In this case, a warning is issued.
 */
registry.registerFeature = function (category, name, func, capabilities) {
  if (!(category in features)) {
    features[category] = {};
    featureCapabilities[category] = {};
  }
  var old = features[category][name];
  if (old) {
    console.warn('The ' + category + '.' + name + ' feature is already registered'); // eslint-disable-line no-console
  }
  features[category][name] = func;
  featureCapabilities[category][name] = capabilities;
  return old;
};

/**
 * Create new instance of a feature.
 *
 * @alias geo.createFeature
 * @param {string} name Name of the feature to create.
 * @param {geo.layer} layer The layer associated with the feature.
 * @param {geo.renderer} renderer The renderer associated with the feature.
 *      This is usually `layer.renderer()`.
 * @param {object} arg Options for the new feature.
 * @returns {geo.feature|null} The new feature or null if no such name is
 *      registered.
 */
registry.createFeature = function (name, layer, renderer, arg) {
  var category = renderer.api(),
    options = {
      layer: layer,
      renderer: renderer
    };
  if (category in features && name in features[category]) {
    if (arg !== undefined) {
      util.deepMerge(options, arg);
    }
    var feature = features[category][name](options);
    if (layer.gcs === undefined) {
      layer.gcs = function () {
        return layer.map().gcs();
      };
    }
    return feature;
  }
  return null;
};

/**
 * Register a layer adjustment.  Layer adjustments are appiled to specified
 * layers when they are created as a method to mixin specific changes,
 * usually based on the renderer used for that layer.
 *
 * @alias geo.registerLayerAdjustment
 * @param {string} category The category for the adjustment; this is commonly
 *      the renderer name.
 * @param {string} name The name of the adjustment; this is commonly the layer
 *      type, or `'all'` for the base layer class.
 * @param {Function} func The function to call when the adjustment is used.
 * @returns {object} if this layer adjustment replaces an existing one, this
 *      was the value that was replaced.  In this case, a warning is issued.
 */
registry.registerLayerAdjustment = function (category, name, func) {
  if (!(category in rendererLayerAdjustments)) {
    rendererLayerAdjustments[category] = {};
  }
  var old = rendererLayerAdjustments[category][name];
  if (old) {
    console.warn('The ' + category + '.' + name + ' layer adjustment is already registered'); // eslint-disable-line no-console
  }
  rendererLayerAdjustments[category][name] = func;
  return old;
};

/**
 * If a layer needs to be adjusted based on the renderer, call the function
 * that adjusts it.
 *
 * @alias geo.adjustLayerForRenderer
 * @param {string} name Name of the layer or adjustment.
 * @param {object} layer Instantiated layer object.
 */
registry.adjustLayerForRenderer = function (name, layer) {
  var rendererName = layer.rendererName();
  if (rendererName) {
    if (rendererLayerAdjustments && rendererLayerAdjustments[rendererName] && rendererLayerAdjustments[rendererName][name]) {
      rendererLayerAdjustments[rendererName][name].apply(layer);
    }
  }
};

/**
 * Register a new layer type.
 *
 * @alias geo.registerLayer
 * @param {string} name Name of the layer to register.  If the name already
 *      exists, the class creation function is replaced.
 * @param {Function} func Class creation function.
 * @param {string[]} [defaultFeatures] An optional list of feature capabilities
 *      that are required to use this layer.
 */
registry.registerLayer = function (name, func, defaultFeatures) {
  layers[name] = func;
  layerDefaultFeatures[name] = defaultFeatures;
};

/**
 * Create new instance of the layer.
 *
 * @alias geo.createLayer
 * @param {string} name Name of the layer to create.
 * @param {geo.map} map The map class instance that owns the layer.
 * @param {object} arg Options for the new layer.
 * @returns {geo.layer|null} The new layer or null if no such name is
 *      registered.
 */
registry.createLayer = function (name, map, arg) {
  // Default renderer is webgl
  var options = {
      map: map
    },
    layer = null;
  if (name in layers) {
    if (!arg.renderer && !arg.features && layerDefaultFeatures) {
      options.features = layerDefaultFeatures[name];
    }
    if (arg !== undefined) {
      var argdata = arg.data;
      delete arg.data;
      util.deepMerge(options, arg);
      if (argdata) {
        options.data = argdata;
      }
    }
    layer = layers[name](options);
    layer.layerName = name;
    layer._init();
    return layer;
  } else {
    return null;
  }
};

/**
 * Register a new widget type.
 *
 * @alias geo.registerWidget
 * @param {string} category A category for this widget.  This is usually
 *      `'dom'`.
 * @param {string} name The name of the widget to register.
 * @param {Function} func Class creation function.
 * @returns {object} If this widget replaces an existing one, this was the
 *      value that was replaced.  In this case, a warning is issued.
 */
registry.registerWidget = function (category, name, func) {
  if (!(category in widgets)) {
    widgets[category] = {};
  }
  var old = widgets[category][name];
  if (old) {
    console.warn('The ' + category + '.' + name + ' widget is already registered'); // eslint-disable-line no-console
  }
  widgets[category][name] = func;
  return old;
};

/**
 * Create new instance of a dom widget.
 *
 * @alias geo.createWidget
 * @param {string} name Name of the widget to create.
 * @param {geo.layer} layer The layer associated with the widget.
 * @param {object} arg Options for the new widget.
 * @returns {geo.widget} The new widget.
 */
registry.createWidget = function (name, layer, arg) {
  var options = {
    layer: layer
  };
  if (name in widgets.dom) {
    if (arg !== undefined) {
      util.deepMerge(options, arg);
    }
    return widgets.dom[name](options);
  }
  throw new Error('Cannot create unknown widget ' + name);
};

/**
 * Register a new annotation type.
 *
 * @alias geo.registerAnnotation
 * @param {string} name The annotation name.
 * @param {Function} func A function to call to create the annotation.
 * @param {object|undefined} features A map of features that are used by this
 *      annotation.  Each key is a feature that is used.  If the value is true,
 *      the that feature is always needed.  If a list, then it is the set of
 *      annotation states for which that feature is required.  These can be
 *      used to pick an appropriate renderer when creating an annotation layer.
 * @returns {object} if this annotation replaces an existing one, this was the
 *      value that was replaced.  In this case, a warning is issued.
 */
registry.registerAnnotation = function (name, func, features) {
  var old = annotations[name];
  if (old) {
    console.warn('The ' + name + ' annotation is already registered'); // eslint-disable-line no-console
  }
  annotations[name] = {
    func: func,
    features: features || {}
  };
  geo_action['annotation_' + name] = 'geo_annotation_' + name;
  return old;
};

/**
 * Create an annotation based on a registered type.
 *
 * @alias geo.createAnnotation
 * @param {string} name The annotation name
 * @param {object} options The options for the annotation.
 * @returns {object?} the new annotation.
 */
registry.createAnnotation = function (name, options) {
  if (!annotations[name]) {
    console.warn('The ' + name + ' annotation is not registered'); // eslint-disable-line no-console
    return undefined;
  }
  var annotation = annotations[name].func(options);
  return annotation;
};

/**
 * Get a list of registered annotation types.
 *
 * @alias geo.listAnnotations
 * @returns {string[]} A list of registered annotations.
 */
registry.listAnnotations = function () {
  return Object.keys(annotations);
};

/**
 * Get a list of required features for a set of annotations.
 *
 * @alias geo.featuresForAnnotations
 * @param {string[]|object|undefined} annotationList A list of annotations that
 *   will be used.  Instead of a list, if this is an object, the keys are the
 *   annotation names, and the values are each a list of modes that will be
 *   used with that annotation.  For example, ['polygon', 'rectangle'] lists
 *   features required to show those annotations in any mode,  whereas
 *   {polygon: [annotationState.done], rectangle: [annotationState.done]} only
 *   lists features that are needed to show the completed annotations.
 * @returns {string[]} a list of features needed for the specified annotations.
 *   There may be duplicates in the list.
 */
registry.featuresForAnnotations = function (annotationList) {
  var features = [];
  var annList = Array.isArray(annotationList) ? annotationList : Object.keys(annotationList);
  annList.forEach(function (ann) {
    if (!annotations[ann]) {
      return;
    }
    Object.keys(annotations[ann].features).forEach(function (feature) {
      if (Array.isArray(annotationList) || annotationList[ann] === true || !Array.isArray(annotations[ann].features[feature])) {
        features.push(feature);
      } else {
        annotationList[ann].forEach(function (state) {
          if (annotations[ann].features[feature].includes(state)) {
            features.push(feature);
          }
        });
      }
    });
  });
  return features;
};

/**
 * Check if there is a renderer that is supported and supports a list of
 * annotations.  If not, display a warning.  This generates a list of required
 * features, then picks the first renderer that supports all of these features.
 *
 * @alias geo.rendererForAnnotations
 * @param {string[]|object|undefined} annotationList A list of annotations that
 *   will be used with this renderer.  Instead of a list, if this is an object,
 *   the keys are the annotation names, and the values are each a list of modes
 *   that will be used with that annotation.  See featuresForAnnotations for
 *   more details.
 * @returns {string|null|false} the name of the renderer that should be used or
 *   false if no valid renderer can be determined.
 */
registry.rendererForAnnotations = function (annotationList) {
  return registry.rendererForFeatures(registry.featuresForAnnotations(annotationList));
};

/**
 * Expose the various registries so that the can be examined to see what
 * things are registered.
 *
 * @namespace geo.registries
 */
registry.registries = {
  annotations: annotations,
  features: features,
  featureCapabilities: featureCapabilities,
  fileReaders: fileReaders,
  layers: layers,
  renderers: renderers,
  widgets: widgets
};
module.exports = registry;

/***/ }),

/***/ 2274:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var object = __webpack_require__(1338);

/**
 * Create a new instance of class renderer.
 *
 * @class
 * @alias geo.renderer
 * @extends geo.object
 * @param {object} arg Options for the renderer.
 * @param {geo.layer} [arg.layer] Layer associated with the renderer.
 * @param {HTMLElement} [arg.canvas] Canvas element associated with the
 *   renderer.
 * @returns {geo.renderer}
 */
var _renderer = function renderer(arg) {
  'use strict';

  if (!(this instanceof _renderer)) {
    return new _renderer(arg);
  }
  object.call(this);
  arg = arg || {};
  var m_this = this,
    m_width = 0,
    m_height = 0,
    m_layer = arg.layer === undefined ? null : arg.layer,
    m_canvas = arg.canvas === undefined ? null : arg.canvas,
    m_initialized = false;

  /**
   * Get layer of the renderer.
   *
   * @returns {geo.layer}
   */
  this.layer = function () {
    return m_layer;
  };

  /**
   * Get/set canvas for the renderer.
   *
   * @param {HTMLElement} [val] If `undefined`, return the current canvas
   *    element, otherwise set the canvas element and mark the renderer as
   *    modified.
   * @returns {HTMLElement|this} The current canvas element or the renderer
   *    instance.
   */
  this.canvas = function (val) {
    if (val === undefined) {
      return m_canvas;
    }
    m_canvas = val;
    m_this.modified();
    return m_this;
  };

  /**
   * Get the map associated with the renderer's layer.
   *
   * @returns {geo.map|null} The map associated with the renderer's layer or
   *    `null` if there is no layer.
   */
  this.map = function () {
    if (m_layer) {
      return m_layer.map();
    } else {
      return null;
    }
  };

  /**
   * Get/set if renderer has been initialized.
   *
   * @param {boolean} [val] If `undefined` return the initialization state,
   *    otherwise set it.
   * @returns {boolean|this} The initialization state or this renderer
   *    instance.
   */
  this.initialized = function (val) {
    if (val === undefined) {
      return m_initialized;
    }
    m_initialized = val;
    return m_this;
  };

  /**
   * Get render API used by the renderer.
   *
   * This must be subclassed, returning a string describing the renderer
   * interface.
   */
  this.api = function () {
    throw new Error('Should be implemented by derived classes');
  };

  /**
   * Get the width of the renderer.
   *
   * @returns {number} The width of the renderer.
   */
  this.width = function () {
    return m_width;
  };

  /**
   * Get the height of the renderer.
   *
   * @returns {number} The height of the renderer.
   */
  this.height = function () {
    return m_height;
  };

  /**
   * Set the width and height of the renderer.
   *
   * @param {number} width The new width.
   * @param {number} height The new height.
   * @returns {this}
   */
  this._setWidthHeight = function (width, height) {
    m_width = width;
    m_height = height;
    return m_this;
  };

  /**
   * Initialize.
   *
   * @returns {this}
   */
  this._init = function () {
    return m_this;
  };

  /**
   * Handle resize event.
   *
   * @param {number} x Ignored.
   * @param {number} y Ignored.
   * @param {number} w New width in pixels.
   * @param {number} h New height in pixels.
   * @returns {this}
   */
  this._resize = function (x, y, w, h) {
    m_this._setWidthHeight(w, h);
    return m_this;
  };

  /**
   * Render.
   *
   * @returns {this}
   */
  this._render = function () {
    return m_this;
  };
  return this;
};
inherit(_renderer, object);
module.exports = _renderer;

/***/ }),

/***/ 5402:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var object = __webpack_require__(1338);

/**
 * Create a new instance of class sceneObject, which extends the object's
 * event handling with a tree-based event propagation.
 *
 * @class
 * @alias geo.sceneObject
 * @extends geo.object
 * @param {object} arg Options for the object.
 * @returns {geo.sceneObject}
 */
var _sceneObject = function sceneObject(arg) {
  'use strict';

  if (!(this instanceof _sceneObject)) {
    return new _sceneObject();
  }
  object.call(this, arg);
  var m_this = this,
    m_parent = null,
    m_children = [],
    s_exit = this._exit,
    s_trigger = this.geoTrigger,
    s_addPromise = this.addPromise,
    s_removePromise = this.removePromise;

  /**
   * Add the promise here and also propagate up the scene tree.
   *
   * @param {Promise} promise A promise object.
   * @returns {this}
   */
  this.addPromise = function (promise) {
    if (m_parent) {
      m_parent.addPromise(promise);
    }
    s_addPromise(promise);
    return m_this;
  };

  /**
   * Remove the promise here and also propagate up the scene tree.
   *
   * @param {Promise} promise A promise object.
   * @returns {this}
   */
  this.removePromise = function (promise) {
    if (m_parent) {
      m_parent.removePromise(promise);
    }
    s_removePromise(promise);
    return m_this;
  };

  /**
   * Get/set parent of the object.
   *
   * @param {geo.sceneObject} [arg] The new parent or `undefined` to get the
   *    current parent.
   * @returns {this|geo.sceneObject}
   */
  this.parent = function (arg) {
    if (arg === undefined) {
      return m_parent;
    }
    m_parent = arg;
    return m_this;
  };

  /**
   * Add a child (or an array of children) to the object.
   *
   * @param {geo.object|geo.object[]} child A child object or array of child
   *    objects.
   * @returns {this}
   */
  this.addChild = function (child) {
    if (Array.isArray(child)) {
      child.forEach(m_this.addChild);
      return m_this;
    }
    child.parent(m_this);
    m_children.push(child);
    return m_this;
  };

  /**
   * Remove a child (or array of children) from the object.
   *
   * @param {geo.object|geo.object[]} child A child object or array of child
   *    objects.
   * @returns {this}
   */
  this.removeChild = function (child) {
    if (Array.isArray(child)) {
      child.forEach(m_this.removeChild);
      return m_this;
    }
    m_children = m_children.filter(function (c) {
      return c !== child;
    });
    return m_this;
  };

  /**
   * Get an array of the child objects.
   *
   * @returns {geo.object[]} A copy of the array of child objects.
   */
  this.children = function () {
    return m_children.slice();
  };

  /**
   * Force redraw of a scene object, to be implemented by subclasses.
   * Base class just calls draw of child objects.
   *
   * @param {object} arg Options to pass to the child draw functions.
   * @returns {this}
   */
  this.draw = function (arg) {
    m_this.children().forEach(function (child) {
      child.draw(arg);
    });
    return m_this;
  };

  /**
   * Trigger an event (or events) on this object and call all handlers.
   *
   * @param {string} event The event to trigger.
   * @param {object} args Arbitrary argument to pass to the handler.
   * @param {boolean} [childrenOnly] If truthy, only propagate down the tree.
   * @returns {this}
   */
  this.geoTrigger = function (event, args, childrenOnly) {
    var geoArgs;
    args = args || {};
    geoArgs = args.geo || {};
    args.geo = geoArgs;

    // stop propagation if requested by the handler
    if (geoArgs.stopPropagation) {
      return m_this;
    }

    // If the event was not triggered by the parent, just propagate up the tree
    if (!childrenOnly && m_parent && geoArgs._triggeredBy !== m_parent) {
      geoArgs._triggeredBy = m_this;
      m_parent.geoTrigger(event, args);
      return m_this;
    }

    // call the object's own handlers
    s_trigger.call(m_this, event, args);

    // stop propagation if requested by the handler
    if (geoArgs.stopPropagation) {
      return m_this;
    }

    // trigger the event on the children
    m_children.forEach(function (child) {
      if (child.geoTrigger) {
        geoArgs._triggeredBy = m_this;
        child.geoTrigger(event, args);
      }
    });
    return m_this;
  };

  /**
   * Free all resources and destroy the object.
   */
  this._exit = function () {
    m_children = [];
    m_parent = null;
    s_exit();
  };
  return this;
};
inherit(_sceneObject, object);
module.exports = _sceneObject;

/***/ }),

/***/ 9079:
/***/ (function(module) {

/* global GEO_SHA */

/**
 * The current geojs git SHA.
 *
 * @alias geo.sha
 * @constant
 * @type {string}
 */
module.exports = "ee211d0404e96876a22a741f9b0a90002ca0a983";

/***/ }),

/***/ 3832:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var graphFeature = __webpack_require__(3187);

/**
 * Create a new instance of svg.graphFeature.
 *
 * @class
 * @alias geo.svg.graphFeature
 * @extends geo.graphFeature
 * @param {geo.graphFeature.spec} arg Feature options.
 * @returns {geo.graphFeature}
 */
var _svg_graphFeature = function svg_graphFeature(arg) {
  'use strict';

  var m_this = this;
  if (!(this instanceof _svg_graphFeature)) {
    return new _svg_graphFeature(arg);
  }
  graphFeature.call(this, arg);

  /**
   * Return a d3 selection for the graph elements.
   *
   * @returns {object} An object with `nodes` and `links`, both d3 selectors
   *    for the graph elements.
   */
  this.select = function () {
    var renderer = m_this.renderer(),
      selection = {},
      node = m_this.nodeFeature(),
      links = m_this.linkFeatures();
    selection.nodes = renderer.select(node._svgid());
    selection.links = links.map(function (link) {
      return renderer.select(link._svgid());
    });
    return selection;
  };
  return this;
};
inherit(_svg_graphFeature, graphFeature);
registerFeature('svg', 'graph', _svg_graphFeature);
module.exports = _svg_graphFeature;

/***/ }),

/***/ 6488:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var geo_event = __webpack_require__(6409);
geo_event.svg = {
  rescale: __webpack_require__(4765)
};

/**
 * @namespace geo.svg
 */
module.exports = {
  graphFeature: __webpack_require__(3832),
  lineFeature: __webpack_require__(9456),
  object: __webpack_require__(5005),
  pathFeature: __webpack_require__(9927),
  pointFeature: __webpack_require__(2602),
  quadFeature: __webpack_require__(4087),
  renderer: __webpack_require__(2493),
  tileLayer: __webpack_require__(4061),
  trackFeature: __webpack_require__(2037),
  uniqueID: __webpack_require__(7376),
  vectorFeature: __webpack_require__(5747)
};

/***/ }),

/***/ 9456:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var lineFeature = __webpack_require__(9281);

/**
 * Create a new instance of class lineFeature.
 *
 * @class
 * @alias geo.svg.lineFeature
 * @extends geo.lineFeature
 * @extends geo.svg.object
 * @param {geo.lineFeature.spec} arg
 * @returns {geo.svg.lineFeature}
 */
var _svg_lineFeature = function svg_lineFeature(arg) {
  'use strict';

  if (!(this instanceof _svg_lineFeature)) {
    return new _svg_lineFeature(arg);
  }
  var d3 = (__webpack_require__(2493).d3);
  var object = __webpack_require__(5005);
  var timestamp = __webpack_require__(77);
  var util = __webpack_require__(642);
  arg = arg || {};
  lineFeature.call(this, arg);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init,
    m_buildTime = timestamp(),
    m_maxIdx = 0,
    s_update = this._update;

  /**
   * Initialize.
   *
   * @param {geo.lineFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    return m_this;
  };

  /**
   * Build.  Create the necessary elements to render lines.
   *
   * @returns {this}
   */
  this._build = function () {
    var data = m_this.data() || [],
      s_style = m_this.style(),
      m_renderer = m_this.renderer(),
      pos_func = m_this.position(),
      line,
      i;
    s_update.call(m_this);
    s_style.fill = function () {
      return false;
    };
    data.forEach(function (item, idx) {
      var m_style;
      var ln = m_this.line()(item, idx);
      var style = {},
        key;
      function wrapStyle(func) {
        if (util.isFunction(func)) {
          return function () {
            return func(ln[0], 0, item, idx);
          };
        } else {
          return func;
        }
      }
      for (key in s_style) {
        if (s_style.hasOwnProperty(key)) {
          style[key] = wrapStyle(s_style[key]);
        }
      }
      line = d3.line().x(function (d) {
        return m_this.featureGcsToDisplay(d).x;
      }).y(function (d) {
        return m_this.featureGcsToDisplay(d).y;
      }).curve(m_this.style.get('closed')(item, idx) && ln.length > 2 ? d3.curveLinearClosed : d3.curveLinear);
      // item is an object representing a single line
      // m_this.line()(item) is an array of coordinates
      m_style = {
        data: [ln.map(function (d, i) {
          return pos_func(d, i, item, idx);
        })],
        append: 'path',
        attributes: {
          d: line
        },
        id: m_this._svgid() + idx,
        classes: ['svgLineFeature', 'svgSubLine-' + idx],
        visible: m_this.visible,
        style: style
      };
      m_renderer._drawFeatures(m_style);
    });
    for (i = data.length; i < m_maxIdx; i += 1) {
      m_renderer._removeFeature(m_this._svgid() + i);
    }
    m_maxIdx = data.length;
    m_buildTime.modified();
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.timestamp() >= m_buildTime.timestamp()) {
      m_this._build();
    }
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_svg_lineFeature, lineFeature);

// Now register it
var capabilities = {};
capabilities[lineFeature.capabilities.basic] = true;
capabilities[lineFeature.capabilities.multicolor] = false;
registerFeature('svg', 'line', _svg_lineFeature, capabilities);
module.exports = _svg_lineFeature;

/***/ }),

/***/ 5005:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * SVG specific subclass of object which adds an id property for d3 selections
 * on groups of objects by class id.
 *
 * @class
 * @alias geo.svg.object
 * @extends geo.sceneObject
 * @param {object} arg Options for the object.
 * @returns {geo.svg.object}
 */
var _svg_object = function svg_object(arg) {
  'use strict';

  var object = __webpack_require__(1338);
  var uniqueID = __webpack_require__(7376);

  // this is used to extend other geojs classes, so only generate
  // a new object when that is not the case... like if this === window
  if (!(this instanceof object)) {
    return new _svg_object(arg);
  }
  var m_id = 'svg-' + uniqueID(),
    s_exit = this._exit,
    m_this = this,
    s_visible = this.visible,
    s_draw = this.draw;
  this._svgid = function () {
    return m_id;
  };

  /**
   * Returns a d3 selection for the feature elements.
   *
   * @returns {d3Selector} A d3 selector of the features in this object.
   */
  this.select = function () {
    return m_this.renderer().select(m_this._svgid());
  };

  /**
   * Redraw the object.
   *
   * @returns {this}
   */
  this.draw = function () {
    if (m_this.ready) {
      m_this._update();
      s_draw();
    }
    return m_this;
  };

  /**
   * Removes the element from the svg and the renderer.
   */
  this._exit = function () {
    m_this.renderer()._removeFeature(m_this._svgid());
    s_exit();
  };

  /**
   * Get/Set the visibility of the feature.
   *
   * @param {boolean} [val] A boolean to change the visibility, or `undefined`
   *    to return the visibility.
   * @param {boolean} [direct] If `true`, when getting the visibility,
   *    disregard the visibility of the parent layer, and when setting, refresh
   *    the state regardless of whether it has changed or not.  Otherwise, the
   *    functional visibility is returned, where both the feature and the layer
   *    must be visible for a `true` result.
   * @returns {boolean|this} Either the visibility (if getting) or the feature
   *    (if setting).
   */
  this.visible = function (val, direct) {
    if (val !== undefined && val !== s_visible(undefined, true) && m_this.renderer()) {
      m_this.renderer()._scheduleUpdate();
    }
    return s_visible(val, direct);
  };
  return this;
};
module.exports = _svg_object;

/***/ }),

/***/ 9927:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var pathFeature = __webpack_require__(2266);

/**
 * Create a new instance of class geo.svg.pathFeature.
 *
 * @class
 * @alias geo.svg.pathFeature
 * @extends geo.pathFeature
 * @extends geo.svg.object
 * @param {geo.pathFeature.spec} arg
 * @returns {geo.svg.pathFeature}
 */
var _svg_pathFeature = function svg_pathFeature(arg) {
  'use strict';

  if (!(this instanceof _svg_pathFeature)) {
    return new _svg_pathFeature(arg);
  }
  var object = __webpack_require__(5005);
  var timestamp = __webpack_require__(77);
  arg = arg || {};
  pathFeature.call(this, arg);
  object.call(this);
  var m_this = this,
    m_buildTime = timestamp(),
    s_update = this._update,
    m_style = {};
  m_style.style = {};

  /**
   * Build.
   *
   * @returns {this}
   */
  this._build = function () {
    var data = m_this.data() || [],
      s_style = m_this.style.get(),
      posFunc = m_this.style.get('position'),
      tmp,
      diag;
    s_update.call(m_this);
    diag = function diag(d) {
      // in d3 v3 this was "d3.svg.diagonal(d);".  See
      // https://stackoverflow.com/questions/40845121/where-is-d3-svg-diagonal
      return 'M' + d.source.x + ',' + d.source.y + 'C' + d.source.x + ',' + (d.source.y + d.target.y) / 2 + ' ' + d.target.x + ',' + (d.source.y + d.target.y) / 2 + ' ' + d.target.x + ',' + d.target.y;
    };
    tmp = [];
    data.forEach(function (d, i) {
      var src, trg;
      if (i < data.length - 1) {
        src = posFunc(d, i);
        trg = posFunc(data[i + 1], i + 1);
        tmp.push({
          source: m_this.featureGcsToDisplay(src),
          target: m_this.featureGcsToDisplay(trg)
        });
      }
    });
    m_style.data = tmp;
    m_style.attributes = {
      d: diag
    };
    m_style.id = m_this._svgid();
    m_style.append = 'path';
    m_style.classes = ['svgPathFeature'];
    m_style.style = Object.assign({
      fill: function fill() {
        return false;
      },
      fillColor: {
        r: 0,
        g: 0,
        b: 0
      }
    }, s_style);
    m_style.visible = m_this.visible;
    m_this.renderer()._drawFeatures(m_style);
    m_buildTime.modified();
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Update.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_buildTime.timestamp()) {
      m_this._build();
    }
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_svg_pathFeature, pathFeature);
registerFeature('svg', 'path', _svg_pathFeature);
module.exports = _svg_pathFeature;

/***/ }),

/***/ 2602:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var pointFeature = __webpack_require__(7541);

/**
 * Create a new instance of svg.pointFeature.
 *
 * @class
 * @alias geo.svg.pointFeature
 * @extends geo.pointFeature
 * @extends geo.svg.object
 * @param {geo.pointFeature.spec} arg
 * @returns {geo.svg.pointFeature}
 */
var _svg_pointFeature = function svg_pointFeature(arg) {
  'use strict';

  if (!(this instanceof _svg_pointFeature)) {
    return new _svg_pointFeature(arg);
  }
  var svg_object = __webpack_require__(5005);
  var timestamp = __webpack_require__(77);
  arg = arg || {};
  pointFeature.call(this, arg);
  svg_object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init,
    s_update = this._update,
    m_buildTime = timestamp(),
    m_style = {};

  /**
   * Initialize.
   *
   * @param {geo.pointFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    return m_this;
  };

  /**
   * Build.  Create the necessary elements to render points.
   *
   * @returns {this}
   */
  this._build = function () {
    var data = m_this.data(),
      s_style = m_this.style.get(),
      m_renderer = m_this.renderer(),
      pos_func = m_this.position();

    // call super-method
    s_update.call(m_this);

    // default to empty data array
    if (!data) {
      data = [];
    }

    // fill in svg renderer style object defaults
    m_style.id = m_this._svgid();
    m_style.data = data;
    m_style.append = 'circle';
    m_style.attributes = {
      r: m_renderer._convertScale(s_style.radius),
      cx: function cx(d) {
        return m_this.featureGcsToDisplay(pos_func(d)).x;
      },
      cy: function cy(d) {
        return m_this.featureGcsToDisplay(pos_func(d)).y;
      }
    };
    m_style.style = s_style;
    m_style.classes = ['svgPointFeature'];
    m_style.visible = m_this.visible;

    // pass to renderer to draw
    m_this.renderer()._drawFeatures(m_style);

    // update time stamps
    m_buildTime.modified();
    m_this.updateTime().modified();
    return m_this;
  };
  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.timestamp() >= m_buildTime.timestamp()) {
      m_this._build();
    }
    return m_this;
  };
  this._init(arg);
  return this;
};
inherit(_svg_pointFeature, pointFeature);
var capabilities = {};
capabilities[pointFeature.capabilities.stroke] = true;

// Now register it
registerFeature('svg', 'point', _svg_pointFeature, capabilities);
module.exports = _svg_pointFeature;

/***/ }),

/***/ 4087:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var quadFeature = __webpack_require__(3842);

/**
 * Create a new instance of class quadFeature.
 *
 * @class
 * @alias geo.svg.quadFeature
 * @param {geo.quadFeature.spec} arg Options object.
 * @extends geo.quadFeature
 * @returns {geo.svg.quadFeature}
 */
var _svg_quadFeature = function svg_quadFeature(arg) {
  'use strict';

  if (!(this instanceof _svg_quadFeature)) {
    return new _svg_quadFeature(arg);
  }
  var $ = __webpack_require__(5616);
  var d3 = (__webpack_require__(2493).d3);
  var object = __webpack_require__(5005);
  quadFeature.call(this, arg);
  object.call(this);
  var m_this = this,
    s_exit = this._exit,
    s_init = this._init,
    s_update = this._update,
    m_quads;

  /**
   * Build this feature.
   */
  this._build = function () {
    if (!this.position()) {
      return;
    }
    var renderer = m_this.renderer(),
      map = renderer.layer().map();
    m_quads = m_this._generateQuads();
    var data = [];
    $.each(m_quads.clrQuads, function (idx, quad) {
      data.push({
        type: 'clr',
        quad: quad,
        zIndex: quad.pos[2]
      });
    });
    $.each(m_quads.imgQuads, function (idx, quad) {
      if (quad.image) {
        data.push({
          type: 'img',
          quad: quad,
          zIndex: quad.pos[2]
        });
      }
    });
    var feature = {
      id: m_this._svgid(),
      data: data,
      dataIndex: function dataIndex(d) {
        return d.quad.quadId;
      },
      append: function append(d) {
        var ns = this.namespaceURI,
          element = d.type === 'clr' ? 'polygon' : 'image';
        return ns ? document.createElementNS(ns, element) : document.createElement(element);
      },
      attributes: {
        fill: function fill(d) {
          if (d.type === 'clr') {
            return d3.rgb(255 * d.quad.color.r, 255 * d.quad.color.g, 255 * d.quad.color.b);
          }
          /* set some styles here */
          if (d.quad.opacity !== 1) {
            d3.select(this).style('opacity', d.quad.opacity);
          }
        },
        height: function height(d) {
          return d.type === 'clr' ? undefined : 1;
        },
        points: function points(d) {
          if (d.type === 'clr' && !d.points) {
            var points = [],
              i;
            for (i = 0; i < d.quad.pos.length; i += 3) {
              var p = {
                x: d.quad.pos[i],
                y: d.quad.pos[i + 1],
                z: d.quad.pos[i + 2]
              };
              /* We don't use 'p = m_this.featureGcsToDisplay(p);' because the
               * quads have already been converted to the map's gcs (no longer
               * the feature's gcs or map's ingcs). */
              p = map.gcsToDisplay(p, null);
              p = renderer.baseToLocal(p);
              points.push('' + p.x + ',' + p.y);
            }
            d.points = points[0] + ' ' + points[1] + ' ' + points[3] + ' ' + points[2];
          }
          return d.type === 'clr' ? d.points : undefined;
        },
        preserveAspectRatio: function preserveAspectRatio(d) {
          return d.type === 'clr' ? undefined : 'none';
        },
        reference: function reference(d) {
          return d.quad.reference;
        },
        stroke: false,
        transform: function transform(d) {
          if (d.type === 'img' && d.quad.image && !d.svgTransform) {
            var pos = [],
              area,
              maxarea = -1,
              maxv,
              i,
              imgscale,
              imgw = d.quad.image.width,
              imgh = d.quad.image.height;
            for (i = 0; i < d.quad.pos.length; i += 3) {
              var p = {
                x: d.quad.pos[i],
                y: d.quad.pos[i + 1],
                z: d.quad.pos[i + 2]
              };
              /* We don't use 'p = m_this.featureGcsToDisplay(p);' because the
               * quads have already been converted to the map's gcs (no longer
               * the feature's gcs or map's ingcs). */
              p = map.gcsToDisplay(p, null);
              p = renderer.baseToLocal(p);
              pos.push(p);
            }
            /* We can only fit three corners of the quad to the image, but we
             * get to pick which three.  We choose to always include the
             * largest of the triangles formed by a set of three vertices.  The
             * image is always rendered as a parallelogram, so it may be larger
             * than desired, and, for convex quads, miss some of the intended
             * area. */
            for (i = 0; i < 4; i += 1) {
              area = Math.abs(pos[(i + 1) % 4].x * (pos[(i + 2) % 4].y - pos[(i + 3) % 4].y) + pos[(i + 2) % 4].x * (pos[(i + 3) % 4].y - pos[(i + 1) % 4].y) + pos[(i + 3) % 4].x * (pos[(i + 1) % 4].y - pos[(i + 2) % 4].y)) / 2;
              if (area > maxarea) {
                maxarea = area;
                maxv = i;
              }
            }
            d.svgTransform = [maxv === 3 || maxv === 2 ? pos[1].x - pos[0].x : pos[3].x - pos[2].x, maxv === 3 || maxv === 2 ? pos[1].y - pos[0].y : pos[3].y - pos[2].y, maxv === 0 || maxv === 2 ? pos[1].x - pos[3].x : pos[0].x - pos[2].x, maxv === 0 || maxv === 2 ? pos[1].y - pos[3].y : pos[0].y - pos[2].y, maxv === 2 ? pos[3].x + pos[0].x - pos[1].x : pos[2].x, maxv === 2 ? pos[3].y + pos[0].y - pos[1].y : pos[2].y];
            if (Math.abs(d.svgTransform[1] / imgw) < 1e-6 && Math.abs(d.svgTransform[2] / imgh) < 1e-6) {
              imgscale = d.svgTransform[0] / imgw;
              d.svgTransform[4] = Math.round(d.svgTransform[4] / imgscale) * imgscale;
              imgscale = d.svgTransform[3] / imgh;
              d.svgTransform[5] = Math.round(d.svgTransform[5] / imgscale) * imgscale;
            }
          }
          return d.type !== 'img' || !d.quad.image ? undefined : 'matrix(' + d.svgTransform.join(' ') + ')';
        },
        width: function width(d) {
          return d.type === 'clr' ? undefined : 1;
        },
        x: function x(d) {
          return d.type === 'clr' ? undefined : 0;
        },
        'xlink:href': function xlinkHref(d) {
          return d.type === 'clr' || !d.quad.image ? undefined : d.quad.image.src;
        },
        y: function y(d) {
          return d.type === 'clr' ? undefined : 0;
        }
      },
      style: {
        fillOpacity: function fillOpacity(d) {
          return d.type === 'clr' ? d.quad.opacity : undefined;
        }
      },
      onlyRenderNew: !this.style('previewColor') && !this.style('previewImage'),
      sortByZ: true,
      visible: m_this.visible,
      classes: ['svgQuadFeature']
    };
    renderer._drawFeatures(feature);
    m_this.buildTime().modified();
  };

  /**
   * Update the feature.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.buildTime().timestamp() <= m_this.dataTime().timestamp() || m_this.buildTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }
    return m_this;
  };

  /**
   * Initialize.
   */
  this._init = function () {
    s_init.call(m_this, arg);
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    s_exit.call(m_this);
  };
  m_this._init(arg);
  return this;
};
inherit(_svg_quadFeature, quadFeature);

// Now register it
var capabilities = {};
capabilities[quadFeature.capabilities.color] = true;
capabilities[quadFeature.capabilities.image] = true;
capabilities[quadFeature.capabilities.imageCrop] = false;
capabilities[quadFeature.capabilities.imageFixedScale] = false;
capabilities[quadFeature.capabilities.imageFull] = false;
capabilities[quadFeature.capabilities.canvas] = false;
capabilities[quadFeature.capabilities.video] = false;
registerFeature('svg', 'quad', _svg_quadFeature, capabilities);
module.exports = _svg_quadFeature;

/***/ }),

/***/ 4765:
/***/ (function(module) {

/**
 * @namespace geo.event.svg
 */

/**
 * @event geo.event.svg.rescale
 * @type {geo.event.base}
 * @property {number} scale The scale as a ratio of the original render size.
 */
module.exports = 'geo_svg_rescale';

/***/ }),

/***/ 2493:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerRenderer = (__webpack_require__(1098).registerRenderer);
var renderer = __webpack_require__(2274);

/**
 * Create a new instance of class svgRenderer.
 *
 * @class
 * @alias geo.svg.renderer
 * @extends geo.renderer
 * @param {object} arg Options for the renderer.
 * @param {geo.layer} [arg.layer] Layer associated with the renderer.
 * @param {HTMLElement} [arg.canvas] Canvas element associated with the
 *   renderer.
 * @param {boolean} [arg.widget] Set to `true` if this is a stand-alone
 *   widget.  If it is not a widget, svg elements are wrapped in a parent
 *   group.
 * @param {HTMLElement} [arg.d3Parent] If specified, the parent for any
 *   rendered objects; otherwise the renderer's layer's main node is used.
 * @returns {geo.svg.svgRenderer}
 */
var _svgRenderer = function svgRenderer(arg) {
  'use strict';

  var d3 = _svgRenderer.d3;
  var object = __webpack_require__(5005);
  var util = __webpack_require__(642);
  var geo_event = __webpack_require__(6409);
  var svgRescale = __webpack_require__(4765);
  if (!(this instanceof _svgRenderer)) {
    return new _svgRenderer(arg);
  }
  renderer.call(this, arg);
  var s_exit = this._exit;
  object.call(this, arg);
  arg = arg || {};
  var m_this = this,
    m_sticky = null,
    m_features = {},
    m_corners = null,
    m_diagonal = null,
    m_scale = 1,
    m_transform = {
      dx: 0,
      dy: 0,
      rx: 0,
      ry: 0,
      rotation: 0
    },
    m_renderIds = {},
    m_removeIds = {},
    m_svg = null,
    m_defs = null;

  /**
   * Set attributes to a d3 selection.
   *
   * @param {d3Selector} select The d3 selector with the elements to change.
   * @param {object} attrs A map of attributes to set on the elements.
   */
  function setAttrs(select, attrs) {
    var key;
    for (key in attrs) {
      if (attrs.hasOwnProperty(key)) {
        select.attr(key, attrs[key]);
      }
    }
  }

  /**
   * Meta functions for converting from geojs styles to d3.
   *
   * @param {object|Function} f The style value or function to convert.
   * @param {Function} [g] An optional function that returns a boolean; if it
   *    returns false, the style is set to `'none'`.
   * @returns {Function} A function for converting styles.
   */
  this._convertColor = function (f, g) {
    f = util.ensureFunction(f);
    g = g || function () {
      return true;
    };
    return function () {
      var c = 'none';
      if (g.apply(m_this, arguments)) {
        c = f.apply(m_this, arguments);
        if (c.hasOwnProperty('r') && c.hasOwnProperty('g') && c.hasOwnProperty('b')) {
          c = d3.rgb(255 * c.r, 255 * c.g, 255 * c.b);
        }
      }
      return c;
    };
  };

  /**
   * Return a function for converting a size in pixels to an appropriate
   * d3 scale.
   *
   * @param {object|Function} f The style value or function to convert.
   * @returns {Function} A function for converting scale.
   */
  this._convertScale = function (f) {
    f = util.ensureFunction(f);
    return function () {
      return f.apply(m_this, arguments) / m_scale;
    };
  };

  /**
   * Set styles to a d3 selection. Ignores unknown style keys.
   *
   * @param {d3Selector} select The d3 selector with the elements to change.
   * @param {object} styles Style object associated with a feature.
   */
  function setStyles(select, styles) {
    var key, k, f;
    /**
     * Check if the fill parameter is truthy.
     *
     * @returns {null|'none'} `null` to fill the element, `'none'` to skip
     *  filling it.
     */
    function fillFunc() {
      if (styles.fill.apply(m_this, arguments)) {
        return null;
      } else {
        return 'none';
      }
    }
    /**
     * Check if the stroke parameter is truthy.
     *
     * @returns {null|'none'} `null` to fill the element, `'none'` to skip
     *  filling it.
     */
    function strokeFunc() {
      if (styles.stroke.apply(m_this, arguments)) {
        return null;
      } else {
        return 'none';
      }
    }
    for (key in styles) {
      if (styles.hasOwnProperty(key)) {
        f = null;
        k = null;
        if (key === 'strokeColor') {
          k = 'stroke';
          f = m_this._convertColor(styles[key], styles.stroke);
        } else if (key === 'stroke' && styles[key] && !styles.hasOwnProperty('strokeColor')) {
          k = 'stroke';
          f = strokeFunc;
        } else if (key === 'strokeWidth') {
          k = 'stroke-width';
          f = m_this._convertScale(styles[key]);
        } else if (key === 'strokeOpacity') {
          k = 'stroke-opacity';
          f = styles[key];
        } else if (key === 'fillColor') {
          k = 'fill';
          f = m_this._convertColor(styles[key], styles.fill);
        } else if (key === 'fill' && !styles.hasOwnProperty('fillColor')) {
          k = 'fill';
          f = fillFunc;
        } else if (key === 'fillOpacity') {
          k = 'fill-opacity';
          f = styles[key];
        } else if (key === 'lineCap') {
          k = 'stroke-linecap';
          f = styles[key];
        } else if (key === 'lineJoin') {
          k = 'stroke-linejoin';
          f = styles[key];
        } else if (key === 'miterLimit') {
          k = 'stroke-miterlimit';
          f = styles[key];
        }
        if (k) {
          select.style(k, f);
        }
      }
    }
  }

  /**
   * Get the svg group element associated with this renderer instance, or of a
   * group within the render instance.
   *
   * @param {string} [parentId] Optional parent ID name.
   * @returns {d3Selector} Selector with the d3 group.
   */
  function getGroup(parentId) {
    if (parentId) {
      return m_svg.select('.group-' + parentId);
    }
    return m_svg.select('.group-' + m_this._svgid());
  }

  /**
   * Set the initial lat-lon coordinates of the map view.
   */
  function initCorners() {
    var layer = m_this.layer(),
      map = layer.map(),
      width = map.size().width,
      height = map.size().height;
    if (!width || !height) {
      throw new Error('Map layer has size 0');
    }
    m_this._setWidthHeight(width, height);
    m_diagonal = Math.pow(width * width + height * height, 0.5);
    m_corners = {
      upperLeft: map.displayToGcs({
        x: 0,
        y: 0
      }, null),
      lowerRight: map.displayToGcs({
        x: width,
        y: height
      }, null),
      center: map.displayToGcs({
        x: width / 2,
        y: height / 2
      }, null)
    };
  }

  /**
   * Set the translation, scale, and zoom for the current view.
   * @private
   */
  this._setTransform = function () {
    if (!m_corners) {
      initCorners();
    }
    if (!m_sticky) {
      return;
    }
    var layer = m_this.layer();
    var map = layer.map(),
      upperLeft = map.gcsToDisplay(m_corners.upperLeft, null),
      lowerRight = map.gcsToDisplay(m_corners.lowerRight, null),
      center = map.gcsToDisplay(m_corners.center, null),
      group = getGroup(),
      dx,
      dy,
      scale,
      rotation,
      rx,
      ry;
    scale = Math.sqrt(Math.pow(lowerRight.y - upperLeft.y, 2) + Math.pow(lowerRight.x - upperLeft.x, 2)) / m_diagonal;
    // calculate the translation
    rotation = map.rotation();
    rx = -m_this.width() / 2;
    ry = -m_this.height() / 2;
    dx = scale * rx + center.x;
    dy = scale * ry + center.y;

    // set the group transform property
    if (!rotation) {
      dx = Math.round(dx);
      dy = Math.round(dy);
    }
    var transform = 'matrix(' + [scale, 0, 0, scale, dx, dy].join() + ')';
    if (rotation) {
      transform += ' rotate(' + [rotation * 180 / Math.PI, -rx, -ry].join() + ')';
    }
    group.attr('transform', transform);

    // set internal variables
    m_scale = scale;
    m_transform.dx = dx;
    m_transform.dy = dy;
    m_transform.rx = rx;
    m_transform.ry = ry;
    m_transform.rotation = rotation;
  };

  /**
   * Convert from screen pixel coordinates to the local coordinate system
   * in the SVG group element taking into account the transform.
   *
   * @private
   * @param {geo.screenPosition} pt The coordinates to convert.
   * @returns {geo.geoPosition} The converted coordinates.
   */
  this.baseToLocal = function (pt) {
    pt = {
      x: (pt.x - m_transform.dx) / m_scale,
      y: (pt.y - m_transform.dy) / m_scale
    };
    if (m_transform.rotation) {
      var sinr = Math.sin(-m_transform.rotation),
        cosr = Math.cos(-m_transform.rotation);
      var x = pt.x + m_transform.rx,
        y = pt.y + m_transform.ry;
      pt = {
        x: x * cosr - y * sinr - m_transform.rx,
        y: x * sinr + y * cosr - m_transform.ry
      };
    }
    return pt;
  };

  /**
   * Convert from the local coordinate system in the SVG group element
   * to screen pixel coordinates.
   *
   * @private
   * @param {geo.geoPosition} pt The coordinates to convert.
   * @returns {geo.screenPosition} The converted coordinates.
   */
  this.localToBase = function (pt) {
    if (m_transform.rotation) {
      var sinr = Math.sin(m_transform.rotation),
        cosr = Math.cos(m_transform.rotation);
      var x = pt.x + m_transform.rx,
        y = pt.y + m_transform.ry;
      pt = {
        x: x * cosr - y * sinr - m_transform.rx,
        y: x * sinr + y * cosr - m_transform.ry
      };
    }
    pt = {
      x: pt.x * m_scale + m_transform.dx,
      y: pt.y * m_scale + m_transform.dy
    };
    return pt;
  };

  /**
   * Initialize.
   *
   * @param {object} arg The options used to create the renderer.
   * @param {boolean} [arg.widget] Set to `true` if this is a stand-alone
   *   widget.  If it is not a widget, svg elements are wrapped in a parent
   *   group.
   * @param {HTMLElement} [arg.d3Parent] If specified, the parent for any
   *   rendered objects; otherwise the renderer's layer's main node is used.
   * @returns {this}
   */
  this._init = function (arg) {
    if (!m_this.canvas()) {
      var canvas;
      arg.widget = arg.widget || false;
      if ('d3Parent' in arg) {
        m_svg = d3.select(arg.d3Parent).append('svg');
      } else {
        m_svg = d3.select(m_this.layer().node().get(0)).append('svg');
      }
      m_svg.attr('display', 'block');

      // create a global svg definitions element
      m_defs = m_svg.append('defs');
      var shadow = m_defs.append('filter').attr('id', 'geo-highlight').attr('x', '-100%').attr('y', '-100%').attr('width', '300%').attr('height', '300%');
      shadow.append('feMorphology').attr('operator', 'dilate').attr('radius', 2).attr('in', 'SourceAlpha').attr('result', 'dilateOut');
      shadow.append('feGaussianBlur').attr('stdDeviation', 5).attr('in', 'dilateOut').attr('result', 'blurOut');
      shadow.append('feColorMatrix').attr('type', 'matrix').attr('values', '-1 0 0 0 1  0 -1 0 0 1  0 0 -1 0 1  0 0 0 1 0').attr('in', 'blurOut').attr('result', 'invertOut');
      shadow.append('feBlend').attr('in', 'SourceGraphic').attr('in2', 'invertOut').attr('mode', 'normal');
      if (!arg.widget) {
        canvas = arg.canvas || m_svg.append('g');
      }
      shadow = m_defs.append('filter').attr('id', 'geo-blur').attr('x', '-100%').attr('y', '-100%').attr('width', '300%').attr('height', '300%');
      shadow.append('feGaussianBlur').attr('stdDeviation', 20).attr('in', 'SourceGraphic');
      m_sticky = m_this.layer().sticky();
      m_svg.attr('class', m_this._svgid());
      m_svg.attr('width', m_this.layer().node().width());
      m_svg.attr('height', m_this.layer().node().height());
      if (!arg.widget) {
        canvas.attr('class', 'group-' + m_this._svgid());
        m_this.canvas(canvas);
      } else {
        m_this.canvas(m_svg);
      }
    }
    m_this._setTransform();
    return m_this;
  };

  /**
   * Get API used by the renderer.
   *
   * @returns {string} 'svg'.
   */
  this.api = function () {
    return _svgRenderer.apiname;
  };

  /**
   * Return the current scaling factor to build features that shouldn't
   * change size during zooms.  For example:
   *
   *  selection.append('circle')
   *    .attr('r', r0 / renderer.scaleFactor());
   *
   * This will create a circle element with radius r0 independent of the
   * current zoom level.
   *
   * @returns {number} The current scale factor.
   */
  this.scaleFactor = function () {
    return m_scale;
  };

  /**
   * Handle resize event.
   *
   * @param {number} x Ignored.
   * @param {number} y Ignored.
   * @param {number} w New width in pixels.
   * @param {number} h New height in pixels.
   * @returns {this}
   * @fires geo.event.svg.rescale
   */
  this._resize = function (x, y, w, h) {
    if (!m_corners) {
      initCorners();
    }
    m_svg.attr('width', w);
    m_svg.attr('height', h);
    m_this._setTransform();
    m_this._setWidthHeight(w, h);
    m_this.layer().geoTrigger(svgRescale, {
      scale: m_scale
    }, true);
    return m_this;
  };

  /**
   * Exit.
   */
  this._exit = function () {
    m_features = {};
    m_this.canvas().remove();
    m_svg.remove();
    m_svg = undefined;
    m_defs.remove();
    m_defs = undefined;
    m_renderIds = {};
    m_removeIds = {};
    s_exit();
  };

  /**
   * Get the definitions DOM element for the layer.
   * @protected
   * @returns {HTMLElement} The definitions DOM element.
   */
  this._definitions = function () {
    return m_defs;
  };

  /**
   * Create a new feature element from an object that describes the feature
   * attributes.  To be called from feature classes only.
   *
   * @param {object} arg
   * @param {string} arg.id A unique string identifying the feature.
   * @param {array} arg.data Array of data objects used in a d3 data method.
   * @param {Function} [arg.dataIndex] A function that returns a unique id for
   *    each data element.  This is passed to the data access function.
   * @param {object} arg.style An object with style values or functions.
   * @param {object} arg.attributes An object containing element attributes.
   *    The keys are the attribute names, and the values are either constants
   *    or functions that get passed a data element and a data index.
   * @param {string[]} arg.classes An array of classes to add to the elements.
   * @param {string} arg.append The element type as used in d3 append methods.
   *    This is something like `'path'`, `'circle'`, or `'line'`.
   * @param {boolean} [arg.onlyRenderNew] If truthy, features only get
   *    attributes and styles set when new.  If falsy, features always have
   *    attributes and styles updated.
   * @param {boolean} [arg.sortByZ] If truthy, sort features by the `d.zIndex`.
   * @param {string} [arg.parentId] If set, the group ID of the parent element.
   * @returns {this}
   */
  this._drawFeatures = function (arg) {
    m_features[arg.id] = {
      data: arg.data,
      index: arg.dataIndex,
      style: arg.style,
      visible: arg.visible,
      attributes: arg.attributes,
      classes: arg.classes,
      append: arg.append,
      onlyRenderNew: arg.onlyRenderNew,
      sortByZ: arg.sortByZ,
      parentId: arg.parentId
    };
    return m_this.__render(arg.id, arg.parentId);
  };

  /**
   * Updates a feature by performing a d3 data join.  If no input id is
   * provided then this method will update all features.
   *
   * @param {string} [id] The id of the feature to update.  `undefined` to
   *    update all features.
   * @param {string} [parentId] The parent of the feature(s).  If not
   *    specified, features are rendered on the next animation frame.
   * @returns {this}
   */
  this.__render = function (id, parentId) {
    var key;
    if (id === undefined) {
      for (key in m_features) {
        if (m_features.hasOwnProperty(key)) {
          m_this.__render(key);
        }
      }
      return m_this;
    }
    if (parentId) {
      m_this._renderFeature(id, parentId);
    } else {
      m_renderIds[id] = true;
      m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame);
    }
    return m_this;
  };

  /**
   * Schedule an update in the next render frame.
   */
  this._scheduleUpdate = function () {
    m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame);
  };

  /**
   * Render all features that are marked as needing an update.  This should
   * only be called during an animation frame.
   */
  this._renderFrame = function () {
    var id;
    for (id in m_removeIds) {
      m_this.select(id).remove();
      m_defs.selectAll('.' + id).remove();
    }
    m_removeIds = {};
    var ids = m_renderIds;
    m_renderIds = {};
    for (id in ids) {
      if (ids.hasOwnProperty(id)) {
        m_this._renderFeature(id);
      }
    }
    for (id in m_features) {
      if (m_features.hasOwnProperty(id) && ids[id] === undefined) {
        m_this.select(id).attr('visibility', !m_features[id].visible || m_features[id].visible() ? 'visible' : 'hidden');
      }
    }
  };

  /**
   * Render a single feature.
   *
   * @param {string} id The id of the feature to update.
   * @param {string} [parentId] The parent of the feature.  This is used to
   *    select the feature.
   * @returns {this}
   */
  this._renderFeature = function (id, parentId) {
    if (!m_features[id]) {
      return m_this;
    }
    m_this.select(id).remove();
    var data = m_features[id].data,
      index = m_features[id].index,
      style = m_features[id].style,
      visible = m_features[id].visible,
      attributes = m_features[id].attributes,
      classes = m_features[id].classes,
      append = m_features[id].append,
      selection = m_this.select(id, parentId).data(data, index),
      entries,
      rendersel;
    entries = selection.enter().append(append);
    selection.exit().remove();
    // in d3 v3 this was
    // rendersel = m_features[id].onlyRenderNew ? entries : selection;
    rendersel = entries;
    setAttrs(rendersel, attributes);
    rendersel.attr('class', classes.concat([id]).join(' '));
    setStyles(rendersel, style);
    if (visible) {
      rendersel.attr('visibility', visible() ? 'visible' : 'hidden');
    }
    if (entries.size() && m_features[id].sortByZ) {
      selection.sort(function (a, b) {
        return (a.zIndex || 0) - (b.zIndex || 0);
      });
    }
    return m_this;
  };

  /**
   * Returns a d3 selection for the given feature id.
   *
   * @param {string} id The id of the feature to select.
   * @param {string} [parentId] The parent of the feature.  This is used to
   *    determine the feature's group.
   * @returns {d3Selector}
   */
  this.select = function (id, parentId) {
    return getGroup(parentId).selectAll('.' + id);
  };

  /**
   * Removes a feature from the layer.
   *
   * @param {string} id The id of the feature to remove.
   * @returns {this}
   */
  this._removeFeature = function (id) {
    m_removeIds[id] = true;
    m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame);
    delete m_features[id];
    if (m_renderIds[id]) {
      delete m_renderIds[id];
    }
    return m_this;
  };

  /**
   * Override draw method to do nothing.
   */
  this.draw = function () {};

  // connect to pan event
  this.layer().geoOn(geo_event.pan, m_this._setTransform);

  // connect to rotate event
  this.layer().geoOn(geo_event.rotate, m_this._setTransform);

  // connect to zoom event
  this.layer().geoOn(geo_event.zoom, function () {
    m_this._setTransform();
    m_this.__render();
    m_this.layer().geoTrigger(svgRescale, {
      scale: m_scale
    }, true);
  });
  this.layer().geoOn(geo_event.resize, function (event) {
    m_this._resize(event.x, event.y, event.width, event.height);
  });
  this._init(arg);
  return this;
};
_svgRenderer.apiname = 'svg';
inherit(_svgRenderer, renderer);
registerRenderer('svg', _svgRenderer);
// Also register under an alternate name (alias for backwards compatibility)
registerRenderer('d3', _svgRenderer);

/* Code for checking if the renderer is supported */

/**
 * Report if the d3 renderer is supported.  This is just a check if d3 is
 * available.
 *
 * @returns {boolean} true if available.
 */
_svgRenderer.supported = function () {
  delete _svgRenderer.d3;
  // webpack expects optional dependencies to be wrapped in a try-catch
  try {
    _svgRenderer.d3 = __webpack_require__(3893);
    if (!_svgRenderer.d3 || !_svgRenderer.d3.rgb) {
      _svgRenderer.d3 = undefined;
    }
  } catch (_error) {}
  return _svgRenderer.d3 !== undefined;
};

/**
 * If the d3 renderer is not supported, supply the name of a renderer that
 * should be used instead.  This asks for the null renderer.
 *
 * @returns {null} `null` for the null renderer.
 */
_svgRenderer.fallback = function () {
  return null;
};
_svgRenderer.supported(); // cache reference to d3 if it is available

module.exports = _svgRenderer;

/***/ }),

/***/ 4061:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var registerLayerAdjustment = (__webpack_require__(1098).registerLayerAdjustment);
var svg_tileLayer = function svg_tileLayer() {
  'use strict';

  var m_this = this,
    s_init = this._init,
    s_exit = this._exit,
    s_update = this._update,
    m_quadFeature,
    m_nextTileId = 0,
    m_tiles = [];
  this._drawTile = function (tile) {
    if (!m_quadFeature) {
      return;
    }
    var bounds = m_this._tileBounds(tile),
      level = tile.index.level || 0,
      to = m_this._tileOffset(level),
      quad = {};
    quad.ul = m_this.fromLocal(m_this.fromLevel({
      x: bounds.left - to.x,
      y: bounds.top - to.y
    }, level), 0);
    quad.ll = m_this.fromLocal(m_this.fromLevel({
      x: bounds.left - to.x,
      y: bounds.bottom - to.y
    }, level), 0);
    quad.ur = m_this.fromLocal(m_this.fromLevel({
      x: bounds.right - to.x,
      y: bounds.top - to.y
    }, level), 0);
    quad.lr = m_this.fromLocal(m_this.fromLevel({
      x: bounds.right - to.x,
      y: bounds.bottom - to.y
    }, level), 0);
    quad.ul.z = quad.ll.z = quad.ur.z = quad.lr.z = level;
    m_nextTileId += 1;
    quad.id = m_nextTileId;
    tile.quadId = quad.id;
    quad.image = tile.image;
    quad.reference = tile.toString();
    m_tiles.push(quad);
    m_quadFeature.data(m_tiles);
    m_quadFeature._update();
    m_this.draw();
  };

  /**
   * Remove the tile feature.
   *
   * @param {geo.tile} tile The tile to remove.
   */
  this._remove = function (tile) {
    if (tile.quadId !== undefined && m_quadFeature) {
      for (var i = 0; i < m_tiles.length; i += 1) {
        if (m_tiles[i].id === tile.quadId) {
          m_tiles.splice(i, 1);
          break;
        }
      }
      m_quadFeature.data(m_tiles);
      m_quadFeature._update();
      m_this.draw();
    }
  };

  /**
   * Update layer.
   *
   * @param {object} request A value to pass to the parent class.
   * @returns {this}
   */
  this._update = function (request) {
    s_update.call(m_this, request);
    m_this._addBaseQuadToTiles(m_quadFeature, m_tiles);
    return m_this;
  };

  /**
   * Clean up the layer.
   */
  this._exit = function () {
    m_this.deleteFeature(m_quadFeature);
    m_quadFeature = null;
    m_tiles = [];
    s_exit.apply(m_this, arguments);
  };

  /**
   * Initialize the tile layer.  This creates a series of sublayers so that
   * the different layers will stack in the proper order.
   */
  this._init = function () {
    s_init.apply(m_this, arguments);
    m_quadFeature = m_this.createFeature('quad', {
      previewColor: m_this._options.previewColor,
      previewImage: m_this._options.previewImage
    });
    m_quadFeature.geoTrigger = undefined;
    m_quadFeature.gcs(m_this._options.gcs || m_this.map().gcs());
    m_quadFeature.data(m_tiles);
    m_quadFeature._update();
  };
  this._getSubLayer = function () {};
  this._updateSubLayers = undefined;
};
registerLayerAdjustment('svg', 'tile', svg_tileLayer);
module.exports = svg_tileLayer;

/***/ }),

/***/ 2037:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var trackFeature = __webpack_require__(338);

/**
 * Create a new instance of class trackFeature.
 *
 * @class
 * @alias geo.svg.trackFeature
 * @extends geo.trackFeature
 * @param {geo.trackFeature.spec} arg
 * @returns {geo.svg.trackFeature}
 */
var _svg_trackFeature = function svg_trackFeature(arg) {
  'use strict';

  if (!(this instanceof _svg_trackFeature)) {
    return new _svg_trackFeature(arg);
  }
  arg = arg || {};
  trackFeature.call(this, arg);
  var object = __webpack_require__(5005);
  object.call(this);
  this._init(arg);
  return this;
};
inherit(_svg_trackFeature, trackFeature);

// Now register it
registerFeature('svg', 'track', _svg_trackFeature);
module.exports = _svg_trackFeature;

/***/ }),

/***/ 7376:
/***/ (function(module) {

var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz',
  strLength = 8;

/**
 * Get a random string to use as a div ID.
 *
 * @alias geo.svg.uniqueID
 * @returns {string} A random ID string.
 */
var uniqueID = function uniqueID() {
  var strArray = [],
    i;
  strArray.length = strLength;
  for (i = 0; i < strLength; i += 1) {
    strArray[i] = chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return strArray.join('');
};
module.exports = uniqueID;

/***/ }),

/***/ 5747:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var vectorFeature = __webpack_require__(6858);

/* These markers are available to all instances of the vectorFeature. */
var markerConfigs = {
  arrow: {
    attrs: {
      class: 'geo-vector-arrow geo-vector-marker',
      viewBox: '0 0 10 10',
      refX: 1,
      refY: 5,
      markerHeight: 5,
      markerWidth: 5,
      orient: 'auto'
    },
    path: 'M 0 0 L 10 5 L 0 10 z'
  },
  point: {
    attrs: {
      class: 'geo-vector-point geo-vector-marker',
      viewBox: '0 0 12 12',
      refX: 6,
      refY: 6,
      markerHeight: 8,
      markerWidth: 8,
      orient: 'auto'
    },
    path: 'M 6 3 A 3 3 0 1 1 5.99999 3 Z'
  },
  bar: {
    attrs: {
      class: 'geo-vector-bar geo-vector-marker',
      viewBox: '0 0 10 10',
      refX: 0,
      refY: 5,
      markerHeight: 6,
      markerWidth: 6,
      orient: 'auto'
    },
    path: 'M 0 0 L 2 0 L 2 10 L 0 10 z'
  },
  wedge: {
    attrs: {
      class: 'geo-vector-wedge geo-vector-marker',
      viewBox: '0 0 10 10',
      refX: 10,
      refY: 5,
      markerHeight: 5,
      markerWidth: 5,
      orient: 'auto'
    },
    path: 'M 0 0 L 1 0 L 10 5 L 1 10 L 0 10 L 9 5 L 0 0'
  }
};

/**
 * Create a new instance of svg.vectorFeature.
 *
 * @class
 * @alias geo.svg.vectorFeature
 * @extends geo.vectorFeature
 * @extends geo.svg.object
 * @param {geo.vectorFeature.spec} arg Feature options.
 * @returns {geo.vectorFeature}
 */
var _svg_vectorFeature = function svg_vectorFeature(arg) {
  'use strict';

  if (!(this instanceof _svg_vectorFeature)) {
    return new _svg_vectorFeature(arg);
  }
  var object = __webpack_require__(5005);
  var timestamp = __webpack_require__(77);
  var d3 = (__webpack_require__(2493).d3);
  arg = arg || {};
  vectorFeature.call(this, arg);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    s_update = this._update,
    m_buildTime = timestamp(),
    m_style = {};

  /**
   * Generate a unique ID for a marker definition.
   *
   * @param {object} d The marker datum (unused).
   * @param {number} i The marker index.
   * @param {string} position The marker's vector position (`'head'` or
   *   `'tail'`).
   * @returns {string} The constructed ID.
   */
  function markerID(d, i, position) {
    return m_this._svgid() + '_marker_' + i + '_' + position;
  }

  /**
   * Add marker styles for vector arrows.
   *
   * @param {object[]} data The vector data array.
   * @param {Function} stroke The stroke accessor.
   * @param {Function} opacity The opacity accessor.
   * @param {Function} originStyle The marker style for the vector head.
   * @param {Function} endStyle The marker style for the vector tail.
   */
  function updateMarkers(data, stroke, opacity, originStyle, endStyle) {
    //this allows for multiple vectorFeature in a layer
    var markerGroup = m_this.renderer()._definitions().selectAll('g.marker-group#' + m_this._svgid()).data(data.length ? [1] : []);
    markerGroup.enter().append('g').attr('id', m_this._svgid).attr('class', 'marker-group');
    markerGroup.exit().remove();
    var markers = data.reduce(function (markers, d, i) {
      var head = markerConfigs[endStyle(d, i)];
      var tail = markerConfigs[originStyle(d, i)];
      if (head) {
        markers.push({
          data: d,
          dataIndex: i,
          head: true
        });
      }
      if (tail) {
        markers.push({
          data: d,
          dataIndex: i,
          head: false
        });
      }
      return markers;
    }, []);
    markerGroup = m_this.renderer()._definitions().selectAll('g.marker-group#' + m_this._svgid());
    var sel = markerGroup.selectAll('marker.geo-vector-marker').data(markers);
    var renderer = m_this.renderer();
    sel.enter().append('marker').each(function (d) {
      var marker = d3.select(this);
      var markerData = d.head ? markerConfigs[endStyle(d.data, d.dataIndex)] : markerConfigs[originStyle(d.data, d.dataIndex)];
      Object.keys(markerData.attrs).forEach(function (attrName) {
        marker.attr(attrName, markerData.attrs[attrName]);
      });
    }).attr('id', function (d) {
      return markerID(d.data, d.dataIndex, d.head ? 'head' : 'tail');
    }).style('stroke', function (d) {
      return renderer._convertColor(stroke)(d.data, d.dataIndex);
    }).style('fill', function (d) {
      return renderer._convertColor(stroke)(d.data, d.dataIndex);
    }).style('opacity', function (d) {
      return opacity(d.data, d.dataIndex);
    }).append('path').attr('d', function (d) {
      return d.head ? markerConfigs[endStyle(d.data, d.dataIndex)].path : markerConfigs[originStyle(d.data, d.dataIndex)].path;
    });
    sel.exit().remove();
  }

  /**
   * Build.
   *
   * @returns {this}.
   */
  this._build = function () {
    var data = m_this.data(),
      s_style = m_this.style.get(),
      m_renderer = m_this.renderer(),
      orig_func = m_this.origin(),
      size_func = m_this.delta(),
      cache = [],
      scale = m_this.style('scale'),
      max = 0;

    // call super-method
    s_update.call(m_this);

    // default to empty data array
    if (!data) {
      data = [];
    }

    // cache the georeferencing
    cache = data.map(function (d, i) {
      var origin = m_this.featureGcsToDisplay(orig_func(d, i)),
        delta = size_func(d, i);
      max = Math.max(max, delta.x * delta.x + delta.y * delta.y);
      return {
        x1: origin.x,
        y1: origin.y,
        dx: delta.x,
        dy: -delta.y
      };
    });
    max = Math.sqrt(max);
    if (!scale) {
      scale = 75 / (max ? max : 1);
    }
    function getScale() {
      return scale / m_renderer.scaleFactor();
    }

    // fill in svg renderer style object defaults
    m_style.id = m_this._svgid();
    m_style.data = data;
    m_style.append = 'line';
    m_style.attributes = {
      x1: function x1(d, i) {
        return cache[i].x1;
      },
      y1: function y1(d, i) {
        return cache[i].y1;
      },
      x2: function x2(d, i) {
        return cache[i].x1 + getScale() * cache[i].dx;
      },
      y2: function y2(d, i) {
        return cache[i].y1 + getScale() * cache[i].dy;
      },
      'marker-start': function markerStart(d, i) {
        return 'url(#' + markerID(d, i, 'tail') + ')';
      },
      'marker-end': function markerEnd(d, i) {
        return 'url(#' + markerID(d, i, 'head') + ')';
      }
    };
    m_style.style = {
      stroke: function stroke() {
        return true;
      },
      strokeColor: s_style.strokeColor,
      strokeWidth: s_style.strokeWidth,
      strokeOpacity: s_style.strokeOpacity,
      originStyle: s_style.originStyle,
      endStyle: s_style.endStyle
    };
    m_style.classes = ['svgVectorFeature'];
    m_style.visible = m_this.visible;

    // Add markers to the definition list
    updateMarkers(data, s_style.strokeColor, s_style.strokeOpacity, s_style.originStyle, s_style.endStyle);

    // pass to renderer to draw
    m_this.renderer()._drawFeatures(m_style);

    // update time stamps
    m_buildTime.modified();
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Update.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.timestamp() >= m_buildTime.timestamp()) {
      m_this._build();
    } else {
      updateMarkers(m_style.data, m_style.style.strokeColor, m_style.style.strokeOpacity, m_style.style.originStyle, m_style.style.endStyle);
    }
    return m_this;
  };

  /**
   * Exit.  Remove markers.
   */
  this._exit = function () {
    s_exit.call(m_this);
    m_style = {};
    updateMarkers([], null, null, null, null);
  };
  this._init(arg);
  return this;
};
_svg_vectorFeature.markerConfigs = markerConfigs;
inherit(_svg_vectorFeature, vectorFeature);

// Now register it
registerFeature('svg', 'vector', _svg_vectorFeature);
module.exports = _svg_vectorFeature;

/***/ }),

/***/ 6546:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);

/**
 * Object specification for a text feature.
 *
 * @typedef {geo.feature.spec} geo.textFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition[]|Function} [position] The position of each data
 *   element.  Defaults to the `x`, `y`, and `z` properties of the data
 *   element.
 * @property {string[]|Function} [text] The text of each data element.
 *   Defaults to the `text` property of the data element.
 * @property {geo.textFeature.styleSpec} [style] The style to apply to each
 *   data element.
 */

/**
 * Style specification for a text feature.
 *
 * @typedef {geo.feature.styleSpec} geo.textFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {boolean|Function} [visible=true] If falsy, don't show this data
 *    element.
 * @property {string|Function} [font] A css font specification.  This is of the
 *    form `[style] [variant] [weight] [stretch] size[/line-height] family`.
 *    Individual font styles override this value if a style is specified in
 *    each.  See the individual font styles for details.
 * @property {string|Function} [fontStyle='normal'] The font style.  One of
 *    `normal`, `italic`, or `oblique`.
 * @property {string|Function} [fontVariant='normal'] The font variant.  This
 *    can have values such as `small-caps` or `slashed-zero`.
 * @property {string|Function} [fontWeight='normal'] The font weight.  This may
 *    be a numeric value where 400 is normal and 700 is bold, or a string such
 *    as `bold` or `lighter`.
 * @property {string|Function} [fontStretch='normal'] The font stretch, such as
 *    `condensed`.
 * @property {string|Function} [fontSize='medium'] The font size.
 * @property {string|Function} [lineHeight='normal'] The font line height.
 * @property {string|Function} [fontFamily] The font family.
 * @property {string|Function} [textAlign='center'] The horizontal text
 *    alignment.  One of `start`, `end`, `left`, `right`, or `center`.
 * @property {string|Function} [textBaseline='middle'] The vertical text
 *    alignment.  One of `top`, `hanging`, `middle`, `alphabetic`,
 *    `ideographic`, or `bottom`.
 * @property {geo.geoColor|Function} [color='black'] Text color.  May include
 *    opacity.
 * @property {number|Function} [textOpacity=1] The opacity of the text.  If the
 *    color includes opacity, this is combined with that value.
 * @property {number|Function} [rotation=0] Text rotation in radians.
 * @property {boolean|Function} [rotateWithMap=false] If truthy, rotate the
 *    text when the map rotates.  Otherwise, the text is always in the same
 *    orientation.
 * @property {number|Function} [textScaled] If defined, the text is scaled when
 *    the map zooms and this is the basis zoom for the fontSize.
 * @property {geo.screenPosition|Function} [offset] Offset from the default
 *    position for the text.  This is applied before rotation.
 * @property {geo.geoColor|Function} [shadowColor='black'] Text shadow color.
 *    May include opacity.
 * @property {geo.screenPosition|Function} [shadowOffset] Offset for a text
 *    shadow.  This is applied before rotation.
 * @property {number|null|Function} [shadowBlur] If not null, add a text shadow
 *    with this much blur.
 * @property {boolean|Function} [shadowRotate=false] If truthy, rotate the
 *    shadow offset based on the text rotation (the `shadowOffset` is the
 *    offset if the text has a 0 rotation).
 * @property {geo.geoColor|Function} [textStrokeColor='transparent'] Text
 *    stroke color.  May include opacity.
 * @property {geo.geoColor|Function} [textStrokeWidth=0] Text stroke width in
 *    pixels.
 * @property {number|Function} [renderThreshold] If this is a positive number,
 *    text elements may not be rendered if their base position (before offset
 *    and font effects are applied) is more than this distance in pixels
 *    outside of the current viewport.  If it is known that such text elements
 *    cannot affect the current viewport, setting this can speed up rendering.
 *    This is computed once for the whole feature.
 */

/**
 * Create a new instance of class textFeature.
 *
 * @class
 * @alias geo.textFeature
 * @extends geo.feature
 *
 * @param {geo.textFeature.spec} [arg] Options for the feature.
 * @returns {geo.textFeature} The created feature.
 */
var _textFeature = function textFeature(arg) {
  'use strict';

  if (!(this instanceof _textFeature)) {
    return new _textFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init;
  this.featureType = 'text';

  /**
   * Get/Set position.
   *
   * @param {array|Function} [val] If `undefined`, return the current position
   *    setting.  Otherwise, modify the current position setting.
   * @returns {array|Function|this} The current position or this feature.
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else if (val !== m_this.style('position')) {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set text.
   *
   * @param {array|Function} [val] If `undefined`, return the current text
   *    setting.  Otherwise, modify the current text setting.
   * @returns {array|Function|this} The current text or this feature.
   */
  this.text = function (val) {
    if (val === undefined) {
      return m_this.style('text');
    } else if (val !== m_this.style('text')) {
      m_this.style('text', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.textFeature.spec} [arg] The feature specification.
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var style = Object.assign({}, {
      font: 'bold 16px sans-serif',
      textAlign: 'center',
      textBaseline: 'middle',
      color: {
        r: 0,
        g: 0,
        b: 0
      },
      rotation: 0,
      /* in radians */
      rotateWithMap: false,
      textScaled: false,
      position: function position(d) {
        return Array.isArray(d) ? {
          x: d[0],
          y: d[1],
          z: d[2] || 0
        } : d;
      },
      text: function text(d) {
        return d.text;
      }
    }, arg.style === undefined ? {} : arg.style);
    if (arg.position !== undefined) {
      style.position = arg.position;
    }
    if (arg.text !== undefined) {
      style.text = arg.text;
    }
    m_this.style(style);
    if (style.position) {
      m_this.position(style.position);
    }
    if (style.text) {
      m_this.text(style.text);
    }
    m_this.dataTime().modified();
  };
  this._init(arg);
  return m_this;
};
_textFeature.usedStyles = ['visible', 'font', 'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'lineHeight', 'fontFamily', 'textAlign', 'textBaseline', 'color', 'textOpacity', 'rotation', 'rotateWithMap', 'textScaled', 'offset', 'shadowColor', 'shadowOffset', 'shadowBlur', 'shadowRotate', 'textStrokeColor', 'textStrokeWidth'];

/**
 * Create a textFeature from an object.
 * @see {@link geo.feature.create}
 * @param {geo.layer} layer The layer to add the feature to
 * @param {geo.textFeature.spec} spec The object specification
 * @returns {geo.textFeature|null}
 */
_textFeature.create = function (layer, spec) {
  'use strict';

  spec = spec || {};
  spec.type = 'text';
  return feature.create(layer, spec);
};
_textFeature.capabilities = {
  /* core feature name -- support in any manner */
  feature: 'text'
};
inherit(_textFeature, feature);
module.exports = _textFeature;

/***/ }),

/***/ 5289:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);

/**
 * @typedef {object} geo.tile.spec
 *
 * @property {object} index The global position of the tile.
 * @property {number} index.x The x-coordinate (usually the column number).
 * @property {number} index.y The y-coordinate (usually the row number).
 * @property {object} size The size of each tile.
 * @property {number} size.x Width (usually in pixels).
 * @property {number} size.y Height (usually in pixels).
 * @property {object|string} url A url or jQuery ajax config object.
 * @property {object} [overlap] The size of overlap with neighboring tiles.
 * @property {number} [overlap.x=0] Overlap in the x direction.
 * @property {number} [overlap.y=0] Overlap in the y direction.
 */

/**
 * This class defines the raw interface for a "tile" on a map.  A tile is
 * defined as a quadrilateral section of a map.  The base implementation is
 * independent of the actual content of the tile, but assumes that the content
 * is loaded asynchronously via a url.  The tile object has a promise-like
 * interface.
 * @example
 * tile.then(function (data) {...}).catch(function (data) {...});
 *
 * @class
 * @alias geo.tile
 * @param {geo.tile.spec} spec The tile specification.
 * @returns {geo.tile}
 */
var _tile = function tile(spec) {
  if (!(this instanceof _tile)) {
    return new _tile(spec);
  }
  this._index = spec.index;
  this._size = spec.size;
  this._overlap = spec.overlap || {
    x: 0,
    y: 0
  };
  this._wrap = spec.wrap || {
    x: 1,
    y: 1
  };
  this._url = spec.url;
  this._fetched = false;
  this._queue = spec.queue || null;

  /**
   * Return the index coordinates.  Read only.
   *
   * @property {object} index The tile index.
   * @property {number} index.x The tile x index.
   * @property {number} index.y The tile y index.
   * @property {number} [index.level] The tile level index.
   * @property {number} [index.reference] The tile reference index.
   * @name geo.tile#index
   */
  Object.defineProperty(this, 'index', {
    get: function get() {
      return this._index;
    }
  });

  /**
   * Return the tile size.  Read only.
   *
   * @property {object} size The tile size.
   * @property {number} size.x The tile width.
   * @property {number} size.y The tile height.
   * @name geo.tile#size
   */
  Object.defineProperty(this, 'size', {
    get: function get() {
      return this._size;
    }
  });

  /**
   * Return the tile overlap.  Read only.
   *
   * @property {object} overlap The tile overlap.
   * @property {number} overlap.x The tile x overlap.
   * @property {number} overlap.y The tile y overlap.
   * @name geo.tile#overlap
   */
  Object.defineProperty(this, 'overlap', {
    get: function get() {
      return this._overlap;
    }
  });

  /**
   * Initiate the ajax request and add a promise interface to the tile
   * object.  This method exists to allow derived classes the ability to
   * override how the tile is obtained.  For example, imageTile uses an
   * Image element rather than $.get.
   *
   * @returns {this}
   */
  this.fetch = function () {
    if (!this._fetched) {
      $.get(this._url).done(function () {
        this._fetched = true;
      }.bind(this)).promise(this);
    }
    return this;
  };

  /**
   * Return whether this tile has been fetched already.
   *
   * @returns {boolean} True if the tile has been fetched.
   */
  this.fetched = function () {
    return this._fetched;
  };

  /**
   * Add a method to be called with the data when the ajax request is
   * successfully resolved.
   *
   * @param {function?} onSuccess The success handler.
   * @param {function?} onFailure The failure handler.
   * @returns {this}
   */
  this.then = function (onSuccess, onFailure) {
    // both fetch and _queueAdd can replace the current then method
    if (!this.fetched() && this._queue && this._queue.add && (!this.state || this.state() === 'pending')) {
      this._queue.add(this, this.fetch);
    } else {
      this.fetch();
    }
    // Call then on the new promise
    if (this.done && this.fail) {
      this.done(onSuccess).fail(onFailure);
    } else {
      this.then(onSuccess, onFailure);
    }
    return this;
  };

  /**
   * Add a method to be called with the data when the ajax fails.
   *
   * @param {Function} method The rejection handler.
   * @returns {this}
   */
  this.catch = function (method) {
    this.then(undefined, method);
    return this;
  };

  /**
   * Return a unique string representation of the given tile usable as a hash
   * key.  Possibly extend later to include url information to make caches
   * aware of the tile source.
   *
   * @returns {string}
   */
  this.toString = function () {
    return [this._index.level || 0, this._index.y, this._index.x, this._index.reference || 0].join('_');
  };

  /**
   * Return the bounds of the tile given an index offset and a translation.
   *
   * @param {object} index The tile index containing (0, 0).
   * @param {object} shift The coordinates of (0, 0) inside the tile.
   * @returns {object} An object with `left`, `top`, `right`, `bottom`.
   */
  this.bounds = function (index, shift) {
    var left, right, bottom, top;
    left = this.size.x * (this.index.x - index.x) - this.overlap.x - shift.x;
    right = left + this.size.x + this.overlap.x * 2;
    top = this.size.y * (this.index.y - index.y) - this.overlap.y - shift.y;
    bottom = top + this.size.y + this.overlap.y * 2;
    if (this.overlap.x && this.index.x === index.x) {
      left += this.overlap.x;
    }
    if (this.overlap.y && this.index.y === index.y) {
      top += this.overlap.y;
    }
    return {
      left: left,
      right: right,
      bottom: bottom,
      top: top
    };
  };

  /**
   * Computes the global coordinates of the bottom edge.
   * @property {number} bottom The global coordinates of the bottom edge.
   * @name geo.tile#bottom
   */
  Object.defineProperty(this, 'bottom', {
    get: function get() {
      return this.size.y * (this.index.y + 1) + this.overlap.y;
    }
  });

  /**
   * Computes the global coordinates of the top edge.
   * @property {number} top The global coordinates of the top edge.
   * @name geo.tile#top
   */
  Object.defineProperty(this, 'top', {
    get: function get() {
      return this.size.y * this.index.y - (this.index.y ? this.overlap.y : 0);
    }
  });

  /**
   * Computes the global coordinates of the left edge.
   * @property {number} left The global coordinates of the left edge.
   * @name geo.tile#left
   */
  Object.defineProperty(this, 'left', {
    get: function get() {
      return this.size.x * this.index.x - (this.index.x ? this.overlap.x : 0);
    }
  });

  /**
   * Computes the global coordinates of the right edge.
   * @property {number} right The global coordinates of the right edge.
   * @name geo.tile#right
   */
  Object.defineProperty(this, 'right', {
    get: function get() {
      return this.size.x * (this.index.x + 1) + this.overlap.x;
    }
  });

  /**
   * Set the opacity of the tile to 0 and gradually fade in over the given
   * number of milliseconds.  This is just a delay.
   *
   * @param {number} duration The duration of the animation in ms.
   * @returns {this}
   */
  this.fadeIn = function (duration) {
    $.noop(duration);
    return this;
  };
};
module.exports = _tile;

/***/ }),

/***/ 9123:
/***/ (function(module) {

/**
 * This class implements a simple cache for tile objects.  Each tile is
 * stored in cache object keyed by a configurable hashing function.  Another
 * array keeps track of last access times for each tile to purge old tiles
 * once the maximum cache size is reached.
 *
 * @class
 * @alias geo.tileCache
 *
 * @param {object} [options] A configuration object for the cache.
 * @param {number} [options.size] The maximum number of tiles to store.
 */
var _tileCache = function tileCache(options) {
  if (!(this instanceof _tileCache)) {
    return new _tileCache(options);
  }
  options = options || {};
  this._size = options.size || 64;

  /**
   * Get/set the maximum cache size.
   * @property {number} size The maximum cache size.
   * @name geo.tileCache#size
   */
  Object.defineProperty(this, 'size', {
    get: function get() {
      return this._size;
    },
    set: function set(n) {
      while (this._atime.length > n) {
        this.remove(this._atime[this._atime.length - 1]);
      }
      this._size = n;
    }
  });

  /**
   * Get the current cache size.  Read only.
   * @property {number} length The current cache size.
   * @name geo.tileCache#length
   */
  Object.defineProperty(this, 'length', {
    get: function get() {
      return this._atime.length;
    }
  });

  /**
   * Get the position of the tile in the access queue.
   *
   * @param {string} hash The tile's hash value.
   * @returns {number} The position in the queue or -1.
   */
  this._access = function (hash) {
    return this._atime.indexOf(hash);
  };

  /**
   * Remove a tile from the cache.
   *
   * @param {string|geo.tile} tile The tile or its hash.
   * @returns {boolean} `true` if a tile was removed.
   */
  this.remove = function (tile) {
    var hash = typeof tile === 'string' ? tile : tile.toString();

    // if the tile is not in the cache
    if (!(hash in this._cache)) {
      return false;
    }

    // Remove the tile from the access queue
    this._atime.splice(this._access(hash), 1);

    // Remove the tile from the cache
    delete this._cache[hash];
    return true;
  };

  /**
   * Remove all tiles from the cache.
   *
   * @returns {this}
   */
  this.clear = function () {
    this._cache = {}; // The hash -> tile mapping
    this._atime = []; // The access queue (the hashes are stored)
    return this;
  };

  /**
   * Get a tile from the cache if it exists, otherwise return `null`.  This
   * method also moves the tile to the front of the access queue.
   *
   * @param {string|geo.tile} hash The tile or the tile hash value.
   * @param {boolean} [noMove] If truthy, don't move the tile to the front of
   *   the access queue.
   * @returns {geo.tile|null}
   */
  this.get = function (hash, noMove) {
    hash = typeof hash === 'string' ? hash : hash.toString();
    if (!(hash in this._cache)) {
      return null;
    }
    if (!noMove) {
      this._atime.splice(this._access(hash), 1);
      this._atime.unshift(hash);
    }
    return this._cache[hash];
  };

  /**
   * Add a tile to the cache.
   *
   * @param {geo.tile} tile The tile to add.
   * @param {Function} removeFunc If specified and tiles must be purged from
   *      the cache, call this function on each tile before purging.
   * @param {boolean} noPurge if true, don't purge tiles.
   */
  this.add = function (tile, removeFunc, noPurge) {
    // remove any existing tiles with the same hash
    this.remove(tile);
    var hash = tile.toString();

    // add the tile
    this._cache[hash] = tile;
    this._atime.unshift(hash);
    if (!noPurge) {
      this.purge(removeFunc);
    }
  };

  /**
   * Purge tiles from the cache if it is full.
   *
   * @param {Function} removeFunc If specified and tiles must be purged from
   *      the cache, call this function on each tile before purging.
   */
  this.purge = function (removeFunc) {
    var hash;
    while (this._atime.length > this.size) {
      hash = this._atime.pop();
      var tile = this._cache[hash];
      if (removeFunc) {
        removeFunc(tile);
      }
      delete this._cache[hash];
    }
  };
  this.clear();
  return this;
};
module.exports = _tileCache;

/***/ }),

/***/ 9264:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var featureLayer = __webpack_require__(6498);
var util = __webpack_require__(642);

/**
 * Object specification for a tile layer.
 *
 * @typedef {geo.layer.spec} geo.tileLayer.spec
 * @extends {geo.layer.spec}
 * @property {number} [minLevel=0] The minimum zoom level available.
 * @property {number} [maxLevel=18] The maximum zoom level available.
 * @property {object} [tileOverlap] Pixel overlap between tiles.
 * @property {number} [tileOverlap.x] Horizontal overlap.
 * @property {number} [tileOverlap.y] Vertical overlap.
 * @property {number} [tileWidth=256] The tile width without overlap.
 * @property {number} [tileHeight=256] The tile height without overlap.
 * @property {Function} [tilesAtZoom=null] A function that is given a zoom
 *   level and returns `{x: (num), y: (num)}` with the number of tiles at that
 *   zoom level.
 * @property {number} [cacheSize=600] The maximum number of tiles to cache.
 *   The default is 200 if keepLower is false.
 * @property {geo.fetchQueue} [queue] A fetch queue to use.  If unspecified, a
 *   new queue is created.
 * @property {number} [queueSize=6] The queue size.  Most browsers make at most
 *   6 requests to any domain, so this should be no more than 6 times the
 *   number of subdomains used.
 * @property {number} [initialQueueSize=0] The initial queue size.  `0` to use
 *   the queue size.  When querying a tile server that needs to load
 *   information before serving the first tile, having an initial queue size of
 *   1 can reduce the load on the tile server.  After the initial queue of
 *   tiles are loaded, the `queueSize` is used for all additional queries
 *   unless the `initialQueueSize` is set again or the tile cache is reset.
 * @property {boolean} [keepLower=true] When truthy, keep lower zoom level
 *   tiles when showing high zoom level tiles.  This uses more memory but
 *   results in smoother transitions.
 * @property {boolean} [wrapX=true] Wrap in the x-direction.
 * @property {boolean} [wrapY=false] Wrap in the y-direction.
 * @property {string|Function} [url=null] A function taking the current tile
 *   indices `(x, y, level, subdomains)` and returning a URL or jquery ajax
 *   config to be passed to the {geo.tile} constructor.  Example:
 *   ```
 *   (x, y, z, subdomains) => "http://example.com/z/y/x.png"
 *   ```
 *   If this is a string, a template url with {x}, {y}, {z}, and {s} as
 *   template variables.  {s} picks one of the subdomains parameter and may
 *   contain a comma-separated list of subdomains.
 * @property {string|string[]} [subdomains="abc"] Subdomains to use in template
 *   url strings.  If a string, this is converted to a list before being passed
 *   to a url function.
 * @property {string} [baseUrl=null]  If defined, use the old-style base url
 *   instead of the url parameter.  This is functionally the same as using a
 *   url of `baseUrl/{z}/{x}/{y}.(imageFormat || png)`.  If the specified
 *   string does not end in a slash, one is added.
 * @property {string} [imageFormat='png'] This is only used if a `baseUrl` is
 *   specified, in which case it determines the image name extension used in
 *   the url.
 * @property {number} [animationDuration=0] The number of milliseconds for the
 *   tile loading animation to occur.  Only some renderers support this.
 * @property {string} [attribution] An attribution to display with the layer
 *   (accepts HTML).
 * @property {Function} [tileRounding=Math.round] This function determines
 *   which tiles will be loaded when the map is at a non-integer zoom.  For
 *   example, `Math.floor`, will use tile level 2 when the map is at zoom 2.9.
 * @property {Function} [tileOffset] This function takes a zoom level argument
 *   and returns, in units of pixels, the coordinates of the point (0, 0) at
 *   the given zoom level relative to the bottom left corner of the domain.
 * @property {Function} [tilesMaxBounds=null] This function takes a zoom level
 *   argument and returns an object with `x` and `y` in pixels which is used to
 *   crop the last row and column of tiles.  Note that if tiles wrap, only
 *   complete tiles in the wrapping direction(s) are supported, and this max
 *   bounds will probably not behave properly.
 * @property {boolean} [topDown=false]  True if the gcs is top-down, false if
 *   bottom-up (the ingcs does not matter, only the gcs coordinate system).
 *   When falsy, this inverts the gcs y-coordinate when calculating local
 *   coordinates.
 * @property {string} [idleAfter='view'] Consider the layer as idle once a
 *   specific set of tiles is loaded.  'view' is when all tiles in view are
 *   loaded.  'all' is when tiles in view and tiles that were once requested
 *   have been loaded (this corresponds to having all network activity
 *   finished).
 * @property {object} [baseQuad] A quad feature element to draw before below
 *   any tile layers.  If specified, this uses the quad defaults, so this is a
 *   ``geo.quadFeature.position`` object with, typically, an ``image`` property
 *   added to it.  The quad positions are in the map gcs coordinates.
 * @property {boolean|number} [nearestPixel] If true, image quads are
 *   rendered with near-neighbor sampling.  If false, with interpolated
 *   sampling.  If a number, interpolate at that zoom level or below and
 *   nearest neighbor at that zoom level or above.
 */

/**
 * Standard modulo operator where the output is in [0, b) for all inputs.
 * @private
 * @param {number} a Any finite number.
 * @param {number} b A positive number.
 * @returns {number} The positive version of `a % b`.
 */
function modulo(a, b) {
  return (a % b + b) % b;
}

/**
 * Pick a subdomain from a list of subdomains based on a the tile location.
 *
 * @private
 * @param {number} x The x tile coordinate.
 * @param {number} y The y tile coordinate.
 * @param {number} z The tile layer.
 * @param {string[]} subdomains The list of known subdomains.
 * @returns {string} A subdomain based on the location.
 */
function m_getTileSubdomain(x, y, z, subdomains) {
  return subdomains[modulo(x + y + z, subdomains.length)];
}

/**
 * Returns an OSM tile server formatting function from a standard format
 * string. Replaces `{s}`, `{z}`, `{x}`, and `{y}`.  These may be any case
 * and may be prefixed with `$` (e.g., `${X}` is the same as `{x}`).  The
 * subdomain can be specified by a string of characters, listed as a range,
 * or as a comma-separated list (e.g., `{s:abc}`, `{a-c}`, `{a,b,c}` are
 * all equivalent.  The comma-separated list can have subdomains that are of
 * any length; the string and range both use one-character subdomains.
 *
 * @private
 * @param {string} base The tile format string
 * @returns {Function} A conversion function.
 */
function m_tileUrlFromTemplate(base) {
  var xPattern = /\$?\{[xX]\}/g,
    yPattern = /\$?\{[yY]\}/g,
    zPattern = /\$?\{[zZ]\}/g,
    sPattern = /\$?\{(s|S|[sS]:[^{}]+|[^-{}]-[^-{}]|([^,{}]+,)+[^,{}]+)\}/;
  var url = base.replace(new RegExp(sPattern, 'g'), '{s}').replace(xPattern, '{x}').replace(yPattern, '{y}').replace(zPattern, '{z}');
  var urlSubdomains;
  var sMatch = base.match(sPattern);
  if (sMatch) {
    if (sMatch[2]) {
      urlSubdomains = sMatch[1].split(',');
    } else if (sMatch[1][1] === ':') {
      urlSubdomains = sMatch[1].substr(2).split('');
    } else if (sMatch[1][1] === '-') {
      urlSubdomains = [];
      var start = sMatch[1].charCodeAt(0),
        end = sMatch[1].charCodeAt(2);
      for (var i = Math.min(start, end); i <= Math.max(start, end); i += 1) {
        urlSubdomains.push(String.fromCharCode(i));
      }
    }
  }
  return function (x, y, z, subdomains) {
    return url.replace(/\{s\}/g, m_getTileSubdomain(x, y, z, urlSubdomains || subdomains)).replace(/\{x\}/g, x).replace(/\{y\}/g, y).replace(/\{z\}/g, z);
  };
}

/**
 * This method defines a tileLayer, an abstract class defining a layer
 * divided into tiles of arbitrary data.  Notably, this class provides the
 * core functionality of {@link geo.osmLayer}, but hooks exist to render
 * tiles more generically.  When multiple zoom levels are present in a given
 * dataset, this class assumes that the space occupied by tile `(i, j)` at
 * level `z` is covered by a 2x2 grid of tiles at zoom level `z + 1`:
 * ```
 *   (2i, 2j),     (2i, 2j + 1)
 *   (2i + 1, 2j), (2i + 1, 2j + 1)
 * ```
 * The higher level tile set should represent a 2x increase in resolution.
 *
 * @class
 * @alias geo.tileLayer
 * @extends geo.featureLayer
 * @param {geo.tileLayer.spec} [arg] Specification for the layer.
 * @returns {geo.tileLayer}
 */
var _tileLayer = function tileLayer(arg) {
  'use strict';

  if (!(this instanceof _tileLayer)) {
    return new _tileLayer(arg);
  }
  featureLayer.call(this, arg);
  var $ = __webpack_require__(5616);
  var geo_event = __webpack_require__(6409);
  var transform = __webpack_require__(5325);
  var tileCache = __webpack_require__(9123);
  var fetchQueue = __webpack_require__(5938);
  var adjustLayerForRenderer = (__webpack_require__(1098).adjustLayerForRenderer);
  var Tile = __webpack_require__(5289);
  arg = util.deepMerge({}, this.constructor.defaults, arg || {});
  if (!arg.cacheSize) {
    // this size should be sufficient for a 4k display
    // where display size is (w, h), minimum tile dimension is ts, and total
    // number of levels is ml, this is roughly
    // sum([(math.ceil((w**2+h**2)**0.5 / (ts*2**l)) + 1) *
    //      (math.ceil(min(w, h) / (ts*2**l)) + 1) for l in range(ml)])
    arg.cacheSize = arg.keepLower ? 600 : 200;
  }
  if ($.type(arg.subdomains) === 'string') {
    arg.subdomains = arg.subdomains.split('');
  }
  /* We used to call the url option baseUrl.  If a baseUrl is specified, use
   * it instead of url, interpreting it as before. */
  if (arg.baseUrl) {
    var url = arg.baseUrl;
    if (url && url.charAt(url.length - 1) !== '/') {
      url += '/';
    }
    arg.url = url + '{z}/{x}/{y}.' + (arg.imageFormat || 'png');
  }
  /* Save the original url so that we can return it if asked */
  arg.originalUrl = arg.url;
  if ($.type(arg.url) === 'string') {
    arg.url = m_tileUrlFromTemplate(arg.url);
  }
  var s_init = this._init,
    s_exit = this._exit,
    s_visible = this.visible,
    m_queueSize = arg.queueSize || 6,
    m_initialQueueSize = arg.initialQueueSize || 0,
    m_lastTileSet = [],
    m_promisedTiles = {},
    m_maxBounds = [],
    m_reference,
    m_exited,
    m_lastBaseQuad,
    m_nearestPixel = arg.nearestPixel,
    m_this = this;

  // copy the options into a private variable
  this._options = util.deepMerge({}, arg);

  // set the layer attribution text
  this.attribution(arg.attribution);

  // initialize the object that keeps track of actively drawn tiles
  this._activeTiles = {};

  // initialize the object that stores active tile regions in a
  // tree-like structure providing quick queries to determine
  // if tiles are completely obscured or not.
  this._tileTree = {};

  // initialize the in memory tile cache
  this._cache = tileCache({
    size: arg.cacheSize
  });

  // initialize the tile fetch queue
  this._queue = arg.queue || fetchQueue({
    // this should probably be 6 * subdomains.length if subdomains are used
    size: m_queueSize,
    initialSize: m_initialQueueSize,
    // if track is the same as the cache size, then neither processing time
    // nor memory will be wasted.  Larger values will use more memory,
    // smaller values will do needless computations.
    track: arg.cacheSize,
    needed: function needed(tile) {
      if (this._tileLayers && this._tileLayers.length) {
        return this._tileLayers.some(function (tl) {
          return tile === tl.cache.get(tile.toString(), true);
        });
      }
      return tile === m_this.cache.get(tile.toString(), true);
    }
  });
  this._queue._tileLayers = this._queue._tileLayers || [];
  this._queue._tileLayers.push(m_this);
  if (this._queue.initialTrack && this._queue.track) {
    this._queue.track = this._queue.initialTrack * this._queue._tileLayers.length;
  }
  var m_tileOffsetValues = {};

  /**
   * Readonly accessor to the options object.
   * @property {object} options A copy of the options object.
   * @name geo.tileLayer#options
   */
  Object.defineProperty(this, 'options', {
    get: function get() {
      return Object.assign({}, m_this._options);
    }
  });

  /**
   * Readonly accessor to the tile cache object.
   * @property {geo.tileCache} cache The tile cache object.
   * @name geo.tileLayer#cache
   */
  Object.defineProperty(this, 'cache', {
    get: function get() {
      return m_this._cache;
    }
  });

  /**
   * Readonly accessor to the active tile mapping.  This is an object
   * containing all currently drawn tiles (hash(tile) => tile).
   *
   * @property {object} activeTiles The keys are `hash(tile)` and the values
   *    are tiles.
   * @name geo.tileLayer#activeTiles
   */
  Object.defineProperty(this, 'activeTiles', {
    get: function get() {
      return Object.assign({}, m_this._activeTiles); // copy on output
    }
  });

  /**
   * Get/set the queue object.
   * @property {geo.fetchQueue} queue The current queue.
   * @name geo.tileLayer#queue
   */
  Object.defineProperty(this, 'queue', {
    get: function get() {
      return m_this._queue;
    },
    set: function set(queue) {
      /* The queue's needed function determines if a tile is still needed. A
       * tile in the queue is needed if it is needed by at least one layer that
       * is using it.  _tileLayers tracks the layers that share the queue to
       * allow walking through the layers and check if any layer needs a tile.
       * When the queue is set, maintain the list of joined tile layers. */
      if (m_this._queue !== queue) {
        if (this._queue && this._queue._tileLayers && this._queue._tileLayers.indexOf(m_this) >= 0) {
          this._queue._tileLayers.splice(this._queue._tileLayers.indexOf(m_this), 1);
          if (this._queue.initialTrack && this._queue.track && this._queue._tileLayers.length) {
            this._queue.track = this._queue.initialTrack * this._queue._tileLayers.length;
          }
        }
        m_this._queue = queue;
        m_this._queue._tileLayers = m_this._queue._tileLayers || [];
        m_this._queue._tileLayers.push(m_this);
        if (m_this._queue.initialTrack && m_this._queue.track) {
          m_this._queue.track = m_this._queue.initialTrack * m_this._queue._tileLayers.length;
        }
      }
    }
  });

  /**
   * Get/set the queue size.
   * @property {number} size The queue size.
   * @name geo.tileLayer#queueSize
   */
  Object.defineProperty(this, 'queueSize', {
    get: function get() {
      return m_queueSize;
    },
    set: function set(n) {
      m_queueSize = n;
      m_this._queue.size = n;
    }
  });

  /**
   * Get/set the initial queue size.
   * @property {number} size The initial queue size.  `0` to use the queue
   *    size.
   * @name geo.tileLayer#queueSize
   */
  Object.defineProperty(this, 'initialQueueSize', {
    get: function get() {
      return m_initialQueueSize;
    },
    set: function set(n) {
      m_initialQueueSize = n || 0;
      m_this._queue.initialSize = n || m_queueSize;
    }
  });

  /**
   * Get/set the tile reference value.
   * @property {string} reference A reference value to distinguish tiles on
   *    this layer.
   * @name geo.tileLayer#reference
   */
  Object.defineProperty(this, 'reference', {
    get: function get() {
      return '' + m_this.id() + '_' + (m_reference || 0);
    },
    set: function set(reference) {
      m_reference = reference;
    },
    configurable: true
  });

  /**
   * The number of tiles at the given zoom level.  The default implementation
   * just returns `Math.pow(2, z)`.
   *
   * @param {number} level A zoom level.
   * @returns {object} The number of tiles in each axis in the form
   *     `{x: nx, y: ny}`.
   */
  this.tilesAtZoom = function (level) {
    if (m_this._options.tilesAtZoom) {
      return m_this._options.tilesAtZoom.call(m_this, level);
    }
    var s = Math.pow(2, level);
    return {
      x: s,
      y: s
    };
  };

  /**
   * The maximum tile bounds at the given zoom level, or null if no special
   * tile bounds.
   *
   * @param {number} level A zoom level.
   * @returns {object} The maximum tile bounds in pixels for the specified
   *    level, or null if none specified (`{x: width, y: height}`).
   */
  this.tilesMaxBounds = function (level) {
    if (m_this._options.tilesMaxBounds) {
      return m_this._options.tilesMaxBounds.call(m_this, level);
    }
    return null;
  };

  /**
   * Get the crop values for a tile based on the tilesMaxBounds function.
   * Returns undefined if the tile should not be cropped.
   *
   * @param {object} tile The tile to compute crop values for.
   * @returns {object?} Either `undefined` or an object with `x` and `y` values
   *      which is the size in pixels for the tile.
   */
  this.tileCropFromBounds = function (tile) {
    if (!m_this._options.tilesMaxBounds) {
      return undefined;
    }
    var level = tile.index.level,
      bounds = m_this._tileBounds(tile);
    if (m_maxBounds[level] === undefined) {
      m_maxBounds[level] = m_this.tilesMaxBounds(level) || null;
    }
    if (m_maxBounds[level] && (bounds.right > m_maxBounds[level].x || bounds.bottom > m_maxBounds[level].y)) {
      return {
        x: Math.max(0, Math.min(m_maxBounds[level].x, bounds.right) - bounds.left),
        y: Math.max(0, Math.min(m_maxBounds[level].y, bounds.bottom) - bounds.top)
      };
    }
    return undefined;
  };

  /**
   * Returns `true` if the given tile index is valid:
   * - min level <= level <= max level
   * - 0 <= x <= 2^level - 1
   * - 0 <= y <= 2^level - 1
   * If the layer wraps, the x and y values may be allowed to extend beyond
   * these values.
   *
   * @param {object} index The tile index.
   * @param {number} index.x
   * @param {number} index.y
   * @param {number} index.level
   * @returns {boolean}
   */
  this.isValid = function (index) {
    if (!(m_this._options.minLevel <= index.level && index.level <= m_this._options.maxLevel)) {
      return false;
    }
    if (!(m_this._options.wrapX || 0 <= index.x && index.x <= m_this.tilesAtZoom(index.level).x - 1)) {
      return false;
    }
    if (!(m_this._options.wrapY || 0 <= index.y && index.y <= m_this.tilesAtZoom(index.level).y - 1)) {
      return false;
    }
    return true;
  };

  /**
   * Returns the current origin tile and offset at the given zoom level.
   * This is intended to be cached in the future to optimize coordinate
   * transformations.
   *
   * @protected
   * @param {number} level The target zoom level.
   * @returns {object} The origin and offset in the form
   *   `{index: {x, y}, offset: {x, y}}`.
   */
  this._origin = function (level) {
    var origin = m_this.toLevel(m_this.toLocal(m_this.map().origin()), level),
      o = m_this._options,
      index,
      offset;

    // get the tile index
    index = {
      x: Math.floor(origin.x / o.tileWidth),
      y: Math.floor(origin.y / o.tileHeight)
    };

    // get the offset inside the tile (in pixels)
    // This computation should contain the only numerically unstable
    // subtraction in this class.  All other methods will assume
    // coordinates are given relative to the map origin.
    offset = {
      x: origin.x - o.tileWidth * index.x,
      y: origin.y - o.tileHeight * index.y
    };
    return {
      index: index,
      offset: offset
    };
  };

  /**
   * Returns a tile's bounds in its level coordinates.
   *
   * @param {geo.tile} tile The tile to check.
   * @returns {object} The tile's bounds with `left`, `top`, `right`,
   *   `bottom`.
   */
  this._tileBounds = function (tile) {
    var origin = m_this._origin(tile.index.level);
    return tile.bounds(origin.index, origin.offset);
  };

  /**
   * Returns the tile indices at the given point.
   *
   * @param {object} point The coordinates in pixels relative to the map
   *   origin.
   * @param {number} point.x
   * @param {number} point.y
   * @param {number} level The target zoom level.
   * @returns {object} The tile indices.  This has `x` and `y` properties.
   */
  this.tileAtPoint = function (point, level) {
    var o = m_this._origin(level);
    var map = m_this.map();
    point = m_this.displayToLevel(map.gcsToDisplay(point, null), level);
    if (isNaN(point.x)) {
      point.x = 0;
    }
    if (isNaN(point.y)) {
      point.y = 0;
    }
    var to = m_this._tileOffset(level);
    if (to) {
      point.x += to.x;
      point.y += to.y;
    }
    var tile = {
      x: Math.floor(o.index.x + (o.offset.x + point.x) / m_this._options.tileWidth),
      y: Math.floor(o.index.y + (o.offset.y + point.y) / m_this._options.tileHeight)
    };
    return tile;
  };

  /**
   * Returns a tile's bounds in a gcs.
   *
   * @param {object|geo.tile} indexOrTile Either a tile or an object with
   *    {x, y, level}` specifying a tile.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the
   *    interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {object} The tile bounds in the specified gcs.
   */
  this.gcsTileBounds = function (indexOrTile, gcs) {
    var tile = indexOrTile.index ? indexOrTile : Tile({
      index: indexOrTile,
      size: {
        x: m_this._options.tileWidth,
        y: m_this._options.tileHeight
      },
      url: ''
    });
    var to = m_this._tileOffset(tile.index.level),
      bounds = tile.bounds({
        x: 0,
        y: 0
      }, to),
      map = m_this.map(),
      unit = map.unitsPerPixel(tile.index.level);
    var coord = [{
      x: bounds.left * unit,
      y: m_this._topDown() * bounds.top * unit
    }, {
      x: bounds.right * unit,
      y: m_this._topDown() * bounds.bottom * unit
    }];
    gcs = gcs === null ? map.gcs() : gcs === undefined ? map.ingcs() : gcs;
    if (gcs !== map.gcs()) {
      coord = transform.transformCoordinates(map.gcs(), gcs, coord);
    }
    return {
      left: coord[0].x,
      top: coord[0].y,
      right: coord[1].x,
      bottom: coord[1].y
    };
  };

  /**
   * Returns an instantiated tile object with the given indices.  This
   * method always returns a new tile object.  Use `_getTileCached`
   * to use the caching layer.
   *
   * @param {object} index The tile index.
   * @param {number} index.x
   * @param {number} index.y
   * @param {number} index.level
   * @param {object} source The tile index used for constructing the url.
   * @param {number} source.x
   * @param {number} source.y
   * @param {number} source.level
   * @returns {geo.tile}
   */
  this._getTile = function (index, source) {
    var urlParams = source || index;
    return Tile({
      index: index,
      size: {
        x: m_this._options.tileWidth,
        y: m_this._options.tileHeight
      },
      queue: m_this._queue,
      url: m_this._options.url.call(m_this, urlParams.x, urlParams.y, Math.max(urlParams.level || 0, Math.min(0, m_this._options.minLevel || 0)), m_this._options.subdomains)
    });
  };

  /**
   * Returns an instantiated tile object with the given indices.  This
   * method is similar to `_getTile`, but checks the cache before
   * generating a new tile.
   *
   * @param {object} index The tile index.
   * @param {number} index.x
   * @param {number} index.y
   * @param {number} index.level
   * @param {object} source The tile index used for constructing the url.
   * @param {number} source.x
   * @param {number} source.y
   * @param {number} source.level
   * @param {boolean} delayPurge If true, don't purge tiles from the cache.
   * @returns {geo.tile}
   */
  this._getTileCached = function (index, source, delayPurge) {
    var tile = m_this.cache.get(m_this._tileHash(index));
    if (tile === null) {
      tile = m_this._getTile(index, source);
      m_this.cache.add(tile, m_this.remove, delayPurge);
    }
    return tile;
  };

  /**
   * Returns a string representation of the tile at the given index.
   *
   * Note: This method **must** return the same string as:
   * ```
   *   tile({index: index}).toString();
   * ```
   * This method is used as a hashing function for the caching layer.
   *
   * @param {object} index The tile index
   * @param {number} index.x
   * @param {number} index.y
   * @param {number} [index.level]
   * @param {number} [index.reference]
   * @returns {string}
   */
  this._tileHash = function (index) {
    return [index.level || 0, index.y, index.x, index.reference || 0].join('_');
  };

  /**
   * Returns the optimal starting and ending tile indices (inclusive)
   * necessary to fill the given viewport.
   *
   * @param {number} level The zoom level
   * @param {geo.geoBounds} bounds The map bounds in world coordinates.
   * @returns {object} The tile range with a `start`  and `end` record, each
   *      with `x` and `y` tile indices.
   */
  this._getTileRange = function (level, bounds) {
    var corners = [m_this.tileAtPoint({
      x: bounds.left,
      y: bounds.top
    }, level), m_this.tileAtPoint({
      x: bounds.right,
      y: bounds.top
    }, level), m_this.tileAtPoint({
      x: bounds.left,
      y: bounds.bottom
    }, level), m_this.tileAtPoint({
      x: bounds.right,
      y: bounds.bottom
    }, level)];
    return {
      start: {
        x: Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
        y: Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
      },
      end: {
        x: Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x),
        y: Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y)
      }
    };
  };

  /**
   * Returns a list of tiles necessary to fill the screen at the given
   * zoom level, center point, and viewport size.  The list is optionally
   * ordered by loading priority (center tiles first).
   *
   * @protected
   * @param {number} maxLevel The zoom level
   * @param {geo.geoBounds} bounds The map bounds
   * @param {boolean} sorted Return a sorted list
   * @param {boolean} [onlyIfChanged] If the set of tiles have not changed
   *     (even if their desired order has), return undefined instead of an
   *     array of tiles.
   * @returns {geo.tile[]?} An array of tile objects
   */
  this._getTiles = function (maxLevel, bounds, sorted, onlyIfChanged) {
    var i,
      j,
      tiles = [],
      index,
      nTilesLevel,
      start,
      end,
      indexRange,
      source,
      center,
      changed = false,
      old,
      level,
      minLevel = m_this._options.keepLower ? m_this._options.minLevel : Math.min(Math.max(maxLevel, m_this._options.minLevel), m_this._options.maxLevel);
    if (maxLevel < minLevel) {
      maxLevel = minLevel;
    }

    /* Generate a list of the tiles that we want to create.  This is done
     * before sorting, because we want to actually generate the tiles in
     * the sort order. */
    for (level = minLevel; level <= maxLevel; level += 1) {
      // get the tile range to fetch
      indexRange = m_this._getTileRange(level, bounds);
      start = indexRange.start;
      end = indexRange.end;
      // total number of tiles existing at m_this level
      nTilesLevel = m_this.tilesAtZoom(level);
      if (!m_this._options.wrapX) {
        if (start.x >= nTilesLevel.x || end.x < 0) {
          continue;
        }
        start.x = Math.min(Math.max(start.x, 0), nTilesLevel.x - 1);
        end.x = Math.min(Math.max(end.x, 0), nTilesLevel.x - 1);
        if (level === minLevel && m_this._options.keepLower) {
          start.x = 0;
          end.x = nTilesLevel.x - 1;
        }
      }
      if (!m_this._options.wrapY) {
        if (start.y > nTilesLevel.y || end.y < 0) {
          continue;
        }
        start.y = Math.min(Math.max(start.y, 0), nTilesLevel.y - 1);
        end.y = Math.min(Math.max(end.y, 0), nTilesLevel.y - 1);
        if (level === minLevel && m_this._options.keepLower) {
          start.y = 0;
          end.y = nTilesLevel.y - 1;
        }
      }
      /* If we are reprojecting tiles, we need a check to not use all levels
       * if the number of tiles is excessive. */
      if (m_this._options.gcs && m_this._options.gcs !== m_this.map().gcs() && level !== minLevel && (end.x + 1 - start.x) * (end.y + 1 - start.y) > m_this.map().size().width * m_this.map().size().height / m_this._options.tileWidth / m_this._options.tileHeight * 16) {
        break;
      }

      // loop over the tile range
      for (i = start.x; i <= end.x; i += 1) {
        for (j = start.y; j <= end.y; j += 1) {
          index = {
            level: level,
            x: i,
            y: j,
            reference: m_this.reference
          };
          source = {
            level: level,
            x: i,
            y: j,
            reference: m_this.reference
          };
          if (m_this._options.wrapX) {
            source.x = modulo(source.x, nTilesLevel.x);
          }
          if (m_this._options.wrapY) {
            source.y = modulo(source.y, nTilesLevel.y);
          }
          if (m_this.isValid(source)) {
            if (onlyIfChanged && tiles.length < m_lastTileSet.length) {
              old = m_lastTileSet[tiles.length];
              changed = changed || index.level !== old.level || index.x !== old.x || index.y !== old.y;
            }
            tiles.push({
              index: index,
              source: source
            });
          }
        }
      }
    }
    if (onlyIfChanged) {
      if (!changed && tiles.length === m_lastTileSet.length) {
        return undefined;
      }
      m_lastTileSet.splice(0, m_lastTileSet.length);
      $.each(tiles, function (idx, tile) {
        m_lastTileSet.push(tile.index);
      });
    }
    if (sorted) {
      center = {
        x: (start.x + end.x) / 2,
        y: (start.y + end.y) / 2,
        level: maxLevel,
        bottomLevel: maxLevel
      };
      var numTiles = Math.max(end.x - start.x, end.y - start.y) + 1;
      for (; numTiles >= 1; numTiles /= 2) {
        center.bottomLevel -= 1;
      }
      tiles.sort(m_this._loadMetric(center));
      /* If we are using a fetch queue, start a new batch */
      if (m_this._queue) {
        m_this._queue.batch(true);
      }
    }
    if (m_this.cache.size < tiles.length) {
      console.log('Increasing cache size to ' + tiles.length); // eslint-disable-line no-console
      m_this.cache.size = tiles.length;
    }
    /* Actually get the tiles. */
    for (i = 0; i < tiles.length; i += 1) {
      tiles[i] = m_this._getTileCached(tiles[i].index, tiles[i].source, true);
    }
    m_this.cache.purge(m_this.remove);
    return tiles;
  };

  /**
   * Get or set the layer gcs.  This defaults to the map's gcs.
   *
   * @param {string} [arg] If `undefined`, return the current gcs.  Otherwise,
   *    a new value for the gcs.  If `null`, use the map's gcs.
   * @returns {string|this} A string used by {@link geo.transform}.
   */
  this.gcs = function (arg) {
    if (arg === undefined) {
      return m_this._options.gcs || m_this.map().gcs();
    }
    var previous = m_this.gcs();
    if (arg === null) {
      delete m_this._options.gcs;
    } else {
      m_this._options.gcs = arg;
    }
    if (m_this.gcs() !== previous) {
      m_this.clear();
      m_this.gcsFeatures(m_this.gcs());
      m_this.modified();
      m_this._update();
    }
    return m_this;
  };

  /**
   * Prefetches tiles up to a given zoom level around a given bounding box.
   *
   * @param {number} level The zoom level.
   * @param {geo.geoBounds} bounds The map bounds.
   * @returns {jQuery.Deferred} resolves when all of the tiles are fetched.
   */
  this.prefetch = function (level, bounds) {
    var tiles;
    tiles = m_this._getTiles(level, bounds, true);
    return $.when.apply($, tiles.map(function (tile) {
      return tile.fetch();
    }));
  };

  /**
   * This method returns a metric that determines tile loading order.  The
   * default implementation prioritizes tiles that are closer to the center,
   * or at a lower zoom level.
   *
   * @protected
   * @param {object} center The center tile.
   * @param {number} center.x
   * @param {number} center.y
   * @returns {Function} A function accepted by `Array.prototype.sort`.
   */
  this._loadMetric = function (center) {
    return function (a, b) {
      var a0, b0, dx, dy, cx, cy, scale;
      a = a.index || a;
      b = b.index || b;
      // shortcut if zoom level differs
      if (a.level !== b.level) {
        if (center.bottomLevel && a.level >= center.bottomLevel !== b.level >= center.bottomLevel) {
          return a.level >= center.bottomLevel ? -1 : 1;
        }
        return a.level - b.level;
      }

      /* compute the center coordinates relative to a.level.  Since we really
       * care about the center of the tiles, use an offset */
      scale = Math.pow(2, a.level - center.level);
      cx = (center.x + 0.5) * scale - 0.5;
      cy = (center.y + 0.5) * scale - 0.5;

      // calculate distances to the center squared
      dx = a.x - cx;
      dy = a.y - cy;
      a0 = dx * dx + dy * dy;
      dx = b.x - cx;
      dy = b.y - cy;
      b0 = dx * dx + dy * dy;

      // return negative if a < b, or positive if a > b
      return a0 - b0;
    };
  };

  /**
   * Convert a coordinate from pixel coordinates at the given zoom
   * level to world coordinates.
   *
   * @param {object} coord
   * @param {number} coord.x The offset in pixels (level 0) from the left
   *      edge.
   * @param {number} coord.y The offset in pixels (level 0) from the bottom
   *      edge.
   * @param {number} level The zoom level of the source coordinates.
   * @returns {object} World coordinates with `x` and `y`.
   */
  this.fromLevel = function (coord, level) {
    var s = Math.pow(2, -level);
    return {
      x: coord.x * s,
      y: coord.y * s
    };
  };

  /**
   * Convert a coordinate from layer coordinates to pixel coordinates at the
   * given zoom level.
   *
   * @param {object} coord
   * @param {number} coord.x The offset in pixels (level 0) from the left
   *      edge.
   * @param {number} coord.y The offset in pixels (level 0) from the bottom
   *      edge.
   * @param {number} level The zoom level of the new coordinates.
   * @returns {object} The pixel coordinates with `x` and `y`.
   */
  this.toLevel = function (coord, level) {
    var s = Math.pow(2, level);
    return {
      x: coord.x * s,
      y: coord.y * s
    };
  };

  /**
   * Draw the given tile on the active canvas
   *.
   * @param {geo.tile} tile The tile to draw.
   */
  this.drawTile = function (tile) {
    var hash = tile.toString();
    if (m_this._activeTiles.hasOwnProperty(hash)) {
      // the tile is already drawn, move it to the top
      m_this._moveToTop(tile);
    } else {
      // pass to the rendering implementation
      m_this._drawTile(tile);
    }

    // add the tile to the active cache
    m_this._activeTiles[hash] = tile;
  };

  /**
   * Render the tile on the canvas.  This implementation draws the tiles
   * directly on the DOM using <img> tags.  Derived classes should override
   * this method to draw the tile on a renderer specific context.
   *
   * @protected
   * @param {geo.tile} tile The tile to draw.
   */
  this._drawTile = function (tile) {
    // Make sure this method is not called when there is
    // a renderer attached.
    if (m_this.renderer() !== null) {
      throw new Error('This draw method is not valid on renderer managed layers.');
    }

    // get the layer node
    var level = tile.index.level,
      div = $(m_this._getSubLayer(level)),
      bounds = m_this._tileBounds(tile),
      duration = m_this._options.animationDuration,
      container = $('<div class="geo-tile-container"/>').attr('tile-reference', tile.toString()),
      crop;

    // apply a transform to place the image correctly
    container.append(tile.image);
    container.css({
      left: bounds.left - parseInt(div.attr('offsetx') || 0, 10) + 'px',
      top: bounds.top - parseInt(div.attr('offsety') || 0, 10) + 'px'
    });
    crop = m_this.tileCropFromBounds(tile);
    if (crop) {
      container.addClass('crop').css({
        width: crop.x + 'px',
        height: crop.y + 'px'
      });
    }

    // apply fade in animation
    if (duration > 0) {
      tile.fadeIn(duration);
    }

    // append the image element
    div.append(container);

    // add an error handler
    tile.catch(function () {
      // May want to do something special here later
      console.warn('Could not load tile at ' + tile.toString()); // eslint-disable-line no-console
      m_this._remove(tile);
    });
  };

  /**
   * Remove the given tile from the canvas and the active cache.
   *
   * @param {geo.tile|string} tile The tile (or hash) to remove.
   * @returns {geo.tile} The tile removed from the active layer.
   */
  this.remove = function (tile) {
    var hash = tile.toString();
    var value = m_this._activeTiles[hash];
    if (value instanceof Tile) {
      m_this._remove(value);
    }
    delete m_this._activeTiles[hash];
    if (m_lastTileSet && tile.index) {
      var index = tile.index;
      for (var idx = m_lastTileSet.length - 1; idx >= 0; idx -= 1) {
        var lastTile = m_lastTileSet[idx];
        if (lastTile.level === index.level && lastTile.x === index.x && lastTile.y === index.y && lastTile.reference === index.reference) {
          m_lastTileSet.splice(idx, 1);
          break;
        }
      }
    }
    return value;
  };

  /**
   * Remove the given tile from the canvas.  This implementation just
   * finds and removes the <img> element created for the tile.
   *
   * @param {geo.tile|string} tile The tile object to remove.
   */
  this._remove = function (tile) {
    if (tile.image) {
      if (tile.image.parentElement) {
        $(tile.image.parentElement).remove();
      } else {
        /* This shouldn't happen, but sometimes does.  Originally it happened
         * when a tile was removed from the cache before it was finished
         * being used; there is still some much rarer condition that can
         * cause it.  Log that it happened until we can figure out how to fix
         * the issue. */
        console.log('No parent element to remove ' + tile.toString(), tile); // eslint-disable-line no-console
      }
      $(tile.image).remove();
    }
  };

  /**
   * Move the given tile to the top on the canvas.
   *
   * @param {geo.tile} tile The tile object to move.
   */
  this._moveToTop = function (tile) {
    $.noop(tile);
  };

  /**
   * Query the attached map for the current bounds and return them as pixels
   *      at the current zoom level.
   *
   * @returns {object} Bounds object with `left`, `right`, `top`, `bottom`,
   *      `scale`, and `level` keys.
   */
  this._getViewBounds = function () {
    var map = m_this.map(),
      mapZoom = map.zoom(),
      zoom = m_this._options.tileRounding(mapZoom),
      scale = Math.pow(2, mapZoom - zoom),
      size = map.size();
    var ul = m_this.displayToLevel({
        x: 0,
        y: 0
      }),
      ur = m_this.displayToLevel({
        x: size.width,
        y: 0
      }),
      ll = m_this.displayToLevel({
        x: 0,
        y: size.height
      }),
      lr = m_this.displayToLevel({
        x: size.width,
        y: size.height
      });
    return {
      level: zoom,
      scale: scale,
      left: Math.min(ul.x, ur.x, ll.x, lr.x),
      right: Math.max(ul.x, ur.x, ll.x, lr.x),
      top: Math.min(ul.y, ur.y, ll.y, lr.y),
      bottom: Math.max(ul.y, ur.y, ll.y, lr.y)
    };
  };

  /**
   * Remove all inactive tiles from the display.  An inactive tile is one
   * that is no longer visible either because it was panned out of the active
   * view or the zoom has changed.
   *
   * @protected
   * @param {number} zoom Tiles in bounds at this zoom level will be kept.
   * @param {boolean} doneLoading If true, allow purging additional tiles.
   * @param {geo.geoBounds} bounds View bounds.  If not specified, this is
   *   obtained from _getViewBounds().
   * @returns {this}
   */
  this._purge = function (zoom, doneLoading, bounds) {
    var tile, hash;

    // Don't purge tiles in an active update
    if (m_this._updating) {
      return m_this;
    }

    // get the view bounds
    if (!bounds) {
      bounds = m_this._getViewBounds();
    }
    for (hash in m_this._activeTiles) {
      tile = m_this._activeTiles[hash];
      if (m_this._canPurge(tile, bounds, zoom, doneLoading)) {
        m_this.remove(tile);
      }
    }
    return m_this;
  };

  /**
   * Remove all active tiles from the canvas.
   *
   * @returns {geo.tile[]} The array of tiles removed.
   */
  this.clear = function () {
    var tiles = [],
      tile;

    // ignoring the warning here because m_this is a privately
    // controlled object with simple keys
    for (tile in m_this._activeTiles) {
      tiles.push(m_this.remove(tile));
    }

    // clear out the tile coverage tree
    m_this._tileTree = {};
    m_lastTileSet = [];
    return tiles;
  };

  /**
   * Reset the layer to the initial state, clearing the canvas and resetting
   * the tile cache.
   *
   * @returns {this}
   */
  this.reset = function () {
    m_this.clear();
    m_this._cache.clear();
    m_this._queue.initialSize = m_initialQueueSize;
    return m_this;
  };

  /**
   * Compute local coordinates from the given world coordinates.  The tile
   * layer uses units of pixels relative to the world space coordinate
   * origin.
   *
   * @param {object} pt A point in world space coordinates with `x` and `y`.
   * @param {number} [zoom] If unspecified, use the map zoom.
   * @returns {object} Local coordinates with `x` and `y`.
   */
  this.toLocal = function (pt, zoom) {
    var map = m_this.map(),
      unit = map.unitsPerPixel(zoom === undefined ? map.zoom() : zoom);
    return {
      x: pt.x / unit,
      y: m_this._topDown() * pt.y / unit
    };
  };

  /**
   * Compute world coordinates from the given local coordinates.  The tile
   * layer uses units of pixels relative to the world space coordinate
   * origin.
   *
   * @param {object} pt A point in world space coordinates with `x` and `y`.
   * @param {number|undefined} zoom If unspecified, use the map zoom.
   * @returns {object} Local coordinates with `x` and `y`.
   */
  this.fromLocal = function (pt, zoom) {
    // these need to always use the *layer* unitsPerPixel, or possibly
    // convert tile space using a transform
    var map = m_this.map(),
      unit = map.unitsPerPixel(zoom === undefined ? map.zoom() : zoom);
    return {
      x: pt.x * unit,
      y: m_this._topDown() * pt.y * unit
    };
  };

  /**
   * Return a factor for inverting the y units as appropriate.
   *
   * @returns {number} Either 1 to not invert y, or -1 to invert it.
   */
  this._topDown = function () {
    return m_this._options.topDown ? 1 : -1;
  };

  /**
   * Return the DOM element containing a level specific layer.  This will
   * create the element if it doesn't already exist.
   *
   * @param {number} level The zoom level of the layer to fetch.
   * @returns {HTMLElement?} The layer's DOM element.
   */
  this._getSubLayer = function (level) {
    if (!m_this.canvas()) {
      return undefined;
    }
    var node = m_this.canvas().find('div[data-tile-layer=' + level.toFixed() + ']').get(0);
    if (!node) {
      node = $('<div class=geo-tile-layer data-tile-layer="' + level.toFixed() + '"/>').get(0);
      m_this.canvas().append(node);
    }
    return node;
  };

  /**
   * Set sublayer transforms to align them with the given zoom level.
   *
   * @param {number} level The target zoom level.
   * @param {geo.geoBounds} view The view bounds.  The top and left are used
   *      to adjust the offset of tile layers.
   * @returns {object} The `x` and `y` offsets for the current level.
   */
  this._updateSubLayers = function (level, view) {
    var canvas = m_this.canvas(),
      lastlevel = parseInt(canvas.attr('lastlevel'), 10),
      lastx = parseInt(canvas.attr('lastoffsetx') || 0, 10),
      lasty = parseInt(canvas.attr('lastoffsety') || 0, 10);
    if (lastlevel === level && Math.abs(lastx - view.left) < 65536 && Math.abs(lasty - view.top) < 65536) {
      return {
        x: lastx,
        y: lasty
      };
    }
    var map = m_this.map(),
      to = m_this._tileOffset(level),
      x = parseInt((view.left + view.right - map.size().width) / 2 + to.x, 10),
      y = parseInt((view.top + view.bottom - map.size().height) / 2 + to.y, 10);
    canvas.find('.geo-tile-layer').each(function (idx, el) {
      var $el = $(el),
        layer = parseInt($el.data('tileLayer'), 10);
      $el.css('transform', 'scale(' + Math.pow(2, level - layer) + ')');
      var layerx = parseInt(x / Math.pow(2, level - layer), 10),
        layery = parseInt(y / Math.pow(2, level - layer), 10),
        dx = layerx - parseInt($el.attr('offsetx') || 0, 10),
        dy = layery - parseInt($el.attr('offsety') || 0, 10);
      $el.attr({
        offsetx: layerx,
        offsety: layery
      });
      $el.find('.geo-tile-container').each(function (tileidx, tileel) {
        $(tileel).css({
          left: parseInt($(tileel).css('left'), 10) - dx + 'px',
          top: parseInt($(tileel).css('top'), 10) - dy + 'px'
        });
      });
    });
    canvas.attr({
      lastoffsetx: x,
      lastoffsety: y,
      lastlevel: level
    });
    return {
      x: x,
      y: y
    };
  };

  /**
   * Update the view according to the map/camera.
   *
   * @param {geo.event} evt The event that triggered the change.  Zoom and
   *      rotate events do nothing, since they are always followed by a pan
   *      event which will cause appropriate action.
   * @returns {this}
   */
  this._update = function (evt) {
    /* Ignore zoom and rotate events, as they are ALWAYS followed by a pan
     * event */
    if (evt && evt.event && (evt.event.event === geo_event.zoom || evt.event.event === geo_event.rotate)) {
      return m_this;
    }
    if (!m_this.visible()) {
      return m_this;
    }
    var map = m_this.map(),
      bounds = map.bounds(undefined, null),
      mapZoom = map.zoom(),
      zoom = m_this._options.tileRounding(mapZoom),
      tiles;
    if (m_this._updateSubLayers) {
      var view = m_this._getViewBounds();
      // Update the transform for the local layer coordinates
      var offset = m_this._updateSubLayers(zoom, view) || {
        x: 0,
        y: 0
      };
      var to = m_this._tileOffset(zoom);
      if (m_this.renderer() === null) {
        var scale = Math.pow(2, mapZoom - zoom),
          rotation = map.rotation(),
          rx = -to.x + -(view.left + view.right) / 2 + offset.x,
          ry = -to.y + -(view.bottom + view.top) / 2 + offset.y,
          dx = rx + map.size().width / 2,
          dy = ry + map.size().height / 2;
        m_this.canvas().css({
          'transform-origin': '' + -rx + 'px ' + -ry + 'px'
        });
        var transform = 'translate(' + dx + 'px' + ',' + dy + 'px' + ')' + 'scale(' + scale + ')';
        if (rotation) {
          transform += 'rotate(' + rotation * 180 / Math.PI + 'deg)';
        }
        m_this.canvas().css('transform', transform);
      }
      /* Set some attributes that can be used by non-css based viewers.  This
       * doesn't include the map center, as that may need to be handled
       * differently from the view center. */
      m_this.canvas().attr({
        scale: Math.pow(2, mapZoom - zoom),
        dx: -to.x + -(view.left + view.right) / 2,
        dy: -to.y + -(view.bottom + view.top) / 2,
        offsetx: offset.x,
        offsety: offset.y,
        rotation: map.rotation()
      });
    }
    tiles = m_this._getTiles(zoom, bounds, true, true);
    if (tiles === undefined) {
      return m_this;
    }

    // reset the tile coverage tree
    m_this._tileTree = {};
    tiles.forEach(function (tile) {
      if (tile.fetched()) {
        delete m_promisedTiles[tile.toString()];
        /* if we have already fetched the tile, we know we can just draw it,
         * as the bounds won't have changed since the call to _getTiles. */
        m_this.drawTile(tile);

        // mark the tile as covered
        m_this._setTileTree(tile);
      } else {
        if (!tile._queued) {
          tile.then(function () {
            if (m_exited) {
              /* If we have disconnected the renderer, do nothing.  This
               * happens when the layer is being deleted. */
              return;
            }
            if (tile !== m_this.cache.get(tile.toString())) {
              /* If the tile has fallen out of the cache, don't draw it -- it
               * is untracked.  This may be an indication that a larger cache
               * should have been used. */
              return;
            }
            /* Check if a tile is still desired.  Don't draw it if it
             * isn't. */
            var mapZoom = map.zoom(),
              zoom = m_this._options.tileRounding(mapZoom),
              view = m_this._getViewBounds();
            if (m_this._canPurge(tile, view, zoom)) {
              m_this.remove(tile);
              return;
            }
            m_this.drawTile(tile);

            // mark the tile as covered
            m_this._setTileTree(tile);
          });
          tile._queued = true;
        } else {
          /* If we are using a fetch queue, tell the queue so this tile can
           * be reprioritized. */
          var pos = m_this._queue ? m_this._queue.get(tile) : -1;
          if (pos >= 0) {
            m_this._queue.add(tile);
          }
        }
        m_this.addPromise(tile);
        m_promisedTiles[tile.toString()] = tile;
      }
    });
    // purge all old tiles when the new tiles are loaded (successfully or not)
    $.when.apply($, tiles).done(
    // called on success and failure
    function () {
      var map = m_this.map(),
        mapZoom = map.zoom(),
        zoom = m_this._options.tileRounding(mapZoom);
      m_this._purge(zoom, true);
    });
    // for tiles that aren't in view, remove them from the list of tiles that
    // are needed to be loaded to be considered idle.
    if (m_this._options.idleAfter !== 'all') {
      for (var hash in m_promisedTiles) {
        var tile = m_promisedTiles[hash];
        if (tiles.indexOf(tile) < 0) {
          m_this.removePromise(tile);
          delete m_promisedTiles[hash];
        }
      }
    }
    return m_this;
  };

  /**
   * Set a value in the tile tree object indicating that the given area of
   * the canvas is covered by the tile.
   *
   * @protected
   * @param {geo.tile} tile The tile to add.
   */
  this._setTileTree = function (tile) {
    if (m_this._options.keepLower) {
      return;
    }
    var index = tile.index;
    m_this._tileTree[index.level] = m_this._tileTree[index.level] || {};
    m_this._tileTree[index.level][index.x] = m_this._tileTree[index.level][index.x] || {};
    m_this._tileTree[index.level][index.x][index.y] = tile;
  };

  /**
   * Get a value in the tile tree object if it exists or return `null`.
   * @protected
   * @param {object} index A tile index object
   * @param {object} index.level
   * @param {object} index.x
   * @param {object} index.y
   * @returns {geo.tile|null}
   */
  this._getTileTree = function (index) {
    return ((m_this._tileTree[index.level] || {})[index.x] || {})[index.y] || null;
  };

  /**
   * Returns true if the tile is completely covered by other tiles on the
   * canvas.  Currently this method only checks layers +/- 1 away from
   * `tile`.  If the zoom level is allowed to change by 2 or more in a single
   * update step, this method will need to be refactored to make a more
   * robust check.  Returns an array of tiles covering it or null if any
   * part of the tile is exposed.
   *
   * @protected
   * @param {geo.tile} tile The tile to check.
   * @returns {geo.tile[]|null}
   */
  this._isCovered = function (tile) {
    var level = tile.index.level,
      x = tile.index.x,
      y = tile.index.y,
      tiles = [];

    // Check one level up
    tiles = m_this._getTileTree({
      level: level - 1,
      x: Math.floor(x / 2),
      y: Math.floor(y / 2)
    });
    if (tiles) {
      return [tiles];
    }

    // Check one level down
    tiles = [m_this._getTileTree({
      level: level + 1,
      x: 2 * x,
      y: 2 * y
    }), m_this._getTileTree({
      level: level + 1,
      x: 2 * x + 1,
      y: 2 * y
    }), m_this._getTileTree({
      level: level + 1,
      x: 2 * x,
      y: 2 * y + 1
    }), m_this._getTileTree({
      level: level + 1,
      x: 2 * x + 1,
      y: 2 * y + 1
    })];
    if (tiles.every(function (t) {
      return t !== null;
    })) {
      return tiles;
    }
    return null;
  };

  /**
   * Returns true if the provided tile is outside of the current view bounds
   * and can be removed from the canvas.
   * @protected
   * @param {geo.tile} tile The tile to check.
   * @param {geo.geoBounds} bounds The view bounds.
   * @returns {boolean}
   */
  this._outOfBounds = function (tile, bounds) {
    /* We may want to add an (n) tile edge buffer so we appear more
     * responsive */
    var to = m_this._tileOffset(tile.index.level);
    var scale = 1;
    if (tile.index.level !== bounds.level) {
      scale = Math.pow(2, (bounds.level || 0) - (tile.index.level || 0));
    }
    return (tile.bottom - to.y) * scale < bounds.top || (tile.left - to.x) * scale > bounds.right || (tile.top - to.y) * scale > bounds.bottom || (tile.right - to.x) * scale < bounds.left;
  };

  /**
   * Returns true if the provided tile can be purged from the canvas.  This
   * method will return `true` if the tile is completely covered by one or
   * more other tiles or it is outside of the active view bounds.  This
   * method returns the logical and of `_isCovered` and `_outOfBounds`.
   * @protected
   * @param {geo.tile} tile The tile to check.
   * @param {geo.geoBounds} [bounds] The view bounds (if unspecified, assume
   *      global bounds)
   * @param {number} bounds.level The zoom level the bounds are given as.
   * @param {number} [zoom] Keep in bound tile at this zoom level.
   * @param {boolean} [doneLoading] If true, allow purging additional tiles.
   * @returns {boolean}
   */
  this._canPurge = function (tile, bounds, zoom, doneLoading) {
    if (m_this._options.keepLower) {
      zoom = zoom || 0;
      if (zoom < tile.index.level && tile.index.level !== m_this._options.minLevel) {
        return true;
      }
      if (tile.index.level === m_this._options.minLevel && !m_this._options.wrapX && !m_this._options.wrapY) {
        return false;
      }
    } else {
      /* For tile layers that should only keep one layer, if loading is
       * finished, purge all but the current layer.  This is important for
       * semi-transparent layers. */
      if ((doneLoading || m_this._isCovered(tile)) && zoom !== tile.index.level && (zoom >= m_this._options.minLevel || tile.index.level !== m_this._options.minLevel) && (zoom < m_this._options.maxLevel || tile.index.level !== m_this._options.maxLevel)) {
        return true;
      }
    }
    if (bounds) {
      return m_this._outOfBounds(tile, bounds);
    }
    return false;
  };

  /**
   * Convert display pixel coordinates (where (0,0) is the upper left) to
   * layer pixel coordinates (typically (0,0) is the center of the map and
   * the upper-left has the most negative values).
   * By default, this is done at the current base zoom level.
   *
   * @param {object} [pt] The point to convert with `x` and `y`.  If
   *      `undefined`, use the center of the display.
   * @param {number} [zoom] If specified, the zoom level to use.
   * @returns {object} The point in level coordinates with `x` and `y`.
   */
  this.displayToLevel = function (pt, zoom) {
    var map = m_this.map(),
      mapzoom = map.zoom(),
      roundzoom = m_this._options.tileRounding(mapzoom),
      unit = map.unitsPerPixel(zoom === undefined ? roundzoom : zoom),
      gcsPt;
    if (pt === undefined) {
      var size = map.size();
      pt = {
        x: size.width / 2,
        y: size.height / 2
      };
    }
    /* displayToGcs can fail under certain projections.  If this happens,
     * just return the origin. */
    try {
      gcsPt = map.displayToGcs(pt, m_this._options.gcs || null);
    } catch (err) {
      gcsPt = {
        x: 0,
        y: 0
      };
    }
    /* Reverse the y coordinate, since we expect the gcs coordinate system
     * to be right-handed and the level coordinate system to be
     * left-handed. */
    var lvlPt = {
      x: gcsPt.x / unit,
      y: m_this._topDown() * gcsPt.y / unit
    };
    return lvlPt;
  };

  /**
   * Get or set the tile url string or function.  If changed, load the new
   * tiles.
   *
   * @param {string|Function} [url] The new tile url.
   * @returns {string|Function|this}
   */
  this.url = function (url) {
    if (url === undefined) {
      return m_this._options.originalUrl;
    }
    if (url === m_this._options.originalUrl) {
      return m_this;
    }
    m_this._options.originalUrl = url;
    if ($.type(url) === 'string') {
      url = m_tileUrlFromTemplate(url);
    }
    m_this._options.url = url;
    m_this.reset();
    m_this.map().draw();
    return m_this;
  };

  /**
   * Get or set the subdomains used for templating.
   *
   * @param {string|string[]} [subdomains] A comma-separated list, a string of
   *      single character subdomains, or a list.
   * @returns {string|string[]|this}
   */
  this.subdomains = function (subdomains) {
    if (subdomains === undefined) {
      return m_this._options.subdomains;
    }
    if (subdomains) {
      if ($.type(subdomains) === 'string') {
        if (subdomains.indexOf(',') >= 0) {
          subdomains = subdomains.split(',');
        } else {
          subdomains = subdomains.split('');
        }
      }
      m_this._options.subdomains = subdomains;
      m_this.reset();
      m_this.map().draw();
    }
    return m_this;
  };

  /**
   * Return a value from the tileOffset function, caching it for different
   * levels.
   *
   * @param {number} level The level to pass to the tileOffset function.
   * @returns {object} A tile offset object with `x` and `y` properties.
   */
  this._tileOffset = function (level) {
    if (m_tileOffsetValues[level] === undefined) {
      m_tileOffsetValues[level] = m_this._options.tileOffset(level);
    }
    return m_tileOffsetValues[level];
  };

  /**
   * Get/Set visibility of the layer.
   *
   * @param {boolean} [val] If unspecified, return the visibility, otherwise
   *    set it.
   * @returns {boolean|this} Either the visibility (if getting) or the layer
   *    (if setting).
   */
  this.visible = function (val) {
    if (val === undefined) {
      return s_visible();
    }
    if (m_this.visible() !== val) {
      s_visible(val);
      if (val) {
        m_this._update();
      }
    }
    return m_this;
  };

  /**
   * Get/Set nearestPixel value.
   *
   * @param {boolean|number} [val] If not specified, return the current value.
   *    If true, image quads are rendered with near-neighbor sampling.  If
   *    false, with interpolated sampling.  If a number, interpolate at that
   *    zoom level or below and nearest neighbor at that zoom level or above.
   * @param {boolean} [skipUpdate] If specifying val and this value is truthy,
   *    don't update the layer or mark it as modified.
   * @returns {boolean|number|this}
   */
  this.nearestPixel = function (val, skipUpdate) {
    if (val === undefined) {
      return m_nearestPixel;
    }
    if (m_nearestPixel !== val) {
      m_nearestPixel = val;
      if (!skipUpdate) {
        m_this.modified();
        m_this._update();
      }
    }
    return m_this;
  };

  /**
   * Get/set the baseQuad.
   *
   * @property {object} [baseQuad] A quad feature element to draw below any
   *   tile layers.  If specified, this uses the quad defaults, so this is a
   *   ``geo.quadFeature.position`` object with, typically, an ``image``
   *   property added to it.  The quad positions are in the map gcs
   *   coordinates.
   * @name geo.tileLayer.baseQuad
   */
  Object.defineProperty(this, 'baseQuad', {
    get: function get() {
      return m_this._options.baseQuad;
    },
    set: function set(baseQuad) {
      m_this._options.baseQuad = baseQuad;
      m_this._update();
    }
  });
  this._addBaseQuadToTiles = function (quadFeature, tiles) {
    if (quadFeature) {
      if (this.baseQuad !== m_lastBaseQuad) {
        if (m_lastBaseQuad) {
          tiles.splice(0, 1);
        }
        m_lastBaseQuad = this.baseQuad;
        if (m_lastBaseQuad) {
          tiles.splice(0, 0, this.baseQuad);
          quadFeature.cacheUpdate(0);
        }
        quadFeature.data(tiles);
      }
      quadFeature._update();
    }
  };

  /**
   * Initialize after the layer is added to the map.
   *
   * @returns {this}
   */
  this._init = function () {
    var sublayer;

    // call super method
    s_init.apply(m_this, arguments);
    if (m_this.renderer() === null) {
      // Initialize sublayers in the correct order
      for (sublayer = 0; sublayer <= m_this._options.maxLevel; sublayer += 1) {
        m_this._getSubLayer(sublayer);
      }
    }
    return m_this;
  };

  /**
   * Clean up the layer.
   *
   * @returns {this}
   */
  this._exit = function () {
    m_this.reset();
    // call super method
    s_exit.apply(m_this, arguments);
    m_exited = true;
    if (this._queue && this._queue._tileLayers && this._queue._tileLayers.indexOf(m_this) >= 0) {
      this._queue._tileLayers.splice(this._queue._tileLayers.indexOf(m_this), 1);
      if (this._queue.initialTrack && this._queue.track && this._queue._tileLayers.length) {
        this._queue.track = this._queue.initialTrack * this._queue._tileLayers.length;
      }
    }
    return m_this;
  };
  adjustLayerForRenderer('tile', this);
  return this;
};

/**
 * This object contains the default options used to initialize the tileLayer.
 */
_tileLayer.defaults = {
  minLevel: 0,
  maxLevel: 18,
  tileOverlap: {
    x: 0,
    y: 0
  },
  tileWidth: 256,
  tileHeight: 256,
  wrapX: true,
  wrapY: false,
  url: null,
  subdomains: 'abc',
  tileOffset: function tileOffset(level) {
    return {
      x: 0,
      y: 0
    };
  },
  tilesMaxBounds: null,
  topDown: false,
  keepLower: true,
  idleAfter: 'view',
  // cacheSize: 600,  // set depending on keepLower
  tileRounding: Math.round,
  attribution: '',
  animationDuration: 0
};
inherit(_tileLayer, featureLayer);
module.exports = _tileLayer;

/***/ }),

/***/ 77:
/***/ (function(module) {

var m_globalTimestamp = 0;

/**
 * Create a new instance of class timestamp.  The timestamp is a globally
 * unique integer that monotonically increases.
 *
 * @class
 * @alias geo.timestamp
 * @returns {geo.timestamp}
 */
var _timestamp = function timestamp() {
  'use strict';

  if (!(this instanceof _timestamp)) {
    return new _timestamp();
  }
  var m_this = this,
    m_timestamp = 0;

  /**
   * Update the timestamp to the next global timestamp value.
   *
   * @returns {this}
   */
  this.modified = function () {
    m_globalTimestamp += 1;
    m_timestamp = m_globalTimestamp;
    return m_this;
  };

  /**
   * Get time.
   *
   * @returns {number} The timestamp.  This is 0 if the timestamp has never
   *    been modified.
   */
  this.timestamp = function () {
    return m_timestamp;
  };

  // Also refer to `timestamp` under an alternate name
  this.getMTime = this.timestamp;
  return this;
};
module.exports = _timestamp;

/***/ }),

/***/ 338:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var registry = __webpack_require__(1098);
var util = __webpack_require__(642);

/**
 * Track feature specification.
 *
 * @typedef {geo.feature.spec} geo.trackFeature.spec
 * @extends geo.feature.spec
 * @property {geo.geoPosition|Function} [position] Position of the data.
 *   Default is (data).
 * @property {number|Function} [time] Time of the data.  Default is `(data).t`.
 * @property {object|Function} [track] Tracks from the data.  Default is
 *   (data).  Typically, the data is an array of tracks, each of which is an
 *   array of points, each of which has a position and time.  The position and
 *   time functions are called for each point as `position(trackPoint,
 *   pointIndex, trackEntry, trackEntryIndex)`.
 * @property {number|null} [startTime=null] Start time.  Used for styling.  If
 *   `null`, this is the duration before the end time if `duration` is not
 *  `null` and the minimum time in any track if `duration` is `null`.
 * @property {number} [endTime=null] End time.  Used for styling and position
 *   of the track head.  If `null` and either of `startTime` or `duration` are
 *   `null`, this is the maximum time in any track.
 * @property {number} [duration=null] Duration between start and end times.
 *   Ignored if both start and end times are specified.
 * @property {number|Function} [text] Text to use for the head of the track.
 *   If specified, the track head is rendered as text.  If `undefined` a marker
 *   is used instead.  If `null` or an empty string (`''`), neither a marker
 *   nor text is used.
 * @property {geo.trackFeature.styleSpec} [style] Style object with default
 *   style options.
 * @property {geo.lineFeature.styleSpec} [pastStyle] Style object with
 *   style options for the track before the start time.
 * @property {geo.lineFeature.styleSpec} [currentStyle] Style object with
 *   style options for the track between the start and end time.
 * @property {geo.lineFeature.styleSpec} [futureStyle] Style object with
 *   style options for the track after the end time.
 * @property {geo.markerFeature.styleSpec} [markerStyle] Style object with
 *  style options for the track head marker.
 * @property {geo.textFeature.styleSpec} [textStyle] Style object with style
 *  options for the track head text.
 */

/**
 * Style specification for a track feature.  Extends
 * {@link geo.lineFeasture.styleSpec}.
 *
 * @typedef {geo.feature.styleSpec} geo.trackFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @extends geo.lineFeature.styleSpec
 */

/**
 * Create a new instance of class trackFeature.
 *
 * @class
 * @alias geo.trackFeature
 * @extends geo.feature
 * @param {geo.trackFeature.spec} arg
 * @returns {geo.trackFeature}
 */
var _trackFeature = function trackFeature(arg) {
  'use strict';

  if (!(this instanceof _trackFeature)) {
    return new _trackFeature(arg);
  }
  var transform = __webpack_require__(5325);
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    m_styles = {},
    m_tracks = {
      // user specified
      startTime: arg.startTime !== undefined ? arg.startTime : null,
      endTime: arg.endTime !== undefined ? arg.endTime : null,
      duration: arg.duration !== undefined ? arg.duration : null,
      // internal
      start: 0,
      end: 0
    },
    m_lineFeatures,
    m_markerLayer,
    m_markerFeature,
    m_textLayer,
    m_textFeature,
    s_draw = this.draw,
    s_exit = this._exit,
    s_init = this._init,
    s_modified = this.modified,
    s_style = this.style,
    s_update = this._update;
  this.featureType = 'track';

  /**
   * Return a function for position of a dependent line feature.
   *
   * @param {string} key One of `past`, `current` or `future`.
   * @returns {Function} The position function.
   */
  this._linePosition = function (key) {
    return function (d, i, l, j) {
      var time = m_tracks.timeFunc(d, i, l, j);
      if (key === 'past' && time >= m_tracks.start || key === 'current' && time < m_tracks.start) {
        return m_tracks.startPosition[j];
      }
      if (key === 'current' && time > m_tracks.end || key === 'future' && time < m_tracks.end) {
        return m_tracks.endPosition[j];
      }
      return m_tracks.positionFunc(d, i, l, j);
    };
  };

  /**
   * Return the position for the head of the track.
   *
   * @param {object} d The data object.
   * @param {number} i The data idex.
   * @returns {geo.geoPosition} The position.
   */
  this._headPosition = function (d, i) {
    return m_tracks.endPosition[i];
  };

  /**
   * Return the text associated with a track.
   *
   * @param {object} d The data object.
   * @param {number} i The data idex.
   * @returns {string|undefined} The text.
   */
  this._headText = function (d, i) {
    return m_tracks.text[i];
  };

  /**
   * Based on the user-specified start time, end time, and duration, and the
   * maximum and minimum track times, compute the functional track start and
   * end times.
   */
  this._updateTimeRange = function () {
    if (m_tracks.endTime !== null || m_tracks.endTime === null && (m_tracks.startTime === null || m_tracks.duration == null)) {
      m_tracks.end = m_tracks.endTime !== null ? m_tracks.endTime : m_tracks.timeExtents.end;
      if (m_tracks.startTime !== null && (m_tracks.endTime === null || m_tracks.startTime <= m_tracks.endTime)) {
        m_tracks.start = m_tracks.startTime;
      } else if (m_tracks.duration !== null) {
        m_tracks.start = m_tracks.end - m_tracks.duration;
      } else {
        m_tracks.start = m_tracks.timeExtents.start;
      }
    } else {
      m_tracks.start = m_tracks.startTime;
      m_tracks.end = m_tracks.start + m_tracks.duration;
    }
  };

  /**
   * Calculate an interpolated position given a time.  If the time is outside
   * the range of a track, the first or last point is returned.
   *
   * @param {number} time The time to compute a position array for.
   * @param {string|geo.transform|null} [gcs] `undefined` to use the feature
   *    gcs, `null` to use the map gcs, or any other transform.  This transform
   *    is used for the interpolation; the results are still in feature gcs.
   * @param {boolean} [calcAngle] If truthy, also calculate the angle.
   * @returns {geo.geoPosition[]} An array of positions, one per track.  If the
   *    angle is computed, these position objects are supplemented with an
   *    `angle` key in radians.
   */
  this.calculateTimePosition = function (time, gcs, calcAngle) {
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp()) {
      m_this._build();
    }
    gcs = gcs === null ? m_this.layer().map().gcs() : gcs === undefined ? m_this.gcs() : gcs;
    var trans = transform({
      source: m_this.gcs(),
      target: gcs
    });
    var data = m_this.data();
    var tracks = [];
    var positions = data.map(function (d, i) {
      var track = m_tracks.trackFunc(d, i);
      tracks.push(track);
      if (!track.length) {
        return {
          x: 0,
          y: 0,
          z: 0,
          posidx: -1
        };
      }
      var lowidx = 0,
        lowt,
        highidx = track.length - 1,
        hight,
        testidx,
        testt;
      if (track.length === 1) {
        return {
          posidx: lowidx,
          angidx0: lowidx,
          angidx1: lowidx
        };
      }
      lowt = m_tracks.timeFunc(track[lowidx], lowidx, d, i);
      if (lowt >= time) {
        return {
          posidx: lowidx,
          angidx0: lowidx,
          angidx1: lowidx + 1
        };
      }
      hight = m_tracks.timeFunc(track[highidx], highidx, d, i);
      if (hight <= time) {
        return {
          posidx: highidx,
          angidx0: highidx - 1,
          angidx1: highidx
        };
      }
      while (highidx - lowidx > 1) {
        testidx = Math.floor((highidx + lowidx) / 2);
        testt = m_tracks.timeFunc(track[testidx], testidx, d, i);
        if (testt === time) {
          return {
            posidx: testidx,
            angidx0: testidx - 1,
            angidx1: testidx + 1
          };
        }
        if (testt < time) {
          lowt = testt;
          lowidx = testidx;
        } else {
          hight = testt;
          highidx = testidx;
        }
      }
      // todo: if we want non-linear travel between points, we would adjust
      // fl and fh here
      var fh = (time - lowt) / (hight - lowt),
        fl = 1 - fh;
      return {
        posidx0: lowidx,
        posidx1: highidx,
        factor0: fl,
        factor1: fh,
        angidx0: lowidx,
        angidx1: highidx
      };
    });
    positions.forEach(function (d, i) {
      if (d.posidx < 0) {
        return;
      }
      var pos, pos0, pos1;
      if (d.posidx1 === undefined) {
        pos = m_tracks.positionFunc(tracks[i][d.posidx], d.posidx, tracks[i], i);
      } else {
        pos0 = trans.forward(m_tracks.positionFunc(tracks[i][d.posidx0], d.posidx0, tracks[i], i), true);
        pos1 = trans.forward(m_tracks.positionFunc(tracks[i][d.posidx1], d.posidx1, tracks[i], i), true);
        pos = trans.inverse({
          x: pos0.x * d.factor0 + pos1.x * d.factor1,
          y: pos0.y * d.factor0 + pos1.y * d.factor1,
          z: (pos0.z || 0) * d.factor0 + (pos1.z || 0) * d.factor1
        }, true);
      }
      d.x = pos.x;
      d.y = pos.y;
      d.z = pos.z || 0;
      if (calcAngle) {
        if (d.posidx1 === undefined) {
          pos0 = trans.forward(d.angidx0 === d.posidx ? pos : m_tracks.positionFunc(tracks[i][d.angidx0], d.angidx0, tracks[i], i), true);
          pos1 = trans.forward(d.angidx1 === d.posidx ? pos : m_tracks.positionFunc(tracks[i][d.angidx1], d.angidx1, tracks[i], i), true);
        }
        d.angle = Math.atan2(pos1.y - pos0.y, pos1.x - pos0.x);
      }
    });
    return positions;
  };

  /**
   * Build.  Generate the tracks.  Create sub-features if necessary and
   * update it.
   *
   * @returns {this}
   */
  this._build = function () {
    m_this.buildTime().modified();
    if (!m_lineFeatures) {
      /* This determines the z-order of the time segments */
      m_lineFeatures = {
        past: m_this.layer().createFeature('line'),
        future: m_this.layer().createFeature('line'),
        current: m_this.layer().createFeature('line')
      };
      m_this.dependentFeatures([m_lineFeatures.past, m_lineFeatures.current, m_lineFeatures.future]);
    }
    var data = m_this.data();
    m_tracks.data = data;
    m_tracks.timeFunc = m_this.style.get('time');
    m_tracks.positionFunc = m_this.style.get('position');
    m_tracks.trackFunc = m_this.style.get('track');
    m_tracks.textFunc = m_this.style.get('text');
    ['past', 'current', 'future'].forEach(function (key) {
      m_lineFeatures[key].style(m_this.style()).style(m_this[key + 'Style']()).line(m_this.style('track')).gcs(m_this.gcs()).data(data).position(m_this._linePosition(key));
    });
    var timeExtents = {};
    data.forEach(function (d, i) {
      var track = m_tracks.trackFunc(d, i);
      var time;
      if (track.length) {
        time = m_tracks.timeFunc(track[0], 0, d, i);
        if (timeExtents.start === undefined || time < timeExtents.start) {
          timeExtents.start = time;
        }
        if (track.length > 1) {
          time = m_tracks.timeFunc(track[track.length - 1], track.length - 1, d, i);
        }
        if (timeExtents.end === undefined || time > timeExtents.end) {
          timeExtents.end = time;
        }
      }
    });
    m_tracks.timeExtents = timeExtents;
    m_this._updateTimeRange();
    m_tracks.startPosition = m_this.calculateTimePosition(m_tracks.start, null);
    m_tracks.endPosition = m_this.calculateTimePosition(m_tracks.end, null, true);
    var hasMarker, hasText;
    m_tracks.text = data.map(function (d, i) {
      var val = m_tracks.textFunc(d, i);
      hasMarker |= val === undefined || val === null;
      if (val === undefined || val === null || val === '') {
        return '';
      }
      hasText = true;
      if (m_tracks.startPosition[i].posidx < 0) {
        val = '';
      }
      return val;
    });
    if (hasMarker && !m_markerFeature) {
      if (!(registry.registries.features[m_this.layer().rendererName()] || {}).marker) {
        var renderer = registry.rendererForFeatures(['marker']);
        m_markerLayer = registry.createLayer('feature', m_this.layer().map(), {
          renderer: renderer
        });
        m_this.layer().addChild(m_markerLayer);
        m_this.layer().node().append(m_markerLayer.node());
      }
      m_markerFeature = (m_markerLayer || m_this.layer()).createFeature('marker');
      var df = m_this.dependentFeatures();
      df.push(m_markerFeature);
      m_this.dependentFeatures(df);
    }
    if (hasText && !m_textFeature) {
      if (!(registry.registries.features[m_this.layer().rendererName()] || {}).text) {
        var _renderer = registry.rendererForFeatures(['text']);
        m_textLayer = registry.createLayer('feature', m_this.layer().map(), {
          renderer: _renderer
        });
        m_this.layer().addChild(m_textLayer);
        m_this.layer().node().append(m_textLayer.node());
      }
      m_textFeature = (m_textLayer || m_this.layer()).createFeature('text');
      var _df = m_this.dependentFeatures();
      _df.push(m_textFeature);
      m_this.dependentFeatures(_df);
    }
    if (m_markerFeature) {
      m_markerFeature.headData = m_tracks.endPosition;
      m_markerFeature.style(m_this.markerStyle()).gcs(m_this.gcs()).data(data).position(m_this._headPosition);
      var radiusFunc = m_markerFeature.style.get('radius');
      m_markerFeature.style('radius', function (d, i) {
        if (m_tracks.text[i] || m_tracks.startPosition[i].posidx < 0) {
          return 0;
        }
        return radiusFunc(d, i);
      });
    }
    if (m_textFeature) {
      m_textFeature.headData = m_tracks.endPosition;
      m_textFeature.style(m_this.textStyle()).gcs(m_this.gcs()).data(data).text(m_this._headText).position(m_this._headPosition);
    }
    return m_this;
  };

  /**
   * Update the time and position and mark features as modified.
   */
  this._updateTimeAndPosition = function () {
    if (!m_lineFeatures) {
      return;
    }
    m_this._updateTimeRange();
    m_tracks.startPosition = m_this.calculateTimePosition(m_tracks.start, null);
    m_tracks.endPosition = m_this.calculateTimePosition(m_tracks.end, null, true);
    m_lineFeatures.past.modified();
    m_lineFeatures.current.modified();
    m_lineFeatures.future.modified();
    if (m_markerFeature) {
      m_markerFeature.modified();
    }
    if (m_textFeature) {
      m_textFeature.modified();
    }
    m_this.updateTime().modified();
    m_this.modified();
  };

  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() <= m_this.timestamp()) {
      m_this._build();
    }
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Redraw the object.
   *
   * @returns {object} The results of the superclass draw function.
   */
  this.draw = function () {
    var result = s_draw();
    if (m_lineFeatures) {
      m_lineFeatures.past.draw();
      m_lineFeatures.current.draw();
      m_lineFeatures.future.draw();
    }
    if (m_markerFeature) {
      m_markerFeature.draw();
    }
    if (m_textFeature) {
      m_textFeature.draw();
    }
    return result;
  };

  /**
   * Update the timestamp to the next global timestamp value.  Mark
   * sub-features as modified, too.
   *
   * @returns {object} The results of the superclass modified function.
   */
  this.modified = function () {
    var result = s_modified();
    if (m_lineFeatures) {
      m_lineFeatures.past.modified();
      m_lineFeatures.current.modified();
      m_lineFeatures.future.modified();
    }
    if (m_markerFeature) {
      m_markerFeature.modified();
    }
    if (m_textFeature) {
      m_textFeature.modified();
    }
    return result;
  };

  /**
   * Get or set style.
   *
   * @param {string|object} [arg1] If `undefined`, return the current style
   *    object.  If a string and `arg2` is undefined, return the style
   *    associated with the specified key.  If a string and `arg2` is defined,
   *    set the named style to the specified value.  Otherwise, extend the
   *    current style with the values in the specified object.
   * @param {*} [arg2] If `arg1` is a string, the new value for that style.
   * @param {string} [styleType] The name of the style type, such as
   *    `markerStyle`, `textStyle`, `pastStyle`, `currentStyle`, or
   *    `futureStyle`.
   * @returns {object|this} Either the entire style object, the value of a
   *    specific style, or the current class instance.
   */
  this.style = function (arg1, arg2, styleType) {
    styleType = styleType || 'style';
    if (styleType === 'style') {
      return s_style(arg1, arg2);
    }
    if (arg1 === undefined) {
      return m_styles[styleType];
    }
    if (typeof arg1 === 'string' && arg2 === undefined) {
      return (m_styles[styleType] || {})[arg1];
    }
    if (m_styles[styleType] === undefined) {
      m_styles[styleType] = {};
    }
    if (arg2 === undefined) {
      m_styles[styleType] = util.deepMerge(m_styles[styleType], arg1);
    } else {
      m_styles[styleType][arg1] = arg2;
    }
    m_this.modified();
    return m_this;
  };
  this.style.get = s_style.get;

  /**
   * Calls {@link geo.annotation#style} with `styleType='markerStyle'`.
   * @function markerStyle
   * @memberof geo.trackFeature
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='textStyle'`.
   * @function textStyle
   * @memberof geo.trackFeature
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='pastStyle'`.
   * @function pastStyle
   * @memberof geo.trackFeature
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='currentStyle'`.
   * @function currentStyle
   * @memberof geo.trackFeature
   * @instance
   */
  /**
   * Calls {@link geo.annotation#style} with `styleType='futureStyle'`.
   * @function futureStyle
   * @memberof geo.trackFeature
   * @instance
   */
  ['markerStyle', 'textStyle', 'pastStyle', 'currentStyle', 'futureStyle'].forEach(function (styleType) {
    m_this[styleType] = function (arg1, arg2) {
      return m_this.style(arg1, arg2, styleType);
    };
  });

  /**
   * Get/set track accessor.
   *
   * @param {object|Function} [val] If not specified, return the current track
   *    accessor.  If specified, use this for the track accessor and return
   *    `this`.  If a function is given, the function is passed `(dataElement,
   *    dataIndex)` and returns an array of vertex elements.
   * @returns {object|Function|this} The current track accessor or this feature.
   */
  this.track = function (val) {
    if (val === undefined) {
      return m_this.style('track');
    } else {
      m_this.style('track', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set position accessor.
   *
   * @param {geo.geoPosition|Function} [val] If not specified, return the
   *    current position accessor.  If specified, use this for the position
   *    accessor and return `this`.  If a function is given, this is called
   *    with `(vertexElement, vertexIndex, dataElement, dataIndex)`.
   * @returns {geo.geoPosition|Function|this} The current position or this
   *    feature.
   */
  this.position = function (val) {
    if (val === undefined) {
      return m_this.style('position');
    } else {
      m_this.style('position', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Get/Set time accessor.
   *
   * @param {number} [val] If not specified, return the current time accessor.
   *    If specified, use this for the time accessor and return `this`.  If a
   *    function is given, this is called with `(vertexElement, vertexIndex,
   *    dataElement, dataIndex)`.
   * @returns {number|Function|this} The current time or this feature.
   */
  this.time = function (val) {
    if (val === undefined) {
      return m_this.style('time');
    } else {
      m_this.style('time', val);
      m_this.dataTime().modified();
      m_this.modified();
    }
    return m_this;
  };

  /**
   * Set or query the time range for the tracks.  Tracks are rendered
   * differently before the start time and after the end time.  The track's
   * marker or text is rendered at the position corresponding to the end time.
   *
   * @param {object} [val] An object with any of `startTime`, `endTime`, and
   *    `duration`.  A value of `undefined` won't change that field.  A value
   *    of `null` uses the default.  If `val` is `undefined`, the existing
   *    settings are returned.
   * @returns {object|this} Either the instance or the current settings.  If
   *    the current settings, `start` and `end` are included with the
   *    calculated start and end times, and `minimum` and `maximum` are values
   *    computed from the data.
   */
  this.timeRange = function (val) {
    if (val === undefined) {
      return {
        startTime: m_tracks.startTime,
        endTime: m_tracks.endTime,
        duration: m_tracks.duration,
        start: m_tracks.start,
        end: m_tracks.end,
        minimum: (m_tracks.timeExtents || {}).start,
        maximum: (m_tracks.timeExtents || {}).end
      };
    }
    var update = false;
    if (val.startTime !== undefined && val.startTime !== m_tracks.startTime) {
      m_tracks.startTime = val.startTime === null ? val.startTime : +val.startTime;
      update = true;
    }
    if (val.endTime !== undefined && val.endTime !== m_tracks.endTime) {
      m_tracks.endTime = val.endTime === null ? val.endTime : +val.endTime;
      update = true;
    }
    if (val.duration !== undefined && val.duration !== m_tracks.duration) {
      m_tracks.duration = val.duration === null ? val.duration : +val.duration;
      update = true;
    }
    if (update) {
      m_this._updateTimeAndPosition();
    }
    return m_this;
  };

  /**
   * Get or set the start time.
   *
   * @param {number|null} [val] If specified, the new start time.
   * @returns {number|null|this} If set, the instance.  Otherwise, the current
   *    start time value.
   */
  this.startTime = function (val) {
    if (val === undefined) {
      return m_tracks.startTime;
    }
    if (val !== m_tracks.startTime) {
      m_tracks.startTime = val === null ? val : +val;
      m_this._updateTimeAndPosition();
    }
    return m_this;
  };

  /**
   * Get or set the end time.
   *
   * @param {number|null} [val] If specified, the new end time.
   * @returns {number|null|this} If set, the instance.  Otherwise, the current
   *    end time value.
   */
  this.endTime = function (val) {
    if (val === undefined) {
      return m_tracks.endTime;
    }
    if (val !== m_tracks.endTime) {
      m_tracks.endTime = val === null ? val : +val;
      m_this._updateTimeAndPosition();
    }
    return m_this;
  };

  /**
   * Get or set the duration.
   *
   * @param {number|null} [val] If specified, the new duration.
   * @returns {number|null|this} If set, the instance.  Otherwise, the current
   *    duration.
   */
  this.duration = function (val) {
    if (val === undefined) {
      return m_tracks.duration;
    }
    if (val !== m_tracks.duration) {
      m_tracks.duration = val === null ? val : +val;
      m_this._updateTimeAndPosition();
    }
    return m_this;
  };

  /**
   * Merge search results from multiple features.
   *
   * @param {object} result The result from the base feature.
   * @param {object[]} additional A list of additional feature search results.
   *    Each entry has `key`, the name of the feature, and `value`, the value
   *    of the search results.
   * @returns {object} The combined search results.
   */
  this._mergeSearchResults = function (result, additional) {
    result.extra = result.extra || {};
    additional.forEach(function (add) {
      return add.value.index.forEach(function (index, i) {
        if (result.index.indexOf(index) < 0) {
          result.index.push(index);
          result.found.push(add.value.found[i]);
          result.where = result.where || {};
          if (add.value.extra && add.value.extra[index]) {
            result.extra[index] = add.value.extra[index];
          }
          if (!util.isObject(result.extra[index])) {
            result.extra[index] = {
              value: result.extra[index]
            };
          }
          result.extra[index].where = add.key;
        }
      });
    });
    return result;
  };

  /**
   * Returns an array of datum indices that contain the given point.
   *
   * @param {geo.geoPosition} p point to search for in map interface gcs.
   * @returns {object} An object with `index`: a list of track indices, `found`:
   *    a list of tracks that contain the specified coordinate, `extra`: an
   *    object with keys that are track indices and values that are the first
   *    segment index for which the track was matched, and `where`: an object
   *    with keys that are track indices and values that are `past`, `future`,
   *    or `marker` if the point was found in that part of the track, or unset
   *    if the point was found in the current part of the track.
   */
  this.pointSearch = function (p) {
    var result = m_lineFeatures.current.pointSearch(p),
      past = m_lineFeatures.past.pointSearch(p),
      future = m_lineFeatures.future.pointSearch(p),
      marker = m_markerFeature ? m_markerFeature.pointSearch(p) : {
        index: []
      };
    return this._mergeSearchResults(result, [{
      key: 'marker',
      value: marker
    }, {
      key: 'past',
      value: past
    }, {
      key: 'future',
      value: future
    }]);
  };

  /**
   * Returns tracks that are contained in the given polygon.
   *
   * @param {geo.polygonObject} poly A polygon as an array of coordinates or an
   *    object with `outer` and optionally `inner` parameters.  All coordinates
   *    are in map interface gcs.
   * @param {object} [opts] Additional search options.
   * @param {boolean} [opts.partial] If truthy, include tracks that are
   *    partially in the polygon, otherwise only include tracks that are fully
   *    within the region.
   * @returns {object} An object with `index`: a list of track indices,
   *    `found`: a list of tracks within the polygon, `extra`: an object with
   *    index keys containing an object with a `segment` key with a value
   *    indicating one of the track segments that is inside the polygon and
   *    `partial` key and a boolean value to indicate if the track is on the
   *    polygon's border, and `where`: an object with keys that are track
   *    indices and values that are `past`, `future`, or `marker` if the point
   *    was found in that part of the track, or unset if the point was found in
   *    the current part of the track.
   */
  this.polygonSearch = function (poly, opts) {
    var result = m_lineFeatures.current.polygonSearch(poly, opts),
      past = m_lineFeatures.past.polygonSearch(poly, opts),
      future = m_lineFeatures.future.polygonSearch(poly, opts),
      marker = m_markerFeature ? m_markerFeature.polygonSearch(poly, opts) : {
        index: []
      };
    return this._mergeSearchResults(result, [{
      key: 'marker',
      value: marker
    }, {
      key: 'past',
      value: past
    }, {
      key: 'future',
      value: future
    }]);
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    if (m_lineFeatures && m_this.layer()) {
      m_this.layer().deleteFeature(m_lineFeatures.past);
      m_this.layer().deleteFeature(m_lineFeatures.current);
      m_this.layer().deleteFeature(m_lineFeatures.future);
    }
    m_lineFeatures = null;
    if (m_markerLayer || m_this.layer()) {
      if (m_markerFeature) {
        (m_markerLayer || m_this.layer()).deleteFeature(m_markerFeature);
      }
    }
    if (m_markerLayer && m_this.layer()) {
      m_this.layer().removeChild(m_markerLayer);
    }
    m_markerLayer = null;
    if (m_textLayer || m_this.layer()) {
      if (m_textFeature) {
        (m_textLayer || m_this.layer()).deleteFeature(m_textFeature);
      }
    }
    if (m_textLayer && m_this.layer()) {
      m_this.layer().removeChild(m_textLayer);
    }
    m_textLayer = null;
    m_this.dependentFeatures([]);
    s_exit();
  };

  /**
   * Initialize.
   *
   * @param {geo.trackFeature.spec} arg The track feature specification.
   */
  this._init = function (arg) {
    arg = arg || {};
    s_init.call(m_this, arg);
    var style = util.deepMerge({}, {
      track: util.identityFunction,
      position: util.identityFunction,
      time: function time(d, i) {
        return d.t !== undefined ? d.t : i;
      },
      uniformLine: 'drop',
      closed: false
    }, arg.style === undefined ? {} : arg.style);
    var markerStyle = util.deepMerge({}, {
      rotateWithMap: true,
      rotation: function rotation(d, i) {
        return -m_tracks.endPosition[i].angle || 0;
      }
    }, arg.markerStyle === undefined ? {} : arg.markerStyle);
    var textStyle = util.deepMerge({}, {
      rotateWithMap: true,
      rotation: function rotation(d, i) {
        return m_tracks.endPosition[i].angle !== undefined ? -m_tracks.endPosition[i].angle + Math.PI / 2 : 0;
      }
    }, arg.textStyle === undefined ? {} : arg.textStyle);
    var pastStyle = util.deepMerge({}, {
      strokeOpacity: 0.25
    }, arg.pastStyle === undefined ? {} : arg.pastStyle);
    var currentStyle = util.deepMerge({}, {
      // defaults go here
    }, arg.currentStyle === undefined ? {} : arg.currentStyle);
    var futureStyle = util.deepMerge({}, {
      strokeOpacity: 0.25
    }, arg.futureStyle === undefined ? {} : arg.futureStyle);
    ['track', 'position', 'time'].forEach(function (key) {
      if (arg[key] !== undefined) {
        style[key] = arg[key];
      }
    });
    m_this.style(style);
    m_this.markerStyle(markerStyle);
    m_this.textStyle(textStyle);
    m_this.pastStyle(pastStyle);
    m_this.currentStyle(currentStyle);
    m_this.futureStyle(futureStyle);
  };
  return this;
};
inherit(_trackFeature, feature);
module.exports = _trackFeature;

/***/ }),

/***/ 5325:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var proj4 = __webpack_require__(9677);
var vec3 = __webpack_require__(1982);
var mat4 = __webpack_require__(3503);
var util = __webpack_require__(642);
proj4 = proj4.__esModule ? proj4.default : proj4;
/* Ensure all projections in proj4 are included. */
var projections = __webpack_require__(9689);
projections.keys().forEach(function (key) {
  proj4.Proj.projections.add(projections(key));
});
var transformCache = {};
/* Up to maxTransformCacheSize squared might be cached.  When the maximum cache
 * size is reached, the cache is completely emptied.  Since we probably won't
 * be rapidly switching between a large number of transforms, this is adequate
 * simple behavior. */
var maxTransformCacheSize = 10;

/* A RegExp to detect if two transforms only different by the middle axis's
 * direction. */
var axisPattern = /^(.* |)\+axis=e(n|s)u(| .*)$/;
var affinePattern = /(^|\s)\+(s[1-3][1-3]|[xyz]off)=\S/;

/**
 * This purpose of this class is to provide a generic interface for computing
 * coordinate transformations.  The interface is taken from proj4js, which also
 * provides the geospatial projection implementation.  The interface is
 * intentionally simple to allow for custom, non-geospatial use cases.  For
 * further details, see http://proj4js.org/
 *
 * The default transforms lat/long coordinates into web mercator for use with
 * standard tile sets.
 *
 * This class is intended to be extended in the future to support 2.5 and 3
 * dimensional transformations.  The forward/inverse methods take optional
 * z values that are ignored in current mapping context, but will in the
 * future perform more general 3D transformations.
 *
 * @class
 * @alias geo.transform
 * @param {object} options Constructor options
 * @param {string} options.source A proj4 string for the source projection
 * @param {string} options.target A proj4 string for the target projection
 * @returns {geo.transform}
 */
var _transform = function transform(options) {
  'use strict';

  if (!(this instanceof _transform)) {
    options = options || {};
    if (!(options.source in transformCache)) {
      if (Object.keys(transformCache).length >= maxTransformCacheSize) {
        transformCache = {};
      }
      transformCache[options.source] = {};
    }
    if (!(options.target in transformCache[options.source])) {
      if (Object.keys(transformCache[options.source]).length >= maxTransformCacheSize) {
        transformCache[options.source] = {};
      }
      transformCache[options.source][options.target] = new _transform(options);
    }
    return transformCache[options.source][options.target];
  }
  var m_this = this,
    m_proj,
    // The raw proj4js object
    m_source,
    // The source projection
    m_target,
    // The target projection
    m_source_matrix,
    // an additional transformation for the source
    m_source_matrix_inv,
    m_target_matrix,
    // an additional transformation for the target
    m_target_matrix_inv;
  var AffineFactorPositions = {
    s11: 0,
    s12: 4,
    s13: 8,
    xoff: 12,
    s21: 1,
    s22: 5,
    s23: 9,
    yoff: 13,
    s31: 2,
    s32: 6,
    s33: 10,
    zoff: 14
  };

  /**
   * Parse a projection string.  If the projection string includes any of
   * +s[123][123]= or +[xyz]off=, those values are converted into a matrix and
   * removed from the projection string.  This allows applying affine
   * transforms as specified in Proj 6.0.0 to be used (excluding toff and
   * tscale).  This could can be removed once proj4js supports the affine
   * parameters.
   *
   * @param {string} value A proj4 string possibly with affine parameters.
   * @returns {object} An object with a string value 'proj' and optional array
   *    values 'matrix' and 'inverse' (either both or neither will be present).
   *    The returned matrices are always 16-value arrays if present.  The proj
   *    value is the proj4 string with the affine parameters removed.
   */
  function parse_projection(value) {
    if (!affinePattern.exec(value)) {
      return {
        proj: value
      };
    }
    var mat = util.mat4AsArray(),
      newvalue = [],
      inv,
      result;
    value.split(/(\s+)/).forEach(function (part) {
      var match = /^\+(s[1-3][1-3]|[xyz]off)=(.*)$/.exec(part);
      if (!match) {
        newvalue.push(part);
      } else {
        mat[AffineFactorPositions[match[1]]] = parseFloat(match[2]);
      }
    });
    result = {
      proj: newvalue.join(' '),
      orig: value
    };
    inv = mat4.invert(util.mat4AsArray(), mat);
    // only store if the matrix is invertable
    if (inv) {
      result.matrix = mat;
      result.inverse = inv;
    } else {
      console.warn('Affine transform is not invertable and will not be used: ' + value); // eslint-disable-line no-console
    }
    return result;
  }

  /**
   * Generate the internal proj4 object.
   * @private
   */
  function generate_proj4() {
    var source_proj = parse_projection(m_this.source()),
      target_proj = parse_projection(m_this.target()),
      source = source_proj.proj,
      target = target_proj.proj;
    m_source_matrix = source_proj.matrix;
    m_source_matrix_inv = source_proj.inverse;
    m_target_matrix = target_proj.matrix;
    m_target_matrix_inv = target_proj.inverse;
    m_proj = new proj4(source, target);
  }

  /**
   * Get/Set the source projection.
   *
   * @param {string} [arg] The new source projection.  If `undefined`, return
   *    the current source projection.
   * @returns {string|this} The current source projection if it was queried,
   *    otherwise the current transform object.
   */
  this.source = function (arg) {
    if (arg === undefined) {
      return m_source || 'EPSG:4326';
    }
    m_source = arg;
    generate_proj4();
    return m_this;
  };

  /**
   * Get/Set the target projection.
   *
   * @param {string} [arg] The new target projection.  If `undefined`, return
   *    the current target projection.
   * @returns {string|this} The current target projection if it was queried,
   *    otherwise the current transform object.
   */
  this.target = function (arg) {
    if (arg === undefined) {
      return m_target || 'EPSG:3857';
    }
    m_target = arg;
    generate_proj4();
    return m_this;
  };

  /**
   * Perform a forward transformation (source -> target).
   * @protected
   *
   * @param {geo.geoPosition} point The point in source coordinates.
   * @returns {geo.geoPosition} A point object in the target coordinates.
   */
  this._forward = function (point) {
    if (m_source_matrix) {
      var mp = vec3.transformMat4(util.vec3AsArray(), [point.x, point.y, point.z || 0], m_source_matrix_inv);
      point = {
        x: mp[0],
        y: mp[1],
        z: mp[2]
      };
    }
    var pt = m_proj.forward(point, true);
    pt.z = point.z || 0;
    if (m_target_matrix) {
      var ip = vec3.transformMat4(util.vec3AsArray(), [pt.x, pt.y, pt.z], m_target_matrix);
      pt = {
        x: ip[0],
        y: ip[1],
        z: ip[2]
      };
    }
    return pt;
  };

  /**
   * Perform an inverse transformation (target -> source).
   * @protected
   *
   * @param {geo.geoPosition} point The point in target coordinates.
   * @returns {geo.geoPosition} A point object in the source coordinates.
   */
  this._inverse = function (point) {
    if (m_target_matrix) {
      var mp = vec3.transformMat4(util.vec3AsArray(), [point.x, point.y, point.z || 0], m_target_matrix_inv);
      point = {
        x: mp[0],
        y: mp[1],
        z: mp[2]
      };
    }
    var pt = m_proj.inverse(point, true);
    pt.z = point.z || 0;
    if (m_source_matrix) {
      var ip = vec3.transformMat4(util.vec3AsArray(), [pt.x, pt.y, pt.z], m_source_matrix);
      pt = {
        x: ip[0],
        y: ip[1],
        z: ip[2]
      };
    }
    return pt;
  };

  /**
   * Perform a forward transformation (source -> target) in place.
   * @protected
   *
   * @param {geo.geoPosition|geo.geoPosition[]} point The point coordinates
   *    or array of points in source coordinates.
   * @returns {geo.geoPosition|geo.geoPosition[]} A point object or array in
   *    the target coordinates.
   */
  this.forward = function (point) {
    if (Array.isArray(point)) {
      return point.map(m_this._forward);
    }
    return m_this._forward(point);
  };

  /**
   * Perform an inverse transformation (target -> source) in place.
   * @protected
   *
   * @param {geo.geoPosition|geo.geoPosition[]} point The point coordinates
   *    or array of points in target coordinates.
   * @returns {geo.geoPosition|geo.geoPosition[]} A point object or array in
   *    the source coordinates.
   */
  this.inverse = function (point) {
    if (Array.isArray(point)) {
      return point.map(m_this._inverse);
    }
    return m_this._inverse(point);
  };

  // Set defaults given by the constructor
  options = options || {};
  try {
    this.source(options.source);
  } catch (err) {
    console.error('Can\'t use transform source: ' + options.source); // eslint-disable-line no-console
    this.source('EPSG:4326');
  }
  try {
    this.target(options.target);
  } catch (err) {
    console.error('Can\'t use transform target: ' + options.target); // eslint-disable-line no-console
    this.target('EPSG:3857');
  }
  return this;
};

/**
 * Contains a reference to `proj4.defs`.  The functions serves two
 * purposes.
 *
 *   1. It is a key value mapping of all loaded projection definitions
 *   2. It is a function that will add additional definitions.
 *
 * See:
 *   http://proj4js.org/
 */
_transform.defs = proj4.defs;

/**
 * Look up a projection definition from epsg.io.
 * For the moment, we only handle `EPSG` codes.
 *
 * @param {string} projection A projection alias (e.g. EPSG:4326)
 * @returns {promise} Resolves with the proj4 definition
 */
_transform.lookup = function (projection) {
  var $ = __webpack_require__(5616);
  var code,
    defer = $.Deferred(),
    parts;
  if (proj4.defs.hasOwnProperty(projection)) {
    return defer.resolve(proj4.defs[projection]);
  }
  parts = projection.split(':');
  if (parts.length !== 2 || parts[0].toUpperCase() !== 'EPSG') {
    return defer.reject('Invalid projection code').promise();
  }
  code = parts[1];
  return $.ajax({
    url: 'https://epsg.io/' + encodeURIComponent(code) + '.proj4'
  }).done(function (data) {
    var result = (data.results || [])[0];
    if (!result) {
      return defer.reject(data).promise();
    }
    proj4.defs(projection, result);
    return $.when(proj4.defs[projection]);
  });
};

/**
 * Transform an array of coordinates from one projection into another.  The
 * transformation may occur in place (modifying the input coordinate array),
 * depending on the input format.  The coordinates can be an object with x,
 * y, and (optionally z) or an array of 2 or 3 values, or an array of either
 * of those, or a single flat array with 2 or 3 components per coordinate.
 * Arrays are always modified in place.  Individual point objects are not
 * altered; new point objects are returned unless no transform is needed.
 *
 * @param {string} srcPrj The source projection.
 * @param {string} tgtPrj The destination projection.
 * @param {geo.geoPosition|geo.geoPosition[]|number[]} coordinates An array of
 *    coordinate objects.  These may be in object or array form, or a flat
 *    array.
 * @param {number} [numberOfComponents] For flat arrays, either 2 or 3.
 * @returns {geo.geoPosition|geo.geoPosition[]|number[]} The transformed
 *    coordinates.
 */
_transform.transformCoordinates = function (srcPrj, tgtPrj, coordinates, numberOfComponents) {
  'use strict';

  if (srcPrj === tgtPrj || Array.isArray(coordinates) && !coordinates.length) {
    return coordinates;
  }
  if (Array.isArray(coordinates) && coordinates.length >= 3 && numberOfComponents === 3 && !util.isObject(coordinates[0]) && !affinePattern.test(srcPrj) && !affinePattern.test(tgtPrj)) {
    return _transform.transformCoordinatesFlatArray3(srcPrj, tgtPrj, coordinates);
  }
  if (Array.isArray(coordinates) && coordinates.length && util.isObject(coordinates[0]) && 'x' in coordinates[0] && 'y' in coordinates[0]) {
    var smatch = srcPrj.match(axisPattern),
      tmatch = tgtPrj.match(axisPattern);
    // if the two projections only differ in the middle axis
    if (smatch && tmatch && smatch[1] === tmatch[1] && smatch[3] === tmatch[3]) {
      if ('z' in coordinates[0]) {
        return coordinates.map(function (p) {
          return {
            x: +p.x,
            y: -p.y,
            z: +p.z || 0
          };
        });
      }
      return coordinates.map(function (p) {
        return {
          x: +p.x,
          y: -p.y
        };
      });
    }
  }
  var trans = _transform({
      source: srcPrj,
      target: tgtPrj
    }),
    output;
  if (util.isObject(coordinates) && 'x' in coordinates && 'y' in coordinates) {
    output = trans.forward({
      x: +coordinates.x,
      y: +coordinates.y,
      z: +coordinates.z || 0
    }, true);
    if ('z' in coordinates) {
      return output;
    }
    return {
      x: output.x,
      y: output.y
    };
  }
  if (Array.isArray(coordinates) && coordinates.length === 1 && util.isObject(coordinates[0]) && 'x' in coordinates[0] && 'y' in coordinates[0]) {
    output = trans.forward({
      x: +coordinates[0].x,
      y: +coordinates[0].y,
      z: +coordinates[0].z || 0
    }, true);
    if ('z' in coordinates[0]) {
      return [output];
    }
    return [{
      x: output.x,
      y: output.y
    }];
  }
  return _transform.transformCoordinatesArray(trans, coordinates, numberOfComponents);
};

/**
 * Transform an array of coordinates from one projection into another.  The
 * transformation may occur in place (modifying the input coordinate array),
 * depending on the input format.  The coordinates can be an array of 2 or 3
 * values, or an array of either of those, or a single flat array with 2 or 3
 * components per coordinate.  The array is modified in place.
 *
 * @param {transform} trans The transformation object.
 * @param {geo.geoPosition[]|number[]} coordinates An array of coordinate
 *      objects or a flat array.
 * @param {number} numberOfComponents For flat arrays, either 2 or 3.
 * @returns {geo.geoPosition[]|number[]} The transformed coordinates
 */
_transform.transformCoordinatesArray = function (trans, coordinates, numberOfComponents) {
  var i,
    count,
    offset,
    xAcc,
    yAcc,
    zAcc,
    writer,
    output,
    projPoint,
    initPoint = {};

  // Default Z accessor
  zAcc = function zAcc() {
    return 0.0;
  };

  // Helper methods
  function handleArrayCoordinates() {
    if (Array.isArray(coordinates[0])) {
      if (coordinates[0].length === 2) {
        xAcc = function xAcc(index) {
          return +coordinates[index][0];
        };
        yAcc = function yAcc(index) {
          return +coordinates[index][1];
        };
        writer = function writer(index, x, y) {
          output[index] = [x, y];
        };
      } else if (coordinates[0].length === 3) {
        xAcc = function xAcc(index) {
          return +coordinates[index][0];
        };
        yAcc = function yAcc(index) {
          return +coordinates[index][1];
        };
        zAcc = function zAcc(index) {
          return +coordinates[index][2];
        };
        writer = function writer(index, x, y, z) {
          output[index] = [x, y, z];
        };
      } else {
        throw new Error('Invalid coordinates. Requires two or three components per array');
      }
    } else {
      if (coordinates.length === 2) {
        offset = 2;
        xAcc = function xAcc(index) {
          return +coordinates[index * offset];
        };
        yAcc = function yAcc(index) {
          return +coordinates[index * offset + 1];
        };
        writer = function writer(index, x, y) {
          output[index] = x;
          output[index + 1] = y;
        };
      } else if (coordinates.length === 3) {
        offset = 3;
        xAcc = function xAcc(index) {
          return +coordinates[index * offset];
        };
        yAcc = function yAcc(index) {
          return +coordinates[index * offset + 1];
        };
        zAcc = function zAcc(index) {
          return +coordinates[index * offset + 2];
        };
        writer = function writer(index, x, y, z) {
          output[index] = x;
          output[index + 1] = y;
          output[index + 2] = z;
        };
      } else if (numberOfComponents) {
        if (numberOfComponents === 2 || numberOfComponents === 3) {
          offset = numberOfComponents;
          xAcc = function xAcc(index) {
            return +coordinates[index];
          };
          yAcc = function yAcc(index) {
            return +coordinates[index + 1];
          };
          if (numberOfComponents === 2) {
            writer = function writer(index, x, y) {
              output[index] = x;
              output[index + 1] = y;
            };
          } else {
            zAcc = function zAcc(index) {
              return +coordinates[index + 2];
            };
            writer = function writer(index, x, y, z) {
              output[index] = x;
              output[index + 1] = y;
              output[index + 2] = z;
            };
          }
        } else {
          throw new Error('Number of components should be two or three');
        }
      } else {
        throw new Error('Invalid coordinates');
      }
    }
  }

  // Helper methods
  function handleObjectCoordinates() {
    if (coordinates[0] && 'x' in coordinates[0] && 'y' in coordinates[0]) {
      xAcc = function xAcc(index) {
        return +coordinates[index].x;
      };
      yAcc = function yAcc(index) {
        return +coordinates[index].y;
      };
      if ('z' in coordinates[0]) {
        zAcc = function zAcc(index) {
          return +coordinates[index].z;
        };
        writer = function writer(index, x, y, z) {
          output[i] = {
            x: x,
            y: y,
            z: z
          };
        };
      } else {
        writer = function writer(index, x, y) {
          output[index] = {
            x: x,
            y: y
          };
        };
      }
    } else {
      throw new Error('Invalid coordinates');
    }
  }
  if (Array.isArray(coordinates)) {
    output = [];
    output.length = coordinates.length;
    count = coordinates.length;
    if (!coordinates.length) {
      return output;
    }
    if (Array.isArray(coordinates[0]) || util.isObject(coordinates[0])) {
      offset = 1;
      if (Array.isArray(coordinates[0])) {
        handleArrayCoordinates();
      } else if (util.isObject(coordinates[0])) {
        handleObjectCoordinates();
      }
    } else {
      handleArrayCoordinates();
    }
  } else {
    throw new Error('Coordinates are not valid');
  }
  for (i = 0; i < count; i += offset) {
    initPoint.x = xAcc(i);
    initPoint.y = yAcc(i);
    initPoint.z = zAcc(i);
    projPoint = trans.forward(initPoint, true);
    writer(i, projPoint.x, projPoint.y, projPoint.z);
  }
  return output;
};

/**
 * Transform an array of coordinates from one projection into another.  The
 * transformation occurs in place, modifying the input coordinate array.  The
 * coordinates are an array of [x0, y0, z0, x1, y1, z1, ...].
 *
 * @param {string} srcPrj The source projection.
 * @param {string} tgtPrj The destination projection.  This must not be the
 *    same as the source projection.
 * @param {number[]} coordinates A flat array of values.
 * @returns {number[]} The transformed coordinates.
 */
_transform.transformCoordinatesFlatArray3 = function (srcPrj, tgtPrj, coordinates) {
  'use strict';

  var i,
    smatch = srcPrj.match(axisPattern),
    tmatch = tgtPrj.match(axisPattern);
  // if the two projections only differ in the middle axis
  if (smatch && tmatch && smatch[1] === tmatch[1] && smatch[3] === tmatch[3]) {
    for (i = coordinates.length - 3 + 1; i >= 0; i -= 3) {
      coordinates[i] *= -1;
    }
    return coordinates;
  }
  var src = proj4.Proj(srcPrj),
    tgt = proj4.Proj(tgtPrj),
    projPoint,
    initPoint = {};
  var trans = new proj4(src, tgt);
  for (i = coordinates.length - 3; i >= 0; i -= 3) {
    initPoint.x = +coordinates[i];
    initPoint.y = +coordinates[i + 1];
    initPoint.z = +(coordinates[i + 2] || 0.0);
    projPoint = trans.forward(initPoint, true);
    coordinates[i] = projPoint.x;
    coordinates[i + 1] = projPoint.y;
    coordinates[i + 2] = projPoint.z === undefined ? initPoint.z : projPoint.z;
  }
  return coordinates;
};

/**
 * Apply an affine transformation consisting of a translation then a scaling
 * to the given coordinate array.  Note, the transformation occurs in place
 * so the input coordinate object are mutated.
 *
 * @param {object} def
 * @param {geo.geoPosition} def.origin The transformed origin
 * @param {object} def.scale The transformed scale factor.  This is an object
 *  with `x`, `y`, and `z` parameters.
 * @param {geo.geoPosition[]} coords An array of coordinate objects.
 * @returns {geo.geoPosition[]} The transformed coordinates.
 */
_transform.affineForward = function (def, coords) {
  'use strict';

  var i,
    origin = def.origin,
    scale = def.scale || {
      x: 1,
      y: 1,
      z: 1
    };
  for (i = 0; i < coords.length; i += 1) {
    coords[i].x = (coords[i].x - origin.x) * scale.x;
    coords[i].y = (coords[i].y - origin.y) * scale.y;
    coords[i].z = ((coords[i].z || 0) - (origin.z || 0)) * scale.z;
  }
  return coords;
};

/**
 * Apply an inverse affine transformation which is the inverse to
 * {@link geo.transform.affineForward}.  Note, the transformation occurs in
 * place so the input coordinate object are mutated.
 *
 * @param {object} def
 * @param {geo.geoPosition} def.origin The transformed origin
 * @param {object} def.scale The transformed scale factor.  This is an object
 *  with `x`, `y`, and `z` parameters.
 * @param {geo.geoPosition[]} coords An array of coordinate objects.
 * @returns {geo.geoPosition[]} The transformed coordinates.
 */
_transform.affineInverse = function (def, coords) {
  'use strict';

  var i,
    origin = def.origin,
    scale = def.scale || {
      x: 1,
      y: 1,
      z: 1
    };
  for (i = 0; i < coords.length; i += 1) {
    coords[i].x = coords[i].x / scale.x + origin.x;
    coords[i].y = coords[i].y / scale.y + origin.y;
    coords[i].z = (coords[i].z || 0) / scale.z + (origin.z || 0);
  }
  return coords;
};

/**
 * Compute the distance on the surface on a sphere.  The sphere is the major
 * radius of a specified ellipsoid.  Altitude is ignored.
 *
 * @param {geo.geoPosition} pt1 The first point.
 * @param {geo.geoPosition} pt2 The second point.
 * @param {string|geo.transform} [gcs] `undefined` to use the same gcs as the
 *    ellipsoid, otherwise the gcs of the points.
 * @param {string|geo.transform} [baseGcs] the gcs of the
 *    ellipsoid.
 * @param {object} [ellipsoid] An object with at least `a` and one
 *    of `b`, `f`, or `rf` (1 / `f`) -- this works with  proj4 ellipsoid
 *    definitions.
 * @returns {number} The distance in meters (or whatever units the ellipsoid
 *    was specified in.
 */
_transform.sphericalDistance = function (pt1, pt2, gcs, baseGcs, ellipsoid) {
  baseGcs = baseGcs || 'EPSG:4326';
  ellipsoid = ellipsoid || proj4.WGS84;
  gcs = gcs || baseGcs;
  if (gcs !== baseGcs) {
    var pts = _transform.transformCoordinates(gcs, baseGcs, [pt1, pt2]);
    pt1 = pts[0];
    pt2 = pts[1];
  }
  // baseGcs must be in degrees or this will be wrong
  var phi1 = pt1.y * Math.PI / 180,
    phi2 = pt2.y * Math.PI / 180,
    lambda = (pt2.x - pt1.x) * Math.PI / 180,
    sinphi1 = Math.sin(phi1),
    cosphi1 = Math.cos(phi1),
    sinphi2 = Math.sin(phi2),
    cosphi2 = Math.cos(phi2);
  var sigma = Math.atan2(Math.pow(Math.pow(cosphi2 * Math.sin(lambda), 2) + Math.pow(cosphi1 * sinphi2 - sinphi1 * cosphi2 * Math.cos(lambda), 2), 0.5), sinphi1 * sinphi2 + cosphi1 * cosphi2 * Math.cos(lambda));
  return ellipsoid.a * sigma;
};

/**
 * Compute the Vincenty distance on the surface on an ellipsoid.  Altitude is
 * ignored.
 *
 * @param {geo.geoPosition} pt1 The first point.
 * @param {geo.geoPosition} pt2 The second point.
 * @param {string|geo.transform} [gcs] `undefined` to use the same gcs as the
 *    ellipsoid, otherwise the gcs of the points.
 * @param {string|geo.transform} [baseGcs] the gcs of the
 *    ellipsoid.
 * @param {object} [ellipsoid] An object with at least `a` and one
 *    of `b`, `f`, or `rf` (1 / `f`) -- this works with  proj4 ellipsoid
 *    definitions.
 * @param {number} [maxIterations] Maximum number of iterations to use
 *    to test convergence.
 * @returns {object} An object with `distance` in meters (or whatever units the
 *    ellipsoid was specified in), `alpha1` and `alpha2`, the azimuths at the
 *    two points in radians.  The result may be `undefined` if the formula
 *    fails to converge, which can happen near antipodal points.
 */
_transform.vincentyDistance = function (pt1, pt2, gcs, baseGcs, ellipsoid, maxIterations) {
  baseGcs = baseGcs || 'EPSG:4326';
  ellipsoid = ellipsoid || proj4.WGS84;
  maxIterations = maxIterations || 100;
  gcs = gcs || baseGcs;
  if (gcs !== baseGcs) {
    var pts = _transform.transformCoordinates(gcs, baseGcs, [pt1, pt2]);
    pt1 = pts[0];
    pt2 = pts[1];
  }
  var a = ellipsoid.a,
    b = ellipsoid.b || ellipsoid.a * (1.0 - (ellipsoid.f || 1.0 / ellipsoid.rf)),
    f = ellipsoid.f || (ellipsoid.rf ? 1.0 / ellipsoid.rf : 1.0 - b / a),
    // baseGcs must be in degrees or this will be wrong
    phi1 = pt1.y * Math.PI / 180,
    phi2 = pt2.y * Math.PI / 180,
    L = ((pt2.x - pt1.x) % 360 + 360) % 360 * Math.PI / 180,
    U1 = Math.atan((1 - f) * Math.tan(phi1)),
    // reduced latitude
    U2 = Math.atan((1 - f) * Math.tan(phi2)),
    sinU1 = Math.sin(U1),
    cosU1 = Math.cos(U1),
    sinU2 = Math.sin(U2),
    cosU2 = Math.cos(U2),
    lambda = L,
    lastLambda = L + Math.PI * 2,
    sinSigma,
    cosSigma,
    sigma,
    sinAlpha,
    cos2alpha,
    cos2sigmasubm,
    C,
    u2,
    A,
    B,
    deltaSigma,
    iter;
  if (phi1 === phi2 && !L) {
    return {
      distance: 0,
      alpha1: 0,
      alpha2: 0
    };
  }
  for (iter = maxIterations; iter > 0 && Math.abs(lambda - lastLambda) > 1e-12; iter -= 1) {
    sinSigma = Math.pow(Math.pow(cosU2 * Math.sin(lambda), 2) + Math.pow(cosU1 * sinU2 - sinU1 * cosU2 * Math.cos(lambda), 2), 0.5);
    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * Math.cos(lambda);
    sigma = Math.atan2(sinSigma, cosSigma);
    sinAlpha = cosU1 * cosU2 * Math.sin(lambda) / sinSigma;
    cos2alpha = 1 - Math.pow(sinAlpha, 2);
    // cos2alpha is zero only when phi1 and phi2 are nearly zero.  In this
    // case, sinU1 and sinU2 are nearly zero and the the second term can be
    // dropped
    cos2sigmasubm = cosSigma - (cos2alpha ? 2 * sinU1 * sinU2 / cos2alpha : 0);
    C = f / 16 * cos2alpha * (4 + f * (4 - 3 * cos2alpha));
    lastLambda = lambda;
    lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2sigmasubm + C * cosSigma * (-1 + 2 * Math.pow(cos2sigmasubm, 2))));
  }
  if (!iter) {
    // failure to converge
    return;
  }
  u2 = cos2alpha * (a * a - b * b) / (b * b);
  A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
  B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
  deltaSigma = B * sinSigma * (cos2sigmasubm + B / 4 * (cosSigma * (-1 + 2 * Math.pow(cos2sigmasubm, 2)) - B / 6 * cos2sigmasubm * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * Math.pow(cos2sigmasubm, 2))));
  return {
    distance: b * A * (sigma - deltaSigma),
    alpha1: Math.atan2(cosU2 * Math.sin(lambda), cosU1 * sinU2 - sinU1 * cosU2 * Math.cos(lambda)),
    alpha2: Math.atan2(cosU1 * Math.sin(lambda), -sinU1 * cosU2 + cosU1 * sinU2 * Math.cos(lambda))
  };
};

/**
 * Return a boolean indicating if the projections only differ in their y
 * coordinate.
 *
 * @param {string} srcPrj The source projection.
 * @param {string} tgtPrj The destination projection.
 * @returns {boolean} truthy if only the y coordinate is different between
 *    projections.
 */
_transform.onlyInvertedY = function (srcPrj, tgtPrj) {
  var smatch = srcPrj.match(axisPattern),
    tmatch = tgtPrj.match(axisPattern);
  return smatch && tmatch && smatch[1] === tmatch[1] && smatch[3] === tmatch[3];
};

/* Expose proj4 to make it easier to debug */
_transform.proj4 = proj4;
module.exports = _transform;

/***/ }),

/***/ 3170:
/***/ (function(module) {

/*
 * Type definitions for jsdoc.
 */

/**
 * General representation of rectangular bounds in world coordinates.
 *
 * @typedef geo.geoBounds
 * @type {object}
 * @property {number} left Horizontal coordinate of the top-left corner.
 * @property {number} top Vertical coordinate of the top-left corner.
 * @property {number} right Horizontal coordinate of the bottom-right corner.
 * @property {number} bottom Vertical coordinate of the bottom-right corner.
 */

/**
 * A location and zoom value.
 *
 * @typedef geo.zoomAndCenter
 * @type {object}
 * @property {geo.geoPosition} center The center coordinates.
 * @property {number} zoom The zoom level.
 */

/**
 * General representation of rectangular bounds in pixel coordinates.
 *
 * @typedef geo.screenBounds
 * @type {object}
 * @property {geo.screenPosition} upperLeft Upper left corner.
 * @property {geo.screenPosition} upperRight Upper right corner.
 * @property {geo.screenPosition} lowerLeft Lower left corner.
 * @property {geo.screenPosition} lowerRight Lower right corner.
 */

/**
 * General representation of a point on the screen.
 *
 * @typedef geo.screenPosition
 * @type {object}
 * @property {number} x Horizontal coordinate in pixels.
 * @property {number} y Vertical coordinate in pixels.
 */

/**
 * General representation of a point on the earth.  The coordinates are most
 * commonly in longitude and latitude, but the coordinate system is changed
 * by the interface gcs.
 *
 * @typedef geo.geoPosition
 * @type {object}
 * @property {number} x Horizontal coordinate, often degrees longitude.
 * @property {number} y Vertical coordinate, often degrees latitude.
 * @property {number} [z=0] Altitude coordinate.
 */

/**
 * General representation of a point on the earth.  The coordinates are most
 * commonly in longitude and latitude, but the coordinate system is changed
 * by the interface gcs.  This is a list of numbers consisting of either [x, y]
 * or [x, y, z], where therse are the horizontal, vertical, and altitude
 * coordinates.
 *
 * @typedef geo.geoPositionFlat
 * @type {number[]}
 */

/**
 * General representation of a two-dimensional point in any coordinate system.
 *
 * @typedef geo.point2D
 * @type {object}
 * @property {number} x Horizontal coordinate.
 * @property {number} y Vertical coordinate.
 */

/**
 * Representation of a point on the map.  The coordinates are in the map's
 * reference system, possibly with an affine transformation.
 *
 * @typedef geo.worldPosition
 * @type {object}
 * @property {number} x Horizontal coordinate in map coordinates.
 * @property {number} y Vertical coordinate in map coordinates.
 * @property {number} [z=0] Altitude coordinate, often zero.
 */

/**
 * Representation of a size in gcs coordinates.
 *
 * @typedef geo.geoSize
 * @type {object}
 * @property {number} width Width in gcs coordinates.
 * @property {number} height Height in gcs coordinates.
 */

/**
 * Representation of a size in pixels.
 *
 * @typedef geo.screenSize
 * @type {object}
 * @property {number} width Width in pixels.
 * @property {number} height Height in pixels.
 */

/**
 * The status of all mouse buttons.
 *
 * @typedef geo.mouseButtons
 * @type {object}
 * @property {boolean} left True if the left mouse button is down.
 * @property {boolean} right True if the right mouse button is down.
 * @property {boolean} middle True if the middle mouse button is down.
 */

/**
 * The status of all modifier keys.  These are usually copied from the
 * standard DOM events.
 *
 * @typedef geo.modifierKeys
 * @type {object}
 * @property {boolean} alt True if the alt or option key is down.
 * @property {boolean} ctrl True if the control key is down.
 * @property {boolean} shift True if the shift key is down.
 * @property {boolean} meta True if the meta, windows, or command key
 *      is down.
 */

/**
 * The state of the mouse.
 *
 * @typedef geo.mouseState
 * @type {object}
 * @property {geo.screenPosition} page Mouse location in pixel space relative
 *      to the entire browser window.
 * @property {geo.screenPosition} map Mouse location in pixel space relative to
 *      the map DOM node.
 * @property {geo.geoPosition} geo Mouse location in interface gcs space.
 * @property {geo.geoPosition} mapgcs Mouse location in gcs space.
 * @property {geo.mouseButtons} buttons The current state of the mouse buttons.
 * @property {geo.modifierKeys} modifiers The current state of all modifier
 *      keys.
 * @property {Date} time The timestamp the event took place.
 * @property {number} deltaTime The time in milliseconds since the last mouse
 *      event.
 * @property {geo.screenPosition} velocity The velocity of the mouse pointer
 *      in pixels per millisecond.
 */

/**
 * The current brush selection (this is when a rectangular area is selected by
 * dragging).
 *
 * @typedef geo.brushSelection
 * @type {object}
 * @property {geo.screenBounds} display The selection bounds in pixel space.
 * @property {object} gcs The selection bounds in the map's gcs.
 * @property {geo.geoPosition} gcs.upperLeft Upper left corner.
 * @property {geo.geoPosition} gcs.upperRight Upper right corner.
 * @property {geo.geoPosition} gcs.lowerLeft Lower left corner.
 * @property {geo.geoPosition} gcs.lowerRight Lower right corner.
 * @property {geo.mouseState} mouse The current mouse state.
 * @property {geo.mouseState} origin The mouse state at the start of the
 *      brush action.
 */

/**
 * The conditions that are necessary to make an action occur.
 *
 * @typedef geo.actionRecord
 * @type {object}
 * @property {string} action The name of the action, from (@link geo.action}.
 * @property {string} [owner] A name of an owning process that can be used to
 *      locate or filter actions.
 * @property {string} [name] A human-readable name that can be used to locate
 *      or filter actions.
 * @property {string|object} input The name of an input that is used for the
 *      action, or an object with input names as keys and boolean values of
 *      inputs that are required to occur or required to not occur to trigger
 *      the action.  Input names include `left`, `right`, `middle` (for mouse
 *      buttons), `wheel` (the mouse wheel), `pan` (touch pan), `rotate` (touch
 *      rotate).
 * @property {string|object} [modifiers] The name of a modifier key or an
 *      object with modifiers as the keys and boolean values.  The listed
 *      modifiers must be set or unset depending on the boolean value.
 *      Modifiers include `shift`, `ctrl`, `alt`, and `meta`.
 * @property {boolean|string} [selectionRectangle] If truthy, a selection
 *      rectangle is shown during the action.  If a string, the name of an
 *      event that is triggered when the selection is complete.
 */

/**
 * The current action state a map interactor.
 *
 * @typedef geo.actionState
 * @type {object}
 * @property {string} action Name of the action that is being handled.
 * @property {geo.actionRecord} actionRecord The action record which triggered
 *      the current action.
 * @property {string} [origAction] The name of an action that triggered this
 *      action.
 * @property {geo.mouseState} origin The mouse state at the start of the
 *      action.
 * @property {number} initialZoom The zoom level at the start of the action.
 * @property {number} initialRotation The map's rotation in radians at the
 *      start of the action.
 * @property {number} initialEventRotation The rotation reported by the
 *      event that triggered this action.  For example, this could be the
 *      angle between two multi-touch points.
 * @property {object} delta The total movement of during the action in gcs
 *      coordinates.
 * @property {number} delta.x The horizontal movement during the action.
 * @property {number} delta.y The vertical movement during the action.
 * @property {boolean} boundDocumentHandlers `true` if the mouse is down and
 *      being tracked.
 * @property {Date} [start] The time when the action started.
 * @property {Function} [handler] A function to call on every animation from
 *      while the action is occurring.
 * @property {geo.mouseState} [momentum] The mouse location when a momentum
 *      action starts.
 * @property {boolean} [zoomrotateAllowRotation] Truthy if enough movement has
 *      occurred that rotations are allowed.
 * @property {boolean} [zoomrotateAllowZoom] Truthy if enough movement has
 *      occurred that zooms are allowed.
 * @property {boolean} [zoomrotateAllowPan] Truthy if enough movement has
 *      occurred that pans are allowed.
 * @property {number} [lastRotationDelta] When rotating, the last amount that
 *      was rotated from the start of the action.  This is used to debounce
 *      jitter on touch events.
 * @property {geo.geoPosition} [initialEventGeo] The position of the mouse
 *      when significant movement first occurred.
 */

/**
 * Polygon as a flat array.  An array of vertices.  The polygon has no holes.
 * The first and last point of may be the same.
 *
 * @typedef {geo.geoPosition[]} geo.polygonFlat
 */

/**
 * Polygon as a object.  The polygon may have holes.
 *
 * @typedef {object} geo.polygonObject
 * @property {geo.geoPosition[]} outer An array of vertices defining the
 *   outside of the polygon.  The first and last point of may be the same.
 * @property {Array.<geo.geoPosition[]>} [inner] An array of holes, each of
 *   which is an array of vertices.  The first and last point of may be the
 *  same.
 */

/**
 * Polygon.
 *
 * @typedef {geo.polygonFlat|geo.polygonObject} geo.polygon
 */

module.exports = {};

/***/ }),

/***/ 5734:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var d3 = (__webpack_require__(2493).d3);
var domWidget = __webpack_require__(8524);
var inherit = __webpack_require__(4626);
var registerWidget = (__webpack_require__(1098).registerWidget);
var util = __webpack_require__(642);
var uniqueID = __webpack_require__(7376);
__webpack_require__(1159);

/**
 * @typedef {object} geo.gui.colorLegendWidget.category
 * @property {string} name The text label of the legend.
 * @property {string} type The type of the legend, either discrete or continuous.
 * @property {string} scale The scale of the legend. For discrete type,
 * linear, log, sqrt, pow, ordinal, and quantile is supported.
 * For continuous type, linear, log, sqrt, and pow is supported.
 * @property {number[]|string[]} domain Only for ordinal scale legend, string
 * values are acceptable. For ordinal legend, the number in the domain array
 * should be the same number of colors. For quantile scale legend, the domain
 * should be an array of all values. For other scales, the domain needs to be
 * an array of two number for marking the upper bound and lower bound.
 * This domain property will be used with d3 scale object internally.
 * @property {geo.geoColor[]} colors The colors of the legend.
 * All valid svg color can be used. For discrete type, multiple values
 * are accepted. For continuous type, an array of two values is supported.
 * @property {number} [base] The base of log when log scale is used.
 * default to 10.
 * @property {number} [exponent] The exponent of power when power scale is used.
 * default to 1.
 * @property {boolean} [endAxisLabelOnly] Only show left most and right most
 * axis label
 * default to null.
 */

/**
 * A UI widget that enables display discrete colors or two-color continuous
 *  transition legend.
 *
 * @class
 * @alias geo.gui.colorLegendWidget
 * @extends geo.gui.domWidget
 * @param {object} [arg] Widget options.
 * @param {geo.gui.widget.position} [arg.position] Position setting relatively to the map
 * container.
 * @param {geo.gui.colorLegendWidget.category[]} [arg.categories] An array
 * of category definitions for the initial color legends
 * @param {number} [arg.width] The width of the widget in pixels.
 * @param {number} [arg.ticks] The maximum number of ticks on the axis of a legend, default is 6.
 * @returns {geo.gui.colorLegendWidget}
 */
var _colorLegendWidget = function colorLegendWidget(arg) {
  'use strict';

  if (!(this instanceof _colorLegendWidget)) {
    return new _colorLegendWidget(arg);
  }
  domWidget.call(this, arg);
  var m_this = this,
    m_categories = [],
    m_width = arg.width || 300,
    m_ticks = arg.ticks || 6,
    s_init = this._init;
  // get the widget container ready
  this._init = function () {
    s_init();
    var canvas = m_this.canvas();
    d3.select(canvas).attr('class', 'color-legend-container');
    m_this.popup = d3.select(canvas).append('div').attr('class', 'color-legend-popup');
    if (arg.categories) {
      m_this.categories(arg.categories);
    }
  };

  /**
   * Clear the DOM container and create legends.
   */
  this._draw = function () {
    d3.select(m_this.canvas()).selectAll('div.geojs-color-legends').remove();
    if (!m_categories.length) {
      d3.select(m_this.canvas()).style('display', 'none');
      return;
    } else {
      d3.select(m_this.canvas()).style('display', 'block');
    }
    var container = d3.select(m_this.canvas()).append('div').attr('class', 'geojs-color-legends');
    var width = m_width;
    var margin = 20;
    m_categories.forEach(function (category, index) {
      var legendContainer = container.append('div').attr('class', 'geojs-color-legend');
      legendContainer.append('div').attr('class', 'geojs-title').text(category.name);
      var legendSvg = legendContainer.append('svg').attr('class', 'svg').attr('width', width).attr('height', '40px').attr('viewBox', -margin + ' 0 ' + width + ' 40');
      if (category.type === 'discrete') {
        m_this._drawDiscrete(legendSvg, width - 2 * margin, category);
      } else if (category.type === 'continuous') {
        m_this._drawContinous(legendSvg, width - 2 * margin, category);
      }
    });
  };

  /**
   * Get or set categories.
   * @param {geo.gui.colorLegendWidget.category[]} [categories] If `undefined`,
   * return the current legend categories array. If an array is provided,
   * remove current legends and recreate with the new categories.
   * @returns {geo.gui.colorLegendWidget.category[]|this}
   * The current list of categories or the current class instance.
   */
  this.categories = function (categories) {
    if (categories === undefined) {
      return m_categories;
    }
    m_categories = m_this._prepareCategories(categories);
    m_this._draw();
    return m_this;
  };

  /**
   * Add additional categories.
   * @param {geo.gui.colorLegendWidget.category[]} categories Append additional
   * legend categories to the end the of the current list of legends.
   * @returns {this} The current class instance.
   */
  this.addCategories = function (categories) {
    m_categories = m_categories.concat(m_this._prepareCategories(categories));
    m_this._draw();
    return m_this;
  };

  /**
   * Remove categories.
   *
   * @param {geo.gui.colorLegendWidget.category[]} categories If a category
   * object exists in the current legend categories, that category will be
   * removed.
   * @returns {this} The current class instance.
   */
  this.removeCategories = function (categories) {
    m_categories = m_categories.filter(function (category) {
      return categories.indexOf(category) === -1;
    });
    m_this._draw();
    return m_this;
  };

  /**
   * This function normalize color input string with the utility function. It modifies the original object.
   * @param {geo.gui.colorLegendWidget.category[]} categories The categories
   * @returns {geo.gui.colorLegendWidget.category[]} prepared categories
   */
  this._prepareCategories = function (categories) {
    categories.forEach(function (category) {
      category.color = category.colors.map(function (color) {
        return util.convertColorToHex(color, true);
      });
    });
    return categories;
  };

  /**
   * Draw an individual discrete type legend.
   * @param {Element} svg svg element that the legend will be drawn
   * @param {number} width width of the svg element in pixel
   * @param {geo.gui.colorLegendWidget.category} category The discrete type legend category
   */
  this._drawDiscrete = function (svg, width, category) {
    /**
     * Render the d3 axis object based on the axis d3 Scale.
     * @param {object} axisScale d3 scale object
     * @returns {object} d3 axis object
     */
    function createAxis(axisScale) {
      var skip = Math.ceil(axisScale.domain().length / m_ticks);
      var values = axisScale.domain().filter(function (d, i) {
        return i % skip === 0;
      });
      return d3.axisBottom(axisScale).tickFormat(d3.format('.2s')).tickValues(values);
    }
    if (['linear', 'log', 'sqrt', 'pow', 'quantile', 'ordinal'].indexOf(category.scale) === -1) {
      throw new Error('unsupported scale');
    }
    var valueRange, valueScale, colorScale, axisScale, axis, steps, ticks;
    if (category.scale === 'ordinal') {
      colorScale = d3.scaleOrdinal().domain(category.domain).range(category.colors);
      m_this._renderDiscreteColors(svg, category.domain, colorScale, width, function (d) {
        return d;
      });
      axisScale = d3.scaleBand().domain(category.domain).rangeRound([0, width]);
      var skip = Math.ceil(category.domain.length / m_ticks);
      var values = category.domain.filter(function (d, i) {
        return i % skip === 0;
      });
      axis = d3.axisBottom(axisScale).tickValues(values);
    } else if (category.scale === 'quantile') {
      valueRange = [0, category.colors.length];
      steps = util.range(0, category.colors.length - 1);
      valueScale = d3.scaleQuantile().domain(category.domain).range(steps);
      colorScale = d3.scaleQuantize().domain(valueRange).range(category.colors);
      m_this._renderDiscreteColors(svg, steps, colorScale, width, function (d) {
        return valueScale.invertExtent(d).join(' - ');
      });
      var axisDomain = [valueScale.invertExtent(0)[0]];
      axisDomain = axisDomain.concat(steps.map(function (step) {
        return valueScale.invertExtent(step)[1];
      }));
      axisScale = d3.scalePoint().domain(axisDomain).range([0, width]);
      axis = createAxis(axisScale);
    } else if (['linear', 'log', 'sqrt', 'pow'].indexOf(category.scale) !== -1) {
      valueRange = [0, category.colors.length];
      valueScale = d3['scale' + category.scale.charAt(0).toUpperCase() + category.scale.slice(1)]().domain(category.domain).range(valueRange).nice();
      colorScale = d3.scaleQuantize().domain(valueRange).range(category.colors);
      steps = util.range(0, category.colors.length - 1);
      var precision = Math.max.apply(null, category.domain.map(function (number) {
        return getPrecision(number);
      }));
      m_this._renderDiscreteColors(svg, steps, colorScale, width, function (d) {
        return m_this._popupFormatter(valueScale.invert(d), precision) + ' - ' + m_this._popupFormatter(valueScale.invert(d + 1), precision);
      });
      ticks = steps.slice();
      ticks.push(category.colors.length);
      axisScale = d3.scalePoint().domain(ticks.map(function (tick) {
        return valueScale.invert(tick);
      })).range([0, width]);
      axis = createAxis(axisScale);
    }
    if (category.endAxisLabelOnly) {
      axis.tickValues([axisScale.domain()[0], axisScale.domain()[axisScale.domain().length - 1]]);
    }
    m_this._renderAxis(svg, axis);
  };

  /**
   * Render colors for discrete type with d3.
   * @param {Element} svg svg element that the legend will be drawn
   * @param {number[]} steps discrete input scale domain for d3 scale
   * @param {object} colorScale d3 scale for transform input into color
   * @param {number} width width of the svg element in pixel
   * @param {Function} getValue function that transforms raw domain into desired discrete range
   */
  this._renderDiscreteColors = function (svg, steps, colorScale, width, getValue) {
    svg.selectAll('rect').data(steps).enter().append('rect').attr('width', width / steps.length).attr('height', '20px').attr('fill', function (d) {
      return colorScale(d);
    }).attr('transform', function (d, i) {
      return 'translate(' + i * width / steps.length + ' ,0)';
    }).on('mousemove', function (evt, d) {
      m_this._showPopup(evt, getValue(d));
    }).on('mouseout', m_this._hidePopup);
  };

  /**
   * Draw an individual continuous type legend.
   * @param {Element} svg svg element that the legend will be drawn
   * @param {number} width width of the svg element in pixel
   * @param {geo.gui.colorLegendWidget.category} category The continuous type legend category
   */
  this._drawContinous = function (svg, width, category) {
    var axisScale, axis, i;
    if (['linear', 'log', 'sqrt', 'pow'].indexOf(category.scale) === -1) {
      throw new Error('unsupported scale');
    }
    var range = [0];
    for (i = 1; i < category.domain.length - 1; i++) {
      range.push(width / (category.domain.length - 1) * i);
    }
    range.push(width);
    axisScale = d3['scale' + category.scale.charAt(0).toUpperCase() + category.scale.slice(1)]().domain(category.domain).range(range).nice();
    if (category.scale === 'log' && category.base) {
      axisScale.base(category.base);
    }
    if (category.scale === 'pow' && category.exponent) {
      axisScale.exponent(category.exponent);
    }
    var id = uniqueID();
    var precision = Math.max.apply(null, category.domain.map(function (number) {
      return getPrecision(number);
    }));
    var gradient = svg.append('defs').append('linearGradient').attr('id', 'gradient' + id);
    gradient.append('stop').attr('offset', '0%').attr('stop-color', category.colors[0]);
    for (i = 1; i < category.colors.length - 1; i++) {
      gradient.append('stop').attr('offset', (100 / (category.colors.length - 1) * i).toFixed(6) + '%').attr('stop-color', category.colors[i]);
    }
    gradient.append('stop').attr('offset', '100%').attr('stop-color', category.colors[category.colors.length - 1]);
    svg.append('rect').attr('fill', 'url(#gradient' + id + ')').attr('width', width).attr('height', '20px').on('mousemove', function (event) {
      var value = axisScale.invert(d3.pointer(event)[0]);
      var text = m_this._popupFormatter(value, precision);
      m_this._showPopup(event, text);
    }).on('mouseout', m_this._hidePopup);
    axis = d3.axisBottom(axisScale).ticks(m_ticks, '.2s');
    if (category.endAxisLabelOnly) {
      axis.tickValues([category.domain[0], category.domain[category.domain.length - 1]]);
    }
    m_this._renderAxis(svg, axis);
  };

  /**
   * Actually render the axis with d3.
   * @param {Element} svg svg element that the axis will be drawn
   * @param {object} axis d3 axis object
   */
  this._renderAxis = function (svg, axis) {
    svg.append('g').attr('class', 'axis x').attr('transform', 'translate(0, 20)')
    /*
    .call(function (g) {
      g.call(axis);
    });
    */.call(axis);
  };

  /**
   * Formatter of number that tries to maximize the precision
   * while making the output shorter.
   * @param {number} number to be formatted
   * @param {number} precision maximum number of decimal places that are kept
   * @returns {string} formatted string output
   */
  this._popupFormatter = function (number, precision) {
    number = parseFloat(number.toFixed(8));
    precision = Math.min(precision, getPrecision(number));
    precision = Math.min(precision, Math.max(3, 7 - Math.trunc(number).toString().length));
    return d3.format('.' + precision + 'f')(number);
  };

  /**
   * Get/Set width.
   *
   * @param {number} [width] If not specified, return the current width.  If
   *    specified, set a new width.
   * @returns {this|number}
   */
  this.width = function (width) {
    if (width === undefined) {
      return m_width;
    } else if (width !== m_width) {
      m_width = width;
      m_this._prepareCategories(m_categories);
      m_this._draw();
    }
    return m_this;
  };

  /**
   * Get/Set ticks.
   *
   * @param {number} [ticks] If not specified, return the current ticks.  If
   *    specified, set a new ticks.
   * @returns {this|number}
   */
  this.ticks = function (ticks) {
    if (ticks === undefined) {
      return m_ticks;
    } else if (ticks !== m_ticks) {
      m_ticks = ticks;
      m_this._prepareCategories(m_categories);
      m_this._draw();
    }
    return m_this;
  };

  /**
   * Show the popup based on current mouse event.
   * @param {d3.event} event The triggering d3 event.
   * @param {string} text content to be shown in the popup
   */
  this._showPopup = function (event, text) {
    // The cursor location relative to the container
    var offset = d3.pointer(event, m_this.canvas());
    m_this.popup.text(text);
    var containerWidth = m_this.canvas().clientWidth;
    var popupWidth = m_this.popup.node().clientWidth;
    m_this.popup
    // If the popup will be longer or almost longer than the container
    .style('left', offset[0] - (offset[0] + popupWidth - containerWidth > -10 ? popupWidth : 0) + 'px').style('top', offset[1] - 22 + 'px').transition().duration(200).style('opacity', 1);
  };

  /**
   * Hide the popup.
   */
  this._hidePopup = function () {
    m_this.popup.transition().duration(200).style('opacity', 0);
  };
  return this;
};

/**
 * Get the number of decimals of a number.
 *
 * @private
 * @param {number} number the number input
 * @returns {number} the number of decimal
 */
function getPrecision(number) {
  if (!isFinite(number)) return 0;
  var e = 1,
    p = 0;
  while (Math.round(number * e) / e !== number) {
    if (!isFinite(number * e)) {
      return 0;
    }
    e *= 10;
    p++;
  }
  return p;
}
inherit(_colorLegendWidget, domWidget);
registerWidget('dom', 'colorLegend', _colorLegendWidget);
module.exports = _colorLegendWidget;

/***/ }),

/***/ 8524:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var widget = __webpack_require__(8738);
var inherit = __webpack_require__(4626);
var registerWidget = (__webpack_require__(1098).registerWidget);

/**
 * Create a new instance of class domWidget.
 *
 * @class
 * @alias geo.gui.domWidget
 * @extends geo.gui.widget
 * @param {object} arg
 * @param {geo.widget} [parent] A parent widget for this widget.
 * @param {string} [el] The type of DOM element to create.
 * @returns {geo.domWidget}
 */
var _domWidget = function domWidget(arg) {
  'use strict';

  if (!(this instanceof _domWidget)) {
    return new _domWidget(arg);
  }
  widget.call(this, arg);
  var m_this = this,
    m_default_canvas = 'div';

  /**
   * Initializes DOM Widget.
   * Sets the canvas for the widget, does parent/child relationship management,
   * appends it to it's parent and handles any positioning logic.
   *
   * @returns {this}
   */
  this._init = function () {
    if (arg.hasOwnProperty('parent')) {
      arg.parent.addChild(m_this);
    }
    m_this._createCanvas();
    m_this._appendCanvasToParent();
    m_this.canvas().addEventListener('mousedown', function (e) {
      e.stopPropagation();
    });
    m_this.reposition();
    return m_this;
  };

  /**
   * Creates the widget canvas.  This is a DOM element (`arg.el` or a div).
   */
  this._createCanvas = function () {
    m_this.canvas(document.createElement(arg.el || m_default_canvas));
  };
  return this;
};
inherit(_domWidget, widget);
registerWidget('dom', 'dom', _domWidget);
module.exports = _domWidget;

/***/ }),

/***/ 4812:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @namespace geo.gui
 */
module.exports = {
  colorLegendWidget: __webpack_require__(5734),
  domWidget: __webpack_require__(8524),
  legendWidget: __webpack_require__(9443),
  scaleWidget: __webpack_require__(2894),
  sliderWidget: __webpack_require__(3019),
  svgWidget: __webpack_require__(7854),
  uiLayer: __webpack_require__(4231),
  widget: __webpack_require__(8738)
};

/***/ }),

/***/ 9443:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var svgWidget = __webpack_require__(7854);
var inherit = __webpack_require__(4626);
var registerWidget = (__webpack_require__(1098).registerWidget);

/**
 * @typedef {object} geo.gui.legendWidget.categorySpec
 *
 * @property {string} name The name of the category.
 * @property {string} type The type of the category.  `point` shows as a
 *   circle, `line` as a line segment, all others as a rounded rectangle.
 * @property {geo.gui.legendWidget.styleSpec} style The style for the category.
 */

/**
 * Style specification for a legend category.
 *
 * @typedef {geo.feature.styleSpec} geo.gui.legendWidget.styleSpec
 * @extends geo.feature.styleSpec
 * @property {boolean|Function} [stroke=true] True to stroke legend.
 * @property {geo.geoColor|Function} [strokeColor] Color to stroke each legend.
 * @property {number|Function} [strokeOpacity=1] Opacity for each legend's
 *   stroke.  Opacity is on a [0-1] scale.
 * @property {number|Function} [strokeWidth=1.5] The weight of the legend's
 *   stroke in pixels.
 * @property {boolean|Function} [fill=true] True to fill legend.
 * @property {geo.geoColor|Function} [fillColor] Color to fill each legend.
 * @property {number|Function} [fillOpacity=1] Opacity for each legend.
 *   Opacity is on a [0-1] scale.
 */

/**
 * Create a new instance of class geo.gui.legendWidget.
 *
 * @class
 * @alias geo.gui.legendWidget
 * @extends geo.gui.svgWidget
 * @param {geo.gui.widget.spec} arg Options for the widget.
 * @returns {geo.gui.legendWidget}
 */
var _legendWidget = function legendWidget(arg) {
  'use strict';

  if (!(this instanceof _legendWidget)) {
    return new _legendWidget(arg);
  }
  svgWidget.call(this, arg);
  var d3 = (__webpack_require__(2493).d3);
  var geo_event = __webpack_require__(6409);
  var m_this = this,
    m_categories = [],
    m_top = null,
    m_group = null,
    m_border = null,
    m_spacing = 20,
    // distance in pixels between lines
    m_padding = 12; // padding in pixels inside the border

  /**
   * Get or set the category array associated with the legend.
   *
   * @param {geo.gui.legendWidget.categorySpec[]} [arg] The categories to
   *   display.
   * @returns {geo.gui.legendWidget.categorySpec[]|this} The current categories
   *   or the widget instance.
   */
  this.categories = function (arg) {
    if (arg === undefined) {
      return m_categories.slice();
    }
    m_categories = arg.slice().map(function (d) {
      if (d.type === 'line') {
        d.style.fill = false;
        d.style.stroke = true;
      }
      return d;
    });
    m_this.draw();
    return m_this;
  };

  /**
   * Return the size of the widget.
   *
   * @returns {geo.screenSize}
   */
  this.size = function () {
    var width = 1,
      height;
    var test = d3.select(m_this.canvas()).append('text').style('opacity', 1e-6);
    m_categories.forEach(function (d) {
      test.text(d.name);
      width = Math.max(width, test.node().getBBox().width);
    });
    test.remove();
    height = m_spacing * (m_categories.length + 1);
    return {
      width: width + 50,
      height: height
    };
  };

  /**
   * Redraw the legend.
   *
   * @returns {this}
   */
  this.draw = function () {
    m_this._init();
    function applyColor(selection) {
      selection.style('fill', function (d) {
        if (d.style.fill || d.style.fill === undefined) {
          return d.style.fillColor;
        } else {
          return 'none';
        }
      }).style('fill-opacity', function (d) {
        if (d.style.fillOpacity === undefined) {
          return 1;
        }
        return d.style.fillOpacity;
      }).style('stroke', function (d) {
        if (d.style.stroke || d.style.stroke === undefined) {
          return d.style.strokeColor;
        } else {
          return 'none';
        }
      }).style('stroke-opacity', function (d) {
        if (d.style.strokeOpacity === undefined) {
          return 1;
        }
        return d.style.strokeOpacity;
      }).style('stroke-width', function (d) {
        if (d.style.strokeWidth === undefined) {
          return 1.5;
        }
        return d.style.strokeWidth;
      });
    }
    m_border.attr('height', m_this.size().height + 2 * m_padding).style('display', null);
    var scale = m_this._scale();
    var labels = m_group.selectAll('g.geo-label').data(m_categories, function (d) {
      return d.name;
    });
    var g = labels.enter().append('g').attr('class', 'geo-label').attr('transform', function (d, i) {
      return 'translate(0,' + scale.y(i) + ')';
    });
    applyColor(g.filter(function (d) {
      return d.type !== 'point' && d.type !== 'line';
    }).append('rect').attr('x', 0).attr('y', -6).attr('rx', 5).attr('ry', 5).attr('width', 40).attr('height', 12));
    applyColor(g.filter(function (d) {
      return d.type === 'point';
    }).append('circle').attr('cx', 20).attr('cy', 0).attr('r', 6));
    applyColor(g.filter(function (d) {
      return d.type === 'line';
    }).append('line').attr('x1', 0).attr('y1', 0).attr('x2', 40).attr('y2', 0));
    g.append('text').attr('x', '50px').attr('y', 0).attr('dy', '0.3em').text(function (d) {
      return d.name;
    });
    m_this.reposition();
    return m_this;
  };

  /**
   * Get scales for the x and y axis for the current size.
   *
   * @returns {object} An object with `x` and `y`, each containing a d3 scale.
   */
  this._scale = function () {
    return {
      x: d3.scaleLinear().domain([0, 1]).range([0, m_this.size().width]),
      y: d3.scaleLinear().domain([0, m_categories.length - 1]).range([m_padding / 2, m_this.size().height - m_padding / 2])
    };
  };

  /**
   * Private initialization.  Creates the widget's DOM container and internal
   * variables.
   * @private
   */
  this._init = function () {
    // adding categories redraws the entire thing by calling _init, see
    // the m_top.remove() line below
    if (!m_top) {
      m_this._createCanvas();
      m_this._appendCanvasToParent();
    }

    // total size = interior size + 2 * padding + 2 * width of the border
    var w = m_this.size().width + 2 * m_padding + 4,
      h = m_this.size().height + 2 * m_padding + 4;

    // @todo - removing after creating to maintain the appendChild structure
    if (m_top) {
      m_top.remove();
    }
    d3.select(m_this.canvas()).attr('width', w).attr('height', h);
    m_top = d3.select(m_this.canvas()).append('g');
    m_group = m_top.append('g').attr('transform', 'translate(' + [m_padding + 2, m_padding + 2] + ')');
    m_border = m_group.append('rect').attr('x', -m_padding).attr('y', -m_padding).attr('width', w - 4).attr('height', h - 4).attr('rx', 3).attr('ry', 3);
    m_border.style('stroke', 'black').style('stroke-width', '1.5px').style('fill', 'white').style('fill-opacity', 0.75).style('display', 'none');
    m_group.on('mousedown', function (evt) {
      evt.stopPropagation();
    });
    m_group.on('mouseover', function () {
      m_border.transition().duration(250).style('fill-opacity', 1);
    });
    m_group.on('mouseout', function () {
      m_border.transition().duration(250).style('fill-opacity', 0.75);
    });
    m_this.reposition();
  };
  this.geoOn(geo_event.resize, function () {
    m_this.draw();
  });
};
inherit(_legendWidget, svgWidget);
registerWidget('dom', 'legend', _legendWidget);
module.exports = _legendWidget;

/***/ }),

/***/ 2894:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var svgWidget = __webpack_require__(7854);
var registerWidget = (__webpack_require__(1098).registerWidget);
__webpack_require__(615);

/**
 * Scale widget specification.
 *
 * @typedef {object} geo.gui.scaleWidget.spec
 * @property {number} [scale=1] A scale applied to the map gcs units to convert
 *   to the scale units.
 * @property {number} [maxWidth=200] The maximum width of the scale in pixels.
 *   For horizontal scales (orientation is `top` or `bottom`) this is the
 *   maximum length of the scale bar.  For vertical scales, this is the width
 *   available for the scale text.
 * @property {number} [maxHeight] The maximum height of the scale in pixels.
 *   For vertical scales (orientation is `left` or `right`) this is the
 *   maximum length of the scale bar.  For horizontal scales, this is the
 *   height available for the scale text.  Default is 200 for vertical scales,
 *   20 for horizontal scales.
 * @property {string} [orientation='bottom'] One of `left`, `right`, `top`, or
 *   `bottom`.  The scale text is placed in that location relative to the scale
 *   bar.
 * @property {number} [strokeWidth=2] The width of the ticks and scale bar in
 *   pixels.
 * @property {number} [tickLength=10] The length of the end ticks in pixels.
 * @property {string|geo.gui.scaleWidget.unit[]} [units='si'] One of either
 *   `'si'` or `'miles'` or an array of units in ascending order.  See the
 *   `UnitsTable` for examples.
 * @property {Function} [distance] The function used to compute the length of
 *   the scale bar.  This defaults to `transform.sphericalDistance` for all
 *   maps except those with a gcs of `'+proj=longlat +axis=enu'`, where
 *   `math.sqrt(util.distance2dSquared(pt1, pt2))` is used instead.
 */

/**
 * Scale widget unit specification.
 *
 * @typedef {object} geo.gui.scaleWidget.unit
 * @property {string} unit Display name for the unit.
 * @property {number} scale Scale for 1 unit in the current system.
 * @property {number} [minimum=1] Minimum value where this applies after
 *   scaling.  This can be used to handle singular and plural words (e.g.,
 *   `[{units: 'meter', scale: 1}, {units: 'meters', scale: 1, minimum: 1.5}]`)
 * @property {number} [basis=10] The basis for the multiples value.
 * @property {object[]} [multiples] A list of objects in ascending value order
 *   that determine what round values are displayed.
 * @property {number} multiples.multiple The value that is selected for display.
 * @property {number} multiples.digit The number of significant digits in
 *   `multiple`.
 */

/**
 * For a unit table, the records are ordered smallest scale to largest scale.
 * The smallest unit can be repeated to have different rounding behavior for
 * values less than 1 and values greater than or equal to 1.
 *
 * @typedef {object} geo.gui.scaleWidget.unitTableRecord
 * @property {string} unit The display name of the unit.
 * @property {number} scale The size of the unit in base unit.
 * @property {number} [basis=10] The number of units in the next greater unit
 *    if not a power of 10.
 * @property {object[]} [multiples] A list of multiplier values to round to
 *    when rounding is used.  The list should probably include a multiple of 1.
 *    Default is 1, 1.5, 2, 3, 5, 8.
 * @property {number} multiples.multiple A factor to round to.
 * @property {number} multiples.digit The number of digits to preserve when
 *    rounding.
 */

/**
 * Create a new instance of class geo.gui.scaleWidget.
 *
 * @class
 * @alias geo.gui.scaleWidget
 * @extends {geo.gui.svgWidget}
 * @param {geo.gui.scaleWidget.spec} arg
 * @returns {geo.gui.scaleWidget}
 */
var _scaleWidget = function scaleWidget(arg) {
  'use strict';

  if (!(this instanceof _scaleWidget)) {
    return new _scaleWidget(arg);
  }
  svgWidget.call(this, arg);
  var geo_event = __webpack_require__(6409);
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var d3 = (__webpack_require__(2493).d3);
  var m_this = this,
    s_exit = this._exit,
    m_options = Object.assign({}, {
      scale: 1,
      maxWidth: 200,
      maxHeight: arg.orientation === 'left' || arg.orientation === 'right' ? 200 : 20,
      orientation: 'bottom',
      strokeWidth: 2,
      tickLength: 10,
      units: 'si',
      distance: function distance(pt1, pt2, gcs) {
        if (gcs === '+proj=longlat +axis=enu') {
          return Math.sqrt(util.distance2dSquared(pt1, pt2));
        }
        /* We can use either the spherical distance or the Vincenty distance
         * here in much the same way.
        return transform.vincentyDistance(pt1, pt2, gcs).distance;
         */
        return transform.sphericalDistance(pt1, pt2, gcs);
      }
    }, arg);

  /**
   * Initialize the scale widget.
   *
   * @returns {this}
   */
  this._init = function () {
    m_this._createCanvas();
    m_this._appendCanvasToParent();
    m_this.reposition();
    d3.select(m_this.canvas()).attr('width', m_options.maxWidth).attr('height', m_options.maxHeight);
    // Update the scale on pan
    m_this.geoOn(geo_event.pan, m_this._update);
    m_this._render();
    return m_this;
  };

  /**
   * Clean up after the widget.
   */
  this._exit = function () {
    m_this.geoOff(geo_event.pan, m_this._update);
    s_exit();
  };

  /**
   * Return true if the scale is vertically oriented.
   *
   * @returns {boolean} `true` if the scale is vertical, `false` if horizontal.
   */
  this._vertical = function () {
    return m_options.orientation === 'left' || m_options.orientation === 'right';
  };

  /**
   * Given a maximum value, return a value that is no larger than it but at a
   * round number of a set of units.
   *
   * @param {number} maxValue The maximum value to return.  The returned value
   *    will never be smaller than 3/5 of this value.
   * @param {number} pixels A number that is scaled by the ratio of the
   *    returned value to `maxValue`.
   * @param {string|geo.gui.scaleWidget.unit[]} [units] The units to use.  If
   *    not specified, the instance's option units value is used.
   * @returns {object} An object with `html`, `value`, and `pixels` values
   *    representing the calculated value.
   */
  this._scaleValue = function (maxValue, pixels, units) {
    units = _scaleWidget.unitsTable[units] || units || _scaleWidget.unitsTable[m_options.units] || m_options.units;
    var multiples = [{
      multiple: 1,
      digits: 1
    }, {
      multiple: 1.5,
      digits: 2
    }, {
      multiple: 2,
      digits: 1
    }, {
      multiple: 3,
      digits: 1
    }, {
      multiple: 5,
      digits: 1
    }, {
      multiple: 8,
      digits: 1
    }];
    var unit = units[0],
      multiple,
      power,
      value;
    units.forEach(function (unitEntry) {
      if (maxValue >= unitEntry.scale * (unitEntry.minimum || 1)) {
        unit = unitEntry;
      }
    });
    power = Math.floor(Math.log(maxValue / unit.scale) / Math.log(unit.basis || 10));
    multiples = unit.multiples || multiples;
    multiples.forEach(function (mul) {
      var mulValue = unit.scale * mul.multiple * Math.pow(10, power);
      if (mulValue <= maxValue) {
        multiple = mul;
        value = mulValue;
      }
    });
    return {
      html: (multiple.multiple * Math.pow(10, power)).toFixed(Math.max(0, -power + multiple.digits - 1)) + ' ' + unit.unit,
      value: value,
      pixels: value / maxValue * pixels,
      power: power,
      multiple: multiple,
      unitRecord: unit,
      originalValue: maxValue,
      originalPixels: pixels
    };
  };

  /**
   * Create and draw the scale based on the current display distance at the
   * location of the scale.
   */
  this._render = function () {
    var svg = d3.select(m_this.canvas()),
      map = m_this.layer().map(),
      width = m_options.maxWidth,
      height = m_options.maxHeight,
      sw = m_options.strokeWidth,
      sw2 = sw * 0.5,
      tl = m_options.tickLength,
      vert = m_this._vertical(),
      pixels,
      pt1,
      pt2,
      dist,
      value,
      pts;
    pixels = (vert ? m_options.maxHeight : m_options.maxWidth) - sw;
    /* Calculate the distance that the maximum length scale bar can occupy at
     * the location that the scale bar will be drawn. */
    pt1 = $(svg.node()).offset();
    pt1 = {
      x: pt1.left + (m_options.orientation === 'left' ? width - sw2 : sw2),
      y: pt1.top + (m_options.orientation === 'top' ? height - sw2 : sw2)
    };
    pt2 = {
      x: pt1.x + (vert ? 0 : pixels),
      y: pt1.y + (vert ? pixels : 0)
    };
    dist = m_options.distance(map.displayToGcs(pt1, null), map.displayToGcs(pt2, null), map.gcs()) * m_options.scale;
    if (dist <= 0 || !isFinite(dist)) {
      console.warn('The distance calculated for the scale is invalid: ' + dist); // eslint-disable-line no-console
      return;
    }
    value = m_this._scaleValue(dist, pixels);
    if (vert) {
      height = value.pixels + sw;
    } else {
      width = value.pixels + sw;
    }
    svg.attr('width', width).attr('height', height);
    if (svg.select('polyline').empty()) {
      svg.append('polyline').classed('geojs-scale-widget-bar', true).attr('fill', 'none').attr('stroke-width', sw);
    }
    if (svg.select('text').empty()) {
      svg.append('text').classed('geojs-scale-widget-text', true);
    }
    switch (m_options.orientation) {
      case 'bottom':
        pts = [[sw2, tl], [sw2, sw2], [width - sw2, sw2], [width - sw2, tl]];
        svg.select('text').attr('x', width / 2).attr('y', sw * 2).attr('text-anchor', 'middle').attr('dominant-baseline', 'hanging');
        break;
      case 'top':
        pts = [[sw2, height - tl], [sw2, height - sw2], [width - sw2, height - sw2], [width - sw2, height - tl]];
        svg.select('text').attr('x', width / 2).attr('y', height - sw * 2).attr('text-anchor', 'middle').attr('dominant-baseline', 'alphabetic');
        break;
      case 'left':
        pts = [[width - tl, sw2], [width - sw2, sw2], [width - sw2, height - sw2], [width - tl, height - sw2]];
        svg.select('text').attr('x', width - sw * 2).attr('y', height / 2).attr('text-anchor', 'end').attr('dominant-baseline', 'middle');
        break;
      case 'right':
        pts = [[tl, sw2], [sw2, sw2], [sw2, height - sw2], [tl, height - sw2]];
        svg.select('text').attr('x', sw * 2).attr('y', height / 2).attr('text-anchor', 'start').attr('dominant-baseline', 'middle');
        break;
    }
    svg.select('polyline').attr('points', pts.map(function (pt) {
      return pt.join(',');
    }).join(' '));
    svg.select('text').html(value.html);
  };

  /**
   * Update the widget upon panning.
   */
  this._update = function () {
    m_this._render();
  };

  /**
   * Get or set options.
   *
   * @param {string|object} [arg1] If `undefined`, return the options object.
   *    If a string, either set or return the option of that name.  If an
   *    object, update the options with the object's values.
   * @param {object} [arg2] If `arg1` is a string and this is defined, set
   *    the option to this value.
   * @returns {object|this} If options are set, return the annotation,
   *    otherwise return the requested option or the set of options.
   */
  this.options = function (arg1, arg2) {
    if (arg1 === undefined) {
      var result = Object.assign({}, m_options);
      result.position = m_this.position(undefined, true);
      return result;
    }
    if (typeof arg1 === 'string' && arg2 === undefined) {
      return arg1 === 'position' ? m_this.position(undefined, true) : m_options[arg1];
    }
    if (arg2 === undefined) {
      m_options = util.deepMerge(m_options, arg1);
    } else {
      m_options[arg1] = arg2;
    }
    if (arg1.position || arg1 === 'position') {
      m_this.position(arg1.position || arg2);
    }
    m_this._render();
    return m_this;
  };
};
inherit(_scaleWidget, svgWidget);

/**
 * The unitsTable has predefined unit sets for a base unit of one meter.  Each
 * entry is an array that must be in ascending order.  Use unicode in strings,
 * not html entities.  It makes it more reusable.
 * @name unitsTable
 * @property {object} unitsTable The key names are the names of unit systems,
 *    such as `si`.
 * @property {geo.gui.scaleWidget.unitTableRecord[]} unitsTable.unit A list of
 *    units within the unit system from smallest to largest.
 * @memberof geo.gui.scaleWidget
 */
_scaleWidget.unitsTable = {
  si: [{
    unit: 'nm',
    scale: 1e-9
  }, {
    unit: "\u03BCm",
    scale: 1e-6
  }, {
    unit: 'mm',
    scale: 0.001
  }, {
    unit: 'm',
    scale: 1
  }, {
    unit: 'km',
    scale: 1000
  }],
  miles: [{
    unit: 'in',
    scale: 0.0254
  },
  // applies to < 1 in
  {
    /* By specifying inches a second time, the first entry will apply to
     * values less than 1 inch, and those will be rounded by powers of 10
     * using the default rules.  This entry will round values differently,
     * so one will see 1, 1.5, 2, 3, 6, 9 rather than the default which would
     * be 1, 1.5, 2, 3, 5, 8, 10. */
    unit: 'in',
    scale: 0.0254,
    basis: 12,
    multiples: [{
      multiple: 1,
      digits: 1
    }, {
      multiple: 1.5,
      digits: 2
    }, {
      multiple: 2,
      digits: 1
    }, {
      multiple: 3,
      digits: 1
    }, {
      multiple: 6,
      digits: 1
    }, {
      multiple: 9,
      digits: 1
    }]
  }, {
    unit: 'ft',
    scale: 0.3048
  }, {
    unit: 'mi',
    scale: 1609.344
  }],
  decmiles: [
  // decimal miles
  {
    unit: 'mi',
    scale: 1609.344
  }]
};

/**
 * The areaUnitsTable has predefined unit sets for a base unit of one square
 * meter.  Each entry is an array that must be in ascending order.  This table
 * can be passed to formatUnit.
 * @name areaUnitsTable
 * @property {object} areaUnitsTable The key names are the names of unit
 *    systems, such as `si`.
 * @property {geo.gui.scaleWidget.unitTableRecord[]} areaUnitsTable.unit A list
 *    of units within the unit system from smallest to largest.
 * @memberof geo.gui.scaleWidget
 */
_scaleWidget.areaUnitsTable = {
  si: [{
    unit: 'nm\xB2',
    scale: 1e-18
  }, {
    unit: "\u03BCm\xB2",
    scale: 1e-12
  }, {
    unit: 'mm\xB2',
    scale: 1e-6
  }, {
    unit: 'm\xB2',
    scale: 1
  }, {
    unit: 'km\xB2',
    scale: 1e6
  }],
  hectares: [{
    unit: 'ha',
    scale: 1e4
  }],
  decmiles: [
  // decimal square miles
  {
    unit: 'mi\xB2',
    scale: 1609.344 * 1609.344
  }],
  miles: [{
    unit: 'in\xB2',
    scale: 0.0254 * 0.0254
  }, {
    unit: 'ft\xB2',
    scale: 0.3048 * 0.3048
  }, {
    unit: 'mi\xB2',
    scale: 1609.344 * 1609.344
  }],
  acres: [{
    unit: 'pl',
    scale: 0.3048 * 0.3048 * 16.5 * 16.5
  }, {
    unit: 'rd',
    scale: 1609.344 * 1609.344 / 640 / 4
  }, {
    unit: 'ac',
    scale: 1609.344 * 1609.344 / 640
  }]
};

/**
 * Format a unit with a specified number of significant figures.  Given a value
 * in base units, such as meters, this will return a string with appropriate
 * units.  For instance, `formatUnit(0.345)` will return `345 mm`.
 *
 * @param {number} val The value.  A length or area in base units.  With the
 *    default unit table, this is in meters.  With the `areaUnitsTable`, this
 *    is square meters.
 * @param {string|object[]} [unit] The name of the unit system or a unit
 *    table.
 * @param {object} [table] The table of the unit system.  Ignored if
 *    `unit` is a unit table.
 * @param {number} [digits] The minimum number of significant figures.
 * @returns {string?} A formatted string or `undefined`.
 */
_scaleWidget.formatUnit = function (val, unit, table, digits) {
  if (val === undefined || val === null) {
    return undefined;
  }
  if (!Array.isArray(unit)) {
    table = table || _scaleWidget.unitsTable;
    if (!table || !table[unit || 'si']) {
      return undefined;
    }
    unit = table[unit || 'si'];
  }
  var pos;
  for (pos = 0; pos < unit.length - 1; pos += 1) {
    if (val < unit[pos + 1].scale) {
      break;
    }
  }
  unit = unit[pos];
  val /= unit.scale;
  digits = Math.max(0, -Math.ceil(Math.log10(val)) + (digits === undefined || digits < 0 ? 3 : digits));
  if (digits > 10) {
    return undefined;
  }
  var result = val.toFixed(digits);
  if (digits) {
    while (result.substr(result.length - 1) === '0') {
      result = result.substr(0, result.length - 1);
    }
    if (result.substr(result.length - 1) === '.') {
      result = result.substr(0, result.length - 1);
    }
  }
  return result + ' ' + unit.unit;
};
registerWidget('dom', 'scale', _scaleWidget);
module.exports = _scaleWidget;

/***/ }),

/***/ 3019:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var svgWidget = __webpack_require__(7854);
var inherit = __webpack_require__(4626);
var registerWidget = (__webpack_require__(1098).registerWidget);

/**
 * @typedef {geo.gui.widget.spec} geo.gui.sliderWidget.spec
 * @extends {geo.gui.widget.spec}
 * @property {number} [width=20] The width of the slider in pixels.
 * @property {number} [height=160] The height of the slider in pixels.  The
 *   actual bar is `height - 3 * width`.
 */

/**
 * Create a new instance of class sliderWidget.
 *
 * @class
 * @alias geo.gui.sliderWidget
 * @extends geo.gui.svgWidget
 * @param {geo.gui.sliderWidget.spec} arg Options for the widget.
 * @returns {geo.gui.sliderWidget}
 */
var _sliderWidget = function sliderWidget(arg) {
  'use strict';

  if (!(this instanceof _sliderWidget)) {
    return new _sliderWidget(arg);
  }
  svgWidget.call(this, arg);
  var d3 = (__webpack_require__(2493).d3);
  var geo_event = __webpack_require__(6409);
  var m_this = this,
    s_exit = this._exit,
    m_xscale,
    m_yscale,
    m_plus,
    m_minus,
    m_nub,
    m_width = arg.width || 20,
    // Size of the widget in pixels
    m_height = arg.height || 160,
    // slider height + 3 * width
    m_nubSize = arg.width ? arg.width * 0.5 : 10,
    m_plusIcon,
    m_minusIcon,
    m_group,
    m_lowContrast,
    m_highlightDur = 100;

  /* http://icomoon.io */
  /* CC BY 3.0 http://creativecommons.org/licenses/by/3.0/ */
  m_plusIcon = 'M512 81.92c-237.568 0-430.080 192.614-430.080 430.080 0 237.568 192.563 430.080 430.080 430.080s430.080-192.563 430.080-430.080c0-237.517-192.563-430.080-430.080-430.080zM564.326 564.326v206.182h-104.653v-206.182h-206.234v-104.653h206.182v-206.234h104.704v206.182h206.182v104.704h-206.182z';
  m_minusIcon = 'M512 81.92c-237.568 0-430.080 192.614-430.080 430.080 0 237.568 192.563 430.080 430.080 430.080s430.080-192.563 430.080-430.080c0-237.517-192.563-430.080-430.080-430.080zM770.56 459.674v104.704h-517.12v-104.704h517.12z';

  // Define off-white gray colors for low contrast ui (unselected).
  m_lowContrast = {
    white: '#f4f4f4',
    black: '#505050'
  };

  /**
   * Add an icon from a path string.  Returns a d3 group element.
   *
   * @param {string} icon svg path string.
   * @param {d3Selection} base where to append the element.
   * @param {number} cx Center x-coordinate.
   * @param {number} cy Center y-coordinate.
   * @param {number} size Icon size in pixels.
   * @returns {d3GroupElement}
   */
  function put_icon(icon, base, cx, cy, size) {
    var g = base.append('g');

    // the scale factor
    var s = size / 1024;
    g.append('g').append('g').attr('transform', 'translate(' + cx + ',' + cy + ') scale(' + s + ') translate(-512,-512)').append('path').attr('d', icon).attr('class', 'geo-glyphicon');
    return g;
  }

  /**
   * Return the size of the widget.
   *
   * @returns {geo.screenSize}
   */
  this.size = function () {
    return {
      width: m_width,
      height: m_height
    };
  };

  /**
   * Initialize the slider widget.
   *
   * @returns {this}
   */
  this._init = function () {
    m_this._createCanvas();
    m_this._appendCanvasToParent();
    m_this.reposition();
    var svg = d3.select(m_this.canvas()),
      map = m_this.layer().map();
    svg.attr('width', m_width).attr('height', m_height);

    // create d3 scales for positioning
    // TODO: make customizable and responsive
    m_xscale = d3.scaleLinear().domain([-4, 4]).range([0, m_width]);
    m_yscale = d3.scaleLinear().domain([0, 1]).range([m_width * 1.5, m_height - m_width * 1.5]);

    // Create the main group element
    svg = svg.append('g').classed('geo-ui-slider', true);
    m_group = svg;

    // Create + zoom button
    m_plus = svg.append('g');
    m_plus.append('circle').datum({
      fill: 'white',
      stroke: null
    }).classed('geo-zoom-in', true).attr('cx', m_xscale(0)).attr('cy', m_yscale(0.0) - m_width + 2).attr('r', (m_width - 2) / 2).style('cursor', 'pointer').on('click', function () {
      var z = map.zoom();
      map.transition({
        zoom: z + 1,
        ease: d3.easeCubicInOut,
        duration: 500
      });
    }).on('mousedown', function (evt) {
      evt.stopPropagation();
    });
    put_icon(m_plusIcon, m_plus, m_xscale(0), m_yscale(0) - m_width + 2, m_width + 4).style('cursor', 'pointer').style('pointer-events', 'none').select('path').datum({
      fill: 'black',
      stroke: null
    });

    // Create the - zoom button
    m_minus = svg.append('g');
    m_minus.append('circle').datum({
      fill: 'white',
      stroke: null
    }).classed('geo-zoom-out', true).attr('cx', m_xscale(0)).attr('cy', m_yscale(1.0) + m_width - 2).attr('r', (m_width - 2) / 2).style('cursor', 'pointer').on('click', function () {
      var z = map.zoom();
      map.transition({
        zoom: z - 1,
        ease: d3.easeCubicInOut,
        duration: 500
      });
    }).on('mousedown', function (evt) {
      evt.stopPropagation();
    });
    put_icon(m_minusIcon, m_minus, m_xscale(0), m_yscale(1) + m_width - 2, m_width + 4).style('cursor', 'pointer').style('pointer-events', 'none').select('path').datum({
      fill: 'black',
      stroke: null
    });

    /**
     * Respond to a mouse event on the widget.
     *
     * @param {d3Event} evt The event on the widget.
     * @param {boolean} [trans] Truthy for an animated transition.
     */
    function respond(evt, trans) {
      var z = m_yscale.invert(d3.pointer(event, svg.node())[1]),
        zrange = map.zoomRange();
      z = (1 - z) * (zrange.max - zrange.min) + zrange.min;
      if (trans) {
        map.transition({
          zoom: z,
          ease: d3.easeCubicInOut,
          duration: 500,
          done: m_this._update()
        });
      } else {
        map.zoom(z);
        m_this._update();
      }
      evt.stopPropagation();
    }

    // Create the track
    svg.append('rect').datum({
      fill: 'white',
      stroke: 'black'
    }).classed('geo-zoom-track', true).attr('x', m_xscale(0) - m_width / 6).attr('y', m_yscale(0)).attr('rx', m_width / 10).attr('ry', m_width / 10).attr('width', m_width / 3).attr('height', m_height - m_width * 3).style('cursor', 'pointer').on('click', function (evt) {
      respond(evt, true);
    });

    // Create the nub
    m_nub = svg.append('rect').datum({
      fill: 'black',
      stroke: null
    }).classed('geo-zoom-nub', true).attr('x', m_xscale(-4)).attr('y', m_yscale(0.5) - m_nubSize / 2).attr('rx', 3).attr('ry', 3).attr('width', m_width).attr('height', m_nubSize).style('cursor', 'pointer').on('mousedown', function (evt) {
      d3.select(document).on('mousemove.geo.slider', function () {
        respond(evt);
      });
      d3.select(document).on('mouseup.geo.slider', function () {
        respond(evt);
        d3.select(document).on('.geo.slider', null);
      });
      evt.stopPropagation();
    });

    /**
     * When the mouse is over the widget, change the style.
     */
    function mouseOver() {
      d3.select(this).attr('filter', 'url(#geo-highlight)');
      m_group.selectAll('rect,path,circle').transition().duration(m_highlightDur).style('fill', function (d) {
        return d.fill || null;
      }).style('stroke', function (d) {
        return d.stroke || null;
      });
    }

    /**
     * When the mouse is no longer over the widget, change the style.
     */
    function mouseOut() {
      d3.select(this).attr('filter', null);
      m_group.selectAll('circle,rect,path').transition().duration(m_highlightDur).style('fill', function (d) {
        return m_lowContrast[d.fill] || null;
      }).style('stroke', function (d) {
        return m_lowContrast[d.stroke] || null;
      });
    }
    m_group.selectAll('*').on('mouseover', mouseOver).on('mouseout', mouseOut);

    // Update the nub position on zoom
    m_this.geoOn(geo_event.zoom, m_this._update);
    mouseOut();
    m_this._update();
    return m_this;
  };

  /**
   * Removes the slider element from the map and unbinds all handlers.
   */
  this._exit = function () {
    m_this.geoOff(geo_event.zoom, m_this._update);
    m_group.remove();
    s_exit();
  };

  /**
   * Update the slider widget state in response to map changes.  I.e., zoom
   * range changes.
   *
   * @param {object} [obj] An object that can specify a zoom value.
   * @param {number} [obj.zoom] The new zoom value to show on the slider.
   */
  this._update = function (obj) {
    var map = m_this.layer().map(),
      zoomRange = map.zoomRange(),
      zoom = map.zoom(),
      zoomScale = d3.scaleLinear();
    obj = obj || {};
    zoom = obj.value || zoom;
    zoomScale.domain([zoomRange.min, zoomRange.max]).range([1, 0]).clamp(true);
    m_nub.attr('y', m_yscale(zoomScale(zoom)) - m_nubSize / 2);
  };
};
inherit(_sliderWidget, svgWidget);
registerWidget('dom', 'slider', _sliderWidget);
module.exports = _sliderWidget;

/***/ }),

/***/ 7854:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var widget = __webpack_require__(8738);
var inherit = __webpack_require__(4626);
var registerWidget = (__webpack_require__(1098).registerWidget);

/**
 * Create a new instance of class geo.gui.svgWidget.
 *
 * Due to the nature of d3 creating DOM elements as it inserts them, calls to
 * appendChild don't appear in this widget.
 *
 * The canvas of an svgWidget always refers to the actual svg element.
 * The parentCanvas can refer to another widget's svg element, dom element, or
 * the UI layer's dom element.
 * See {@link geo.gui.widget#parentCanvas}.
 *
 * @class
 * @alias geo.gui.svgWidget
 * @extends geo.gui.widget
 * @param {geo.gui.widget.spec} arg Options for the widget.
 * @returns {geo.gui.svgWidget}
 */
var _svgWidget = function svgWidget(arg) {
  'use strict';

  if (!(this instanceof _svgWidget)) {
    return new _svgWidget(arg);
  }
  widget.call(this, arg);
  var svgRenderer = __webpack_require__(2493);
  var m_this = this,
    s_exit = this._exit,
    m_renderer = null;

  /**
   * Initializes SVG Widget.
   *
   * @returns {this}
   */
  this._init = function () {
    var d3Parent;
    if (arg.hasOwnProperty('parent')) {
      arg.parent.addChild(m_this);

      // Tell the renderer there is an SVG element as a parent
      d3Parent = arg.parent.canvas();
    }
    m_this._createCanvas(d3Parent);
    m_this.canvas().addEventListener('mousedown', function (e) {
      e.stopPropagation();
    });
    m_this.reposition();
    return m_this;
  };

  /**
   * Clean up the widget.
   */
  this._exit = function () {
    if (m_renderer) {
      m_renderer._exit();
    }
    s_exit();
  };

  /**
   * Creates the canvas for the svg widget.
   * This directly uses the {@link geo.svg.svgRenderer} as a helper to do all
   * of the heavy lifting.
   *
   * @param {d3Selector} d3Parent The canvas's parent element.
   */
  this._createCanvas = function (d3Parent) {
    var rendererOpts = {
      layer: m_this.layer(),
      widget: true
    };
    if (d3Parent) {
      rendererOpts.d3Parent = d3Parent;
    }
    m_renderer = svgRenderer(rendererOpts);

    // svg widgets manage their own sizes, so make the resize handler a no-op
    m_renderer._resize = function () {};
    m_this.canvas(m_renderer.canvas().node());
  };
  return this;
};
inherit(_svgWidget, widget);
registerWidget('dom', 'svg', _svgWidget);
module.exports = _svgWidget;

/***/ }),

/***/ 4231:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerLayer = (__webpack_require__(1098).registerLayer);
var layer = __webpack_require__(5156);

/**
 * Create a new instance of class uiLayer.
 *
 * @class
 * @alias geo.gui.uiLayer
 * @extends {geo.layer}
 * @param {geo.layer.spec} [arg] Specification for the new layer.
 * @returns {geo.gui.uiLayer}
 */
var _uiLayer = function uiLayer(arg) {
  'use strict';

  var createWidget = (__webpack_require__(1098).createWidget);

  // The widget stays fixed on the screen.
  arg.renderer = 'dom';
  arg.sticky = false;
  if (!(this instanceof _uiLayer)) {
    return new _uiLayer(arg);
  }
  layer.call(this, arg);
  var m_this = this,
    s_exit = this._exit;

  /**
   * Create a new ui control.
   *
   * @param {string} widgetName The name of the widget.
   * @param {object} arg Options for the widget.
   * @param {geo.object} [arg.parent] A parent object for the widget.
   * @returns {geo.gui.widget} The new widget.
   */
  this.createWidget = function (widgetName, arg) {
    var newWidget = createWidget(widgetName, m_this, arg);

    // We only want top level widgets to be a child of the uiLayer
    if (!(arg && 'parent' in arg)) {
      m_this.addChild(newWidget);
    }
    newWidget._init(arg);
    m_this.modified();
    return newWidget;
  };

  /**
   * Delete a ui control.
   *
   * @param {geo.gui.widget} widget The widget to remove.
   * @returns {this}
   */
  this.deleteWidget = function (widget) {
    widget._exit();
    m_this.removeChild(widget);
    m_this.modified();
    return m_this;
  };

  /**
   * Free memory and destroy the layer.
   */
  this._exit = function () {
    m_this.children().forEach(function (child) {
      m_this.deleteWidget(child);
    });
    s_exit();
  };
};
inherit(_uiLayer, layer);
registerLayer('ui', _uiLayer);
module.exports = _uiLayer;

/***/ }),

/***/ 8738:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var sceneObject = __webpack_require__(5402);

/**
 * @typedef {object} geo.gui.widget.position
 * @property {string|number} [top] The position to the top of the container.
 *   A string css position or a number in pixels.
 * @property {string|number} [right] The position to the right of the
 *   container.  A string css position or a number in pixels.
 * @property {string|number} [bottom] The position to the bottom of the
 *   container.  A string css position or a number in pixels.
 * @property {string|number} [left] The position to the left of the container.
 * @property {*} [any] Additional css properties that affect position are
 *   allowed.  See the css specification for details.
 */

/**
 * @typedef {object} geo.gui.widget.spec
 *
 * @property {geo.layer} [layer] Layer associated with the widget.
 * @property {geo.gui.widget.position} [position] Location of the widget.
 * @property {geo.gui.widget} [parent] Optional parent widget.
 */

/**
 * Create a new instance of class widget.
 *
 * @class
 * @alias geo.gui.widget
 * @extends {geo.sceneObject}
 * @param {geo.gui.widget.spec} [arg] Options for the widget.
 * @returns {geo.gui.widget}
 */
var _widget = function widget(arg) {
  'use strict';

  if (!(this instanceof _widget)) {
    return new _widget(arg);
  }
  arg = arg || {};
  sceneObject.call(this, arg);
  var geo_event = __webpack_require__(6409);
  var m_this = this,
    s_exit = this._exit,
    m_layer = arg.layer,
    m_canvas = null,
    m_position = arg.position === undefined ? {
      left: 0,
      top: 0
    } : arg.position;
  if (arg.parent !== undefined && !(arg.parent instanceof _widget)) {
    throw new Error('Parent must be of type geo.gui.widget');
  } else if (arg.parent) {
    m_this.parent(arg.parent);
  }

  /**
   * Initialize the widget.
   *
   * @returns {this}
   */
  this._init = function () {
    m_this.modified();
    return m_this;
  };

  /**
   * Clean up the widget.
   */
  this._exit = function () {
    m_this.children().forEach(function (child) {
      m_this.removeChild(child);
      child._exit();
    });
    m_this.layer().geoOff(geo_event.pan, m_this.repositionEvent);
    if (m_this.parentCanvas().removeChild && m_this.canvas()) {
      try {
        m_this.parentCanvas().removeChild(m_this.canvas());
      } catch (err) {
        // fail gracefully if the canvas is not a child of the parentCanvas
      }
    }
    s_exit();
  };

  /**
   * Return the layer associated with this widget.
   *
   * @returns {geo.layer}
   */
  this.layer = function () {
    return m_layer || m_this.parent() && m_this.parent().layer();
  };

  /**
   * Create the canvas this widget will operate on.
   */
  this._createCanvas = function () {
    throw new Error('Must be defined in derived classes');
  };

  /**
   * Get/Set the canvas for the widget.
   *
   * @param {HTMLElement} [val] If specified, set the canvas, otherwise get
   *    the canvas.
   * @returns {HTMLElement|this} If getting the canvas, return the current
   *    value; otherwise, return this widget.
   */
  this.canvas = function (val) {
    if (val === undefined) {
      return m_canvas;
    }
    m_canvas = val;
    return m_this;
  };

  /**
   * Appends the canvas to the parent canvas.
   * The widget determines how to append itself to a parent, the parent can
   * either be another widget, or the UI Layer.
   */
  this._appendCanvasToParent = function () {
    m_this.parentCanvas().appendChild(m_this.canvas());
  };

  /**
   * Get the parent canvas (top level widgets define their layer as their
   * parent canvas).
   *
   * @returns {HTMLElement} The canvas of the widget's parent.
   */
  this.parentCanvas = function () {
    if (!m_this.parent()) {
      return m_this.layer().canvas();
    }
    return m_this.parent().canvas();
  };

  /**
   * Get or set the CSS positioning that a widget should be placed at.
   *
   * @param {geo.gui.widget.position} [pos] If unspecified, return the current
   *    position.  Otherwise, set the current position.
   * @param {boolean} [actualValue] If getting the position, if this is truthy,
   *    always return the stored value, not a value adjusted for display.
   * @returns {geo.gui.widget.position|this} Either the position or the widget
   *    instance.  If this is the position and `actualValue` is falsy,
   *    positions that specify an explicit `x` and `y` parameter will be
   *    converted to a value that can be used by the display css.
   */
  this.position = function (pos, actualValue) {
    if (pos !== undefined) {
      m_this.layer().geoOff(geo_event.pan, m_this.repositionEvent);
      var clearPosition = {};
      for (var attr in m_position) {
        if (m_position.hasOwnProperty(attr)) {
          clearPosition[attr] = null;
        }
      }
      m_position = pos;
      if (m_position.hasOwnProperty('x') && m_position.hasOwnProperty('y')) {
        m_this.layer().geoOn(geo_event.pan, m_this.repositionEvent);
      }
      m_this.reposition(Object.assign(clearPosition, m_this.position()));
      return m_this;
    }
    if (m_position.hasOwnProperty('x') && m_position.hasOwnProperty('y') && !actualValue) {
      var position = m_this.layer().map().gcsToDisplay(m_position);
      return {
        left: position.x,
        top: position.y,
        right: null,
        bottom: null
      };
    }
    return m_position;
  };

  /**
   * Repositions a widget.
   *
   * @param {geo.gui.widget.position} [position] The new position for the
   *    widget.  `undefined` uses the stored position value.
   * @returns {this}
   */
  this.reposition = function (position) {
    position = position || m_this.position();
    if (m_this.canvas() && m_this.canvas().style) {
      m_this.canvas().style.position = 'absolute';
      for (var cssAttr in position) {
        if (position.hasOwnProperty(cssAttr)) {
          // if the property is a number, add px to it, otherwise set it to the
          // specified value.  Setting a property to null clears it.  Setting to
          // undefined doesn't alter it.
          if (/^\s*(-|\+)?(\d+(\.\d*)?|\d*\.\d+)([eE](-|\+)?\d+)?\s*$/.test(position[cssAttr])) {
            // this ensures that the number is a float with no more than 3
            // decimal places (Chrome does this automatically, but doing so
            // explicitly makes testing more consistent).  It will be an
            // integer when possible.
            m_this.canvas().style[cssAttr] = parseFloat(parseFloat(position[cssAttr]).toFixed(3)) + 'px';
          } else {
            m_this.canvas().style[cssAttr] = position[cssAttr];
          }
        }
      }
    }
    return m_this;
  };

  /**
   * If the position is based on map coordinates, this gets called when the
   * map is panned to resposition the widget.
   *
   * @returns {this}
   */
  this.repositionEvent = function () {
    return m_this.reposition();
  };

  /**
   * Report if the top left of widget (or its current x, y position) is within
   * the viewport.
   *
   * @returns {boolean} True if the widget is within the viewport.
   */
  this.isInViewport = function () {
    var position = m_this.position();
    var layer = m_this.layer();
    return position.left >= 0 && position.top >= 0 && position.left <= layer.width() && position.top <= layer.height();
  };
  if (m_position.hasOwnProperty('x') && m_position.hasOwnProperty('y')) {
    this.layer().geoOn(geo_event.pan, m_this.repositionEvent);
  }
};
inherit(_widget, sceneObject);
module.exports = _widget;

/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
 * Using methods adapted from leaflet to cluster an array of positions
 * hierarchically given an array of length scales (zoom levels).
 */

/**
 * This class manages a group of nearby points that are clustered as a
 * single object for display purposes.  The class constructor is private
 * and only meant to be created by the ClusterGroup object.
 *
 * This is a tree-like data structure.  Each node in the tree is a
 * cluster containing child clusters and unclustered points.
 *
 * @class
 * @alias geo.util.ClusterTree
 *
 * @param {geo.util.ClusterGroup} group The source cluster group
 * @param {number} zoom The zoom level of the current node
 * @param {object[]} [children] An array of ClusterTrees or point objects
 */
function ClusterTree(group, zoom, children) {
  this._group = group;
  this._zoom = zoom;
  this._points = []; // Unclustered points
  this._clusters = []; // Child clusters
  this._count = 0; // Total number of points
  this._parent = null;
  this._coord = null; // The cached coordinates
  var that = this;

  // add the children provided in the constructor call
  (children || []).forEach(function (c) {
    that._add(c);
  });
}

/**
 * Add a point or cluster as a child to the current cluster.
 * @param {object} pt A ClusterTree or point object
 * @private
 */
ClusterTree.prototype._add = function (pt) {
  var inc = 1;
  if (pt instanceof ClusterTree) {
    // add a child cluster
    this._clusters.push(pt);
    inc = pt._count;
  } else {
    this._points.push(pt);
  }
  pt._parent = this;

  // increment the counter
  this._increment(inc);
};

/**
 * Increment the child counter for this and the parent.
 * @param {number} inc The value to increment by
 * @private
 */
ClusterTree.prototype._increment = function (inc) {
  this._coord = null;
  this._count += inc;
  if (this._parent) {
    this._parent._increment(inc);
  }
};

/**
 * Return the total number of child points contained in the cluster.
 * @returns {number} Total points contained
 */
ClusterTree.prototype.count = function () {
  return this._count;
};

/**
 * Recursively call a function on all points contained in the cluster.
 * Calls the function with `this` as the current ClusterTree object, and
 * arguments to arguments the point object and the zoom level:
 * `func.call(this, point, zoom)`.
 *
 * @param {Function} func The function to call.
 */
ClusterTree.prototype.each = function (func) {
  var i;
  for (i = 0; i < this._points.length; i += 1) {
    func.call(this, this._points[i], this._zoom);
  }
  for (i = 0; i < this._clusters.length; i += 1) {
    this._clusters[i].each.call(this._clusters[i], func);
  }
};

/**
 * Get the coordinates of the cluster (the mean position of all the points
 * contained).  This is lazily calculated and cached.
 *
 * @returns {geo.geoPosition} The 2-d coordinates of the center.
 */
ClusterTree.prototype.coords = function () {
  if (this._coord) {
    return this._coord;
  }
  var i,
    center = {
      x: 0,
      y: 0
    };
  // first add up the points at the node
  for (i = 0; i < this._points.length; i += 1) {
    center.x += this._points[i].x;
    center.y += this._points[i].y;
  }

  // add up the contribution from the clusters
  for (i = 0; i < this._clusters.length; i += 1) {
    center.x += this._clusters[i].coords().x * this._clusters[i].count();
    center.y += this._clusters[i].coords().y * this._clusters[i].count();
  }
  this._coord = {
    x: center.x / this.count(),
    y: center.y / this.count()
  };
  return this._coord;
};

/**
 * This class manages clustering of an array of positions hierarchically.
 * The algorithm and code was adapted from the Leaflet marker cluster
 * plugin by David Leaver: https://github.com/Leaflet/Leaflet.markercluster .
 *
 * @class
 * @alias geo.util.ClusterGroup
 * @param {object} opts An options object
 * @param {number} [opts.maxZoom] The maximum zoom level to calculate.
 * @param {number} [opts.radius] Size of clustering at zoom 0 in point gcs.
 */
function C(opts) {
  var DistanceGrid = __webpack_require__(7235);

  // store the options
  this._opts = Object.assign({
    maxZoom: 18,
    radius: 5
  }, opts);

  // generate the initial datastructures
  this._clusters = {}; // clusters at each zoom level
  this._points = {}; // unclustered points at each zoom level

  var zoom, scl;
  for (zoom = this._opts.maxZoom; zoom >= 0; zoom -= 1) {
    scl = this._opts.radius * Math.pow(2, -zoom);
    this._clusters[zoom] = new DistanceGrid(scl);
    this._points[zoom] = new DistanceGrid(scl);
  }
  this._topClusterLevel = new ClusterTree(this, -1);
}

/**
 * Add a position to the cluster group.
 * @protected
 * @param {geo.geoPosition} point A point to add to the cluster.
 */
C.prototype.addPoint = function (point) {
  var zoom, closest, parent, newCluster, lastParent, z;
  /*
   * start at the maximum zoom level and search for nearby
   *
   * 1.  existing clusters
   * 2.  unclustered points
   *
   * otherwise add the point as a new unclustered point
   */
  for (zoom = this._opts.maxZoom; zoom >= 0; zoom -= 1) {
    // find near cluster
    closest = this._clusters[zoom].getNearObject(point);
    if (closest) {
      // add the point to the cluster and return
      closest._add(point);
      return;
    }

    // find near point
    closest = this._points[zoom].getNearObject(point);
    if (closest) {
      parent = closest._parent;
      if (parent) {
        // remove the point from the parent
        for (z = parent._points.length - 1; z >= 0; z -= 1) {
          if (parent._points[z] === closest) {
            parent._points.splice(z, 1);
            parent._increment(-1);
            break;
          }
        }
      }

      // create a new cluster with these two points
      newCluster = new ClusterTree(this, zoom, [closest, point]);
      this._clusters[zoom].addObject(newCluster, newCluster.coords());

      // create intermediate parent clusters that don't exist
      lastParent = newCluster;
      for (z = zoom - 1; z > parent._zoom; z -= 1) {
        lastParent = new ClusterTree(this, z, [lastParent]);
        this._clusters[z].addObject(lastParent, lastParent.coords());
      }
      parent._add(lastParent);

      // remove closest from this zoom level and any above (replace with newCluster)
      for (z = zoom; z >= 0; z -= 1) {
        if (!this._points[z].removeObject(closest, closest)) {
          break;
        }
      }
      return;
    }

    // add an unclustered point
    this._points[zoom].addObject(point, point);
  }

  // otherwise add to the top
  this._topClusterLevel._add(point);
};

/**
 * Return the unclustered points contained at a given zoom level.
 * @param {number} zoom The zoom level.
 * @returns {object[]} The array of unclustered points.
 */
C.prototype.points = function (zoom) {
  zoom = Math.min(Math.max(Math.floor(zoom), 0), this._opts.maxZoom - 1);
  return this._points[Math.floor(zoom)].contents();
};

/**
 * Return the clusters contained at a given zoom level.
 * @param {number} zoom The zoom level.
 * @returns {geo.util.ClusterTree[]} The array of clusters.
 */
C.prototype.clusters = function (zoom) {
  zoom = Math.min(Math.max(Math.floor(zoom), 0), this._opts.maxZoom - 1);
  return this._clusters[Math.floor(zoom)].contents();
};
module.exports = C;

/***/ }),

/***/ 5637:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Utility functions related to color */

var util = __webpack_require__(1949);
var colorName = __webpack_require__(3087);
colorName = colorName.__esModule ? colorName.default : colorName;

/**
 * A color value.  Although opacity can be specified, it is not always used.
 * When a string is specified, any of the following forms can be used:
 *   - CSS color name
 *   - `#rrggbb` The color specified in hexadecimal with each channel on a
 *     scale between 0 and 255 (`ff`).  Case insensitive.
 *   - `#rrggbbaa` The color and opacity specified in hexadecimal with each
 *     channel on a scale between 0 and 255 (`ff`).  Case insensitive.
 *   - `#rgb` The color specified in hexadecimal with each channel on a scale
 *     between 0 and 15 (`f`).  Case insensitive.
 *   - `#rgba` The color and opacity specified in hexadecimal with each channel
 *      on a scale between 0 and 15 (`f`).  Case insensitive.
 *   - `rgb(R, G, B)`, `rgb(R, G, B, A)`, `rgba(R, G, B)`, `rgba(R, G, B, A)`
 *     The color with the values of each color channel specified as numeric
 *     values between 0 and 255 or as percent (between 0 and 100) if a percent
 *     `%` follows the number.  The alpha (opacity) channel is optional and can
 *     either be a number between 0 and 1 or a percent.  White space may appear
 *     before and after numbers, and between the number and a percent symbol.
 *     Commas are not required.  A slash may be used as a separator before the
 *     alpha value instead of a comma.  The numbers conform to the CSS number
 *     specification, and can be signed floating-point values, possibly with
 *     exponents.
 *   - `hsl(H, S, L)`, `hsl(H, S, L, A)`, `hsla(H, S, L)`, `hsla(H, S, L, A)`
 *     Hue, saturation, and lightness with optional alpha (opacity).  Hue is a
 *     number between 0 and 360 and is interpreted as degrees unless an angle
 *     unit is specified.  CSS units of `deg`, `grad`, `rad`, and `turn` are
 *     supported.  Saturation and lightness are percentages between 0 and 100
 *     and *must* be followed by a percent `%` symbol.  The alpha (opacity)
 *     channel is optional and is specified as with `rgba(R, G, B, A)`.
 *   - `transparent` Black with 0 opacity.
 *
 * When a number, this is an integer of the form `0xrrggbb` or its decimal
 * equivalent.  For example, 0xff0000 or 16711680 are both solid red.
 *
 * See {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for
 * more details on CSS color values.
 *
 * @typedef geo.geoColor
 * @type {geo.geoColorObject|string|number}
 */

/**
 * A color value represented as an object.  Although opacity can be specified,
 * it is not always used.
 *
 * @typedef {object} geo.geoColorObject
 * @property {number} r The red intensity on a scale of [0-1].
 * @property {number} g The green intensity on a scale of [0-1].
 * @property {number} b The blue intensity on a scale of [0-1].
 * @property {number} [a] The opacity on a scale of [0-1].  If unspecified and
 *      used, it should be treated as 1.
 */

/**
 * @typedef {object} geo.util.cssColorConversionRecord
 * @property {string} name The name of the color conversion.
 * @property {RegExp} regex A regex that, if it matches the color string, will
 *      cause the process function to be invoked.
 * @property {Function} process A function that takes (`color`, `match`) with
 *      the original color string and the results of matching the regex using
 *      the regex's `exec` function.  It outputs a {@link geo.geoColorObject}
 *      color object or the original color string if there is still a parsing
 *      failure.
 */

var m_memoizeConvertColor = {
  maxCount: 1000,
  count: 0,
  memo: {}
};

/**
 * Store the results of convertColor in dictionary for so repeated requests can
 * be returned quickly.  If the memoization table gets over a certain size,
 * just reset it.
 *
 * @private
 * @param {geo.geoColor} origColor The original color specification.
 * @param {geo.geoColorObject} resultColor The result of the conversion.
 * @returns {geo.geoColorObject} The `resultColor`.
 */
function memoizeConvertColor(origColor, resultColor) {
  m_memoizeConvertColor.count += 1;
  if (m_memoizeConvertColor.count >= m_memoizeConvertColor.maxCount) {
    m_memoizeConvertColor.memo = {};
    m_memoizeConvertColor.count = 0;
  }
  m_memoizeConvertColor.memo[origColor] = resultColor;
  return resultColor;
}
var colorUtils = {
  /**
   * Convert a color to a standard rgb object.  Allowed inputs:
   *   - rgb object with optional 'a' (alpha) value.
   *   - css color name
   *   - #rrggbb, #rrggbbaa, #rgb, #rgba hexadecimal colors
   *   - rgb(), rgba(), hsl(), and hsla() css colors
   *   - transparent
   * The output object always contains r, g, b on a scale of [0-1].  If an
   * alpha value is specified, the output will also contain an 'a' value on a
   * scale of [0-1].  Objects already in rgb format are not checked to make
   * sure that all parameters are in the range of [0-1], but string inputs
   * are so validated.
   *
   * @param {geo.geoColor} color Any valid color input.
   * @returns {geo.geoColorObject} An rgb color object, possibly with an 'a'
   *    value.  If the input cannot be converted to a valid color, the input
   *    value is returned.
   * @memberof geo.util
   */
  convertColor: function convertColor(color) {
    if (color === undefined || color === null || color.r !== undefined && color.g !== undefined && color.b !== undefined) {
      return color;
    }
    if (m_memoizeConvertColor.memo[color] !== undefined) {
      return m_memoizeConvertColor.memo[color];
    }
    var opacity,
      origColor = color;
    if (typeof color === 'string') {
      var lowerColor = color.toLowerCase();
      if (colorName.hasOwnProperty(lowerColor)) {
        color = {
          r: colorName[lowerColor][0] / 255,
          g: colorName[lowerColor][1] / 255,
          b: colorName[lowerColor][2] / 255
        };
      } else if (color.charAt(0) === '#') {
        if (color.length === 4 || color.length === 5) {
          /* interpret values of the form #rgb as #rrggbb and #rgba as
           * #rrggbbaa */
          if (color.length === 5) {
            opacity = parseInt(color.slice(4), 16) / 0xf;
          }
          color = parseInt(color.slice(1, 4), 16);
          color = (color & 0xf00) * 0x1100 + (color & 0xf0) * 0x110 + (color & 0xf) * 0x11;
        } else if (color.length === 7 || color.length === 9) {
          if (color.length === 9) {
            opacity = parseInt(color.slice(7), 16) / 0xff;
          }
          color = parseInt(color.slice(1, 7), 16);
        }
      } else if (lowerColor === 'transparent') {
        opacity = color = 0;
      } else if (lowerColor.indexOf('(') >= 0) {
        for (var idx = 0; idx < colorUtils.cssColorConversions.length; idx += 1) {
          var match = colorUtils.cssColorConversions[idx].regex.exec(lowerColor);
          if (match) {
            color = colorUtils.cssColorConversions[idx].process(lowerColor, match);
            return memoizeConvertColor(origColor, color);
          }
        }
      }
    }
    if (isFinite(color)) {
      color = {
        r: ((color & 0xff0000) >> 16) / 255,
        g: ((color & 0xff00) >> 8) / 255,
        b: (color & 0xff) / 255
      };
    }
    if (opacity !== undefined && color && color.r !== undefined) {
      color.a = opacity;
    }
    return memoizeConvertColor(origColor, color);
  },
  /**
   * Convert a color (possibly with opacity) and an optional opacity value to
   * a color object that always has opacity.  The opacity is guaranteed to be
   * within [0-1].  A valid color object is always returned.
   *
   * @param {geo.geoColor} [color] Any valid color input.  If an invalid value
   *    or no value is supplied, the `defaultColor` is used.
   * @param {number} [opacity] A value from [0-1].  This is multiplied with
   *    the opacity from `color`.
   * @param {geo.geoColorObject} [defaultColor] The color
   *    to use if an invalid color is supplied.
   * @returns {geo.geoColorObject} An rgba color object.
   * @memberof geo.util
   */
  convertColorAndOpacity: function convertColorAndOpacity(color, opacity, defaultColor) {
    color = colorUtils.convertColor(color);
    if (!color || color.r === undefined || color.g === undefined || color.b === undefined) {
      color = colorUtils.convertColor(defaultColor || {
        r: 0,
        g: 0,
        b: 0
      });
    }
    if (!color || color.r === undefined || color.g === undefined || color.b === undefined) {
      color = {
        r: 0,
        g: 0,
        b: 0
      };
    }
    color = {
      r: isFinite(color.r) && color.r >= 0 ? color.r <= 1 ? +color.r : 1 : 0,
      g: isFinite(color.g) && color.g >= 0 ? color.g <= 1 ? +color.g : 1 : 0,
      b: isFinite(color.b) && color.b >= 0 ? color.b <= 1 ? +color.b : 1 : 0,
      a: util.isNonNullFinite(color.a) && color.a >= 0 && color.a < 1 ? +color.a : 1
    };
    if (util.isNonNullFinite(opacity) && opacity < 1) {
      color.a = opacity <= 0 ? 0 : color.a * opacity;
    }
    return color;
  },
  /**
   * Convert a color to a six or eight digit hex value prefixed with #.
   *
   * @param {geo.geoColorObject} color The color object to convert.
   * @param {boolean} [allowAlpha] If truthy and `color` has a defined `a`
   *    value, include the alpha channel in the output.  If `'needed'`, only
   *    include the alpha channel if it is set and not 1.
   * @returns {string} A color string.
   * @memberof geo.util
   */
  convertColorToHex: function convertColorToHex(color, allowAlpha) {
    var rgb = colorUtils.convertColor(color),
      value;
    if (!rgb.r && !rgb.g && !rgb.b) {
      value = '#000000';
    } else {
      value = '#' + ((1 << 24) + (Math.round(rgb.r * 255) << 16) + (Math.round(rgb.g * 255) << 8) + Math.round(rgb.b * 255)).toString(16).slice(1);
    }
    if (rgb.a !== undefined && allowAlpha && (rgb.a < 1 || allowAlpha !== 'needed')) {
      value += (256 + Math.round(rgb.a * 255)).toString(16).slice(1);
    }
    return value;
  },
  /**
   * Convert a color to a css rgba() value.
   *
   * @param {geo.geoColorObject} color The color object to convert.
   * @returns {string} A color string.
   * @memberof geo.util
   */
  convertColorToRGBA: function convertColorToRGBA(color) {
    var rgb = colorUtils.convertColor(color);
    if (!rgb) {
      rgb = {
        r: 0,
        g: 0,
        b: 0
      };
    }
    if (!util.isNonNullFinite(rgb.a) || rgb.a > 1) {
      rgb.a = 1;
    }
    return 'rgba(' + Math.round(rgb.r * 255) + ', ' + Math.round(rgb.g * 255) + ', ' + Math.round(rgb.b * 255) + ', ' + +(+rgb.a).toFixed(5) + ')';
  },
  /**
   * A dictionary of conversion factors for angular CSS measurements.
   * @memberof geo.util
   */
  cssAngleUnitsBase: {
    deg: 360,
    grad: 400,
    rad: 2 * Math.PI,
    turn: 1
  },
  /**
   * A regular expression string that will parse a number (integer or floating
   * point) for CSS properties.
   * @memberof geo.util
   */
  cssNumberRegex: '[+-]?(?:\\d+\\.?\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?'
};

/**
 * A list of regex and processing functions for color conversions to rgb
 * objects.  Each entry is a {@link geo.util.cssColorConversionRecord}.  In
 * general, these conversions are somewhat more forgiving than the css
 * specification (see {@link https://drafts.csswg.org/css-color/}) in that
 * percentages may be mixed with numbers, and that floating point values are
 * accepted for all numbers.  Commas are optional.  As per the latest draft
 * standard, `rgb` and `rgba` are aliases of each other, as are `hsl` and
 * `hsla`.
 * @name cssColorConversions
 * @property {geo.util.cssColorConversionRecord[]} cssColorConversions A list
 *   of conversion records.
 * @memberof geo.util
 */
colorUtils.cssColorConversions = [{
  name: 'rgb',
  regex: new RegExp('^\\s*rgba?' + '\\(\\s*(' + colorUtils.cssNumberRegex + ')\\s*(%?)\\s*' + ',?\\s*(' + colorUtils.cssNumberRegex + ')\\s*(%?)\\s*' + ',?\\s*(' + colorUtils.cssNumberRegex + ')\\s*(%?)\\s*' + '([/,]?\\s*(' + colorUtils.cssNumberRegex + ')\\s*(%?)\\s*)?' + '\\)\\s*$'),
  process: function process(color, match) {
    color = {
      r: Math.min(1, Math.max(0, +match[1] / (match[2] ? 100 : 255))),
      g: Math.min(1, Math.max(0, +match[3] / (match[4] ? 100 : 255))),
      b: Math.min(1, Math.max(0, +match[5] / (match[6] ? 100 : 255)))
    };
    if (match[7]) {
      color.a = Math.min(1, Math.max(0, +match[8] / (match[9] ? 100 : 1)));
    }
    return color;
  }
}, {
  name: 'hsl',
  regex: new RegExp('^\\s*hsla?' + '\\(\\s*(' + colorUtils.cssNumberRegex + ')\\s*(deg|grad|rad|turn)?\\s*' + ',?\\s*(' + colorUtils.cssNumberRegex + ')\\s*%\\s*' + ',?\\s*(' + colorUtils.cssNumberRegex + ')\\s*%\\s*' + '([/,]?\\s*(' + colorUtils.cssNumberRegex + ')\\s*(%?)\\s*)?' + '\\)\\s*$'),
  process: function process(color, match) {
    /* Conversion from https://www.w3.org/TR/2011/REC-css3-color-20110607
     */
    var hue_to_rgb = function hue_to_rgb(m1, m2, h) {
      h = h - Math.floor(h);
      if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
      }
      if (h * 6 < 3) {
        return m2;
      }
      if (h * 6 < 4) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
      }
      return m1;
    };
    var h = +match[1] / (colorUtils.cssAngleUnitsBase[match[2]] || 360),
      s = Math.min(1, Math.max(0, +match[3] / 100)),
      l = Math.min(1, Math.max(0, +match[4] / 100)),
      m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
      m1 = l * 2 - m2;
    color = {
      r: hue_to_rgb(m1, m2, h + 1 / 3),
      g: hue_to_rgb(m1, m2, h),
      b: hue_to_rgb(m1, m2, h - 1 / 3)
    };
    if (match[5]) {
      color.a = Math.min(1, Math.max(0, +match[6] / (match[7] ? 100 : 1)));
    }
    return color;
  }
}];
module.exports = colorUtils;

/***/ }),

/***/ 1949:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var $ = __webpack_require__(5616);
var proj4 = __webpack_require__(9677);
proj4 = proj4.__esModule ? proj4.default : proj4;
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
var svgForeignObject = '<svg xmlns="http://www.w3.org/2000/svg">' + '<foreignObject width="100%" height="100%">' + '</foreignObject>' + '</svg>';
var m_timingData = {},
  m_timingKeepRecent = 200,
  m_threshold = 15,
  m_originalRequestAnimationFrame,
  m_htmlToImageSupport;

/**
 * Takes a variable number of arguments and returns the first numeric value
 * it finds.
 *
 * @param {...*} var_args Any number of arguments.
 * @returns {number?} The first numeric argument, or `undefined` if there are no
 *      numeric arguments.
 * @private
 */
function setNumeric() {
  var i;
  for (i = 0; i < arguments.length; i += 1) {
    if (isFinite(arguments[i])) {
      return arguments[i];
    }
  }
  return undefined;
}

/**
 * Contains utility classes and methods used by geojs.
 * @namespace geo.util
 */
var util = {
  /**
   * Check if a point is inside of a polygon.  The point and polygon must be in
   * the same coordinate system.  A point exactly on the edge is not considered
   * inside.
   *
   * @param {geo.point2D} point The test point.
   * @param {geo.point2D[]|geo.polygonObject} outer The outer boundary of the
   *    polygon or a polygon object that has both the inner and outer
   *    boundaries.
   * @param {Array.<geo.point2D[]>} [inner] A list of inner boundaries
   *    (holes).
   * @param {object} [range] If specified, this is the extent of the outer
   *    polygon and is used for early detection.
   * @param {geo.point2D} range.min The minimum value of coordinates in
   *    the outer polygon.
   * @param {geo.point2D} range.max The maximum value of coordinates in
   *    the outer polygon.
   * @returns {boolean} `true` if the point is inside or on the border of the
   *    polygon.
   * @memberof geo.util
   */
  pointInPolygon: function pointInPolygon(point, outer, inner, range) {
    if (outer.outer) {
      inner = outer.inner;
      outer = outer.outer;
    }
    if (outer.length < 3) {
      // we need 3 coordinates for this to make sense
      return false;
    }
    if (range && range.min && range.max) {
      if (point.x < range.min.x || point.y < range.min.y || point.x > range.max.x || point.y > range.max.y) {
        return false;
      }
    }
    return util.distanceToPolygon2d(point, inner ? {
      outer: outer,
      inner: inner
    } : outer, true) > 0;
  },
  /**
   * Return a point in the basis of the triangle.  If the point is located on
   * a vertex of the triangle, it will be at `vert0`: (0, 0), `vert1`:
   * (1, 0), `vert2`: (0, 1).  If it is within the triangle, its coordinates
   * will be 0 <= x <= 1, 0 <= y <= 1, x + y <= 1.  The point and vertices
   * must be in the same coordinate system.
   *
   * @param {geo.point2D} point The point to convert.
   * @param {geo.point2D} vert0 Vertex 0 of the triangle.
   * @param {geo.point2D} vert1 Vertex 1 (x direction) of the triangle.
   * @param {geo.point2D} vert2 Vertex 2 (y direction) of the triangle.
   * @returns {geo.point2D?} The point in the triangle basis, or `undefined`
   *    if the triangle is degenerate.
   * @memberof geo.util
   */
  pointToTriangleBasis2d: function pointToTriangleBasis2d(point, vert0, vert1, vert2) {
    var a = vert1.x - vert0.x,
      b = vert2.x - vert0.x,
      c = vert1.y - vert0.y,
      d = vert2.y - vert0.y,
      x = point.x - vert0.x,
      y = point.y - vert0.y,
      det = a * d - b * c;
    if (det) {
      return {
        x: (x * d - y * b) / det,
        y: (x * -c + y * a) / det
      };
    }
    return undefined;
  },
  /**
   * Check if an object an HTML Image element that is fully loaded.
   *
   * @param {object} img An object that might be an HTML Image element.
   * @param {boolean} [allowFailedImage] If `true`, an image element that has
   *     a source and has failed to load is also considered 'ready' in the
   *     sense that it isn't expected to change to a better state.
   * @returns {boolean} `true` if this is an image that is ready.
   * @memberof geo.util
   */
  isReadyImage: function isReadyImage(img, allowFailedImage) {
    if (img instanceof Image && img.complete && img.src) {
      if (img.naturalWidth && img.naturalHeight || allowFailedImage) {
        return true;
      }
    }
    return false;
  },
  /**
   * Check if an object an HTMLVideoElement element that is loaded.
   *
   * @param {object} vid An object that might be an HTMLVideoElement.
   * @param {boolean} [allowFailedVideo] If `true`, an video element that has
   *     a source and has failed to load is also considered 'ready' in the
   *     sense that it isn't expected to change to a better state.
   * @returns {boolean} `true` if this is a video that is ready.
   * @memberof geo.util
   */
  isReadyVideo: function isReadyVideo(vid, allowFailedVideo) {
    if (vid instanceof HTMLVideoElement && vid.src && vid.HAVE_CURRENT_DATA !== undefined) {
      if (vid.videoWidth && vid.videoHeight && vid.readyState >= vid.HAVE_CURRENT_DATA || allowFailedVideo && vid.error) {
        return true;
      }
    }
    return false;
  },
  /**
   * Test if an object is a function.
   *
   * @param {object} f An object that might be a function.
   * @returns {boolean} `true` if the object is a function.
   * @memberof geo.util
   */
  isFunction: function isFunction(f) {
    return typeof f === 'function';
  },
  /**
   * Return a function.  If the supplied object is a function, return it.
   * Otherwise, return a function that returns the argument.
   *
   * @param {object} f An object that might be a function.
   * @returns {Function} A function.  Either `f` or a function that returns
   *    `f`.
   * @memberof geo.util
   */
  ensureFunction: function ensureFunction(f) {
    if (util.isFunction(f)) {
      return f;
    } else {
      return function () {
        return f;
      };
    }
  },
  /**
   * Check if a value coerces to a number that is finite, not a NaN, and not
   * `null`, `false`, or the empty string.
   *
   * @param {object} val The value to check.
   * @returns {boolean} True if `val` is a non-null, non-false, finite number.
   */
  isNonNullFinite: function isNonNullFinite(val) {
    return isFinite(val) && val !== null && val !== false && val !== '';
  },
  /**
   * Return a random string of length n || 8.  The string consists of
   * mixed-case ASCII alphanumerics.
   *
   * @param {number} [n] The length of the string to return.
   * @returns {string} A string of random characters.
   * @memberof geo.util
   */
  randomString: function randomString(n) {
    var s, i, r;
    n = n || 8;
    s = '';
    for (i = 0; i < n; i += 1) {
      r = Math.floor(Math.random() * chars.length);
      s += chars.substring(r, r + 1);
    }
    return s;
  },
  /**
   * Normalize a coordinate object into {@link geo.geoPosition} form.  The
   * input can be a 2 or 3 element array or an object with a variety of
   * properties.
   *
   * @param {object|array} p The point to convert.
   * @returns {geo.geoPosition} The point as an object with `x`, `y`, and `z`
   *    properties.
   * @memberof geo.util
   */
  normalizeCoordinates: function normalizeCoordinates(p) {
    p = p || {};
    if (Array.isArray(p)) {
      return {
        x: p[0],
        y: p[1],
        z: p[2] || 0
      };
    }
    return {
      x: setNumeric(p.x, p.longitude, p.lng, p.lon, 0),
      y: setNumeric(p.y, p.latitude, p.lat, 0),
      z: setNumeric(p.z, p.elevation, p.elev, p.height, 0)
    };
  },
  /**
   * Create an integer array contains elements from one integer to another
   * integer.
   *
   * @param {number} start The start integer.
   * @param {number} end The end integer.
   * @param {number} [step] The step.
   * @returns {number[]} An array of integers.
   * @memberof geo.util
   */
  range: function range(start, end, step) {
    step = step || 1;
    var results = [];
    for (var i = start; i <= end; i += step) {
      results.push(i);
    }
    return results;
  },
  /**
   * Compare two arrays and return if their contents are equal.
   * @param {array} a1 First array to compare.
   * @param {array} a2 Second array to compare.
   * @returns {boolean} `true` if the contents of the arrays are equal.
   * @memberof geo.util
   */
  compareArrays: function compareArrays(a1, a2) {
    return a1.length === a2.length && a1.every(function (el, idx) {
      return el === a2[idx];
    });
  },
  /**
   * Create a `vec3` that is always an array.  This should only be used if it
   * will not be used in a WebGL context.  Plain arrays usually use 64-bit
   * float values, whereas `vec3` defaults to 32-bit floats.
   *
   * @returns {array} Zeroed-out vec3 compatible array.
   * @memberof geo.util
   */
  vec3AsArray: function vec3AsArray() {
    return [0, 0, 0];
  },
  /**
   * Create a `mat3` that is always an array.  This should only be used if it
   * will not be used in a WebGL context.  Plain arrays usually use 64-bit
   * float values, whereas `mat3` defaults to 32-bit floats.
   *
   * @returns {array} Identity `mat3` compatible array.
   * @memberof geo.util
   */
  mat3AsArray: function mat3AsArray() {
    return [1, 0, 0, 0, 1, 0, 0, 0, 1];
  },
  /**
   * Create a `mat4` that is always an array.  This should only be used if it
   * will not be used in a WebGL context.  Plain arrays usually use 64-bit
   * float values, whereas `mat4` defaults to 32-bit floats.
   *
   * @returns {array} Identity `mat4` compatible array.
   * @memberof geo.util
   */
  mat4AsArray: function mat4AsArray() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  },
  /**
   * Get a buffer for a vgl geometry source.  If a buffer already exists and
   * is the correct size, return it.  Otherwise, allocate a new buffer; any
   * data in an old buffer is discarded.
   *
   * @param {geo.vgl.geometryData} geom The geometry to reference and modify.
   * @param {string} srcName The name of the source.
   * @param {number} len The number of elements for the array.
   * @param {number} [allowLarger] If the existing buffer is larger than
   *    requested, don't reallocate it unless it exceeds the size of
   *    `len * (1 + allowLarger)`.
   * @param {number} [allocateLarger] If reallocating an existing buffer,
   *    allocate `len * (1 + allocateLarger)` to reduce the need to reallocate
   *    on subsequent calls.  If this is the first allocation (the previous
   *    size was 0), `len` is allocated.
   * @returns {Float32Array} A buffer for the named source.
   * @memberof geo.util
   */
  getGeomBuffer: function getGeomBuffer(geom, srcName, len, allowLarger, allocateLarger) {
    allowLarger = allowLarger === undefined ? 0.2 : allowLarger;
    allocateLarger = allocateLarger === undefined ? 0.1 : allocateLarger;
    var src = geom.sourceByName(srcName),
      data = src.data(),
      allow = Math.floor((allowLarger + 1) * len);
    data = src.data();
    /* If the current buffer is either the length we want or no larger than a
     * factor of allowBigger more in size, just return it. */
    if (data instanceof Float32Array && (data.length === len || data.length >= len && data.length <= allow)) {
      return data;
    }
    /* If we need to allocate a new buffer (smaller or larger), and we have an
     * existing, non-zero-length buffer, allocate a larger than needed buffer.
     * Add an extra factor of allocateLarger. */
    var allocate = len;
    if (data instanceof Float32Array && data.length && len && allocateLarger > 0) {
      allocate = Math.floor((allocateLarger + 1) * len);
    }
    data = new Float32Array(allocate);
    src.setData(data);
    return data;
  },
  /**
   * Ensure that the input and modifiers properties of all actions are
   * objects, not plain strings.
   *
   * @param {geo.actionRecord[]} actions An array of actions to adjust as
   *    needed.
   * @memberof geo.util
   */
  adjustActions: function adjustActions(actions) {
    var action, i;
    for (i = 0; i < actions.length; i += 1) {
      action = actions[i];
      if ($.type(action.input) === 'string') {
        var actionEvents = {};
        actionEvents[action.input] = true;
        action.input = actionEvents;
      }
      if (!action.modifiers) {
        action.modifiers = {};
      }
      if ($.type(action.modifiers) === 'string') {
        var actionModifiers = {};
        actionModifiers[action.modifiers] = true;
        action.modifiers = actionModifiers;
      }
    }
  },
  /**
   * Add an action to the list of handled actions.
   *
   * @param {geo.actionRecord[]} actions An array of actions to adjust as
   *    needed.
   * @param {geo.actionRecord} action An object defining the action.  Use
   *    `action`, `name`, and `owner` to make this entry distinct if it will
   *    need to be removed later.
   * @param {boolean} toEnd The action is added at the beginning of the
   *    actions list unless `toEnd` is `true`.  Earlier actions prevent later
   *    actions with the similar input and modifiers.
   * @memberof geo.util
   */
  addAction: function addAction(actions, action, toEnd) {
    if (toEnd) {
      actions.push(action);
    } else {
      actions.unshift(action);
    }
    util.adjustActions(actions);
  },
  /**
   * Check if an action is in the actions list.  An action matches if the
   * `action`, `name`, and `owner` match.  A `null` or `undefined` value will
   * match all actions.  If using a {@link geo.actionRecord} object, this is
   * the same as passing (`action.action`, `action.name`, `action.owner`).
   *
   * @param {geo.actionRecord[]} actions An array of actions to search.
   * @param {geo.actionRecord|string} action Either an action object or the
   *    name of an action.
   * @param {string} [name] Optional name associated with the action.
   * @param {string} [owner] Optional owner associated with the action.
   * @returns {geo.actionRecord?} The first matching action or `null`.
   * @memberof geo.util
   */
  hasAction: function hasAction(actions, action, name, owner) {
    if (action && action.action) {
      name = action.name;
      owner = action.owner;
      action = action.action;
    }
    for (var i = 0; i < actions.length; i += 1) {
      if ((!action || actions[i].action === action) && (!name || actions[i].name === name) && (!owner || actions[i].owner === owner)) {
        return actions[i];
      }
    }
    return null;
  },
  /**
   * Remove all matching actions.  Actions are matched as with `hasAction`.
   *
   * @param {geo.actionRecord[]} actions An array of actions to adjust as
   *    needed.
   * @param {geo.actionRecord|string} action Either an action object or the
   *    name of an action.
   * @param {string} [name] Optional name associated with the action.
   * @param {string} [owner] Optional owner associated with the action.
   * @returns {number} The number of actions that were removed.
   * @memberof geo.util
   */
  removeAction: function removeAction(actions, action, name, owner) {
    var found,
      removed = 0;
    do {
      found = util.hasAction(actions, action, name, owner);
      if (found) {
        actions.splice(actions.indexOf(found), 1);
        removed += 1;
      }
    } while (found);
    return removed;
  },
  /**
   * Determine if the current inputs and modifiers match a known action.
   *
   * @param {object} inputs Aan object where each input that is currently
   *    active is truthy.  Common inputs are `left`, `right`, `middle`,
   *    `wheel`, `pan`, `rotate`.
   * @param {object} modifiers An object where each currently applied
   *    modifier is truthy.  Common modifiers are `shift`, `ctrl`, `alt`,
   *    `meta`.
   * @param {geo.actionRecord[]} actions A list of actions to compare to the
   *    inputs and modifiers.  The first action that matches will be
   *    returned.
   * @returns {geo.actionRecord?} A matching action or `undefined`.
   * @memberof geo.util
   */
  actionMatch: function actionMatch(inputs, modifiers, actions) {
    var matched;

    /* actions must have already been processed by adjustActions */
    if (actions.some(function (action) {
      for (var input in action.input) {
        if (action.input.hasOwnProperty(input)) {
          if (action.input[input] === false && inputs[input] || action.input[input] && !inputs[input]) {
            return false;
          }
        }
      }
      for (var modifier in action.modifiers) {
        if (action.modifiers.hasOwnProperty(modifier)) {
          if (action.modifiers[modifier] === false && modifiers[modifier] || action.modifiers[modifier] && !modifiers[modifier]) {
            return false;
          }
        }
      }
      matched = action;
      return true;
    })) {
      return matched;
    }
    return undefined;
  },
  /**
   * Return recommended defaults for map parameters and osm or tile layer
   * parameters where the expected intent is to use the map in pixel
   * coordinates (upper left is (0, 0), lower right is (`width`, `height`).
   *
   * @example <caption>The returned objects can be modified or
   *    extended.</caption>
   * var results = pixelCoordinateParams('#map', 10000, 9000);
   * var map = geo.map(Object.assign(results.map, {clampZoom: false}));
   * map.createLayer('osm', results.layer);
   *
   * @param {string?} node DOM selector for the map container.
   * @param {number} width Width of the whole map contents in pixels.
   * @param {number} height Height of the whole map contents in pixels.
   * @param {number} [tileWidth] If an osm or tile layer is going to be used,
   *    the width of a tile.
   * @param {number} [tileHeight] If an osm or tile layer is going to be used,
   *    the height of a tile.
   * @returns {object} An object with `map` and `layer` properties.  `map` is
   *    an object that can be passed to {@link geo.map}, and `layer` is an
   *    object that can be passed to `map.createLayer`.
   * @memberof geo.util
   */
  pixelCoordinateParams: function pixelCoordinateParams(node, width, height, tileWidth, tileHeight) {
    var mapW, mapH, tiled;
    if (node) {
      node = $(node);
      mapW = node.innerWidth();
      mapH = node.innerHeight();
    }
    tileWidth = tileWidth || width;
    tileHeight = tileHeight || height;
    tiled = tileWidth !== width || tileHeight !== height;
    var minLevel = Math.min(0, Math.floor(Math.log(Math.min((mapW || tileWidth) / tileWidth, (mapH || tileHeight) / tileHeight)) / Math.log(2))),
      maxLevel = Math.max(0, Math.ceil(Math.log(Math.max(width / tileWidth, height / tileHeight)) / Math.log(2)));
    var mapParams = {
      node: node,
      ingcs: '+proj=longlat +axis=esu',
      gcs: '+proj=longlat +axis=enu',
      maxBounds: {
        left: 0,
        top: 0,
        right: width,
        bottom: height
      },
      unitsPerPixel: Math.pow(2, maxLevel),
      center: {
        x: width / 2,
        y: height / 2
      },
      min: minLevel,
      max: maxLevel,
      zoom: minLevel,
      clampBoundsX: true,
      clampBoundsY: true,
      clampZoom: true
    };
    var layerParams = {
      maxLevel: maxLevel,
      minLevel: Math.min(0, maxLevel),
      wrapX: false,
      wrapY: false,
      tileOffset: function tileOffset() {
        return {
          x: 0,
          y: 0
        };
      },
      attribution: '',
      tileWidth: tileWidth,
      tileHeight: tileHeight,
      tileRounding: Math.ceil,
      tilesAtZoom: tiled ? function (level) {
        var scale = Math.pow(2, maxLevel - level);
        return {
          x: Math.ceil(width / tileWidth / scale),
          y: Math.ceil(height / tileHeight / scale)
        };
      } : undefined,
      tilesMaxBounds: tiled ? function (level) {
        var scale = Math.pow(2, maxLevel - level);
        return {
          x: Math.floor(width / scale),
          y: Math.floor(height / scale)
        };
      } : undefined
    };
    return {
      map: mapParams,
      layer: layerParams
    };
  },
  /**
   * Return the coordinate associated with the center of the perimeter formed
   * from a list of points.  This averages all of the vertices in the perimeter
   * weighted by the line length on either side of each point.  Functionally,
   * this is the same as the average of all the points of the lines of the
   * perimeter.
   *
   * @param {geo.geoPolygon} coor An array of coordinates.  This can also be
   *    a polygon object with an ``outer`` element with an array of
   *    coordinates.
   * @returns {geo.geoPosition|undefined} The position for the center, or
   *    `undefined` if no such position exists.
   * @memberof geo.util
   */
  centerFromPerimeter: function centerFromPerimeter(coor) {
    var position, p0, p1, w, sumw, i;
    if (coor && coor.outer) {
      coor = coor.outer;
    }
    if (!coor || !coor.length) {
      return;
    }
    if (coor.length === 1) {
      return {
        x: coor[0].x,
        y: coor[0].y
      };
    }
    position = {
      x: 0,
      y: 0
    };
    sumw = 0;
    p0 = coor[coor.length - 1];
    for (i = 0; i < coor.length; i += 1) {
      p1 = p0;
      p0 = coor[i];
      w = Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));
      position.x += (p0.x + p1.x) * w;
      position.y += (p0.y + p1.y) * w;
      sumw += 2 * w;
    }
    position.x /= sumw;
    position.y /= sumw;
    // return a copy of p0 if all points are the same
    return sumw ? position : {
      x: p0.x,
      y: p0.y
    };
  },
  /**
   * Get the square of the Euclidean 2D distance between two points.
   *
   * @param {geo.geoPosition} pt1 The first point.
   * @param {geo.geoPosition} pt2 The second point.
   * @returns {number} The distance squared.
   */
  distance2dSquared: function distance2dSquared(pt1, pt2) {
    var dx = pt1.x - pt2.x,
      dy = pt1.y - pt2.y;
    return dx * dx + dy * dy;
  },
  /**
   * Get the square of the Euclidean 2D distance between a point and a line
   * segment.
   *
   * @param {geo.geoPosition} pt The point.
   * @param {geo.geoPosition} line1 One end of the line.
   * @param {geo.geoPosition} line2 The other end of the line.
   * @returns {number} The distance squared.
   * @memberof geo.util
   */
  distance2dToLineSquared: function distance2dToLineSquared(pt, line1, line2) {
    var dx = line2.x - line1.x,
      dy = line2.y - line1.y,
      // we could get the line length from the distance2dSquared function,
      // but since we need dx and dy in this function, it is faster to just
      // compute it here.
      lengthSquared = dx * dx + dy * dy,
      t = 0;
    if (lengthSquared) {
      t = ((pt.x - line1.x) * dx + (pt.y - line1.y) * dy) / lengthSquared;
      t = Math.max(0, Math.min(1, t));
    }
    return util.distance2dSquared(pt, {
      x: line1.x + t * dx,
      y: line1.y + t * dy
    });
  },
  /**
   * Get the signed Euclidean 2D distance between a point and a polygon.  The
   * distance is positive if the point is inside of the polygon.
   *
   * @param {geo.geoPosition} pt The point.
   * @param {geo.polygonObject} poly The polygon.
   * @param {boolean} [onlySign] If truthy, only the sign of the answer is
   *    significant.
   * @returns {number} The signed distance.
   * @memberof geo.util
   */
  distanceToPolygon2d: function distanceToPolygon2d(pt, poly, onlySign) {
    var outer = poly.outer || poly;
    var inside = false,
      minDistSq,
      distSq;
    for (var i = 0, len = outer.length, j = len - 1; i < len; j = i, i += 1) {
      var p0 = outer[i],
        p1 = outer[j];
      if (p0.y > pt.y !== p1.y > pt.y && pt.x < (p1.x - p0.x) * (pt.y - p0.y) / (p1.y - p0.y) + p0.x) {
        inside = !inside;
      }
      distSq = onlySign ? 1 : util.distance2dToLineSquared(pt, p0, p1);
      if (minDistSq === undefined || distSq < minDistSq) {
        minDistSq = distSq;
      }
    }
    if (poly.inner) {
      poly.inner.forEach(function (inner) {
        var innerDist = util.distanceToPolygon2d(pt, inner, onlySign);
        if (innerDist * innerDist < minDistSq) {
          minDistSq = innerDist * innerDist;
        }
        if (innerDist > 0) {
          inside = !inside;
        }
      });
    }
    var dist = (inside ? 1 : -1) * Math.sqrt(minDistSq);
    return dist;
  },
  /**
   * Get twice the signed area of a 2d triangle.
   *
   * @param {geo.geoPosition} pt1 A vertex.
   * @param {geo.geoPosition} pt2 A vertex.
   * @param {geo.geoPosition} pt3 A vertex.
   * @returns {number} Twice the signed area.
   * @memberof geo.util
   */
  triangleTwiceSignedArea2d: function triangleTwiceSignedArea2d(pt1, pt2, pt3) {
    return (pt2.y - pt1.y) * (pt3.x - pt2.x) - (pt2.x - pt1.x) * (pt3.y - pt2.y);
  },
  /**
   * Determine if a line segment crosses any line segments of a polygon.
   *
   * @param {geo.geoPosition} pt1 One endpoint of the line.
   * @param {geo.geoPosition} pt2 The other endpoint of the line.
   * @param {geo.polygonObject} poly The polygon.
   * @returns {boolean} True if the segment cross any segment of the polygon.
   * @memberof geo.util
   */
  crossedLineSegmentPolygon2d: function crossedLineSegmentPolygon2d(pt1, pt2, poly) {
    var outer = poly.outer || poly,
      len = outer.length;
    var i, j;
    for (i = 0, j = len - 1; i < len; j = i, i += 1) {
      if (util.crossedLineSegments2d(pt1, pt2, outer[i], outer[j])) {
        return true;
      }
    }
    if (poly.inner) {
      for (i = 0; i < poly.inner.length; i += 1) {
        if (util.crossedLineSegmentPolygon2d(pt1, pt2, poly.inner[i])) {
          return true;
        }
      }
    }
    return false;
  },
  /**
   * Determine if two line segments cross.  They are not considered crossing if
   * they share a vertex.  They are crossing if either of one segment's
   * vertices are collinear with the other segment.
   *
   * @param {geo.geoPosition} seg1pt1 One endpoint of the first segment.
   * @param {geo.geoPosition} seg1pt2 The other endpoint of the first segment.
   * @param {geo.geoPosition} seg2pt1 One endpoint of the second segment.
   * @param {geo.geoPosition} seg2pt2 The other endpoint of the second segment.
   * @returns {boolean} True if the segments cross.
   * @memberof geo.util
   */
  crossedLineSegments2d: function crossedLineSegments2d(seg1pt1, seg1pt2, seg2pt1, seg2pt2) {
    /* If the segments don't have any overlap in x or y, they can't cross */
    if (seg1pt1.x > seg2pt1.x && seg1pt1.x > seg2pt2.x && seg1pt2.x > seg2pt1.x && seg1pt2.x > seg2pt2.x || seg1pt1.x < seg2pt1.x && seg1pt1.x < seg2pt2.x && seg1pt2.x < seg2pt1.x && seg1pt2.x < seg2pt2.x || seg1pt1.y > seg2pt1.y && seg1pt1.y > seg2pt2.y && seg1pt2.y > seg2pt1.y && seg1pt2.y > seg2pt2.y || seg1pt1.y < seg2pt1.y && seg1pt1.y < seg2pt2.y && seg1pt2.y < seg2pt1.y && seg1pt2.y < seg2pt2.y) {
      return false;
    }
    /* If any vertex is in common, it is not considered crossing */
    if (seg1pt1.x === seg2pt1.x && seg1pt1.y === seg2pt1.y || seg1pt1.x === seg2pt2.x && seg1pt1.y === seg2pt2.y || seg1pt2.x === seg2pt1.x && seg1pt2.y === seg2pt1.y || seg1pt2.x === seg2pt2.x && seg1pt2.y === seg2pt2.y) {
      return false;
    }
    /* If the lines cross, the signed area of the triangles formed between one
     * segment and the other's vertices will have different signs.  By using
     * > 0, collinear points are crossing. */
    if (util.triangleTwiceSignedArea2d(seg1pt1, seg1pt2, seg2pt1) * util.triangleTwiceSignedArea2d(seg1pt1, seg1pt2, seg2pt2) > 0 || util.triangleTwiceSignedArea2d(seg2pt1, seg2pt2, seg1pt1) * util.triangleTwiceSignedArea2d(seg2pt1, seg2pt2, seg1pt2) > 0) {
      return false;
    }
    return true;
  },
  /**
   * Check if a line segment crosses any segment from a list of lines.  The
   * segment is considered crossing it it touches a line segment, unless that
   * line segment shares a vertex with the segment.
   *
   * @param {geo.geoPosition} pt1 One end of the line segment.
   * @param {geo.geoPosition} pt2 The other end of the line segment.
   * @param {Array.<geo.geoPosition[]>} lineList A list of open lines.  Each
   *    line is a list of vertices.  The line segment is checked against each
   *    segment of each line in this list.
   * @returns {boolean} True if the segment crosses any line segment.
   * @memberof geo.util
   */
  segmentCrossesLineList2d: function segmentCrossesLineList2d(pt1, pt2, lineList) {
    var result = lineList.some(function (line) {
      return line.some(function (linePt, idx) {
        if (idx) {
          return util.crossedLineSegments2d(pt1, pt2, line[idx - 1], linePt);
        }
        return false;
      });
    });
    return result;
  },
  /**
   * Remove vertices from a chain of 2d line segments so that it is simpler but
   * is close to the original overall shape within some tolerance limit.  This
   * is the RamerDouglasPeucker algorithm.  The first and last points will
   * always remain the same for open lines.  For closed lines (polygons), this
   * picks an point that likely to be significant and then reduces it, possibly
   * returning a single point.
   *
   * @param {geo.geoPosition[]} pts A list of points forming the line or
   *    polygon.
   * @param {number} tolerance The maximum variation allowed.  A value of zero
   *    will only remove perfectly collinear points.
   * @param {boolean} [closed] If true, this is a polygon rather than an open
   *    line.  In this case, it is possible to get back a single point.
   * @param {Array.<geo.geoPosition[]>?} [noCrossLines] A falsy value to allow
   *    the resultant line to cross itself, an empty array (`[]`) to prevent
   *    self-crossing, or an array of line segments to prevent self-crossing
   *    and disallow crossing any line segment in the list.  Each entry in the
   *    list is an open line (with one segment less than the number of
   *    vertices).  If self-crossing is prohibited, the resultant point set
   *    might not be as simplified as it could be.
   * @returns {geo.geoPosition[]} The new point set.
   * @memberof geo.util
   */
  rdpLineSimplify: function rdpLineSimplify(pts, tolerance, closed, noCrossLines) {
    if (pts.length <= 2 || tolerance < 0) {
      return pts;
    }
    var i,
      distSq,
      maxDistSq = -1,
      index,
      toleranceSq = tolerance * tolerance;
    if (closed) {
      /* If this is closed, find the point that is furthest from the first
       * point.  ideally, one would find a point that is guaranteed to be on
       * the diameter of the convex hull, but doing so is an O(n^2) operation,
       * whereas this is sufficient and only O(n).  The chosen point is
       * duplicated at the start and end of the chain. */
      for (i = 1; i < pts.length; i += 1) {
        distSq = util.distance2dSquared(pts[0], pts[i]);
        if (distSq > maxDistSq) {
          maxDistSq = distSq;
          index = i;
        }
      }
      /* Points could be on any side of the start point, so if all points are
       * within 1/2 of the tolerance of the start point, we know all points are
       * within the tolerance of each other and therefore this polygon or
       * closed line can be simplified to a point. */
      if (maxDistSq * 4 <= toleranceSq) {
        return pts.slice(index, index + 1);
      }
      pts = pts.slice(index).concat(pts.slice(0, index + 1));
      pts = util.rdpLineSimplify(pts, tolerance, false, noCrossLines);
      /* Removed the duplicated first point */
      pts.splice(pts.length - 1);
      return pts;
    }
    for (i = 1; i < pts.length - 1; i += 1) {
      distSq = util.distance2dToLineSquared(pts[i], pts[0], pts[pts.length - 1]);
      if (distSq > maxDistSq) {
        maxDistSq = distSq;
        index = i;
      }
    }
    /* We can collapse this to a single line if it is within the tolerance and
     * we are either allowed to self-cross or it does not self-cross the rest
     * of the line. */
    if (maxDistSq <= toleranceSq && (!noCrossLines || !util.segmentCrossesLineList2d(pts[0], pts[pts.length - 1], noCrossLines))) {
      return [pts[0], pts[pts.length - 1]];
    }
    var left = pts.slice(0, index + 1),
      right = pts.slice(index),
      leftSide = util.rdpLineSimplify(left, tolerance, false, noCrossLines ? noCrossLines.concat([right]) : null),
      rightSide = util.rdpLineSimplify(right, tolerance, false, noCrossLines ? noCrossLines.concat([left]) : null);
    return leftSide.slice(0, leftSide.length - 1).concat(rightSide);
  },
  /**
   * Given an array, return the minimum and maximum values within the array.
   * If a numeric value is specified for one or the other, return that instead.
   *
   * @param {number[]} values An array of numeric values.
   * @param {number} [min] If specified, use this instead of calculating the
   *    minimum.
   * @param {number} [max] If specified, use this instead of calculating the
   *    maximum.
   * @param {boolean} [limit] If truthy, if `min` is specified, the
   *    returned `min` will be the larger of the specified value and the
   *    computed value, and if `max` is specified, the returned value will
   *    be the smaller of the specified value and the computed value.
   * @returns {object} An object with `min` and `max`, both numbers.  If the
   *    array is empty, `undefined` may be returned for the `min` and `max`.
   * @memberof geo.util
   */
  getMinMaxValues: function getMinMaxValues(values, min, max, limit) {
    if (values.length && (limit || !$.isNumeric(min) || !$.isNumeric(max))) {
      var minValue = values[0],
        maxValue = values[0],
        value,
        i;
      for (i = values.length - 1; i > 0; i -= 1) {
        value = values[i];
        if (value < minValue) {
          minValue = value;
        }
        if (value > maxValue) {
          maxValue = value;
        }
      }
      if (!$.isNumeric(min) || limit && minValue > min) {
        min = minValue;
      }
      if (!$.isNumeric(max) || limit && maxValue < max) {
        max = maxValue;
      }
    }
    return {
      min: min,
      max: max
    };
  },
  /**
   * Given a value in radians, return a value wrapped to the range [-PI, PI).
   *
   * @param {number} value A value in radians.
   * @returns {number} The wrapped value.
   * @memberof geo.util
   */
  wrapAngle: function wrapAngle(value) {
    /* Module will only ensure that this is between [-2 PI, 2 PI). */
    value = value % (Math.PI * 2);
    if (value < -Math.PI) {
      value += Math.PI * 2;
    } else if (value >= Math.PI) {
      value -= Math.PI * 2;
    }
    return value;
  },
  /**
   * Escape any character in a string that has a code point >= 127.
   *
   * @param {string} text The string to escape.
   * @returns {string} The escaped string.
   * @memberof geo.util
   */
  escapeUnicodeHTML: function escapeUnicodeHTML(text) {
    return text.replace(/[^- 0-9A-Za-z~`!@#$%^&*()_+={}|[\]\\:";'<>?,./]/g, function (k, pos) {
      var code = k.charCodeAt(0);
      if (code < 127) {
        return k;
      }
      /* decode utf016 surrogate pairs */
      if (code >= 0xD800 && code <= 0xE000) {
        if (code < 0xDC00 || pos) {
          return '';
        }
        var code0 = text.charCodeAt(pos - 1);
        if (code0 < 0xD800 || code0 >= 0xDC00) {
          return '';
        }
        code = (code0 - 0xD800) * 0x400 + (code - 0xDC00);
      }
      return '&#' + code.toString(10) + ';';
    });
  },
  /**
   * Recursively merge two objects.  This is intended to replace
   * $.extend(target, ...sources).
   *
   * @param {object} target target object to modify.
   * @param {object} sources object(s) to merge into the target.
   * @returns {object} The merged object.
   * @memberof geo.util
   */
  deepMerge: function deepMerge(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }
    for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
      var source = _sources[_i];
      if (source === null || source === undefined) {
        continue;
      }
      for (var key in source) {
        if (key === '__proto__' || target === source[key]) {
          continue;
        }
        var copy = source[key];
        if (copy && _typeof(copy) === 'object' && (copy.constructor === Object || Array.isArray(copy))) {
          var value = target[key];
          if (!Array.isArray(copy)) {
            if (_typeof(value) !== 'object' || Array.isArray(value)) {
              value = {};
            }
          } else if (!Array.isArray(value)) {
            value = [];
          }
          target[key] = util.deepMerge(value, copy);
        } else if (copy !== undefined) {
          target[key] = copy;
        }
      }
    }
    return target;
  },
  /**
   * Check svg image and html img tags.  If the source is set, load images
   * explicitly and convert them to local data:image references.
   *
   * @param {jQuery.selector} elem A jQuery selector or element set that may
   *    contain images.
   * @returns {jQuery.Deferred[]} A list of deferred objects that resolve
   *    when images are dereferenced.
   * @memberof geo.util
   */
  dereferenceElements: function dereferenceElements(elem) {
    var deferList = [];
    $('img,image', elem).each(function () {
      var src = $(this);
      var key = src.is('image') ? 'href' : 'src';
      if (src.attr(key)) {
        var img = new Image();
        if (src.attr(key).substr(0, 4) === 'http' || src[0].crossOrigin) {
          img.crossOrigin = src[0].crossOrigin || 'anonymous';
        }
        var defer = $.Deferred();
        img.onload = function () {
          var cvs = document.createElement('canvas');
          cvs.width = img.naturalWidth;
          cvs.height = img.naturalHeight;
          cvs.getContext('2d').drawImage(img, 0, 0);
          src.attr(key, cvs.toDataURL('image/png'));
          if (src.attr(key).substr(0, 10) !== 'data:image') {
            src.remove();
          }
          defer.resolve();
        };
        img.onerror = function () {
          src.remove();
          defer.resolve();
        };
        img.src = src.attr(key);
        deferList.push(defer);
      }
    });
    return deferList;
  },
  dereferenceCssUrlsRegex: /url\(["']?(http[^)"']+|[^:)"']+)["']?\)/g,
  /**
   * Check css text.  Any url(http[s]...) references are dereferenced and
   * stored as local base64 urls.
   *
   * @param {string} css The css to parse for urls.
   * @param {jQuery.selector|HTMLElement} styleElem The element that receives
   *    the css text after dereferencing or the DOM element that has style
   *    that will be updated.
   * @param {jQuery.Deferred} styleDefer A Deferred to resolve once
   *    dereferencing is complete.
   * @param {string} [styleKey] If unset, styleElem is a header element.  If
   *    set, styleElem is a DOM element and the named style will be updated.
   * @param {string} [baseUrl] If present, this is the base for relative urls.
   * @memberof geo.util
   */
  dereferenceCssUrls: function dereferenceCssUrls(css, styleElem, styleDefer, styleKey, baseUrl) {
    var deferList = [],
      results = [];

    /* Remove comments to avoid dereferencing commented out sections.
     * To match across lines, use [^\0] rather than . */
    css = css.replace(/\/\*[^\0]*?\*\//g, '');
    /* reduce whitespace to make the css shorter */
    css = css.replace(/\r/g, '\n').replace(/\s+\n/g, '\n').replace(/\n\s+/g, '\n').replace(/\n\n+/g, '\n');
    if (baseUrl) {
      var match = /(^[^?#]*)\/[^?#/]*([?#]|$)/g.exec(baseUrl);
      baseUrl = match && match[1] ? match[1] + '/' : null;
    }
    css.replace(util.dereferenceCssUrlsRegex, function (match, url) {
      var idx = deferList.length,
        defer = $.Deferred(),
        xhr = new XMLHttpRequest();
      deferList.push(defer);
      results.push('');
      if (/^[^/:][^:]*(\/|$)/g.exec(url) && baseUrl) {
        url = baseUrl + url;
      }
      xhr.open('GET', url, true);
      xhr.responseType = 'arraybuffer';
      xhr.onload = function () {
        if (this.status === 200) {
          var response = new Uint8Array(this.response),
            data = new Array(response.length),
            i;
          for (i = 0; i < response.length; i += 1) {
            data[i] = String.fromCharCode(response[i]);
          }
          data = data.join('');
          results[idx] = 'url(data:' + xhr.getResponseHeader('content-type') + ';base64,' + btoa(data) + ')';
        }
        // resolve regardless of what response we get
        defer.resolve();
      };
      // if this fails, resolve anyway
      xhr.onerror = defer.resolve;
      xhr.send();
      return match;
    });
    $.when.apply($, deferList).then(function () {
      var idx = 0;
      css = css.replace(util.dereferenceCssUrlsRegex, function (match, url) {
        idx += 1;
        return results[idx - 1];
      });
      if (styleKey === undefined) {
        styleElem.text(css);
      } else {
        styleElem.style[styleKey] = css;
      }
      styleDefer.resolve();
    });
  },
  /**
   * Check if the current browser supports converting html to an image via an
   * svg foreignObject and canvas.  If this has not been checked before, it
   * returns a Deferred that resolves to a boolean (never rejects).  If the
   * check has been done before, it returns a boolean.
   *
   * @returns {boolean|jQuery.Deferred}
   * @memberof geo.util
   */
  htmlToImageSupported: function htmlToImageSupported() {
    if (m_htmlToImageSupport === undefined) {
      var defer = $.Deferred();
      var svg = $(svgForeignObject);
      svg.attr({
        width: '10px',
        height: '10px',
        'text-rendering': 'optimizeLegibility'
      });
      $('foreignObject', svg).append('<div/>');
      var img = new Image();
      img.onload = img.onerror = function () {
        var canvas = document.createElement('canvas');
        canvas.width = 10;
        canvas.height = 10;
        var context = canvas.getContext('2d');
        context.drawImage(img, 0, 0);
        try {
          canvas.toDataURL();
          m_htmlToImageSupport = true;
        } catch (err) {
          console.warn(
          // eslint-disable-line no-console
          'This browser does not support converting HTML to an image via ' + 'SVG foreignObject.  Some functionality will be limited.', err);
          m_htmlToImageSupport = false;
        }
        defer.resolve(m_htmlToImageSupport);
      };
      img.src = 'data:image/svg+xml;base64,' + btoa(util.escapeUnicodeHTML(new XMLSerializer().serializeToString(svg[0])));
      return defer;
    }
    return m_htmlToImageSupport;
  },
  /**
   * Convert an html element to an image.  This attempts to localize any
   * images within the element.  If there are other external references, the
   * image may not work due to security considerations.
   *
   * @param {jQuery.selector} elem Either a jquery selector or an HTML
   *    element.  This may contain multiple elements.  The direct parent and
   *    grandparent of the element are used for class information.
   * @param {number} [parents] Number of layers up to travel to get class
   *    information.
   * @returns {jQuery.Deferred} A jquery deferred object which receives an
   *    HTML Image element when resolved.
   * @memberof geo.util
   */
  htmlToImage: function htmlToImage(elem, parents) {
    var defer = $.Deferred(),
      deferList = [util.htmlToImageSupported()],
      container;
    var parent = $(elem);
    elem = $(elem).clone();
    while (parents && parents > 0) {
      parent = parent.parent();
      if (parent.is('div')) {
        /* Create a containing div with the parent's class and id (so css
         * will be used), but override size and background. */
        container = $('<div>').attr({
          class: parent.attr('class'),
          id: parent.attr('id')
        }).css({
          width: '100%',
          height: '100%',
          background: 'none',
          margin: 0
        });
        container.append(elem);
        elem = container;
      }
      parents -= 1;
    }
    // canvas elements won't render properly here.
    $('canvas', elem).remove();
    /* Walk through all of the children of elem and check if any explicitly set
     * css property needs to be dereferenced. */
    $('*', elem).addBack().each(function () {
      var style = this.style;
      for (var idx = 0; idx < style.length; idx += 1) {
        var key = this.style[idx];
        if (this.style[key].match(util.dereferenceCssUrlsRegex)) {
          var styleDefer = $.Deferred();
          util.dereferenceCssUrls(this.style[key], this, styleDefer, key);
          deferList.push(styleDefer);
        }
      }
    });
    container = $('<div xmlns="http://www.w3.org/1999/xhtml">');
    container.css({
      width: parent.width() + 'px',
      height: parent.height() + 'px'
    });
    container.append($('<head>'));
    var body = $('<body>');
    container.append(body);
    /* We must specify the new body as having no background, or we'll clobber
     * other layers. */
    body.css({
      width: parent.width() + 'px',
      height: parent.height() + 'px',
      background: 'none',
      margin: 0
    });
    body.append(elem);
    deferList = deferList.concat(util.dereferenceElements(elem));
    /* Get styles and links in order, as order matters in css */
    $('style,link[rel="stylesheet"]').each(function () {
      var styleElem = $('<style type="text/css">'),
        styleDefer = $.Deferred();
      if ($(this).is('style')) {
        var css = $(this).text();
        util.dereferenceCssUrls(css, styleElem, styleDefer);
      } else {
        var href = $(this).attr('href');
        $.get(href).done(function (css) {
          util.dereferenceCssUrls(css, styleElem, styleDefer, undefined, href);
        }).fail(function (xhr, status, err) {
          console.warn('Failed to dereference ' + href, status, err); // eslint-disable-line no-console
          styleElem.remove();
          styleDefer.resolve();
        });
      }
      deferList.push(styleDefer);
      $('head', container).append(styleElem);
    });
    $.when.apply($, deferList).then(function () {
      var svg = $(svgForeignObject);
      svg.attr({
        width: parent.width() + 'px',
        height: parent.height() + 'px',
        // Adding this via the attr call works in Firefox headless, whereas if
        // it is part of the svgForeignObject string, it does not.
        'text-rendering': 'optimizeLegibility'
      });
      $('foreignObject', svg).append(container);
      var img = new Image();
      if (!util.htmlToImageSupported()) {
        defer.resolve(img);
      } else {
        img.onload = function () {
          defer.resolve(img);
        };
        img.onerror = function () {
          console.warn('Failed to render html to image'); // eslint-disable-line no-console
          defer.reject();
        };
        // Firefox requires the HTML to be base64 encoded.  Chrome doesn't, but
        // doing so does no harm.
        img.src = 'data:image/svg+xml;base64,' + btoa(util.escapeUnicodeHTML(new XMLSerializer().serializeToString(svg[0])));
      }
    });
    return defer;
  },
  /**
   * Report on one or all of the tracked timings.
   *
   * @param {string} [name] A name to report on, or `undefined` to report all.
   * @returns {object} An object with timing information, or an object with
   *    properties for all tracked timings, each of which contains timing
   *    information.
   * @memberof geo.util
   */
  timeReport: function timeReport(name) {
    $.each(m_timingData, function (key, item) {
      /* calculate the standard deviation of each item. */
      if (item.count) {
        item.stddev = Math.sqrt(Math.abs((item.sum2 - item.sum * item.sum / item.count) / item.count));
        item.average = item.sum / item.count;
      } else {
        item.stddev = 0;
        item.average = 0;
      }
    });
    if (name) {
      return m_timingData[name];
    }
    return m_timingData;
  },
  /**
   * Note the start time of a function (or any other section of code).  This
   * should be paired with `timeFunctionStop`, which will collect statistics on
   * the amount of time spent in a function.
   *
   * @param {string} name Name to use for tracking the timing.
   * @param {boolean} reset If `true`, clear old tracking data for this named
   *    tracker.
   * @memberof geo.util
   */
  timeFunctionStart: function timeFunctionStart(name, reset) {
    if (!m_timingData[name] || reset) {
      m_timingData[name] = {
        count: 0,
        sum: 0,
        sum2: 0,
        max: 0,
        recent: []
      };
    }
    m_timingData[name].start = window.performance.now();
  },
  /**
   * Note the stop time of a function (or any other section of code).  This
   * should be paired with `timeFunctionStart`.
   *
   * @param {string} name Name to use for tracking the timing.
   * @memberof geo.util
   */
  timeFunctionStop: function timeFunctionStop(name) {
    if (!m_timingData[name] || !m_timingData[name].start) {
      return;
    }
    var duration = window.performance.now() - m_timingData[name].start;
    m_timingData[name].start = null;
    m_timingData[name].sum += duration;
    m_timingData[name].sum2 += duration * duration;
    m_timingData[name].count += 1;
    m_timingData[name].max = Math.max(m_timingData[name].max, duration);
    m_timingData[name].recent.push(duration);
    if (m_timingData[name].recent.length > m_timingKeepRecent) {
      m_timingData[name].recent.splice(0, m_timingData[name].recent.length - m_timingKeepRecent);
    }
  },
  /**
   * Start or stop tracking the time spent in `requestAnimationFrame`.  If
   * tracked, the results can be fetched via
   * `timeFunctionReport('requestAnimationFrame')`.
   *
   * @param {boolean} [stop] Falsy to start tracking, truthy to start tracking.
   * @param {boolean} [reset] If truthy, reset the statistics.
   * @param {number} [threshold] If present, set the threshold in
   *    milliseconds used in tracking slow callbacks.
   * @param {number} [keep] If present, set the number of recent frame
   *    times to track.
   * @memberof geo.util
   */
  timeRequestAnimationFrame: function timeRequestAnimationFrame(stop, reset, threshold, keep) {
    if (!m_timingData.requestAnimationFrame || reset) {
      m_timingData.requestAnimationFrame = {
        count: 0,
        sum: 0,
        sum2: 0,
        max: 0,
        above_threshold: 0,
        recent: [],
        recentsub: []
      };
    }
    if (threshold) {
      m_threshold = threshold;
    }
    if (keep) {
      m_timingKeepRecent = keep;
    }
    if (stop && m_originalRequestAnimationFrame) {
      window.requestAnimationFrame = m_originalRequestAnimationFrame;
      m_originalRequestAnimationFrame = null;
    } else if (!stop && !m_originalRequestAnimationFrame) {
      m_originalRequestAnimationFrame = window.requestAnimationFrame;
      window.requestAnimationFrame = function (callback) {
        return m_originalRequestAnimationFrame.call(window, function (timestamp) {
          var track = m_timingData.requestAnimationFrame,
            recent;
          /* Some environments have unsynchronized performance and time
           * counters.  The nowDelta factor compensates for this.  For
           * instance, our test environment has performance.now() values on
           * the order of ~3000 and timestamps approximating epoch. */
          if (track.timestamp !== timestamp) {
            track.nowDelta = window.performance.now() - timestamp;
            if (Math.abs(track.nowDelta) < 1000) {
              track.nowDelta = 0;
            }
            track.timestamp = timestamp;
            track.subcalls = track.subcalls || 0;
            track.start = {
              sum: track.sum,
              sum2: track.sum2,
              count: track.count,
              max: track.max,
              above_threshold: track.above_threshold
            };
            track.recent.push([0]);
            track.recentsub.push([]);
            if (track.recent.length > m_timingKeepRecent) {
              track.recent.splice(0, track.recent.length - m_timingKeepRecent);
              track.recentsub.splice(0, track.recentsub.length - m_timingKeepRecent);
            }
          }
          track.subcalls += 1;
          callback.apply(this, arguments);
          var duration = window.performance.now() - timestamp;
          duration -= track.nowDelta;
          track.sum = track.start.sum + duration;
          track.sum2 = track.start.sum2 + duration * duration;
          track.count = track.start.count + 1;
          track.max = Math.max(track.max, duration);
          track.above_threshold = track.start.above_threshold + (duration >= m_threshold ? 1 : 0);
          track.recent[track.recent.length - 1] = duration;
          recent = track.recentsub[track.recent.length - 1];
          recent.push({
            total_duration: duration,
            duration: duration - (recent.length ? recent[recent.length - 1].total_duration : 0),
            callback: callback.name || callback
          });
        });
      };
    }
  },
  /**
   * Test if an item is an object.  This uses typeof not instanceof, since
   * instanceof will return false for some things that we expect to be objects.
   *
   * @param {*} value The item to test.
   * @returns {boolean} True if the tested item is an object.
   * @memberof geo.util
   */
  isObject: function isObject(value) {
    var type = _typeof(value);
    return value !== null && value !== undefined && (type === 'object' || type === 'function');
  },
  /**
   * Return the first value passed to the function.  Using this function for
   * identity calls can allow some code to bypass making such a call entirely.
   *
   * @param {*} d Any value.
   * @returns {*} The passed value.
   */
  identityFunction: function identityFunction(d) {
    return d;
  },
  /**
   * Pack an array of three numbers and one boolean into a single float.  Each
   * numerical value is either undefined or on the scale of [0, 1] and is
   * mapped to an integer range of [0, 250].
   *
   * @param {number|number[]} value A single value or an array of up to four
   *    values where the first three values are numbers and the last is a
   *    boolean.
   * @returns {number} A packed number.
   */
  packFloats: function packFloats(value) {
    if (!value.length) {
      return value === undefined ? 0 : Math.floor(Math.abs(value) * 250) + 1;
    }
    return ((value[0] === undefined ? 0 : Math.floor(Math.abs(value[0]) * 250) + 1) + (value[1] === undefined ? 0 : Math.floor(Math.abs(value[1]) * 250) + 1) * 252 + (value[2] === undefined ? 0 : Math.floor(Math.abs(value[2]) * 250) + 1) * 252 * 252) * (value[3] ? -1 : 1);
  },
  ///////////////////////////////////////////////////////////////////////////
  /*
   * Utility member properties.
   */
  ///////////////////////////////////////////////////////////////////////////

  /**
   * Radius of the earth in meters, from the equatorial radius of SRID 4326.
   * @memberof geo.util
   */
  radiusEarth: proj4.WGS84.a
};
module.exports = util;

/***/ }),

/***/ 7235:
/***/ (function(module) {

/*
markercluster plugin:

Copyright 2012 David Leaver

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Leaflet utilities:

Copyright (c) 2010-2015, Vladimir Agafonkin
Copyright (c) 2010-2011, CloudMade
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice, this list of
      conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright notice, this list
      of conditions and the following disclaimer in the documentation and/or other
      materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * Code taken from https://github.com/Leaflet/Leaflet.markercluster
 * to support faster hierarchical clustering of features.
 * @copyright 2012, David Leaver
 */

var L = {};
L.Util = {
  // return unique ID of an object
  stamp: function stamp(obj) {
    obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
    return obj._leaflet_id;
  },
  lastId: 0
};

/**
 * @class
 * @alias geo.util.DistanceGrid
 */
var DistanceGrid = function DistanceGrid(cellSize) {
  this._cellSize = cellSize;
  this._sqCellSize = cellSize * cellSize;
  this._grid = {};
  this._objectPoint = {};
};
DistanceGrid.prototype = {
  addObject: function addObject(obj, point) {
    var x = this._getCoord(point.x),
      y = this._getCoord(point.y),
      grid = this._grid,
      row = grid[y] = grid[y] || {},
      cell = row[x] = row[x] || [],
      stamp = L.Util.stamp(obj);
    point.obj = obj;
    this._objectPoint[stamp] = point;
    cell.push(obj);
  },
  updateObject: function updateObject(obj, point) {
    this.removeObject(obj);
    this.addObject(obj, point);
  },
  //Returns true if the object was found
  removeObject: function removeObject(obj, point) {
    var x = this._getCoord(point.x),
      y = this._getCoord(point.y),
      grid = this._grid,
      row = grid[y] = grid[y] || {},
      cell = row[x] = row[x] || [],
      i,
      len;
    delete this._objectPoint[L.Util.stamp(obj)];
    for (i = 0, len = cell.length; i < len; i++) {
      if (cell[i] === obj) {
        cell.splice(i, 1);
        if (len === 1) {
          delete row[x];
        }
        return true;
      }
    }
  },
  eachObject: function eachObject(fn, context) {
    var i,
      j,
      k,
      len,
      row,
      cell,
      removed,
      grid = this._grid;
    for (i in grid) {
      row = grid[i];
      for (j in row) {
        cell = row[j];
        for (k = 0, len = cell.length; k < len; k++) {
          removed = fn.call(context, cell[k]);
          if (removed) {
            k--;
            len--;
          }
        }
      }
    }
  },
  getNearObject: function getNearObject(point) {
    var x = this._getCoord(point.x),
      y = this._getCoord(point.y),
      i,
      j,
      k,
      row,
      cell,
      len,
      obj,
      dist,
      objectPoint = this._objectPoint,
      closestDistSq = this._sqCellSize,
      closest = null;
    for (i = y - 1; i <= y + 1; i++) {
      row = this._grid[i];
      if (row) {
        for (j = x - 1; j <= x + 1; j++) {
          cell = row[j];
          if (cell) {
            for (k = 0, len = cell.length; k < len; k++) {
              obj = cell[k];
              dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
              if (dist < closestDistSq) {
                closestDistSq = dist;
                closest = obj;
              }
            }
          }
        }
      }
    }
    return closest;
  },
  /* return the point coordinates contained in the structure */
  contents: function contents() {
    return Object.values(this._objectPoint);
  },
  _getCoord: function _getCoord(x) {
    return Math.floor(x / this._cellSize);
  },
  _sqDist: function _sqDist(p, p2) {
    var dx = p2.x - p.x,
      dy = p2.y - p.y;
    return dx * dx + dy * dy;
  }
};
module.exports = DistanceGrid;

/***/ }),

/***/ 642:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = Object.assign(__webpack_require__(1949), /* These modules are merged to a common name space */
__webpack_require__(5637), __webpack_require__(208), __webpack_require__(269), /* These modules are added under separate names */
{
  DistanceGrid: __webpack_require__(7235),
  ClusterGroup: __webpack_require__(5966),
  mesh: __webpack_require__(5905),
  polyops: __webpack_require__(5647)
});

/***/ }),

/***/ 5905:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Computed colored mesh information.
 *
 * @typedef {geo.meshFeature.meshInfo} geo.meshFeature.meshColoredInfo
 * @extends geo.meshFeature.meshInfo
 * @property {number[]} value An array of values that have been normalized to a
 *    range of [0, steps].  There is one value per vertex or element.
 * @property {number[]} opacity An array of opacities per vertex or element.
 * @property {number} minValue the minimum value used for the contour.  If
 *    `rangeValues` was specified, this is the first entry of that array.
 * @property {number} maxValue the maximum value used for the contour.  If
 *    `rangeValues` was specified, this is the last entry of that array.
 * @property {number} factor If linear value scaling is used, this is the
 *    number of color values divided by the difference between the maximum and
 *    minimum values.  It is ignored if non-linear value scaling is used.
 * @property {geo.geoColorObject} minColor The color used for values below
 *    minValue.  Includes opacity.
 * @property {geo.geoColorObject} maxColor The color used for values above
 *    maxValue.  Includes opacity.
 * @property {geo.geoColorObject[]} colorMap The specified `colorRange` and
 *    `opacityRange` converted into objects that include opacity.
 * @property {boolean} elementValues Truthy if the `value` and `opacity` are
 *    for elements, falsy for vertices.
 */

/**
 * Create a set of vertices, values at the vertices or elements, and opacities
 * at the vertices or elements.  Create a set of triangles of indices into the
 * vertex array.  Create a color and opacity map corresponding to the values.
 *
 * @param {geo.meshFeature} feature A mesh feature.
 * @param {boolean} elementValues Truthy to compute values and opacities at
 *    elements, falsy for vertices.
 * @returns {geo.meshFeature.meshColoredInfo} An object with the colored mesh
 *    information.
 * @memberof geo.util
 */
function createColoredMesh(feature, elementValues) {
  var util = __webpack_require__(642);
  var mesh = feature.mesh,
    valueFunc = feature.style.get('value'),
    usedFunc = feature.style('used') !== undefined ? feature.style.get('used') : function (d, i) {
      return util.isNonNullFinite(valueFunc(d, i));
    },
    minmax,
    val,
    range,
    i,
    k;
  var meshParams = {
    used: usedFunc,
    opacity: feature.style.get('opacity'),
    value: valueFunc
  };
  var result = feature._createMesh(!elementValues ? meshParams : {}, elementValues ? meshParams : {});
  result.elementValues = !!elementValues;
  if (!result.numVertices || !result.numElements) {
    return result;
  }
  var stepped = mesh.get('stepped')(result),
    opacityRange = mesh.get('opacityRange')(result),
    rangeValues = mesh.get('rangeValues')(result);
  result.stepped = stepped === undefined || stepped ? true : false;
  /* Create the min/max colors and the color array */
  result.colorMap = [];
  result.minColor = Object.assign({
    a: mesh.get('minOpacity')(result) || 0
  }, util.convertColor(mesh.get('minColor')(result)));
  result.maxColor = Object.assign({
    a: mesh.get('maxOpacity')(result) || 0
  }, util.convertColor(mesh.get('maxColor')(result)));
  mesh.get('colorRange')(result).forEach(function (clr, idx) {
    result.colorMap.push(Object.assign({
      a: opacityRange && opacityRange[idx] !== undefined ? opacityRange[idx] : 1
    }, util.convertColor(clr)));
  });
  /* Get min and max values */
  minmax = util.getMinMaxValues(result.value, mesh.get('min')(result), mesh.get('max')(result));
  result.minValue = minmax.min;
  result.maxValue = minmax.max;
  if (!rangeValues || !result.colorMap || rangeValues.length !== result.colorMap.length + 1 && (stepped || rangeValues.length !== result.colorMap.length)) {
    rangeValues = null;
  }
  if (rangeValues) {
    /* ensure increasing monotonicity */
    for (k = 1; k < rangeValues.length; k += 1) {
      if (rangeValues[k - 1] > rangeValues[k]) {
        rangeValues = null;
        break;
      }
    }
  }
  if (rangeValues) {
    result.minValue = rangeValues[0];
    result.maxValue = rangeValues[rangeValues.length - 1];
  }
  range = result.maxValue - result.minValue;
  if (!range) {
    result.colorMap = result.colorMap.slice(0, 1);
    range = 1;
    rangeValues = null;
  }
  result.rangeValues = rangeValues;
  result.factor = (result.colorMap.length - (stepped ? 0 : 1)) / range;
  /* Scale values */
  for (i = 0; i < result.value.length; i += 1) {
    val = result.value[i];
    if (rangeValues && val >= result.minValue && val <= result.maxValue) {
      for (k = 1; k < rangeValues.length; k += 1) {
        if (val <= rangeValues[k]) {
          result.value[i] = k - 1 + (val - rangeValues[k - 1]) / (rangeValues[k] - rangeValues[k - 1]);
          break;
        }
      }
    } else {
      result.value[i] = (val - result.minValue) * result.factor;
    }
  }
  return result;
}
module.exports = {
  createColoredMesh: createColoredMesh
};

/***/ }),

/***/ 269:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var webglRenderer = __webpack_require__(7945);
var _renderWindow, _supported;
module.exports = {};

/**
 * Replace webgl.renderer with a mocked version for testing in a non-webGL
 * state.  Use restoreWebglRenderer to unmock.  Call vgl.mockCounts() to get
 * the number of times different webGL functions have been called.
 *
 * @param {boolean} [supported] If false, then the webgl renderer will
 *      indicate that this is an unsupported browser environment.
 * @alias geo.util.mockWebglRenderer
 */
module.exports.mockWebglRenderer = function mockWebglRenderer(supported) {
  'use strict';

  var vgl = __webpack_require__(1611);
  if (supported === undefined) {
    supported = true;
  }
  if (vgl._mocked) {
    throw new Error('webgl renderer already mocked');
  }
  var mockCounts = {};
  var count = function count(name) {
    mockCounts[name] = (mockCounts[name] || 0) + 1;
  };
  var noop = function noop(name) {
    return function () {
      count(name);
    };
  };
  var _id = 0,
    incID = function incID(name) {
      return function () {
        count(name);
        _id += 1;
        return _id;
      };
    };
  /* The context largely does nothing. */
  var default_context = {
    activeTexture: noop('activeTexture'),
    attachShader: noop('attachShader'),
    bindAttribLocation: noop('bindAttribLocation'),
    bindBuffer: noop('bindBuffer'),
    bindFramebuffer: noop('bindFramebuffer'),
    bindTexture: noop('bindTexture'),
    blendFuncSeparate: noop('blendFuncSeparate'),
    bufferData: noop('bufferData'),
    bufferSubData: noop('bufferSubData'),
    checkFramebufferStatus: function checkFramebufferStatus(key) {
      count('checkFramebufferStatus');
      if (key === vgl.GL.FRAMEBUFFER) {
        return vgl.GL.FRAMEBUFFER_COMPLETE;
      }
    },
    clear: noop('clear'),
    clearColor: noop('clearColor'),
    clearDepth: noop('clearDepth'),
    compileShader: noop('compileShader'),
    createBuffer: incID('createBuffer'),
    createFramebuffer: noop('createFramebuffer'),
    createProgram: incID('createProgram'),
    createShader: incID('createShader'),
    createTexture: incID('createTexture'),
    deleteBuffer: noop('deleteBuffer'),
    deleteProgram: noop('deleteProgram'),
    deleteShader: noop('deleteShader'),
    deleteTexture: noop('deleteTexture'),
    detachShader: noop('detachShader'),
    depthFunc: noop('depthFunc'),
    disable: noop('disable'),
    disableVertexAttribArray: noop('disableVertexAttribArray'),
    drawArrays: noop('drawArrays'),
    enable: noop('enable'),
    enableVertexAttribArray: noop('enableVertexAttribArray'),
    finish: noop('finish'),
    getError: noop('getError'),
    getExtension: incID('getExtension'),
    getParameter: function getParameter(key) {
      count('getParameter');
      switch (key) {
        case vgl.GL.ALIASED_POINT_SIZE_RANGE:
          return [1, 64];
        case vgl.GL.DEPTH_BITS:
          return 16;
        case vgl.GL.MAX_TEXTURE_SIZE:
          return 4096;
      }
    },
    getProgramParameter: function getProgramParameter(id, key) {
      count('getProgramParameter');
      if (key === vgl.GL.LINK_STATUS) {
        return true;
      }
    },
    getShaderInfoLog: function getShaderInfoLog() {
      count('getShaderInfoLog');
      return 'log';
    },
    getShaderParameter: function getShaderParameter(id, key) {
      count('getShaderParameter');
      if (key === vgl.GL.COMPILE_STATUS) {
        return true;
      }
    },
    getSupportedExtensions: function getSupportedExtensions() {
      count('getSupportedExtensions');
      return [];
    },
    getUniformLocation: incID('getUniformLocation'),
    isEnabled: function isEnabled(key) {
      count('isEnabled');
      if (key === vgl.GL.BLEND) {
        return true;
      }
    },
    linkProgram: noop('linkProgram'),
    pixelStorei: noop('pixelStorei'),
    shaderSource: noop('shaderSource'),
    texImage2D: noop('texImage2D'),
    texParameteri: noop('texParameteri'),
    uniform1iv: noop('uniform1iv'),
    uniform1fv: noop('uniform1fv'),
    uniform2fv: noop('uniform2fv'),
    uniform3fv: noop('uniform3fv'),
    uniform4fv: noop('uniform4fv'),
    uniformMatrix3fv: noop('uniformMatrix3fv'),
    uniformMatrix4fv: noop('uniformMatrix4fv'),
    useProgram: noop('useProgram'),
    vertexAttribPointer: noop('vertexAttribPointer'),
    vertexAttrib3fv: noop('vertexAttrib3fv'),
    viewport: noop('viewport')
  };
  _renderWindow = vgl.renderWindow;
  var _mockedRenderWindow = function mockedRenderWindow() {
    /* Temporarily put back the original definition of renderWindow so that the
     * class instance will be instantiated correctly. */
    vgl.renderWindow = _renderWindow;
    var m_this = new vgl.renderWindow(),
      m_context;
    vgl.renderWindow = _mockedRenderWindow;
    m_this._setup = function () {
      var i,
        renderers = m_this.renderers(),
        wsize = m_this.windowSize(),
        wpos = m_this.windowPosition();
      m_context = Object.assign({}, vgl.GL, default_context);
      for (i = 0; i < renderers.length; i += 1) {
        if (renderers[i].width() > wsize[0] || renderers[i].width() === 0 || renderers[i].height() > wsize[1] || renderers[i].height() === 0) {
          renderers[i].resize(wpos[0], wpos[1], wsize[0], wsize[1]);
        }
      }
      return true;
    };
    m_this.context = function () {
      return m_context;
    };
    return m_this;
  };
  vgl.renderWindow = _mockedRenderWindow;
  _supported = webglRenderer.supported;
  webglRenderer.supported = function () {
    return !!supported;
  };
  webglRenderer._maxTextureSize = 4096;
  webglRenderer._maxPointSize = 64;
  vgl._mocked = true;
  vgl.mockCounts = function () {
    return mockCounts;
  };
};

/**
 * Unmock the vgl renderer.
 * @alias geo.util.restoreWebglRenderer
 */
module.exports.restoreWebglRenderer = function () {
  var vgl = __webpack_require__(1611);
  if (vgl._mocked) {
    vgl.renderWindow = _renderWindow;
    webglRenderer.supported = _supported;
    delete vgl._mocked;
    delete vgl.mockCounts;
  }
};

/***/ }),

/***/ 5647:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var _require = __webpack_require__(9061),
  PolyBool = _require.PolyBool,
  GeometryEpsilon = _require.GeometryEpsilon;
var polybool = new PolyBool();
var geo_map = __webpack_require__(6211);
var util = __webpack_require__(1949);

/**
 * A list of flat polygon lists.
 *
 * @typedef {Array.<Array.<Array.<geo.geoPositionFlat>>>} geo.polygonList
 */

/**
 * A polygon in any of a variety of formats.
 *
 * This can be any object with a ``toPolygonList`` and ``fromPolygonList``
 * method.
 *
 * @typedef {geo.polygonFlat|Array.<geo.polygonFlat>|Array.<Array.<geo.polygonFlat>>|geo.polygonObject|Array.<geo.polygonObject>|Array.<geo.geoPositionFlat>|Array.<Array.<geo.geoPositionFlat>>|geo.polygonList|object} geo.polygonAny
 */

/**
 * Object specification for polygon operation options.
 *
 * @typedef {object} geo.util.polyop.spec
 * @property {geo.polygonAny} [poly1] The first polygon set to operate on.
 * @property {geo.polygonAny} [poly2] The second polygon set to operate on.
 * @property {number} [epsilon1] A precision value to use when computing the
 *   operation.  If not specified, this is computed from the range of values in
 *   ``poly1``.  It is used for processing ``poly1`` and the general operation.
 * @property {number} [epsilon2] A precision value to use when processing
 *   ``poly2``.  If not specified, this is computed from the range of values in
 *   ``poly2``.
 * @property {string|object} [style] If specified, the preferred output style.
 *   This can be (flat|object)[-list[list[-outer[-list]]]].  If an object,
 *   the object must have a method ``fromPolygonList``.
 * @property {string|geo.transform} [ingcs] The default coordinate
 *   system of the source polygon coordinates.  If not specified , this is
 *   taken from the feature first or the map second if either is available.
 * @property {string|geo.transform} [gcs] The default coordinate system to use
 *   for the actual operations.  This is where the epsilon and rdp values are
 *   applied.  If not specified , this is taken from the map second if
 *   available.
 * @property {geo.map} [map] Used for ``ingcs`` and ``gcs`` if needed.
 * @property {string} [innerOperation="union"] one of union, intersect, xor.
 *   Used to combine individual polygons in each of ``poly1`` and ``poly2``
 *   before the main operation is carried out.
 * @property {object} [correspond] If present, information about the
 *   correspondence of the input and output polygons is added to this object.
 *   This is of the form {poly1: [idx...], poly2: [idx...], exact1: [idx...],
 *   exact2: [idx...]}, where the [idx...] array is the length of the input
 *  polygon array and each entry is either undefined or contains a list of
 *   indices of corresponding output polygons.  Exact means that all of the
 *   points in the input polygon are in the output polygon.  Multiple inputs
 *   can refer to the same output.
 * @property {number} [tolerance] A tolerance value to pass to features,
 *   annotations, or other object-based polygon generators to specify how
 *   closely non-polygons are converted to polygons.  This is in the feature's
 *   gcs coordinate system.
 * @property {number} [pixelTolerance] A tolerance value to pass to features,
 *   annotations, or other object-based polygon generators to specify how
 *   closely non-polygons are converted to polygons.  This is interpreted in
 *   the feature's map's display coordinates.
 */

var AlternateOpNames = {
  '+': 'union',
  '|': 'union',
  add: 'union',
  '-': 'difference',
  sub: 'difference',
  subtract: 'difference',
  minus: 'difference',
  '*': 'intersect',
  '&': 'intersect',
  mul: 'intersect',
  multiply: 'intersect',
  intersection: 'intersect',
  x: 'xor',
  '^': 'xor'
};

/**
 * Convert a segment list to a polygon list.
 *
 * @param {object[]} seglist A PolyBool segment list.
 * @returns {geo.polygonList|undefined} A polygon list.
 * @private
 */
function seglistToPolygonList(seglist) {
  // This single line doesn't arrange holes correctly
  // return seglist.map((s) => PolyBool.polygon(s).regions);
  /* This uses PolyBools' operations (mostly), but is much slower than needed
   * since it goes through geojson.
  const polys = [];
  seglist.forEach((s) => {
    const geojson = PolyBool.polygonToGeoJSON(PolyBool.polygon(s));
    if (geojson.type === 'MultiPolygon') {
      geojson.coordinates.forEach((p) => {
        polys.push(p.map((h) => h.slice(0, h.length - 1)));
      });
    } else if (geojson.type === 'Polygon') {
      polys.push(geojson.coordinates.map((h) => h.slice(0, h.length - 1)));
    }
  });
  return polys;
   */
  var polys = []; // end result
  var borders = []; // polygons in format needed for util.pointInPolygon
  var regions = []; // polygons in end result format
  var parents = []; // list of parents of each polygon
  seglist.forEach(function (s) {
    return polybool.polygon(s).regions.forEach(function (r) {
      var border = r.map(function (pt) {
        return {
          x: pt[0],
          y: pt[1]
        };
      });
      if (border.length < 3) {
        return;
      }
      parents.push([]);
      borders.forEach(function (b, i) {
        if (util.pointInPolygon(border[0], b)) {
          parents[borders.length].push(i);
        } else if (util.pointInPolygon(b[0], border)) {
          parents[i].push(borders.length);
        }
      });
      regions.push(r);
      borders.push(border);
    });
  });
  /* find nested polygons */
  var dest = Array(regions.length);
  var used = 0;
  while (used < regions.length) {
    for (var i = 0; i < regions.length; i += 1) {
      if (dest[i] === undefined && !parents[i].length) {
        dest[i] = polys.length;
        /* reverse the outer polygons for consistency with how PolyBool
         * generates geojson */
        polys.push([regions[i].reverse()]);
        used += 1;
      }
    }
    for (var _i = 0; _i < regions.length; _i += 1) {
      if (dest[_i] === undefined && parents[_i].length === 1 && dest[parents[_i][0]] !== undefined) {
        polys[dest[parents[_i][0]]].push(regions[_i]);
        dest[_i] = dest[parents[_i][0]];
        used += 1;
      }
    }
    for (var _i2 = 0; _i2 < regions.length; _i2 += 1) {
      parents[_i2] = parents[_i2].filter(function (d) {
        return dest[d] === undefined;
      });
    }
  }
  return polys.length ? polys : [[]];
}

/**
 * Perform an boolean operation on a seglist from polygons.
 *
 * @param {string} op One of 'union', 'intersect', or other value PolyBool
 *      supports.
 * @param {number} epsilon Precision for calculations.  In degrees, 1e-9 is
 *      around 0.11 mm in ground distance.
 * @param {object} seglist A seglist array as used by the polybool library.
 * @returns {object} A seglist array.
 * @private
 */
function polygonOperationSeglist(op, epsilon, seglist) {
  op = 'select' + op.charAt(0).toUpperCase() + op.slice(1);
  var polyboolEps1 = new PolyBool(new GeometryEpsilon(epsilon));
  while (seglist.length > 1) {
    var newlist = [];
    var half = Math.ceil(seglist.length / 2);
    for (var i = 0; i < half; i += 1) {
      var segments = seglist[i];
      if (i + half < seglist.length) {
        var nextseg = seglist[i + half];
        try {
          segments = polyboolEps1.combine(segments, nextseg);
        } catch (err) {
          segments = polyboolEps1.segments(polyboolEps1.polygon(segments));
          nextseg = polyboolEps1.segments(polyboolEps1.polygon(nextseg));
          for (var j = 20; j >= 6; j -= 1) {
            var polyboolEps2 = new PolyBool(new GeometryEpsilon(Math.pow(0.1, j)));
            try {
              segments = polyboolEps2.combine(segments, nextseg);
              break;
            } catch (err) {}
          }
        }
        segments = polyboolEps1[op](segments);
      }
      newlist.push(segments);
    }
    seglist = newlist;
  }
  return seglist;
}

/**
 * Convert a polygon in any of several formats to a polygon list.  Each polygon
 * in the list is a list of polylines.  Each polyline is a list of points.
 * Each point is a list of two coordinates.  The input can be a variety of
 * formats:
 *   - object, flat: a list of {x, y} or [x, y]
 *   - object-list, flat-list: a list of lists of {x, y} or [x, y]
 *   - object-listlist, flat-listlist: a list if lists of lists of {x, y} or
 *     [x, y]
 *   - object-listlist-outer, flat-listlist-outer: {outer: {x, y}, inner:
 *     [{x, y}]} or {outer: [x, y], inner: [[x, y]]}
 *   - object-listlist-outer-list, flat-listlist-outer-list: a list of objects
 *     in outer/inner object or outer/inner list form
 * The actual format is stored in the mode object.
 *
 * @param {geo.polygonAny} poly A polygon in one of the above formats to
 *   convert.
 * @param {object} mode An object that is modified with information about
 *   the conversion.  This includes style: the input polygon format; min: a
 *   2-item list with minimum values in x, y; max: a 2-item list with
 *   maximum values in x, y; epsilon: a recommended value for epsilon in other
 *   functions.
 * @param {geo.util.polyop.spec} [opts] Options for the operation.  Only used
 *    if poly is an object with a toPolygonList method.
 * @returns {geo.polygonList} A list of polygons.
 * @memberof geo.util.polyops
 */
function toPolygonList(poly, mode, opts) {
  mode = mode || {};
  if (poly.toPolygonList) {
    mode.style = poly;
    poly = poly.toPolygonList(opts);
    if (!poly.length) {
      mode.min = mode.max = [0, 0];
      mode.epsilon = 1e-10;
      return poly;
    }
  } else {
    mode.style = '';
    if (poly.outer) {
      mode.style = '-outer';
      poly = [[poly.outer].concat(_toConsumableArray(poly.inner || []))];
    } else if (poly.length && poly[0].outer) {
      mode.style = '-outer-list';
      poly = poly.map(function (p) {
        return [p.outer].concat(_toConsumableArray(p.inner || []));
      });
    }
    if (!poly.length) {
      mode.style = 'flat-listlist' + mode.style;
      mode.min = mode.max = [0, 0];
      mode.epsilon = 1e-10;
      return poly;
    }
    if (poly[0].x !== undefined) {
      mode.style = 'object';
      poly = [[poly.map(function (pt) {
        return [pt.x, pt.y];
      })]];
    } else if (poly[0][0].x !== undefined) {
      mode.style = 'object-list' + mode.style;
      poly = [poly.map(function (p) {
        return p.map(function (pt) {
          return [pt.x, pt.y];
        });
      })];
    } else if (poly[0][0][0] === undefined) {
      mode.style = 'flat';
      poly = [[poly]];
    } else if (poly[0][0][0].x !== undefined) {
      mode.style = 'object-listlist' + mode.style;
      poly = poly.map(function (p) {
        return p.map(function (l) {
          return l.map(function (pt) {
            return [pt.x, pt.y];
          });
        });
      });
    } else if (poly[0][0][0][0] === undefined) {
      mode.style = 'flat-list';
      poly = [poly];
    } else {
      mode.style = 'flat-listlist' + mode.style;
    }
  }
  mode.min = [poly[0][0][0][0], poly[0][0][0][1]];
  mode.max = [poly[0][0][0][0], poly[0][0][0][1]];
  poly.forEach(function (p) {
    return p.forEach(function (l) {
      return l.forEach(function (pt) {
        if (pt[0] < mode.min[0]) {
          mode.min[0] = pt[0];
        }
        if (pt[0] > mode.max[0]) {
          mode.max[0] = pt[0];
        }
        if (pt[1] < mode.min[1]) {
          mode.min[1] = pt[1];
        }
        if (pt[1] > mode.max[1]) {
          mode.max[1] = pt[1];
        }
      });
    });
  });
  mode.epsilon = Math.max(Math.max(mode.max[0], mode.max[1]), Math.max(Math.abs(mode.min[0]), Math.abs(mode.min[1]))) * 1e-10;
  return poly;
}

/**
 * Convert a polygon list to another format.
 *
 * @param {geo.polygonList} poly A list of polygons.
 * @param {object} mode An object that is modified with information about the
 *   conversion.  This includes style: the input polygon format; min: a 2-item
 *   list with minimum values in x, y; max: a 2-item list with maximum values
 *   in x, y; epsilon: a recommended value for epsilon in other functions.
 * @param {geo.util.polyop.spec} [opts] Options for the operation.  Only used
 *    if ``mode.style`` is an object with a fromPolygonList method.
 * @returns {geo.polygonAny} A polygon in one of several formats.
 * @memberof geo.util.polyops
 */
function fromPolygonList(poly, mode, opts) {
  if (mode.style.fromPolygonList) {
    return mode.style.fromPolygonList(poly, opts);
  }
  if (mode.style.includes('object')) {
    poly = poly.map(function (p) {
      return p.map(function (h) {
        return h.map(function (pt) {
          return {
            x: pt[0],
            y: pt[1]
          };
        });
      });
    });
  }
  if (mode.style.includes('outer')) {
    poly = [poly.map(function (p) {
      return {
        outer: p[0],
        inner: p.slice(1)
      };
    })];
  }
  if (!mode.style.endsWith('listlist')) {
    if (mode.style.endsWith('list')) {
      poly = poly[0];
    } else {
      poly = poly[0][0];
    }
  }
  return poly;
}

/**
 * Use a minimum style for output to include all of the results.
 *
 * @private
 * @param {geo.polygonList} polylist A list of polygons.
 * @param {string} style the proposed style.
 * @returns {string} The preferred style.
 */
function minimumPolygonStyle(polylist, style) {
  if (style.fromPolygonList) {
    return style;
  }
  if (polylist.length > 1) {
    if (style.includes('outer')) {
      return style + (style.endsWith('list') ? '' : '-list');
    }
    if (style.endsWith('listlist')) {
      return style;
    }
    return style + (style.endsWith('list') ? 'list' : '-listlist');
  }
  if (polylist.length === 1 && polylist[0].length > 1) {
    if (style.includes('outer') || style.endsWith('list')) {
      return style;
    }
    return style + '-list';
  }
  return style;
}

/**
 * Generate the correspondence between the source polygons and the output
 * polygons.  A polygon corresponds if it has at least two points in common.
 *
 * @private
 * @param {geo.polygonList} poly1 First set of source polygons.
 * @param {geo.polygonList} poly2 Second set of source polygons.
 * @param {geo.polygonList} newpoly Output polygons.
 * @param {object} results An object to add results to.
 */
function generateCorrespondence(poly1, poly2, newpoly, results) {
  var pts = {};
  var counts = [];
  newpoly.forEach(function (p, idx) {
    return p.forEach(function (h) {
      return h.forEach(function (pt) {
        var key = '_' + pt[0] + '_' + pt[1];
        if (pts[key]) {
          if (pts[key].indexOf(idx) === -1) {
            pts[key].push(idx);
          }
        } else {
          pts[key] = [idx];
        }
        if (counts.length <= idx) {
          counts.push(0);
        }
        counts[idx] += 1;
      });
    });
  });
  ['poly1', 'poly2'].forEach(function (pkey) {
    var poly = pkey === 'poly1' ? poly1 : poly2;
    var ekey = pkey === 'poly1' ? 'exact1' : 'exact2';
    results[pkey] = Array(poly.length);
    results[ekey] = Array(poly.length);
    poly.forEach(function (p, idx) {
      var found = {};
      var missed = 0;
      p.forEach(function (h) {
        return h.forEach(function (pt) {
          var key = '_' + pt[0] + '_' + pt[1];
          if (pts[key]) {
            pts[key].forEach(function (val) {
              found[val] = (found[val] || 0) + 1;
            });
          } else {
            missed += 1;
          }
        });
      });
      Object.keys(found).forEach(function (nidx) {
        if (found[nidx] === counts[+nidx] && !missed && p.length === newpoly[+nidx].length) {
          if (!results[ekey][idx]) {
            results[ekey][idx] = [];
          }
          results[ekey][idx].push(+nidx);
        }
        if (found[nidx] >= 2) {
          if (!results[pkey][idx]) {
            results[pkey][idx] = [];
          }
          results[pkey][idx].push(+nidx);
        }
      });
    });
  });
}

/**
 * Perform a general operation of a set of polygons.
 *
 * @private
 * @param {string} op The operation to handle.  One of union, intersect,
 *    difference, or xor.
 * @param {geo.polygonAny|geo.util.polyop.spec} poly1 Either the first polygon
 *    set or an object containing all parameters for the function.
 * @param {geo.polygonAny} [poly2] If the poly1 parameter is not a complete
 *    options object, the second polygon set for the operation.
 * @param {geo.util.polyop.spec} [opts] If the poly1 parameter is not a
 *    complete options object, the options for the operation.
 * @returns {geo.polygonAny} A polygon set in the same style as poly1.
 */
function generalOperationProcess(op, poly1, poly2, opts) {
  var transform = __webpack_require__(5325);
  op = AlternateOpNames[op] || op;
  if (poly1.poly1) {
    opts = poly1;
    poly1 = opts.poly1;
    poly2 = opts.poly2;
  }
  opts = opts || {};
  var ingcs1 = opts.ingcs || (opts.map ? opts.map.ingcs() : poly1.gcs ? poly1.gcs() : poly1.layer && poly1.layer().gcs ? poly1.layer().gcs() : poly1.layer ? poly1.layer().map().ingcs() : poly1.map instanceof geo_map ? poly1.map().ingcs() : undefined);
  var ingcs2 = opts.ingcs || (opts.map ? opts.map.ingcs() : poly2.gcs ? poly2.gcs() : poly2.layer && poly2.layer().gcs ? poly2.layer().gcs() : poly2.layer ? poly2.layer().map().ingcs() : poly2.map instanceof geo_map ? poly2.map().ingcs() : ingcs1);
  var gcs = opts.gcs || (opts.map ? opts.map.gcs() : poly1.layer ? poly1.layer().map().gcs() : poly1.map instanceof geo_map ? poly1.map().gcs() : undefined);
  var mode1 = {};
  var mode2 = {};
  poly1 = toPolygonList(poly1, mode1, opts);
  poly2 = toPolygonList(poly2, mode2, opts);
  mode1.epsilon = opts.epsilon1 || mode1.epsilon;
  mode2.epsilon = opts.epsilon2 || mode1.epsilon;
  if (ingcs1 && gcs && ingcs1 !== gcs) {
    poly1 = poly1.map(function (p) {
      return p.map(function (h) {
        return transform.transformCoordinates(ingcs1, gcs, h);
      });
    });
  }
  if (ingcs2 && gcs && ingcs2 !== gcs) {
    poly2 = poly2.map(function (p) {
      return p.map(function (h) {
        return transform.transformCoordinates(ingcs2, gcs, h);
      });
    });
  }
  var seglist1 = poly1.map(function (p) {
    return polybool.segments({
      regions: p
    });
  });
  var seglist2 = poly2.map(function (p) {
    return polybool.segments({
      regions: p
    });
  });
  seglist1 = polygonOperationSeglist(opts.innerOperation || 'union', mode1.epsilon, seglist1);
  seglist2 = polygonOperationSeglist(opts.innerOperation || 'union', mode2.epsilon, seglist2);
  var seglist = seglist1;
  if (seglist1[0] && seglist2[0]) {
    /* We need to do the main operation with the same inversion flags */
    seglist1[0].inverted = false;
    seglist2[0].inverted = false;
    seglist = polygonOperationSeglist(op, Math.max(mode1.epsilon, mode2.epsilon), [seglist1[0], seglist2[0]]);
  } else if (seglist2[0]) {
    seglist = seglist2;
  }
  var newpoly = seglistToPolygonList(seglist);
  if (opts.correspond) {
    generateCorrespondence(poly1, poly2, newpoly, opts.correspond);
  }
  if (ingcs1 && gcs && ingcs1 !== gcs) {
    newpoly = newpoly.map(function (p) {
      return p.map(function (h) {
        return transform.transformCoordinates(gcs, ingcs1, h);
      });
    });
  }
  var mode = {
    style: opts.style || minimumPolygonStyle(newpoly, mode1.style)
  };
  return fromPolygonList(newpoly, mode, opts);
}

/**
 * Generate a polygon function for a specific operation.
 *
 * @private
 * @param {string} op The operation to handle.  One of union, intersect,
 *    difference, or xor.
 * @returns {Function} a function for the polygons.
 */
function generalOperation(op) {
  return function (poly1, poly2, opts) {
    return generalOperationProcess(op, poly1, poly2, opts);
  };
}
module.exports = {
  union: generalOperation('union'),
  intersect: generalOperation('intersect'),
  difference: generalOperation('difference'),
  xor: generalOperation('xor'),
  toPolygonList: toPolygonList,
  fromPolygonList: fromPolygonList
};

/***/ }),

/***/ 208:
/***/ (function(module) {

/**
 * Based on the following jquery throttle / debounce plugin:
 *
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 *
 * @copyright 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 *
 * The implementation included here is modified to support a callback
 * method that can accumulate values between actual invocations of
 * the throttled method.
 */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll. If you want to
 * rate-limit execution of a function to a single time see
 * {@link geo.util.debounce}.
 *
 * In this visualization, | is a throttled-function call and X is the actual
 * callback execution:
 *
 * ```
 * Throttled with `no_trailing` specified as false or unspecified:
 * ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
 * X    X    X    X    X    X        X    X    X    X    X    X
 *
 * Throttled with `no_trailing` specified as true:
 * ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
 * X    X    X    X    X             X    X    X    X    X
 * ```
 *
 * This is also used to handle debouncing a function.
 *
 * @alias geo.util.throttle
 * @param {number} delay A zero-or-greater delay in milliseconds. For event
 *    callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {boolean} [no_trailing] If no_trailing is
 *    true, callback will only execute every `delay` milliseconds while the
 *    throttled-function is being called. If no_trailing is false or
 *    unspecified, callback will be executed one final time after the last
 *    throttled-function call. (After the throttled-function has not been
 *    called for `delay` milliseconds, the internal counter is reset)
 * @param {Function} [callback] A function to be executed after `delay`
 *    milliseconds. The `this` context and all arguments are passed through,
 *    as-is, to `callback` when the throttled-function is executed.
 * @param {Function} [accumulator] A function to be executed (synchronously)
 *    during **each** call to the wrapped function.  Typically, this
 *    this method is used to accumulate values that the callback uses
 *    when it finally executes.
 * @param {boolean} [debounce_mode] See the `at_begin` parameter of the
 *    {@link geo.util.debounce} function.
 * @returns {Function} The throttled version of `callback`.
 *
 * @example
 * var throttled = geo.util.throttle( delay, [ no_trailing, ] callback );
 * $('selector').bind( 'someevent', throttled );
 * $('selector').unbind( 'someevent', throttled );
 */
var throttle = function throttle(delay, no_trailing, callback, accumulator, debounce_mode) {
  // After wrapper has stopped being called, this timeout ensures that
  // `callback` is executed at the proper times in `throttle` and `end`
  // debounce modes.
  var timeout_id,
    // Keep track of the last time `callback` was executed.
    last_exec = 0;

  // `no_trailing` defaults to falsy.
  if (typeof no_trailing !== 'boolean') {
    debounce_mode = accumulator;
    accumulator = callback;
    callback = no_trailing;
    no_trailing = undefined;
  }

  // accumulator defaults to no-op
  if (typeof accumulator !== 'function') {
    debounce_mode = accumulator;
    accumulator = function accumulator() {};
  }

  // The `wrapper` function encapsulates all of the throttling / debouncing
  // functionality and when executed will limit the rate at which `callback`
  // is executed.
  function wrapper() {
    var that = this,
      elapsed = +new Date() - last_exec,
      args = arguments;

    // Execute `callback` and update the `last_exec` timestamp.
    function exec() {
      last_exec = +new Date();
      callback.apply(that, args);
    }

    // If `debounce_mode` is true (at_begin) this is used to clear the flag
    // to allow future `callback` executions.
    function clear() {
      timeout_id = undefined;
    }

    // always call the accumulator first
    accumulator.apply(that, args);
    if (debounce_mode && !timeout_id) {
      // Since `wrapper` is being called for the first time and
      // `debounce_mode` is true (at_begin), execute `callback`.
      exec();
    }

    // Clear any existing timeout.
    if (timeout_id) {
      clearTimeout(timeout_id);
    }
    if (debounce_mode === undefined && elapsed > delay) {
      // In throttle mode, if `delay` time has been exceeded, execute
      // `callback`.
      exec();
    } else if (no_trailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounce_mode` is true (at_begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounce_mode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
    }
  }

  // Return the wrapper function.
  return wrapper;
};

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end. If you want to
 * simply rate-limit execution of a function, see the <jQuery.throttle>
 * method.
 *
 * In this visualization, | is a debounced-function call and X is the actual
 * callback execution:
 *
 * ::
 *
 *   Debounced with `at_begin` specified as false or unspecified:
 *   ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
 *                            X                                 X
 *
 *   Debounced with `at_begin` specified as true:
 *   ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
 *   X                                 X
 *
 * The bulk of the work is handled by the {@link geo.util.throttle} function.
 *
 * @method geo.util.debounce
 * @param {number} delay A zero-or-greater delay in milliseconds. For event
 *    callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {boolean} [at_begin] If at_begin is false or
 *    unspecified, callback will only be executed `delay` milliseconds after
 *    the last debounced-function call. If at_begin is true, callback will be
 *    executed only at the first debounced-function call. (After the
 *    throttled-function has not been called for `delay` milliseconds, the
 *    internal counter is reset)
 * @param {Function} callback A function to be executed after delay milliseconds.
 *    The `this` context and all arguments are passed through, as-is, to
 *    `callback` when the debounced-function is executed.
 * @param {Function} [accumulator] A function to be executed (synchronously)
 *    during **each** call to the wrapped function.  Typically, this
 *    this method is used to accumulate values that the callback uses
 *    when it finally executes.
 *
 * @returns {Function} A new, debounced, function.
 *
 * @example
 * var debounced = geo.util.debounce( delay, [ at_begin, ] callback );
 * $('selector').bind( 'someevent', debounced );
 * $('selector').unbind( 'someevent', debounced );
 *
 */
var debounce = function debounce(delay, at_begin, callback, accumulator) {
  if (typeof at_begin !== 'boolean') {
    accumulator = callback;
    callback = at_begin;
    at_begin = false;
  }
  accumulator = accumulator || function () {};
  return throttle(delay, false, callback, accumulator, !!at_begin);
};
module.exports = {
  throttle: throttle,
  debounce: debounce
};

/***/ }),

/***/ 6858:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var feature = __webpack_require__(1275);
var util = __webpack_require__(642);

/**
 * Object specification for a graph feature.
 *
 * @typedef {geo.feature.spec} geo.vectorFeature.spec
 * @extends geo.feature.spec
 * @property {geo.vectorFeature.styleSpec} [style] Style object with default
 *   style options.
 * @property {Function|object} [origin={x: 0, y: 0, z: 0}] Origin accessor.
 */

/**
 * Style specification for a vector feature.
 *
 * @typedef {geo.feature.styleSpec} geo.vectorFeature.styleSpec
 * @extends geo.feature.styleSpec
 * @property {geo.geoColor|Function} [strokeColor] Color to stroke each vector.
 * @property {number|Function} [strokeOpacity] Opacity for each vector.
 *   Opacity is on a [0-1] scale.
 * @property {number|Function} [strokeWidth] The weight of the vector stroke in
 *   pixels.
 * @property {string|Function} [originStyle='none'] The style at the origin of
 *   the vector.  One of the marker styles or `'none'`.  Marker styles are
 *   usually `'arrow'`, `'point'`, `'bar'`, and `'wedge'`.
 * @property {string|Function} [endStyle='arrow'] The style at the far end of
 *   the vector.  One of the marker styles or `'none'`.  Marker styles are
 *   usually `'arrow'`, `'point'`, `'bar'`, and `'wedge'`.
 * @property {geo.geoPosition|Function} [origin={x: 0, y: 0, z: 0}] The origin
 *   of the vector.  One end of the vector will be at this point.
 * @property {geo.geoPosition|Function} [delta] The direction that the vector
 *   points in.  The length of the vector is dependent on this and the `scale`.
 * @property {number|Function} [scale] The size of the vector relative to the
 *   delta.  If `null`, `undefined`, or `0`, this is `75 / <maximum length of
 *   any delta in x-y space>`.
 */

/**
 * Create a new instance of class vectorFeature.
 *
 * @class
 * @alias geo.vectorFeature
 * @extends geo.feature
 * @param {geo.vectorFeature.spec} arg Feature options.
 * @returns {geo.vectorFeature}
 */
var _vectorFeature = function vectorFeature(arg) {
  'use strict';

  if (!(this instanceof _vectorFeature)) {
    return new _vectorFeature(arg);
  }
  arg = arg || {};
  feature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    s_init = this._init;
  this.featureType = 'vector';

  /**
   * Get or set the accessor for the origin of the vector.  This is the point
   * that the vector starts.
   *
   * @param {geo.geoPosition|Function} [val] The new origin if specified.  If
   *   not specified, return the current origin.
   * @returns {geo.geoPosition|Function|this} Either the current origin or
   *   this feature.
   */
  this.origin = function (val) {
    if (val === undefined) {
      return m_this.style('origin');
    } else {
      m_this.style('origin', val);
      m_this.dataTime().modified();
    }
    return m_this;
  };

  /**
   * Get or set the accessor for the displacement (coordinates) of the vector.
   * This is the direction of the vector.
   *
   * @param {geo.geoPosition|Function} [val] The new delta if specified.  If
   *   not specified, return the current delta.
   * @returns {geo.geoPosition|Function|this} Either the current delta or this
   *   feature.
   */
  this.delta = function (val) {
    if (val === undefined) {
      return m_this.style('delta');
    } else {
      m_this.style('delta', val);
      m_this.dataTime().modified();
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {geo.vectorFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    s_init.call(m_this, arg);
    var defaultStyle = Object.assign({}, {
      strokeColor: 'black',
      strokeWidth: 2.0,
      strokeOpacity: 1.0,
      originStyle: 'none',
      endStyle: 'arrow',
      origin: {
        x: 0,
        y: 0,
        z: 0
      },
      delta: util.identityFunction,
      scale: null // size scaling factor (null -> renderer decides)
    }, arg.style === undefined ? {} : arg.style);
    if (arg.origin !== undefined) {
      defaultStyle.origin = arg.origin;
    }
    m_this.style(defaultStyle);
    m_this.dataTime().modified();
    return m_this;
  };
};
inherit(_vectorFeature, feature);
module.exports = _vectorFeature;

/***/ }),

/***/ 4081:
/***/ (function(module) {

/* global GEO_VERSION */

/**
 * The current geojs version.
 *
 * @alias geo.version
 * @constant
 * @type {string}
 */
module.exports = "0.0.0-semantically-released";

/***/ }),

/***/ 6552:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);

/**
 * Wrap GL enums. Currently to get values of the enums we need to create
 * or access the context.
 *
 * Using enums from here:
 * https://github.com/toji/dart-gl-enums/blob/master/lib/gl_enums.dart
 *
 * @class
 */
vgl.GL = {
  ACTIVE_ATTRIBUTES: 0x8B89,
  ACTIVE_TEXTURE: 0x84E0,
  ACTIVE_UNIFORMS: 0x8B86,
  ALIASED_LINE_WIDTH_RANGE: 0x846E,
  ALIASED_POINT_SIZE_RANGE: 0x846D,
  ALPHA: 0x1906,
  ALPHA_BITS: 0x0D55,
  ALWAYS: 0x0207,
  ARRAY_BUFFER: 0x8892,
  ARRAY_BUFFER_BINDING: 0x8894,
  ATTACHED_SHADERS: 0x8B85,
  BACK: 0x0405,
  BLEND: 0x0BE2,
  BLEND_COLOR: 0x8005,
  BLEND_DST_ALPHA: 0x80CA,
  BLEND_DST_RGB: 0x80C8,
  BLEND_EQUATION: 0x8009,
  BLEND_EQUATION_ALPHA: 0x883D,
  BLEND_EQUATION_RGB: 0x8009,
  BLEND_SRC_ALPHA: 0x80CB,
  BLEND_SRC_RGB: 0x80C9,
  BLUE_BITS: 0x0D54,
  BOOL: 0x8B56,
  BOOL_VEC2: 0x8B57,
  BOOL_VEC3: 0x8B58,
  BOOL_VEC4: 0x8B59,
  BROWSER_DEFAULT_WEBGL: 0x9244,
  BUFFER_SIZE: 0x8764,
  BUFFER_USAGE: 0x8765,
  BYTE: 0x1400,
  CCW: 0x0901,
  CLAMP_TO_EDGE: 0x812F,
  COLOR_ATTACHMENT0: 0x8CE0,
  COLOR_BUFFER_BIT: 0x00004000,
  COLOR_CLEAR_VALUE: 0x0C22,
  COLOR_WRITEMASK: 0x0C23,
  COMPILE_STATUS: 0x8B81,
  COMPRESSED_TEXTURE_FORMATS: 0x86A3,
  CONSTANT_ALPHA: 0x8003,
  CONSTANT_COLOR: 0x8001,
  CONTEXT_LOST_WEBGL: 0x9242,
  CULL_FACE: 0x0B44,
  CULL_FACE_MODE: 0x0B45,
  CURRENT_PROGRAM: 0x8B8D,
  CURRENT_VERTEX_ATTRIB: 0x8626,
  CW: 0x0900,
  DECR: 0x1E03,
  DECR_WRAP: 0x8508,
  DELETE_STATUS: 0x8B80,
  DEPTH_ATTACHMENT: 0x8D00,
  DEPTH_BITS: 0x0D56,
  DEPTH_BUFFER_BIT: 0x00000100,
  DEPTH_CLEAR_VALUE: 0x0B73,
  DEPTH_COMPONENT: 0x1902,
  DEPTH_COMPONENT16: 0x81A5,
  DEPTH_FUNC: 0x0B74,
  DEPTH_RANGE: 0x0B70,
  DEPTH_STENCIL: 0x84F9,
  DEPTH_STENCIL_ATTACHMENT: 0x821A,
  DEPTH_TEST: 0x0B71,
  DEPTH_WRITEMASK: 0x0B72,
  DITHER: 0x0BD0,
  DONT_CARE: 0x1100,
  DST_ALPHA: 0x0304,
  DST_COLOR: 0x0306,
  DYNAMIC_DRAW: 0x88E8,
  ELEMENT_ARRAY_BUFFER: 0x8893,
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
  EQUAL: 0x0202,
  FASTEST: 0x1101,
  FLOAT: 0x1406,
  FLOAT_MAT2: 0x8B5A,
  FLOAT_MAT3: 0x8B5B,
  FLOAT_MAT4: 0x8B5C,
  FLOAT_VEC2: 0x8B50,
  FLOAT_VEC3: 0x8B51,
  FLOAT_VEC4: 0x8B52,
  FRAGMENT_SHADER: 0x8B30,
  FRAMEBUFFER: 0x8D40,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
  FRAMEBUFFER_BINDING: 0x8CA6,
  FRAMEBUFFER_COMPLETE: 0x8CD5,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
  FRAMEBUFFER_UNSUPPORTED: 0x8CDD,
  FRONT: 0x0404,
  FRONT_AND_BACK: 0x0408,
  FRONT_FACE: 0x0B46,
  FUNC_ADD: 0x8006,
  FUNC_REVERSE_SUBTRACT: 0x800B,
  FUNC_SUBTRACT: 0x800A,
  GENERATE_MIPMAP_HINT: 0x8192,
  GEQUAL: 0x0206,
  GREATER: 0x0204,
  GREEN_BITS: 0x0D53,
  HIGH_FLOAT: 0x8DF2,
  HIGH_INT: 0x8DF5,
  INCR: 0x1E02,
  INCR_WRAP: 0x8507,
  INT: 0x1404,
  INT_VEC2: 0x8B53,
  INT_VEC3: 0x8B54,
  INT_VEC4: 0x8B55,
  INVALID_ENUM: 0x0500,
  INVALID_FRAMEBUFFER_OPERATION: 0x0506,
  INVALID_OPERATION: 0x0502,
  INVALID_VALUE: 0x0501,
  INVERT: 0x150A,
  KEEP: 0x1E00,
  LEQUAL: 0x0203,
  LESS: 0x0201,
  LINEAR: 0x2601,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  LINE_WIDTH: 0x0B21,
  LINK_STATUS: 0x8B82,
  LOW_FLOAT: 0x8DF0,
  LOW_INT: 0x8DF3,
  LUMINANCE: 0x1909,
  LUMINANCE_ALPHA: 0x190A,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
  MAX_RENDERBUFFER_SIZE: 0x84E8,
  MAX_TEXTURE_IMAGE_UNITS: 0x8872,
  MAX_TEXTURE_SIZE: 0x0D33,
  MAX_VARYING_VECTORS: 0x8DFC,
  MAX_VERTEX_ATTRIBS: 0x8869,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
  MAX_VIEWPORT_DIMS: 0x0D3A,
  MEDIUM_FLOAT: 0x8DF1,
  MEDIUM_INT: 0x8DF4,
  MIRRORED_REPEAT: 0x8370,
  NEAREST: 0x2600,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  NEVER: 0x0200,
  NICEST: 0x1102,
  NONE: 0,
  NOTEQUAL: 0x0205,
  NO_ERROR: 0,
  ONE: 1,
  ONE_MINUS_CONSTANT_ALPHA: 0x8004,
  ONE_MINUS_CONSTANT_COLOR: 0x8002,
  ONE_MINUS_DST_ALPHA: 0x0305,
  ONE_MINUS_DST_COLOR: 0x0307,
  ONE_MINUS_SRC_ALPHA: 0x0303,
  ONE_MINUS_SRC_COLOR: 0x0301,
  OUT_OF_MEMORY: 0x0505,
  PACK_ALIGNMENT: 0x0D05,
  POINTS: 0x0000,
  POLYGON_OFFSET_FACTOR: 0x8038,
  POLYGON_OFFSET_FILL: 0x8037,
  POLYGON_OFFSET_UNITS: 0x2A00,
  RED_BITS: 0x0D52,
  RENDERBUFFER: 0x8D41,
  RENDERBUFFER_ALPHA_SIZE: 0x8D53,
  RENDERBUFFER_BINDING: 0x8CA7,
  RENDERBUFFER_BLUE_SIZE: 0x8D52,
  RENDERBUFFER_DEPTH_SIZE: 0x8D54,
  RENDERBUFFER_GREEN_SIZE: 0x8D51,
  RENDERBUFFER_HEIGHT: 0x8D43,
  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
  RENDERBUFFER_RED_SIZE: 0x8D50,
  RENDERBUFFER_STENCIL_SIZE: 0x8D55,
  RENDERBUFFER_WIDTH: 0x8D42,
  RENDERER: 0x1F01,
  REPEAT: 0x2901,
  REPLACE: 0x1E01,
  RGB: 0x1907,
  RGB565: 0x8D62,
  RGB5_A1: 0x8057,
  RGBA: 0x1908,
  RGBA4: 0x8056,
  SAMPLER_2D: 0x8B5E,
  SAMPLER_CUBE: 0x8B60,
  SAMPLES: 0x80A9,
  SAMPLE_ALPHA_TO_COVERAGE: 0x809E,
  SAMPLE_BUFFERS: 0x80A8,
  SAMPLE_COVERAGE: 0x80A0,
  SAMPLE_COVERAGE_INVERT: 0x80AB,
  SAMPLE_COVERAGE_VALUE: 0x80AA,
  SCISSOR_BOX: 0x0C10,
  SCISSOR_TEST: 0x0C11,
  SHADER_TYPE: 0x8B4F,
  SHADING_LANGUAGE_VERSION: 0x8B8C,
  SHORT: 0x1402,
  SRC_ALPHA: 0x0302,
  SRC_ALPHA_SATURATE: 0x0308,
  SRC_COLOR: 0x0300,
  STATIC_DRAW: 0x88E4,
  STENCIL_ATTACHMENT: 0x8D20,
  STENCIL_BACK_FAIL: 0x8801,
  STENCIL_BACK_FUNC: 0x8800,
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
  STENCIL_BACK_REF: 0x8CA3,
  STENCIL_BACK_VALUE_MASK: 0x8CA4,
  STENCIL_BACK_WRITEMASK: 0x8CA5,
  STENCIL_BITS: 0x0D57,
  STENCIL_BUFFER_BIT: 0x00000400,
  STENCIL_CLEAR_VALUE: 0x0B91,
  STENCIL_FAIL: 0x0B94,
  STENCIL_FUNC: 0x0B92,
  STENCIL_INDEX: 0x1901,
  STENCIL_INDEX8: 0x8D48,
  STENCIL_PASS_DEPTH_FAIL: 0x0B95,
  STENCIL_PASS_DEPTH_PASS: 0x0B96,
  STENCIL_REF: 0x0B97,
  STENCIL_TEST: 0x0B90,
  STENCIL_VALUE_MASK: 0x0B93,
  STENCIL_WRITEMASK: 0x0B98,
  STREAM_DRAW: 0x88E0,
  SUBPIXEL_BITS: 0x0D50,
  TEXTURE: 0x1702,
  TEXTURE0: 0x84C0,
  TEXTURE1: 0x84C1,
  TEXTURE10: 0x84CA,
  TEXTURE11: 0x84CB,
  TEXTURE12: 0x84CC,
  TEXTURE13: 0x84CD,
  TEXTURE14: 0x84CE,
  TEXTURE15: 0x84CF,
  TEXTURE16: 0x84D0,
  TEXTURE17: 0x84D1,
  TEXTURE18: 0x84D2,
  TEXTURE19: 0x84D3,
  TEXTURE2: 0x84C2,
  TEXTURE20: 0x84D4,
  TEXTURE21: 0x84D5,
  TEXTURE22: 0x84D6,
  TEXTURE23: 0x84D7,
  TEXTURE24: 0x84D8,
  TEXTURE25: 0x84D9,
  TEXTURE26: 0x84DA,
  TEXTURE27: 0x84DB,
  TEXTURE28: 0x84DC,
  TEXTURE29: 0x84DD,
  TEXTURE3: 0x84C3,
  TEXTURE30: 0x84DE,
  TEXTURE31: 0x84DF,
  TEXTURE4: 0x84C4,
  TEXTURE5: 0x84C5,
  TEXTURE6: 0x84C6,
  TEXTURE7: 0x84C7,
  TEXTURE8: 0x84C8,
  TEXTURE9: 0x84C9,
  TEXTURE_2D: 0x0DE1,
  TEXTURE_BINDING_2D: 0x8069,
  TEXTURE_BINDING_CUBE_MAP: 0x8514,
  TEXTURE_CUBE_MAP: 0x8513,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  TRIANGLES: 0x0004,
  TRIANGLE_FAN: 0x0006,
  TRIANGLE_STRIP: 0x0005,
  UNPACK_ALIGNMENT: 0x0CF5,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
  UNPACK_FLIP_Y_WEBGL: 0x9240,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
  UNSIGNED_BYTE: 0x1401,
  UNSIGNED_INT: 0x1405,
  UNSIGNED_SHORT: 0x1403,
  UNSIGNED_SHORT_4_4_4_4: 0x8033,
  UNSIGNED_SHORT_5_5_5_1: 0x8034,
  UNSIGNED_SHORT_5_6_5: 0x8363,
  VALIDATE_STATUS: 0x8B83,
  VENDOR: 0x1F00,
  VERSION: 0x1F02,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
  VERTEX_SHADER: 0x8B31,
  VIEWPORT: 0x0BA2,
  ZERO: 0
};

/***/ }),

/***/ 10:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var vec3 = __webpack_require__(1982);
var mat4 = __webpack_require__(3503);

/**
 * Create a new instance of class actor.
 *
 * @class
 * @alias vgl.actor
 * @extends vgl.node
 * @returns {vgl.actor}
 */
vgl.actor = function () {
  'use strict';

  if (!(this instanceof vgl.actor)) {
    return new vgl.actor();
  }
  vgl.node.call(this);
  var m_this = this,
    m_transformMatrix = mat4.create(),
    m_referenceFrame = vgl.boundingObject.ReferenceFrame.Relative,
    m_mapper = null;

  /**
   * Get transformation matrix used by the actor.
   *
   * @returns {mat4} The transformation matrix.
   */
  this.matrix = function () {
    return m_transformMatrix;
  };

  /**
   * Get reference frame for the transformations.
   *
   * @returns {string} Possible values are Absolute or Relative
   */
  this.referenceFrame = function () {
    return m_referenceFrame;
  };

  /**
   * Return mapper where actor gets it behavior and data.
   *
   * @returns {vgl.mapper}
   */
  this.mapper = function () {
    return m_mapper;
  };

  /**
   * Connect an actor to its data source.
   *
   * @param {vgl.mapper} mapper The vlg mapper object.
   */
  this.setMapper = function (mapper) {
    if (mapper !== m_mapper) {
      m_mapper = mapper;
      m_this.boundsModified();
    }
  };

  /**
   * Compute actor bounds.
   */
  this.computeBounds = function () {
    if (m_mapper === null || m_mapper === undefined) {
      m_this.resetBounds();
      return;
    }
    var computeBoundsTimestamp = m_this.computeBoundsTimestamp(),
      mapperBounds,
      minPt,
      maxPt,
      newBounds;
    if (m_this.boundsDirtyTimestamp().getMTime() > computeBoundsTimestamp.getMTime() || m_mapper.boundsDirtyTimestamp().getMTime() > computeBoundsTimestamp.getMTime()) {
      m_mapper.computeBounds();
      mapperBounds = m_mapper.bounds();
      minPt = [mapperBounds[0], mapperBounds[2], mapperBounds[4]];
      maxPt = [mapperBounds[1], mapperBounds[3], mapperBounds[5]];
      vec3.transformMat4(minPt, minPt, m_transformMatrix);
      vec3.transformMat4(maxPt, maxPt, m_transformMatrix);
      newBounds = [minPt[0] > maxPt[0] ? maxPt[0] : minPt[0], minPt[0] > maxPt[0] ? minPt[0] : maxPt[0], minPt[1] > maxPt[1] ? maxPt[1] : minPt[1], minPt[1] > maxPt[1] ? minPt[1] : maxPt[1], minPt[2] > maxPt[2] ? maxPt[2] : minPt[2], minPt[2] > maxPt[2] ? minPt[2] : maxPt[2]];
      m_this.setBounds(newBounds[0], newBounds[1], newBounds[2], newBounds[3], newBounds[4], newBounds[5]);
      computeBoundsTimestamp.modified();
    }
  };
  return m_this;
};
inherit(vgl.actor, vgl.node);

/***/ }),

/***/ 8576:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class blendFunction.
 *
 * @class
 * @alias vgl.blendFunction
 * @param {number} source GL source constant.
 * @param {number} destination GL destination constant.
 * @returns {vgl.blendFunction}
 */
vgl.blendFunction = function (source, destination) {
  'use strict';

  if (!(this instanceof vgl.blendFunction)) {
    return new vgl.blendFunction(source, destination);
  }
  var m_source = source,
    m_destination = destination;

  /**
   * Apply blend function to the current state.
   *
   * @param {vgl.renderState} renderState The state that contains the current
   *    render context.
   */
  this.apply = function (renderState) {
    renderState.m_context.blendFuncSeparate(m_source, m_destination, vgl.GL.ONE, vgl.GL.ONE_MINUS_SRC_ALPHA);
  };
  return this;
};

/**
 * Create a new instance of class blend.
 *
 * @class
 * @alias vgl.blend
 * @extends vgl.materialAttribute
 * @returns {vgl.blend}
 */
vgl.blend = function () {
  'use strict';

  if (!(this instanceof vgl.blend)) {
    return new vgl.blend();
  }
  vgl.materialAttribute.call(this, vgl.materialAttributeType.Blend);

  /** @private */
  var m_wasEnabled = false,
    m_blendFunction = vgl.blendFunction(vgl.GL.SRC_ALPHA, vgl.GL.ONE_MINUS_SRC_ALPHA);

  /**
   * Bind blend attribute.
   *
   * @param {vgl.renderState} renderState The state containing the context.
   * @returns {boolean} True if bound.
   */
  this.bind = function (renderState) {
    m_wasEnabled = renderState.m_context.isEnabled(vgl.GL.BLEND);
    if (this.enabled()) {
      renderState.m_context.enable(vgl.GL.BLEND);
      m_blendFunction.apply(renderState);
    } else {
      renderState.m_context.disable(vgl.GL.BLEND);
    }
    return true;
  };

  /**
   * Undo bind blend attribute.
   *
   * @param {vgl.renderState} renderState The state containing the context.
   * @returns {boolean} True if unbound.
   */
  this.undoBind = function (renderState) {
    if (m_wasEnabled) {
      renderState.m_context.enable(vgl.GL.BLEND);
    } else {
      renderState.m_context.disable(vgl.GL.BLEND);
    }
    return true;
  };
  return this;
};
inherit(vgl.blend, vgl.materialAttribute);

/***/ }),

/***/ 3556:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class boundingObject.
 *
 * @class
 * @alias vgl.boundingObject
 * @extends vgl.object
 * @returns {vgl.boundingObject}
 */
vgl.boundingObject = function () {
  'use strict';

  if (!(this instanceof vgl.boundingObject)) {
    return new vgl.boundingObject();
  }
  vgl.object.call(this);
  var m_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    m_computeBoundsTimestamp = timestamp(),
    m_boundsDirtyTimestamp = timestamp();
  m_computeBoundsTimestamp.modified();
  m_boundsDirtyTimestamp.modified();

  /**
   * Get current bounds of the object.
   *
   * @returns {number[]} The min x, max x, min y, max y, min z, max z bounding
   *    range of the object.
   */
  this.bounds = function () {
    return m_bounds;
  };

  /**
   * Check if bounds are valid.
   *
   * @param {number[]} bounds The six value bounds of the object.
   * @returns {boolean} true if the bounds are valid.
   */
  this.hasValidBounds = function (bounds) {
    if (bounds[0] === Number.MAX_VALUE || bounds[1] === -Number.MAX_VALUE || bounds[2] === Number.MAX_VALUE || bounds[3] === -Number.MAX_VALUE || bounds[4] === Number.MAX_VALUE || bounds[5] === -Number.MAX_VALUE) {
      return false;
    }
    return true;
  };

  /**
   * Set current bounds of the object.
   *
   * @param {number} minX Minimum x value.
   * @param {number} maxX Maximum x value.
   * @param {number} minY Minimum y value.
   * @param {number} maxY Maximum y value.
   * @param {number} minZ Minimum z value.
   * @param {number} maxZ Maximum z value.
   * @returns {boolean?} true if the bounds were set.
   */
  this.setBounds = function (minX, maxX, minY, maxY, minZ, maxZ) {
    if (!this.hasValidBounds([minX, maxX, minY, maxY, minZ, maxZ])) {
      return undefined;
    }
    m_bounds[0] = minX;
    m_bounds[1] = maxX;
    m_bounds[2] = minY;
    m_bounds[3] = maxY;
    m_bounds[4] = minZ;
    m_bounds[5] = maxZ;
    this.modified();
    m_computeBoundsTimestamp.modified();
    return true;
  };

  /**
   * Reset bounds to default values.
   */
  this.resetBounds = function () {
    m_bounds[0] = Number.MAX_VALUE;
    m_bounds[1] = -Number.MAX_VALUE;
    m_bounds[2] = Number.MAX_VALUE;
    m_bounds[3] = -Number.MAX_VALUE;
    m_bounds[4] = Number.MAX_VALUE;
    m_bounds[5] = -Number.MAX_VALUE;
    this.modified();
  };

  /**
   * Compute bounds of the object.
   *
   * Should be implemented by the concrete class.
   */
  this.computeBounds = function () {};

  /**
   * Return bounds computation modification time.
   *
   * @returns {geo.timestamp}
   */
  this.computeBoundsTimestamp = function () {
    return m_computeBoundsTimestamp;
  };

  /**
   * Return bounds dirty timestamp.
   *
   * @returns {geo.timestamp}
   */
  this.boundsDirtyTimestamp = function () {
    return m_boundsDirtyTimestamp;
  };
  this.resetBounds();
  return this;
};
vgl.boundingObject.ReferenceFrame = {
  Relative: 0,
  Absolute: 1
};
inherit(vgl.boundingObject, vgl.object);

/***/ }),

/***/ 4580:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);
var vec3 = __webpack_require__(1982);
var vec4 = __webpack_require__(4663);
var mat4 = __webpack_require__(3503);

/**
 * Create a new instance of class camera.
 *
 * @class
 * @alias vgl.camera
 * @extends vgl.groupNode
 * @param {object} arg
 * @param {boolean?} arg.parallelProjection Optionally start with a parallel
 *      projection.
 * @returns {vgl.camera}
 */
vgl.camera = function (arg) {
  'use strict';

  if (!(this instanceof vgl.camera)) {
    return new vgl.camera(arg);
  }
  vgl.groupNode.call(this);
  arg = arg || {};

  /** @private */
  var m_viewAngle = Math.PI * 30 / 180.0,
    m_position = vec4.fromValues(0.0, 0.0, 1.0, 1.0),
    m_focalPoint = vec4.fromValues(0.0, 0.0, 0.0, 1.0),
    m_viewUp = vec4.fromValues(0.0, 1.0, 0.0, 0.0),
    m_near = 0.01,
    m_far = 10000.0,
    m_viewAspect = 1.0,
    m_directionOfProjection = vec4.fromValues(0.0, 0.0, -1.0, 0.0),
    m_viewMatrix = mat4.create(),
    m_projectionMatrix = mat4.create(),
    m_computeModelViewMatrixTime = timestamp(),
    m_computeProjectMatrixTime = timestamp(),
    m_left = -1.0,
    m_right = 1.0,
    m_top = +1.0,
    m_bottom = -1.0,
    m_parallelExtents = {
      zoom: 1,
      tilesize: 256
    },
    m_enableParallelProjection = false,
    m_clearColor = [0.0, 0.0, 0.0, 0.0],
    m_clearDepth = 1.0,
    /*jshint bitwise: false */
    m_clearMask = vgl.GL.COLOR_BUFFER_BIT | vgl.GL.DEPTH_BUFFER_BIT;
  /*jshint bitwise: true */

  if (arg.parallelProjection !== undefined) {
    m_enableParallelProjection = arg.parallelProjection ? true : false;
  }

  /**
   * Set view aspect.
   *
   * @param {number} aspect Aspect ration (width / height).
   */
  this.setViewAspect = function (aspect) {
    m_viewAspect = aspect;
    this.modified();
  };

  /**
   * Get parallel projection extents parameters.
   *
   * @returns {object} Extents object with width, height, zoom, and tilesize.
   */
  this.parallelExtents = function () {
    return m_parallelExtents;
  };

  /**
   * Set parallel projection extents parameters.
   *
   * @param {object} extents Extents object with width, height, zoom, and
   *    tilesize.
   */
  this.setParallelExtents = function (extents) {
    var prop = ['width', 'height', 'zoom', 'tilesize'],
      mod = false,
      i,
      key;
    for (i = 0; i < prop.length; i += 1) {
      key = prop[i];
      if (extents[key] !== undefined && extents[key] !== m_parallelExtents[key]) {
        m_parallelExtents[key] = extents[key];
        mod = true;
      }
    }
    if (mod && m_parallelExtents.width && m_parallelExtents.height && m_parallelExtents.zoom !== undefined && m_parallelExtents.tilesize) {
      var unitsPerPixel = this.unitsPerPixel(m_parallelExtents.zoom, m_parallelExtents.tilesize);
      m_right = unitsPerPixel * m_parallelExtents.width / 2;
      m_left = -m_right;
      m_top = unitsPerPixel * m_parallelExtents.height / 2;
      m_bottom = -m_top;
      this.modified();
    }
  };

  /**
   * Compute the units per pixel.
   *
   * @param {number} zoom Tile zoom level.
   * @param {number} tilesize Number of pixels per tile (defaults to 256).
   * @returns {number} unitsPerPixel.
   */
  this.unitsPerPixel = function (zoom, tilesize) {
    tilesize = tilesize || 256;
    return 360.0 * Math.pow(2, -zoom) / tilesize;
  };

  /**
   * Return view-matrix for the camera This method does not compute the
   * view-matrix for the camera. It is assumed that a call to computeViewMatrix
   * has been made earlier.
   *
   * @returns {mat4}
   */
  this.viewMatrix = function () {
    return this.computeViewMatrix();
  };

  /**
   * Set the view-matrix for the camera and mark that it is up to date so that
   * it won't be recomputed unless something else changes.
   *
   * @param {mat4} view new view matrix.
   * @param {boolean} preserveType If true, clone the input using slice.  This
   *    can be used to ensure the array is a specific precision.
   */
  this.setViewMatrix = function (view, preserveType) {
    if (!preserveType) {
      mat4.copy(m_viewMatrix, view);
    } else {
      m_viewMatrix = view.slice();
    }
    m_computeModelViewMatrixTime.modified();
  };

  /**
   * Return camera projection matrix This method does not compute the
   * projection-matrix for the camera. It is assumed that a call to
   * computeProjectionMatrix has been made earlier.
   *
   * @returns {mat4}
   */
  this.projectionMatrix = function () {
    return this.computeProjectionMatrix();
  };

  /**
   * Set the projection-matrix for the camera and mark that it is up to date so
   * that it won't be recomputed unless something else changes.
   *
   * @param {mat4} proj New projection matrix.
   */
  this.setProjectionMatrix = function (proj) {
    mat4.copy(m_projectionMatrix, proj);
    m_computeProjectMatrixTime.modified();
  };

  /**
   * Return clear mask used by this camera.
   *
   * @returns {number}
   */
  this.clearMask = function () {
    return m_clearMask;
  };

  /**
   * Get clear color (background color) of the camera.
   *
   * @returns {Array}
   */
  this.clearColor = function () {
    return m_clearColor;
  };

  /**
   * Get the clear depth value.
   *
   * @returns {number}
   */
  this.clearDepth = function () {
    return m_clearDepth;
  };

  /**
   * Compute direction of projection.
   */
  this.computeDirectionOfProjection = function () {
    vec3.subtract(m_directionOfProjection, m_focalPoint, m_position);
    vec3.normalize(m_directionOfProjection, m_directionOfProjection);
    this.modified();
  };

  /**
   * Compute camera view matrix.
   *
   * @returns {mat4}
   */
  this.computeViewMatrix = function () {
    if (m_computeModelViewMatrixTime.getMTime() < this.getMTime()) {
      mat4.lookAt(m_viewMatrix, m_position, m_focalPoint, m_viewUp);
      m_computeModelViewMatrixTime.modified();
    }
    return m_viewMatrix;
  };

  /**
   * Compute camera projection matrix.
   *
   * @returns {mat4}
   */
  this.computeProjectionMatrix = function () {
    if (m_computeProjectMatrixTime.getMTime() < this.getMTime()) {
      if (!m_enableParallelProjection) {
        mat4.perspective(m_projectionMatrix, m_viewAngle, m_viewAspect, m_near, m_far);
      } else {
        mat4.ortho(m_projectionMatrix, m_left, m_right, m_bottom, m_top, m_near, m_far);
      }
      m_computeProjectMatrixTime.modified();
    }
    return m_projectionMatrix;
  };
  this.computeDirectionOfProjection();
  return this;
};
inherit(vgl.camera, vgl.groupNode);

/***/ }),

/***/ 7695:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);

/**
 * Create a new instance of class data.
 *
 * @class
 * @alias vgl.data
 * @returns {vgl.data}
 */
vgl.data = function () {
  'use strict';

  if (!(this instanceof vgl.data)) {
    return new vgl.data();
  }

  /**
   * Return data type. Should be implemented by the derived class.
   */
  this.type = function () {};
};
vgl.data.raster = 0;
vgl.data.point = 1;
vgl.data.lineString = 2;
vgl.data.polygon = 3;
vgl.data.geometry = 10;

/***/ }),

/***/ 4831:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
vgl.event = {};

/**
 *  types
 */
vgl.event.keyPress = 'vgl.event.keyPress';
vgl.event.mousePress = 'vgl.event.mousePress';
vgl.event.mouseRelease = 'vgl.event.mouseRelease';
vgl.event.contextMenu = 'vgl.event.contextMenu';
vgl.event.configure = 'vgl.event.configure';
vgl.event.enable = 'vgl.event.enable';
vgl.event.mouseWheel = 'vgl.event.mouseWheel';
vgl.event.keyRelease = 'vgl.event.keyRelease';
vgl.event.middleButtonPress = 'vgl.event.middleButtonPress';
vgl.event.startInteraction = 'vgl.event.startInteraction';
vgl.event.enter = 'vgl.event.enter';
vgl.event.rightButtonPress = 'vgl.event.rightButtonPress';
vgl.event.middleButtonRelease = 'vgl.event.middleButtonRelease';
vgl.event.char = 'vgl.event.char';
vgl.event.disable = 'vgl.event.disable';
vgl.event.endInteraction = 'vgl.event.endInteraction';
vgl.event.mouseMove = 'vgl.event.mouseMove';
vgl.event.mouseOut = 'vgl.event.mouseOut';
vgl.event.expose = 'vgl.event.expose';
vgl.event.timer = 'vgl.event.timer';
vgl.event.leftButtonPress = 'vgl.event.leftButtonPress';
vgl.event.leave = 'vgl.event.leave';
vgl.event.rightButtonRelease = 'vgl.event.rightButtonRelease';
vgl.event.leftButtonRelease = 'vgl.event.leftButtonRelease';
vgl.event.click = 'vgl.event.click';
vgl.event.dblClick = 'vgl.event.dblClick';

/***/ }),

/***/ 7327:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class primitive.
 *
 * @class
 * @alias vgl.primitive
 * @returns {vgl.primitive}
 */
vgl.primitive = function () {
  'use strict';

  if (!(this instanceof vgl.primitive)) {
    return new vgl.primitive();
  }
  var m_primitiveType = 0,
    m_indicesValueType = 0,
    m_indices = null;

  /**
   * Get indices of the primitive.
   *
   * @returns {Uint16Array}
   */
  this.indices = function () {
    return m_indices;
  };

  /**
   * Return the number of indices.
   *
   * @returns {number} The number of indices.
   */
  this.numberOfIndices = function () {
    return m_indices === null ? 0 : m_indices.length;
  };

  /*
   * Return primitive type.
   *
   * @returns {number}
   */
  this.primitiveType = function () {
    return m_primitiveType;
  };

  /**
   * Set primitive type.
   *
   * @param {number} type The new type.
   */
  this.setPrimitiveType = function (type) {
    m_primitiveType = type;
  };

  /**
   * Return indices value type.
   *
   * @returns {number}
   */
  this.indicesValueType = function () {
    return m_indicesValueType;
  };

  /**
   * Set indices value type.
   *
   * @param {number} type
   */
  this.setIndicesValueType = function (type) {
    m_indicesValueType = type;
  };

  /**
   * Set indices from a array.
   *
   * @param {Array} indicesArray The array of new indices.
   */
  this.setIndices = function (indicesArray) {
    // TODO Check for the type
    m_indices = new Uint16Array(indicesArray);
  };
  return this;
};

/**
 * Create a new instance of class triangles.
 *
 * @class
 * @alias vgl.triangles
 * @returns {vgl.triangles}
 */
vgl.triangles = function () {
  'use strict';

  if (!(this instanceof vgl.triangles)) {
    return new vgl.triangles();
  }
  vgl.primitive.call(this);
  this.setPrimitiveType(vgl.GL.TRIANGLES);
  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
  return this;
};
inherit(vgl.triangles, vgl.primitive);

/**
 * Create a new instance of class points.
 *
 * @class
 * @alias vgl.points
 * @returns {vgl.points}
 */
vgl.points = function () {
  'use strict';

  if (!(this instanceof vgl.points)) {
    return new vgl.points();
  }
  vgl.primitive.call(this);
  this.setPrimitiveType(vgl.GL.POINTS);
  this.setIndicesValueType(vgl.GL.UNSIGNED_SHORT);
  return this;
};
inherit(vgl.points, vgl.primitive);

/**
 * Create a new instance of class sourceData.
 *
 * @class
 * @alias vgl.sourceData
 * @param {object} arg
 * @param {string?} arg.name Name of the source
 * @returns {vgl.sourceData}
 */
vgl.sourceData = function (arg) {
  'use strict';

  if (!(this instanceof vgl.sourceData)) {
    return new vgl.sourceData(arg);
  }
  arg = arg || {};
  var m_attributesMap = {},
    m_data = [],
    m_name = arg.name || 'Source ' + new Date().toISOString(),
    /* Attribute data for the source */
    vglAttributeData = function vglAttributeData() {
      // Number of components per group
      // Type of data type (GL_FLOAT etc)
      this.m_numberOfComponents = 0;
      // Size of data type
      this.m_dataType = 0;
      this.m_dataTypeSize = 0;
      // Specifies whether fixed-point data values should be normalized
      // (true) or converted directly as fixed-point values (false)
      // when they are accessed.
      this.m_normalized = false;
      // Strides for each attribute.
      this.m_stride = 0;
      // Offset
      this.m_offset = 0;
    };

  /**
   * Return raw data for this source.
   *
   * @returns {Array|Float32Array}
   */
  this.data = function () {
    return m_data;
  };

  /**
   * Return raw data for this source.
   *
   * @returns {Array|Float32Array}
   */
  this.getData = function () {
    return this.data();
  };

  /**
   * If the raw data is not a Float32Array, convert it to one.  Then, return
   * raw data for this source.
   *
   * @returns {Float32Array}
   */
  this.dataToFloat32Array = function () {
    if (!(m_data instanceof Float32Array)) {
      m_data = new Float32Array(m_data);
    }
    return m_data;
  };

  /**
   * Set data for this source.
   *
   * @param {Array|Float32Array} data
   */
  this.setData = function (data) {
    if (!(data instanceof Array) && !(data instanceof Float32Array)) {
      console.log('[error] Requires array'); // eslint-disable-line no-console
      return;
    }
    if (data instanceof Float32Array) {
      m_data = data;
    } else {
      m_data = data.slice(0);
    }
  };

  /**
   * Add new attribute data to the source.
   *
   * @param {string} key Attribute key.
   * @param {number} dataType
   * @param {number} sizeOfDataType
   * @param {number} offset
   * @param {number} stride
   * @param {number} noOfComponents
   * @param {boolean} normalized
   */
  this.addAttribute = function (key, dataType, sizeOfDataType, offset, stride, noOfComponents, normalized) {
    if (!m_attributesMap.hasOwnProperty(key)) {
      var newAttr = new vglAttributeData();
      newAttr.m_dataType = dataType;
      newAttr.m_dataTypeSize = sizeOfDataType;
      newAttr.m_offset = offset;
      newAttr.m_stride = stride;
      newAttr.m_numberOfComponents = noOfComponents;
      newAttr.m_normalized = normalized;
      m_attributesMap[key] = newAttr;
    }
  };

  /**
   * Check if there is attribute exists of a given key type.
   *
   * @param {string} key Attribute key.
   * @returns {boolean}
   */
  this.hasKey = function (key) {
    return m_attributesMap.hasOwnProperty(key);
  };

  /**
   * Return keys of all attributes.
   *
   * @returns {string[]}
   */
  this.keys = function () {
    return Object.keys(m_attributesMap);
  };

  /**
   * Return number of components of the attribute data.
   *
   * @param {string} key Attribute key.
   * @returns {number}
   */
  this.attributeNumberOfComponents = function (key) {
    if (m_attributesMap.hasOwnProperty(key)) {
      return m_attributesMap[key].m_numberOfComponents;
    }
    return 0;
  };

  /**
   * Return if the attribute data is normalized.
   *
   * @param {string} key Attribute key.
   * @returns {boolean}
   */
  this.normalized = function (key) {
    if (m_attributesMap.hasOwnProperty(key)) {
      return m_attributesMap[key].m_normalized;
    }
    return false;
  };

  /**
   * Return attribute data type.
   *
   * @param {string} key Attribute key.
   * @returns {number}
   */
  this.attributeDataType = function (key) {
    if (m_attributesMap.hasOwnProperty(key)) {
      return m_attributesMap[key].m_dataType;
    }
    return undefined;
  };

  /**
   * Return attribute offset.
   *
   * @param {string} key Attribute key.
   * @returns {number}
   */
  this.attributeOffset = function (key) {
    if (m_attributesMap.hasOwnProperty(key)) {
      return m_attributesMap[key].m_offset;
    }
    return 0;
  };

  /**
   * Return attribute stride.
   *
   * @param {string} key Attribute key.
   * @returns {number}
   */
  this.attributeStride = function (key) {
    if (m_attributesMap.hasOwnProperty(key)) {
      return m_attributesMap[key].m_stride;
    }
    return 0;
  };

  /**
   * Virtual function to insert new vertex data at the end.
   *
   * @param {number|Array} vertexData
   */
  this.pushBack = function (vertexData) {
    // Should be implemented by the base class
  };

  /**
   * Insert new data block to the raw data.
   *
   * @param {number[]|Float32Array} data
   */
  this.insert = function (data) {
    var i;

    /* If we will are given a Float32Array and don't have any other data, use
     * it directly. */
    if (!m_data.length && data.length && data instanceof Float32Array) {
      m_data = data;
      return;
    }
    /* If our internal array is immutable and we will need to change it, create
     * a regular mutable array from it. */
    if (!m_data.slice && (m_data.length || !data.slice)) {
      m_data = Array.prototype.slice.call(m_data);
    }
    if (!data.length) {
      /* data is a singular value, so append it to our array */
      m_data[m_data.length] = data;
    } else {
      /* We don't have any data currently, so it is faster to copy the data
       * using slice. */
      if (!m_data.length && data.slice) {
        m_data = data.slice(0);
      } else {
        for (i = 0; i < data.length; i += 1) {
          m_data[m_data.length] = data[i];
        }
      }
    }
  };

  /**
   * Return name of the source data.
   *
   * @returns {string}
   */
  this.name = function () {
    return m_name;
  };
  return this;
};

/**
 * Create a new instance of class sourceDataP3fv.
 *
 * @class
 * @alias vgl.sourceDataAnyfv
 * @param {number} size Number of sets of 4 floats.
 * @param {string} key Attribute key.
 * @param {object} arg Argument to pass to parent class.
 * @returns {vgl.sourceDataAnyfv}
 */
vgl.sourceDataAnyfv = function (size, key, arg) {
  'use strict';

  if (!(this instanceof vgl.sourceDataAnyfv)) {
    return new vgl.sourceDataAnyfv(size, key, arg);
  }
  vgl.sourceData.call(this, arg);
  this.addAttribute(key, vgl.GL.FLOAT, 4, 0, size * 4, size, false);
  this.pushBack = function (value) {
    this.insert(value);
  };
  return this;
};
inherit(vgl.sourceDataAnyfv, vgl.sourceData);

/**
 * Create a new instance of class sourceDataP3fv.
 *
 * @class
 * @alias vgl.sourceDataP3fv
 * @param {object} arg Object to pass to parent class.
 * @returns {vgl.sourceDataP3fv}
 */
vgl.sourceDataP3fv = function (arg) {
  'use strict';

  if (!(this instanceof vgl.sourceDataP3fv)) {
    return new vgl.sourceDataP3fv(arg);
  }
  vgl.sourceData.call(this, arg);
  this.addAttribute(vgl.vertexAttributeKeys.Position, vgl.GL.FLOAT, 4, 0, 3 * 4, 3, false);
  this.pushBack = function (value) {
    this.insert(value);
  };
  return this;
};
inherit(vgl.sourceDataP3fv, vgl.sourceData);

/**
 * Create a new instance of class sourceDataT2fv.
 *
 * @class
 * @alias vgl.sourceDataT2fv
 * @param {object} arg Object to pass to parent class.
 * @returns {vgl.sourceDataT2fv}
 */
vgl.sourceDataT2fv = function (arg) {
  'use strict';

  if (!(this instanceof vgl.sourceDataT2fv)) {
    return new vgl.sourceDataT2fv(arg);
  }
  vgl.sourceData.call(this, arg);
  this.addAttribute(vgl.vertexAttributeKeys.TextureCoordinate, vgl.GL.FLOAT, 4, 0, 2 * 4, 2, false);
  this.pushBack = function (value) {
    this.insert(value);
  };
  return this;
};
inherit(vgl.sourceDataT2fv, vgl.sourceData);

/**
 * Create a new instance of class geometryData.
 *
 * @class
 * @alias vgl.geometryData
 * @returns {vgl.geometryData}
 */
vgl.geometryData = function () {
  'use strict';

  if (!(this instanceof vgl.geometryData)) {
    return new vgl.geometryData();
  }
  vgl.data.call(this);
  var m_name = '',
    m_primitives = [],
    m_sources = [],
    m_bounds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
    m_computeBoundsTimestamp = timestamp(),
    m_boundsDirtyTimestamp = timestamp();

  /**
   * Return type.
   *
   * @returns {number}
   */
  this.type = function () {
    return vgl.data.geometry;
  };

  /**
   * Return ID of the geometry data.
   *
   * @returns {string}
   */
  this.name = function () {
    return m_name;
  };

  /**
   * Add new source.
   *
   * @param {vgl.sourceData} source
   * @returns {boolean} True is the source was added.
   */
  this.addSource = function (source) {
    if (m_sources.indexOf(source) === -1) {
      m_sources.push(source);
      if (source.hasKey(vgl.vertexAttributeKeys.Position)) {
        m_boundsDirtyTimestamp.modified();
      }
      return true;
    }
    return false;
  };

  /**
   * Return source for a given index. Returns 0 if not found.
   *
   * @param {number} index
   * @returns {vgl.sourceData|number}
   */
  this.source = function (index) {
    if (index < m_sources.length) {
      return m_sources[index];
    }
    return 0;
  };

  /**
   * Return source with a specified name.  Returns 0 if not found.
   *
   * @param {string} sourceName
   * @returns {vgl.sourceData|number}
   */
  this.sourceByName = function (sourceName) {
    for (var i = 0; i < m_sources.length; i += 1) {
      if (m_sources[i].name() === sourceName) {
        return m_sources[i];
      }
    }
    return 0;
  };

  /**
   * Return number of sources.
   *
   * @returns {number}
   */
  this.numberOfSources = function () {
    return m_sources.length;
  };

  /**
   * Return source data given a key.
   *
   * @param {string} key
   * @returns {vgl.sourceData|null}
   */
  this.sourceData = function (key) {
    var i;
    for (i = 0; i < m_sources.length; i += 1) {
      if (m_sources[i].hasKey(key)) {
        return m_sources[i];
      }
    }
    return null;
  };

  /**
   * Add new primitive.
   *
   * @param {vgl.primitive} primitive
   * @returns {boolean}
   */
  this.addPrimitive = function (primitive) {
    m_primitives.push(primitive);
    return true;
  };

  /**
   * Return primitive for a given index. Returns null if not found.
   *
   * @param {number} index
   * @returns {vgl.primitive|null}
   */
  this.primitive = function (index) {
    if (index < m_primitives.length) {
      return m_primitives[index];
    }
    return null;
  };

  /**
   * Return number of primitives.
   *
   * @returns {number}
   */
  this.numberOfPrimitives = function () {
    return m_primitives.length;
  };

  /**
   * Return bounds.
   *
   * @returns {number[]} Array of minX, maxX, minY, maxY, minZ, maxZ.
   */
  this.bounds = function () {
    if (m_boundsDirtyTimestamp.getMTime() > m_computeBoundsTimestamp.getMTime()) {
      this.computeBounds();
    }
    return m_bounds;
  };

  /**
   * Check if bounds are dirty or mark them as such.
   *
   * @param {boolean} dirty true to set bounds as dirty.
   * @returns {boolean} true if bounds are dirty.
   */
  this.boundsDirty = function (dirty) {
    if (dirty) {
      m_boundsDirtyTimestamp.modified();
    }
    return m_boundsDirtyTimestamp.getMTime() > m_computeBoundsTimestamp.getMTime();
  };

  /**
   * Set bounds.
   *
   * @param {number} minX
   * @param {number} maxX
   * @param {number} minY
   * @param {number} maxY
   * @param {number} minZ
   * @param {number} maxZ
   * @returns {boolean} True if set.
   */
  this.setBounds = function (minX, maxX, minY, maxY, minZ, maxZ) {
    m_bounds[0] = minX;
    m_bounds[1] = maxX;
    m_bounds[2] = minY;
    m_bounds[3] = maxY;
    m_bounds[4] = minZ;
    m_bounds[5] = maxZ;
    m_computeBoundsTimestamp.modified();
    return true;
  };
  return this;
};
inherit(vgl.geometryData, vgl.data);

/***/ }),

/***/ 29:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class graphicsObject.
 *
 * @class
 * @alias vgl.graphicsObject
 * @param {number} type A GL type.
 * @returns {vgl.graphicsObject}
 */
vgl.graphicsObject = function (type) {
  'use strict';

  if (!(this instanceof vgl.graphicsObject)) {
    return new vgl.graphicsObject();
  }
  vgl.object.call(this);
  var m_this = this;

  /**
   * Setup (initialize) the object.
   *
   * @param {vgl.renderState} renderState
   * @returns {boolean}
   */
  this._setup = function (renderState) {
    return false;
  };

  /**
   * Remove any resources acquired before deletion.
   *
   * @param {vgl.renderState} renderState
   * @returns {boolean}
   */
  this._cleanup = function (renderState) {
    return false;
  };
  return m_this;
};
inherit(vgl.graphicsObject, vgl.object);

/***/ }),

/***/ 7616:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class groupNode.
 *
 * @class
 * @alias vgl.groupNode
 * @returns {vgl.groupNode}
 */
vgl.groupNode = function () {
  'use strict';

  if (!(this instanceof vgl.groupNode)) {
    return new vgl.groupNode();
  }
  vgl.node.call(this);
  var m_children = [];

  /**
   * Make the incoming node a child of the group node.
   *
   * @param {vgl.node} childNode
   * @returns {boolean}
   */
  this.addChild = function (childNode) {
    if (childNode instanceof vgl.node) {
      if (m_children.indexOf(childNode) === -1) {
        childNode.setParent(this);
        m_children.push(childNode);
        this.boundsDirtyTimestamp().modified();
        return true;
      }
      return false;
    }
    return false;
  };

  /**
   * Remove parent-child relationship between the group and incoming node.
   *
   * @param {vgl.node} childNode
   * @returns {boolean}
   */
  this.removeChild = function (childNode) {
    if (childNode.parent() === this) {
      var index = m_children.indexOf(childNode);
      if (index >= 0) {
        m_children.splice(index, 1);
        childNode.setParent(null);
        this.boundsDirtyTimestamp().modified();
        return true;
      }
    }
    return false;
  };

  /**
   * Remove parent-child relationship between child nodes and the group node.
   */
  this.removeChildren = function () {
    while (m_children.length) {
      this.removeChild(m_children[0]);
    }
    this.modified();
  };

  /**
   * Return children of this group node.
   *
   * @returns {vgl.node[]}
   */
  this.children = function () {
    return m_children;
  };

  /**
   * Return true if this group node has node as a child, false otherwise.
   *
   * @param {vgl.node} node
   * @returns {boolean}
   */
  this.hasChild = function (node) {
    var i = 0,
      child = false;
    for (i = 0; i < m_children.length; i += 1) {
      if (m_children[i] === node) {
        child = true;
        break;
      }
    }
    return child;
  };
  return this;
};
inherit(vgl.groupNode, vgl.node);

/***/ }),

/***/ 1611:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @namespace vgl
 */
module.exports = __webpack_require__(698);
__webpack_require__(6552);
__webpack_require__(9156);
__webpack_require__(3556); // requires object
__webpack_require__(9838); // requires boundingObject
__webpack_require__(4831); // requires object
__webpack_require__(29); // requires object
__webpack_require__(4970); // requires graphicsObject
__webpack_require__(1232); // requires graphicsObject
__webpack_require__(2971); // requires boundingObject
__webpack_require__(10); // requires node
__webpack_require__(7616); // requires node
__webpack_require__(4580); // requires groupNode
__webpack_require__(8576); // requires materialAttribute
__webpack_require__(7695);
__webpack_require__(7327); // requires data
__webpack_require__(5763); // requires graphicsObject
__webpack_require__(5796); // requires graphcisObject
__webpack_require__(5794); // requires object
__webpack_require__(796); // requires materialAttribute
__webpack_require__(8888); // requires materialAttributes
__webpack_require__(3471);
__webpack_require__(4933);
__webpack_require__(7205); // requires object

/***/ }),

/***/ 9838:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class mapper.
 *
 * @class
 * @alias vgl.mapper
 * @param {object} arg
 * @param {boolean} arg.dynamicDraw true if the dynamic draw flag should be
 *      set.
 * @returns {vgl.mapper}
 */
vgl.mapper = function (arg) {
  'use strict';

  if (!(this instanceof vgl.mapper)) {
    return new vgl.mapper(arg);
  }
  vgl.boundingObject.call(this);
  arg = arg || {};
  var m_color = [0.0, 1.0, 1.0],
    m_geomData = null,
    m_buffers = [],
    m_bufferVertexAttributeMap = {},
    m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
    m_glCompileTimestamp = timestamp(),
    m_context = null,
    m_this = this;

  /**
   * Delete cached VBO.
   *
   * @param {vgl.renderState} renderState
   */
  this.deleteVertexBufferObjects = function (renderState) {
    var i;
    var context = m_context;
    if (renderState) {
      context = renderState.m_context;
    }
    if (context) {
      for (i = 0; i < m_buffers.length; i += 1) {
        context.deleteBuffer(m_buffers[i]);
      }
    }
  };

  /**
   * Cleanup mapper.
   *
   * @param {vgl.renderState} renderState
   */
  this._cleanup = function (renderState) {
    m_this.deleteVertexBufferObjects(renderState);
    cleanUpDrawObjects(renderState);
    m_this.modified();
  };

  /**
   * Create new VBO for all its geometryData sources and primitives.
   *
   * @param {vgl.renderState} renderState
   */
  function createVertexBufferObjects(renderState) {
    if (m_geomData) {
      if (renderState) {
        m_context = renderState.m_context;
      }
      var numberOfSources = m_geomData.numberOfSources(),
        i,
        j,
        k,
        bufferId = null,
        keys,
        ks,
        numberOfPrimitives,
        data;
      for (i = 0; i < numberOfSources; i += 1) {
        bufferId = m_context.createBuffer();
        m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, bufferId);
        data = m_geomData.source(i).data();
        if (!(data instanceof Float32Array)) {
          data = new Float32Array(data);
        }
        m_context.bufferData(vgl.GL.ARRAY_BUFFER, data, m_dynamicDraw ? vgl.GL.DYNAMIC_DRAW : vgl.GL.STATIC_DRAW);
        keys = m_geomData.source(i).keys();
        ks = [];
        for (j = 0; j < keys.length; j += 1) {
          ks.push(keys[j]);
        }
        m_bufferVertexAttributeMap[i] = ks;
        m_buffers[i] = bufferId;
      }
      numberOfPrimitives = m_geomData.numberOfPrimitives();
      for (k = 0; k < numberOfPrimitives; k += 1) {
        bufferId = m_context.createBuffer();
        m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, bufferId);
        m_context.bufferData(vgl.GL.ARRAY_BUFFER, m_geomData.primitive(k).indices(), vgl.GL.STATIC_DRAW);
        m_buffers[i] = bufferId;
        i += 1;
      }
      m_glCompileTimestamp.modified();
    }
  }

  /**
   * Clear cache related to buffers.
   *
   * @param {vgl.renderState} renderState
   */
  function cleanUpDrawObjects(renderState) {
    m_bufferVertexAttributeMap = {};
    m_buffers = [];
  }

  /**
   * Setup draw objects; Delete old ones and create new ones.
   *
   * @param {vgl.renderState} renderState
   */
  function setupDrawObjects(renderState) {
    // Delete buffer objects from past if any.
    m_this.deleteVertexBufferObjects(renderState);

    // Clear any cache related to buffers
    cleanUpDrawObjects(renderState);

    // Now construct the new ones.
    createVertexBufferObjects(renderState);
  }

  /**
   * Compute bounds of the data.
   */
  this.computeBounds = function () {
    if (m_geomData === null || typeof m_geomData === 'undefined') {
      this.resetBounds();
      return;
    }
    var computeBoundsTimestamp = this.computeBoundsTimestamp(),
      boundsDirtyTimestamp = this.boundsDirtyTimestamp(),
      geomBounds = null;
    if (boundsDirtyTimestamp.getMTime() > computeBoundsTimestamp.getMTime()) {
      geomBounds = m_geomData.bounds();
      this.setBounds(geomBounds[0], geomBounds[1], geomBounds[2], geomBounds[3], geomBounds[4], geomBounds[5]);
      computeBoundsTimestamp.modified();
    }
  };

  /**
   * Get solid color of the geometry.
   *
   * @returns {number[]}
   */
  this.color = function () {
    return m_color;
  };

  /**
   * Return stored geometry data.
   *
   * @returns {number[]}
   */
  this.geometryData = function () {
    return m_geomData;
  };

  /**
   * Connect mapper to its geometry data.
   *
   * @param {number[]} geom
   */
  this.setGeometryData = function (geom) {
    if (m_geomData !== geom) {
      m_geomData = geom;
      this.modified();
      this.boundsDirtyTimestamp().modified();
    }
  };

  /**
   * Update the buffer used for a named source.
   *
   * @param {string} sourceName The name of the source to update.
   * @param {object[]|Float32Array} values The values to use for the source.
   *    If not specified, use the source's own buffer.
   * @param {vgl.renderState} renderState
   * @returns {boolean} true if there was a context to update.
   */
  this.updateSourceBuffer = function (sourceName, values, renderState) {
    if (renderState) {
      m_context = renderState.m_context;
    }
    if (!m_context) {
      return false;
    }
    var bufferIndex = -1;
    for (var i = 0; i < m_geomData.numberOfSources(); i += 1) {
      if (m_geomData.source(i).name() === sourceName) {
        bufferIndex = i;
        break;
      }
    }
    if (bufferIndex < 0 || bufferIndex >= m_buffers.length) {
      return false;
    }
    if (!values) {
      values = m_geomData.source(i).dataToFloat32Array();
    }
    m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_buffers[bufferIndex]);
    if (values instanceof Float32Array) {
      m_context.bufferSubData(vgl.GL.ARRAY_BUFFER, 0, values);
    } else {
      m_context.bufferSubData(vgl.GL.ARRAY_BUFFER, 0, new Float32Array(values));
    }
    return true;
  };

  /**
   * Get the buffer used for a named source.  If the current buffer isn't a
   * Float32Array, it is converted to one.  This array can then be modified
   * directly, after which updateSourceBuffer can be called to update the
   * GL array.
   *
   * @param {string} sourceName The name of the source to update.
   * @returns {Float32Array} An array used for this source.
   */
  this.getSourceBuffer = function (sourceName) {
    var source = m_geomData.sourceByName(sourceName);
    if (!source) {
      return new Float32Array();
    }
    return source.dataToFloat32Array();
  };

  /**
   * Render the mapper.
   *
   * @param {vgl.renderState} renderState The current rendering state object.
   * @param {boolean} noUndoBindVertexData If true, do not unbind vertex data.
   *    This may be desirable if the render function is subclassed.
   */
  this.render = function (renderState, noUndoBindVertexData) {
    if (this.getMTime() > m_glCompileTimestamp.getMTime() || renderState.m_contextChanged) {
      setupDrawObjects(renderState);
    }
    m_context = renderState.m_context;

    // Fixed vertex color
    m_context.vertexAttrib3fv(vgl.vertexAttributeKeys.Color, this.color());
    var bufferIndex = 0,
      j = 0,
      i,
      noOfPrimitives = null,
      primitive = null;
    for (i in m_bufferVertexAttributeMap) {
      if (m_bufferVertexAttributeMap.hasOwnProperty(i)) {
        m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_buffers[bufferIndex]);
        for (j = 0; j < m_bufferVertexAttributeMap[i].length; j += 1) {
          renderState.m_material.bindVertexData(renderState, m_bufferVertexAttributeMap[i][j]);
        }
        bufferIndex += 1;
      }
    }
    noOfPrimitives = m_geomData.numberOfPrimitives();
    for (j = 0; j < noOfPrimitives; j += 1, bufferIndex += 1) {
      primitive = m_geomData.primitive(j);
      if (!primitive.numberOfIndices()) {
        continue;
      }
      m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, m_buffers[bufferIndex]);
      switch (primitive.primitiveType()) {
        case vgl.GL.POINTS:
          m_context.drawArrays(vgl.GL.POINTS, 0, primitive.numberOfIndices());
          break;
        case vgl.GL.LINES:
          m_context.drawArrays(vgl.GL.LINES, 0, primitive.numberOfIndices());
          break;
        case vgl.GL.LINE_STRIP:
          m_context.drawArrays(vgl.GL.LINE_STRIP, 0, primitive.numberOfIndices());
          break;
        case vgl.GL.TRIANGLES:
          m_context.drawArrays(vgl.GL.TRIANGLES, 0, primitive.numberOfIndices());
          break;
        case vgl.GL.TRIANGLE_STRIP:
          m_context.drawArrays(vgl.GL.TRIANGLE_STRIP, 0, primitive.numberOfIndices());
          break;
      }
      m_context.bindBuffer(vgl.GL.ARRAY_BUFFER, null);
    }

    /* If we are rendering multiple features in the same context, we must
     * unbind the vertex data to make sure the next feature has a known state.
     * This is optional.
     */
    if (!noUndoBindVertexData) {
      this.undoBindVertexData(renderState);
    }
  };

  /**
   * Unbind the vertex data.
   *
   * @param {vgl.renderState} renderState
   */
  this.undoBindVertexData = function (renderState) {
    var i, j;
    for (i in m_bufferVertexAttributeMap) {
      if (m_bufferVertexAttributeMap.hasOwnProperty(i)) {
        for (j = 0; j < m_bufferVertexAttributeMap[i].length; j += 1) {
          renderState.m_material.undoBindVertexData(renderState, m_bufferVertexAttributeMap[i][j]);
        }
      }
    }
  };
  return this;
};
inherit(vgl.mapper, vgl.boundingObject);

/***/ }),

/***/ 4970:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class material.
 *
 * @class
 * @alias vgl.material
 * @returns {vgl.material}
 */
vgl.material = function () {
  'use strict';

  if (!(this instanceof vgl.material)) {
    return new vgl.material();
  }
  vgl.graphicsObject.call(this);
  var m_this = this,
    m_shaderProgram = new vgl.shaderProgram(),
    m_binNumber = 100,
    m_textureAttributes = {},
    m_attributes = {};

  /**
   * Return bin number for the material.
   *
   * @default
   * @returns {number}
   */
  this.binNumber = function () {
    return m_binNumber;
  };

  /**
   * Set bin number for the material.
   *
   * @param {number} binNo
   */
  this.setBinNumber = function (binNo) {
    m_binNumber = binNo;
    m_this.modified();
  };

  /**
   * Check if incoming attribute already exists in the material.
   *
   * @param {vgl.materialAttribute} attr
   * @returns {boolean}
   */
  this.exists = function (attr) {
    if (attr.type() === vgl.materialAttributeType.Texture) {
      return m_textureAttributes.hasOwnProperty(attr.textureUnit());
    }
    return m_attributes.hasOwnProperty(attr.type());
  };

  /**
   * Add a new attribute to the material.
   *
   * @param {vgl.materialAttribute} attr
   * @returns {boolean}
   */
  this.addAttribute = function (attr) {
    if (m_this.exists(attr)) {
      return false;
    }
    if (attr.type() === vgl.materialAttributeType.Texture) {
      // TODO Currently we don't check if we are replacing or not.
      // It would be nice to have a flag for it.
      m_textureAttributes[attr.textureUnit()] = attr;
      m_this.modified();
      return true;
    }

    // Shader is a very special attribute
    if (attr.type() === vgl.materialAttributeType.ShaderProgram) {
      m_shaderProgram = attr;
    }
    m_attributes[attr.type()] = attr;
    m_this.modified();
    return true;
  };

  /**
   * Return shader program used by the material.
   *
   * @returns {vgl.shaderProgram}
   */
  this.shaderProgram = function () {
    return m_shaderProgram;
  };

  /**
   * Remove any resources acquired before deletion.
   *
   * @param {vgl.renderState} renderState
   */
  this._cleanup = function (renderState) {
    for (var key in m_attributes) {
      if (m_attributes.hasOwnProperty(key)) {
        m_attributes[key]._cleanup(renderState);
      }
    }
    for (key in m_textureAttributes) {
      if (m_textureAttributes.hasOwnProperty(key)) {
        m_textureAttributes[key]._cleanup(renderState);
      }
    }
    m_shaderProgram._cleanup(renderState);
    m_this.modified();
  };

  /**
   * Bind and activate material states.
   *
   * @param {vgl.renderState} renderState
   */
  this.bind = function (renderState) {
    var key = null;
    m_shaderProgram.bind(renderState);
    for (key in m_attributes) {
      if (m_attributes.hasOwnProperty(key)) {
        if (m_attributes[key] !== m_shaderProgram) {
          m_attributes[key].bind(renderState);
        }
      }
    }
    for (key in m_textureAttributes) {
      if (m_textureAttributes.hasOwnProperty(key)) {
        m_textureAttributes[key].bind(renderState);
      }
    }
  };

  /**
   * Undo-bind and de-activate material states.
   *
   * @param {vgl.renderState} renderState
   */
  this.undoBind = function (renderState) {
    var key = null;
    for (key in m_attributes) {
      if (m_attributes.hasOwnProperty(key)) {
        m_attributes[key].undoBind(renderState);
      }
    }
    for (key in m_textureAttributes) {
      if (m_textureAttributes.hasOwnProperty(key)) {
        m_textureAttributes[key].undoBind(renderState);
      }
    }
  };

  /**
   * Bind vertex data.
   *
   * @param {vgl.renderState} renderState
   * @param {string} key
   */
  this.bindVertexData = function (renderState, key) {
    var i = null;
    for (i in m_attributes) {
      if (m_attributes.hasOwnProperty(i)) {
        m_attributes[i].bindVertexData(renderState, key);
      }
    }
  };

  /**
   * Undo bind vertex data.
   *
   * @param {vgl.renderState} renderState
   * @param {string} key
   */
  this.undoBindVertexData = function (renderState, key) {
    var i = null;
    for (i in m_attributes) {
      if (m_attributes.hasOwnProperty(i)) {
        m_attributes[i].undoBindVertexData(renderState, key);
      }
    }
  };
  return m_this;
};
vgl.material.RenderBin = {
  Base: 0,
  Default: 100,
  Opaque: 100,
  Transparent: 1000,
  Overlay: 10000
};
inherit(vgl.material, vgl.graphicsObject);

/***/ }),

/***/ 1232:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
vgl.materialAttributeType = {
  Undefined: 0x0,
  ShaderProgram: 0x1,
  Texture: 0x2,
  Blend: 0x3,
  Depth: 0x4
};

/**
 * Create a new instance of class materialAttribute.
 *
 * @class
 * @alias vgl.materialAttribute
 * @param {number} type
 * @returns {vgl.materialAttribute}
 */
vgl.materialAttribute = function (type) {
  'use strict';

  if (!(this instanceof vgl.materialAttribute)) {
    return new vgl.materialAttribute(type);
  }
  vgl.graphicsObject.call(this);

  /** @private */
  var m_this = this,
    m_type = type,
    m_enabled = true;

  /**
   * Return type of the material attribute.
   *
   * @returns {number}
   */
  this.type = function () {
    return m_type;
  };

  /**
   * Return if material attribute is enabled or not.
   *
   * @returns {boolean}
   */
  this.enabled = function () {
    return m_enabled;
  };

  /**
   * Bind and activate vertex specific data.
   *
   * @param {vgl.renderState} renderState
   * @param {string} key
   * @returns {boolean}
   */
  this.bindVertexData = function (renderState, key) {
    return false;
  };

  /**
   * Undo bind and deactivate vertex specific data.
   *
   * @param {vgl.renderState} renderState
   * @param {string} key
   * @returns {boolean}
   */
  this.undoBindVertexData = function (renderState, key) {
    return false;
  };
  return m_this;
};
inherit(vgl.materialAttribute, vgl.graphicsObject);

/***/ }),

/***/ 2971:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class node.
 *
 * @class
 * @alias vgl.node
 * @returns {vgl.node}
 */
vgl.node = function () {
  'use strict';

  if (!(this instanceof vgl.node)) {
    return new vgl.node();
  }
  vgl.boundingObject.call(this);
  var m_parent = null,
    m_material = null,
    m_visible = true;

  /**
   * Return active material used by the node.
   *
   * @returns {vgl.material}
   */
  this.material = function () {
    return m_material;
  };

  /**
   * Set material to be used the node.
   *
   * @param {vgl.material} material
   * @returns {boolean}
   */
  this.setMaterial = function (material) {
    if (material !== m_material) {
      m_material = material;
      this.modified();
      return true;
    }
    return false;
  };

  /**
   * Check if the node is visible or node.
   *
   * @returns {boolean}
   */
  this.visible = function () {
    return m_visible;
  };

  /**
   * Turn ON/OFF visibility of the node.
   *
   * @param {boolean} flag
   * @returns {boolean}
   */
  this.setVisible = function (flag) {
    if (flag !== m_visible) {
      m_visible = flag;
      this.modified();
      return true;
    }
    return false;
  };

  /**
   * Return current parent of the node.
   *
   * @returns {vgl.node}
   */
  this.parent = function () {
    return m_parent;
  };

  /**
   * Set parent of the node.
   *
   * @param {vgl.node} parent
   * @returns {boolean}
   */
  this.setParent = function (parent) {
    if (parent !== m_parent) {
      if (m_parent !== null) {
        m_parent.removeChild(this);
      }
      m_parent = parent;
      this.modified();
      return true;
    }
    return false;
  };

  /**
   * Mark that the bounds are modified.
   */
  this.boundsModified = function () {
    this.boundsDirtyTimestamp().modified();
    if (m_parent !== null) {
      m_parent.boundsModified();
    }
  };
  return this;
};
inherit(vgl.node, vgl.boundingObject);

/***/ }),

/***/ 9156:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class object.
 *
 * @class
 * @alias vgl.object
 * @returns {vgl.object}
 */
vgl.object = function () {
  'use strict';

  if (!(this instanceof vgl.object)) {
    return new vgl.object();
  }

  /** @private */
  var m_modifiedTime = timestamp();
  m_modifiedTime.modified();

  /**
   * Mark the object modified.
   */
  this.modified = function () {
    m_modifiedTime.modified();
  };

  /**
   * Return modified time of the object.
   *
   * @returns {number}
   */
  this.getMTime = function () {
    return m_modifiedTime.getMTime();
  };
  return this;
};

/***/ }),

/***/ 5763:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class renderWindow.
 *
 * @class
 * @alias vgl.renderWindow
 * @param {HTMLElement} canvas
 * @returns {vgl.renderWindow}
 */
vgl.renderWindow = function (canvas) {
  'use strict';

  if (!(this instanceof vgl.renderWindow)) {
    return new vgl.renderWindow(canvas);
  }
  vgl.graphicsObject.call(this);
  var m_this = this,
    m_x = 0,
    m_y = 0,
    m_width = 400,
    m_height = 400,
    m_canvas = canvas,
    m_activeRender = null,
    m_renderers = [],
    m_context = null;

  /**
   * Get size of the render window.
   *
   * @returns {number[]}
   */
  this.windowSize = function () {
    return [m_width, m_height];
  };

  /**
   * Get window position (top left coordinates).
   *
   * @returns {number[]}
   */
  this.windowPosition = function () {
    return [m_x, m_y];
  };

  /**
   * Return all renderers contained in the render window.
   *
   * @returns {vgl.renderer[]}
   */
  this.renderers = function () {
    return m_renderers;
  };

  /**
   * Get active renderer of the the render window.
   *
   * @returns {vgl.renderer}
   */
  this.activeRenderer = function () {
    return m_activeRender;
  };

  /**
   * Add renderer to the render window.
   *
   * @param {vgl.renderer} ren
   * @returns {boolean}
   */
  this.addRenderer = function (ren) {
    if (m_this.hasRenderer(ren) === false) {
      m_renderers.push(ren);
      ren.setRenderWindow(m_this);
      if (m_activeRender === null) {
        m_activeRender = ren;
      }
      if (ren.layer() !== 0) {
        ren.camera().setClearMask(vgl.GL.DepthBufferBit);
      }
      m_this.modified();
      return true;
    }
    return false;
  };

  /**
   * Check if the renderer exists.
   *
   * @param {vgl.renderer} ren
   * @returns {boolean}
   */
  this.hasRenderer = function (ren) {
    var i;
    for (i = 0; i < m_renderers.length; i += 1) {
      if (ren === m_renderers[i]) {
        return true;
      }
    }
    return false;
  };

  /**
   * Resize and reposition the window.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  this.positionAndResize = function (x, y, width, height) {
    m_x = x;
    m_y = y;
    m_width = width;
    m_height = height;
    var i;
    for (i = 0; i < m_renderers.length; i += 1) {
      m_renderers[i].positionAndResize(m_x, m_y, m_width, m_height);
    }
    m_this.modified();
  };

  /**
   * Create the window.
   *
   * @param {vgl.renderState} renderState
   * @returns {boolean}
   */
  this._setup = function (renderState) {
    m_context = null;
    try {
      // Try to grab the standard context. If it fails, fallback to
      // experimental.
      m_context = m_canvas.getContext('webgl') || m_canvas.getContext('experimental-webgl');

      // Set width and height of renderers if not set already
      var i;
      for (i = 0; i < m_renderers.length; i += 1) {
        if (m_renderers[i].width() > m_width || m_renderers[i].width() === 0 || m_renderers[i].height() > m_height || m_renderers[i].height() === 0) {
          m_renderers[i].resize(m_x, m_y, m_width, m_height);
        }
      }
      return true;
    } catch (e) {}

    // If we don't have a GL context, give up now
    if (!m_context) {
      console.warn('[ERROR] Unable to initialize WebGL. Your browser may not support it.'); // eslint-disable-line no-console
    }
    return false;
  };

  /**
   * Return current GL context.
   *
   * @returns {WebGLRenderingContext}
   */
  this.context = function () {
    return m_context;
  };

  /**
   * Delete this window and release any graphics resources.
   *
   * @param {vgl.renderState} renderState
   */
  this._cleanup = function (renderState) {
    var i;
    for (i = 0; i < m_renderers.length; i += 1) {
      m_renderers[i]._cleanup(renderState);
    }
    vgl.clearCachedShaders(renderState ? renderState.m_context : null);
    m_this.modified();
  };

  /**
   * Render the scene.
   */
  this.render = function () {
    var i;
    m_renderers.sort(function (a, b) {
      return a.layer() - b.layer();
    });
    for (i = 0; i < m_renderers.length; i += 1) {
      m_renderers[i].render();
    }
  };
  return m_this;
};
inherit(vgl.renderWindow, vgl.graphicsObject);

/***/ }),

/***/ 5796:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var mat4 = __webpack_require__(3503);

/**
 * Create a new instance of class renderState.
 *
 * @class
 * @alias vgl.renderState
 */
vgl.renderState = function () {
  'use strict';

  this.m_context = null;
  this.m_modelViewMatrix = mat4.create();
  this.m_normalMatrix = mat4.create();
  this.m_projectionMatrix = null;
  this.m_material = null;
  this.m_mapper = null;
};

/**
 * Create a new instance of class renderer.
 *
 * @class
 * @alias vgl.renderer
 * @extends vgl.graphicsObject
 * @param {object} arg
 * @returns {vgl.renderer}
 */
vgl.renderer = function (arg) {
  'use strict';

  if (!(this instanceof vgl.renderer)) {
    return new vgl.renderer(arg);
  }
  vgl.graphicsObject.call(this);
  arg = arg || {};

  /** @private */
  var m_this = this;
  m_this.m_renderWindow = null;
  m_this.m_contextChanged = false;
  m_this.m_sceneRoot = new vgl.groupNode();
  m_this.m_camera = new vgl.camera(arg);
  m_this.m_nearClippingPlaneTolerance = null;
  m_this.m_x = 0;
  m_this.m_y = 0;
  m_this.m_width = 0;
  m_this.m_height = 0;
  m_this.m_resizable = true;
  m_this.m_resetScene = true;
  m_this.m_layer = 0;
  m_this.m_renderPasses = null;
  m_this.m_resetClippingRange = true;
  m_this.m_depthBits = null;
  m_this.m_camera.addChild(m_this.m_sceneRoot);

  /**
   * Get width of the renderer.
   *
   * @returns {number}
   */
  this.width = function () {
    return m_this.m_width;
  };

  /**
   * Get height of the renderer.
   *
   * @returns {number}
   */
  this.height = function () {
    return m_this.m_height;
  };

  /**
   * Get layer this renderer is associated with.
   *
   * @returns {number}
   */
  this.layer = function () {
    return m_this.m_layer;
  };

  /**
   * Set the layer this renderer is associated with.
   *
   * @param {number} layerNo
   */
  this.setLayer = function (layerNo) {
    m_this.m_layer = layerNo;
    m_this.modified();
  };

  /**
   * Return render window (owner) of the renderer.
   *
   * @returns {vgl.renderWindow}
   */
  this.renderWindow = function () {
    return m_this.m_renderWindow;
  };

  /**
   * Set render window for the renderer.
   *
   * @param {vgl.renderWindow} renWin
   */
  this.setRenderWindow = function (renWin) {
    if (m_this.m_renderWindow !== renWin) {
      if (m_this.m_renderWindow) {
        m_this.m_renderWindow.removeRenderer(this);
      }
      m_this.m_renderWindow = renWin;
      m_this.m_contextChanged = true;
      m_this.modified();
    }
  };

  /**
   * Get main camera of the renderer.
   *
   * @returns {vgl.camera}
   */
  this.camera = function () {
    return m_this.m_camera;
  };

  /**
   * Render the scene.
   */
  this.render = function () {
    var i,
      renSt,
      children,
      actor = null,
      sortedActors = [],
      mvMatrixInv = mat4.create(),
      clearColor = null;
    renSt = new vgl.renderState();
    renSt.m_renderer = m_this;
    renSt.m_context = m_this.renderWindow().context();
    if (!m_this.m_depthBits || m_this.m_contextChanged) {
      m_this.m_depthBits = renSt.m_context.getParameter(vgl.GL.DEPTH_BITS);
    }
    renSt.m_contextChanged = m_this.m_contextChanged;
    if (m_this.m_renderPasses) {
      for (i = 0; i < m_this.m_renderPasses.length; i += 1) {
        if (m_this.m_renderPasses[i].render(renSt)) {
          // Stop the rendering if render pass returns false
          m_this.m_renderPasses[i].remove(renSt);
          return;
        }
        m_this.m_renderPasses[i].remove(renSt);
      }
    }
    renSt.m_context.enable(vgl.GL.DEPTH_TEST);
    renSt.m_context.depthFunc(vgl.GL.LEQUAL);
    if (m_this.m_camera.clearMask() & vgl.GL.COLOR_BUFFER_BIT) {
      clearColor = m_this.m_camera.clearColor();
      renSt.m_context.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    }
    if (m_this.m_camera.clearMask() & vgl.GL.DEPTH_BUFFER_BIT) {
      renSt.m_context.clearDepth(m_this.m_camera.clearDepth());
    }
    renSt.m_context.clear(m_this.m_camera.clearMask());

    // Set the viewport for this renderer
    renSt.m_context.viewport(m_this.m_x, m_this.m_y, m_this.m_width, m_this.m_height);
    children = m_this.m_sceneRoot.children();
    if (children.length > 0 && m_this.m_resetScene) {
      m_this.m_resetScene = false;
    }
    for (i = 0; i < children.length; i += 1) {
      actor = children[i];

      // Compute the bounds even if the actor is not visible
      actor.computeBounds();

      // If bin number is < 0, then don't even bother
      // rendering the data
      if (actor.visible() && actor.material().binNumber() >= 0) {
        sortedActors.push([actor.material().binNumber(), actor]);
      }
    }

    // Now perform sorting
    sortedActors.sort(function (a, b) {
      return a[0] - b[0];
    });
    for (i = 0; i < sortedActors.length; i += 1) {
      actor = sortedActors[i][1];
      if (actor.referenceFrame() === vgl.boundingObject.ReferenceFrame.Relative) {
        var view = m_this.m_camera.viewMatrix();
        /* If the view matrix is a plain array, keep it as such.  This is
         * intended to preserve precision, and will only be the case if the
         * view matrix was created by deliberately setting it as an array. */
        if (view instanceof Array) {
          renSt.m_modelViewMatrix = new Array(16);
        }
        mat4.multiply(renSt.m_modelViewMatrix, view, actor.matrix());
        renSt.m_projectionMatrix = m_this.m_camera.projectionMatrix();
        renSt.m_modelViewAlignment = m_this.m_camera.viewAlignment();
      } else {
        renSt.m_modelViewMatrix = actor.matrix();
        renSt.m_modelViewAlignment = null;
        renSt.m_projectionMatrix = mat4.create();
        mat4.ortho(renSt.m_projectionMatrix, 0, m_this.m_width, 0, m_this.m_height, -1, 1);
      }
      mat4.invert(mvMatrixInv, renSt.m_modelViewMatrix);
      mat4.transpose(renSt.m_normalMatrix, mvMatrixInv);
      renSt.m_material = actor.material();
      renSt.m_mapper = actor.mapper();

      // TODO Fix this shortcut
      renSt.m_material.bind(renSt);
      renSt.m_mapper.render(renSt);
      renSt.m_material.undoBind(renSt);
    }
    renSt.m_context.finish();
    m_this.m_contextChanged = false;
    m_this.m_lastRenderState = renSt;
  };

  /**
   * Resize viewport given a width and height.
   *
   * @param {number} width
   * @param {number} height
   */
  this.resize = function (width, height) {
    if (!width || !height) {
      return;
    }
    // @note: where do m_this.m_x and m_this.m_y come from?
    m_this.positionAndResize(m_this.m_x, m_this.m_y, width, height);
  };

  /**
   * Resize viewport given a position, width and height.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} width
   * @param {number} height
   */
  this.positionAndResize = function (x, y, width, height) {
    var i;

    // TODO move this code to camera
    if (x < 0 || y < 0 || width <= 0 || height <= 0) {
      console.log('[error] Invalid position and resize values', x, y, width, height); // eslint-disable-line no-console
      return;
    }

    //If we're allowing this renderer to resize ...
    if (m_this.m_resizable) {
      m_this.m_width = width;
      m_this.m_height = height;
      m_this.m_camera.setViewAspect(width / height);
      m_this.m_camera.setParallelExtents({
        width: width,
        height: height
      });
      m_this.modified();
    }
    if (m_this.m_renderPasses) {
      for (i = 0; i < m_this.m_renderPasses.length; i += 1) {
        m_this.m_renderPasses[i].resize(width, height);
        m_this.m_renderPasses[i].renderer().positionAndResize(x, y, width, height);
      }
    }
  };

  /**
   * Add new actor to the collection.
   *
   * @param {vgl.actor} actor
   * @returns {boolean}
   */
  this.addActor = function (actor) {
    if (actor instanceof vgl.actor) {
      m_this.m_sceneRoot.addChild(actor);
      m_this.modified();
      return true;
    }
    return false;
  };

  /**
   * Return true if this renderer has this actor attached, false otherwise.
   *
   * @param {vgl.actor} actor
   * @returns {boolean}
   */
  this.hasActor = function (actor) {
    return m_this.m_sceneRoot.hasChild(actor);
  };

  /**
   * Remove the actor from the collection.
   *
   * @param {vgl.actor} actor
   * @returns {boolean}
   */
  this.removeActor = function (actor) {
    if (m_this.m_sceneRoot.children().indexOf(actor) !== -1) {
      /* When we remove an actor, free the VBOs of the mapper and mark the
       * mapper as modified; it will reallocate VBOs as necessary. */
      if (m_this.m_lastRenderState) {
        if (actor.mapper()) {
          actor.mapper()._cleanup(m_this.m_lastRenderState);
        }
        if (actor.material()) {
          actor.material()._cleanup(m_this.m_lastRenderState);
        }
      }
      actor.modified();
      m_this.m_sceneRoot.removeChild(actor);
      m_this.modified();
      return true;
    }
    return false;
  };

  /**
   * If true the scene will be reset, otherwise the scene will not be
   * automatically reset.
   *
   * @param {boolean} reset
   */
  this.setResetScene = function (reset) {
    if (m_this.m_resetScene !== reset) {
      m_this.m_resetScene = reset;
      m_this.modified();
    }
  };

  /**
   * Cleanup.
   *
   * @param {vgl.renderState} renderState
   */
  this._cleanup = function (renderState) {
    var children = m_this.m_sceneRoot.children();
    for (var i = 0; i < children.length; i += 1) {
      var actor = children[i];
      actor.material()._cleanup(renderState);
      actor.mapper()._cleanup(renderState);
    }
    m_this.m_sceneRoot.removeChildren();
    m_this.modified();
  };
  return m_this;
};
inherit(vgl.renderer, vgl.graphicsObject);

/***/ }),

/***/ 5794:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class shader.
 *
 * @class
 * @alias vgl.shader
 * @extends vgl.object
 * @param {number} type The GL shader type.
 * @returns {vgl.shader}
 */
vgl.shader = function (type) {
  'use strict';

  if (!(this instanceof vgl.shader)) {
    return new vgl.shader(type);
  }
  vgl.object.call(this);
  var m_shaderContexts = [],
    m_shaderType = type,
    m_shaderSource = '';

  /**
   * A shader can be associated with multiple contexts.  Each context needs to
   * be compiled and attached separately.  These are tracked in the
   * m_shaderContexts array.
   *
   * @param {vgl.renderState} renderState a renderState that includes a
   *    m_context value.
   * @returns {object} an object with context, compileTimestamp, and, if
   *    compiled, a shaderHandle entry.
   */
  this._getContextEntry = function (renderState) {
    var context = renderState.m_context,
      i,
      entry;
    for (i = 0; i < m_shaderContexts.length; i += 1) {
      if (m_shaderContexts[i].context === context) {
        return m_shaderContexts[i];
      }
    }
    entry = {
      context: context,
      compileTimestamp: timestamp()
    };
    m_shaderContexts.push(entry);
    return entry;
  };

  /**
   * Remove the context from the list of tracked contexts.  This allows the
   * associated shader handle to be GCed.  Does nothing if the context is not
   * in the list of tracked contexts.
   *
   * @param {vgl.renderState} renderState A renderState that includes a
   *    m_context value.
   */
  this.removeContext = function (renderState) {
    var context = renderState.m_context,
      i;
    for (i = 0; i < m_shaderContexts.length; i += 1) {
      if (m_shaderContexts[i].context === context) {
        m_shaderContexts.splice(i, 1);
        return;
      }
    }
  };

  /**
   * Get shader handle.
   *
   * @param {vgl.renderState} renderState
   * @returns {number} GL shader handle
   */
  this.shaderHandle = function (renderState) {
    var entry = this._getContextEntry(renderState);
    return entry.shaderHandle;
  };

  /**
   * Set shader source.
   *
   * @param {string} source
   */
  this.setShaderSource = function (source) {
    m_shaderSource = source;
    this.modified();
  };

  /**
   * Compile the shader.
   *
   * @param {vgl.renderState} renderState
   * @returns {number} GL shader handle.
   */
  this.compile = function (renderState) {
    var entry = this._getContextEntry(renderState);
    if (this.getMTime() < entry.compileTimestamp.getMTime()) {
      return entry.shaderHandle;
    }
    renderState.m_context.deleteShader(entry.shaderHandle);
    entry.shaderHandle = renderState.m_context.createShader(m_shaderType);
    renderState.m_context.shaderSource(entry.shaderHandle, m_shaderSource);
    renderState.m_context.compileShader(entry.shaderHandle);

    // See if it compiled successfully
    if (!renderState.m_context.getShaderParameter(entry.shaderHandle, vgl.GL.COMPILE_STATUS)) {
      console.log('[ERROR] An error occurred compiling the shaders: ' +
      // eslint-disable-line no-console
      renderState.m_context.getShaderInfoLog(entry.shaderHandle));
      console.log(m_shaderSource); // eslint-disable-line no-console
      renderState.m_context.deleteShader(entry.shaderHandle);
      return null;
    }
    entry.compileTimestamp.modified();
    return entry.shaderHandle;
  };

  /**
   * Attach shader to the program.
   *
   * @param {vgl.renderState} renderState
   * @param {number} programHandle GL shader handler.
   */
  this.attachShader = function (renderState, programHandle) {
    renderState.m_context.attachShader(programHandle, this.shaderHandle(renderState));
  };
};
inherit(vgl.shader, vgl.object);

/* We can use the same shader multiple times if it is identical.  This caches
 * the last N shaders and will reuse them when possible.  The cache keeps the
 * most recently requested shader at the front.  If you are doing anything more
 * to a shader then creating it and setting its source once, do not use this
 * cache.
 */
(function () {
  'use strict';

  var m_shaderCache = [],
    m_shaderCacheMaxSize = 10;

  /**
   * Get a shader from the cache.  Create a new shader if necessary using a
   * specific source.
   *
   * @param {number} type One of vgl.GL.*_SHADER
   * @param {WebGLRenderingContext} context The GL context for the shader.
   * @param {string} source The source code of the shader.
   * @returns {number} GL shader handle
   */
  vgl.getCachedShader = function (type, context, source) {
    for (var i = 0; i < m_shaderCache.length; i += 1) {
      if (m_shaderCache[i].type === type && m_shaderCache[i].context === context && m_shaderCache[i].source === source) {
        if (i) {
          m_shaderCache.splice(0, 0, m_shaderCache.splice(i, 1)[0]);
        }
        return m_shaderCache[0].shader;
      }
    }
    var shader = new vgl.shader(type);
    shader.setShaderSource(source);
    m_shaderCache.unshift({
      type: type,
      context: context,
      source: source,
      shader: shader
    });
    if (m_shaderCache.length >= m_shaderCacheMaxSize) {
      m_shaderCache.splice(m_shaderCacheMaxSize, m_shaderCache.length - m_shaderCacheMaxSize);
    }
    return shader;
  };

  /**
   * Clear the shader cache.
   *
   * @param {WebGLRenderingContext} context The GL context to clear, or null
   *    for clear all.
   */
  vgl.clearCachedShaders = function (context) {
    for (var i = m_shaderCache.length - 1; i >= 0; i -= 1) {
      if (context === null || context === undefined || m_shaderCache[i].context === context) {
        m_shaderCache.splice(i, 1);
      }
    }
  };
})();

/***/ }),

/***/ 796:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class shaderProgram.
 *
 * @class
 * @alias vgl.shaderProgram
 * @returns {vgl.shaderProgram}
 */
vgl.shaderProgram = function () {
  'use strict';

  if (!(this instanceof vgl.shaderProgram)) {
    return new vgl.shaderProgram();
  }
  vgl.materialAttribute.call(this, vgl.materialAttributeType.ShaderProgram);
  var m_this = this,
    m_programHandle = 0,
    m_compileTimestamp = timestamp(),
    m_bindTimestamp = timestamp(),
    m_shaders = [],
    m_uniforms = [],
    m_vertexAttributes = {},
    m_uniformNameToLocation = {},
    m_vertexAttributeNameToLocation = {};

  /**
   * Query uniform location in the program.
   *
   * @param {vgl.renderState} renderState
   * @param {string} name
   * @returns {number}
   */
  this.queryUniformLocation = function (renderState, name) {
    return renderState.m_context.getUniformLocation(m_programHandle, name);
  };

  /**
   * Query attribute location in the program.
   *
   * @param {vgl.renderState} renderState
   * @param {string} name
   * @returns {number}
   */
  this.queryAttributeLocation = function (renderState, name) {
    return renderState.m_context.getAttribLocation(m_programHandle, name);
  };

  /**
   * Add a new shader to the program.
   *
   * @param {string} shader
   * @returns {boolean}
   */
  this.addShader = function (shader) {
    if (m_shaders.indexOf(shader) > -1) {
      return false;
    }
    var i;
    for (i = m_shaders.length - 2; i >= 0; i -= 1) {
      if (m_shaders[i].shaderType() === shader.shaderType()) {
        m_shaders.splice(i, 1);
      }
    }
    m_shaders.push(shader);
    m_this.modified();
    return true;
  };

  /**
   * Add a new uniform to the program.
   *
   * @param {vgl.uniform} uniform
   * @returns {boolean}
   */
  this.addUniform = function (uniform) {
    if (m_uniforms.indexOf(uniform) > -1) {
      return false;
    }
    m_uniforms.push(uniform);
    m_this.modified();
    return true;
  };

  /**
   * Add a new vertex attribute to the program.
   *
   * @param {vgl.vertexAttribute} attr
   * @param {string} key
   */
  this.addVertexAttribute = function (attr, key) {
    m_vertexAttributes[key] = attr;
    m_this.modified();
  };

  /**
   * Get uniform location.
   *
   * This method does not perform any query into the program but relies on
   * the fact that it depends on a call to queryUniformLocation earlier.
   *
   * @param {string} name
   * @returns {number}
   */
  this.uniformLocation = function (name) {
    return m_uniformNameToLocation[name];
  };

  /**
   * Get attribute location.
   *
   * This method does not perform any query into the program but relies on the
   * fact that it depends on a call to queryUniformLocation earlier.
   *
   * @param {string} name
   * @returns {number}
   */
  this.attributeLocation = function (name) {
    return m_vertexAttributeNameToLocation[name];
  };

  /**
   * Get uniform object using name as the key.
   *
   * @param {string} name
   * @returns {vgl.uniform}
   */
  this.uniform = function (name) {
    var i;
    for (i = 0; i < m_uniforms.length; i += 1) {
      if (m_uniforms[i].name() === name) {
        return m_uniforms[i];
      }
    }
    return null;
  };

  /**
   * Update all uniforms.
   *
   * This method should not be used directly unless required.
   *
   * @param {vgl.renderState} renderState
   */
  this.updateUniforms = function (renderState) {
    var i;
    for (i = 0; i < m_uniforms.length; i += 1) {
      m_uniforms[i].callGL(renderState, m_uniformNameToLocation[m_uniforms[i].name()]);
    }
  };

  /**
   * Link shader program.
   *
   * @param {vgl.renderState} renderState
   * @returns {boolean}
   */
  this.link = function (renderState) {
    renderState.m_context.linkProgram(m_programHandle);

    // If creating the shader program failed, alert
    if (!renderState.m_context.getProgramParameter(m_programHandle, vgl.GL.LINK_STATUS)) {
      console.log('[ERROR] Unable to initialize the shader program.'); // eslint-disable-line no-console
      return false;
    }
    return true;
  };

  /**
   * Use the shader program.
   *
   * @param {vgl.renderState} renderState
   */
  this.use = function (renderState) {
    renderState.m_context.useProgram(m_programHandle);
  };

  /**
   * Perform any initialization required.
   *
   * @param {vgl.renderState} renderState
   */
  this._setup = function (renderState) {
    if (m_programHandle === 0) {
      m_programHandle = renderState.m_context.createProgram();
    }
  };

  /**
   * Perform any clean up required when the program gets deleted.
   *
   * @param {vgl.renderState} renderState
   */
  this._cleanup = function (renderState) {
    m_this.deleteVertexAndFragment(renderState);
    m_this.deleteProgram(renderState);
    m_this.modified();
  };

  /**
   * Delete the shader program.
   *
   * @param {vgl.renderState} renderState
   */
  this.deleteProgram = function (renderState) {
    if (m_programHandle) {
      renderState.m_context.deleteProgram(m_programHandle);
    }
    m_programHandle = 0;
  };

  /**
   * Delete vertex and fragment shaders.
   *
   * @param {vgl.renderState} renderState
   */
  this.deleteVertexAndFragment = function (renderState) {
    var i;
    for (i = 0; i < m_shaders.length; i += 1) {
      if (m_shaders[i].shaderHandle(renderState)) {
        renderState.m_context.detachShader(m_programHandle, m_shaders[i].shaderHandle(renderState));
      }
      renderState.m_context.deleteShader(m_shaders[i].shaderHandle(renderState));
      m_shaders[i].removeContext(renderState);
    }
  };

  /**
   * Compile and link a shader.
   *
   * @param {vgl.renderState} renderState
   */
  this.compileAndLink = function (renderState) {
    var i;
    if (m_compileTimestamp.getMTime() >= this.getMTime()) {
      return;
    }
    m_this._setup(renderState);

    // Compile shaders
    for (i = 0; i < m_shaders.length; i += 1) {
      m_shaders[i].compile(renderState);
      m_shaders[i].attachShader(renderState, m_programHandle);
    }
    m_this.bindAttributes(renderState);

    // link program
    if (!m_this.link(renderState)) {
      console.log('[ERROR] Failed to link Program'); // eslint-disable-line no-console
      m_this._cleanup(renderState);
    }
    m_compileTimestamp.modified();
  };

  /**
   * Bind the program with its shaders.
   *
   * @param {vgl.renderState} renderState
   */
  this.bind = function (renderState) {
    var i = 0;
    if (m_bindTimestamp.getMTime() < m_this.getMTime()) {
      // Compile shaders
      m_this.compileAndLink(renderState);
      m_this.use(renderState);
      m_this.bindUniforms(renderState);
      m_bindTimestamp.modified();
    } else {
      m_this.use(renderState);
    }

    // Call update callback.
    for (i = 0; i < m_uniforms.length; i += 1) {
      m_uniforms[i].update(renderState, m_this);
    }

    // Now update values to GL.
    m_this.updateUniforms(renderState);
  };

  /**
   * Undo binding of the shader program.
   *
   * @param {vgl.renderState} renderState
   */
  this.undoBind = function (renderState) {
    // REF https://www.khronos.org/opengles/sdk/docs/man/xhtml/glUseProgram.xml
    // If program is 0, then the current rendering state refers to an invalid
    // program object, and the results of vertex and fragment shader execution
    // due to any glDrawArrays or glDrawElements commands are undefined
    renderState.m_context.useProgram(null);
  };

  /**
   * Bind vertex data.
   *
   * @param {vgl.renderState} renderState
   * @param {string} key
   */
  this.bindVertexData = function (renderState, key) {
    if (m_vertexAttributes.hasOwnProperty(key)) {
      m_vertexAttributes[key].bindVertexData(renderState, key);
    }
  };

  /**
   * Undo bind vertex data.
   *
   * @param {vgl.renderState} renderState
   * @param {string} key
   */
  this.undoBindVertexData = function (renderState, key) {
    if (m_vertexAttributes.hasOwnProperty(key)) {
      m_vertexAttributes[key].undoBindVertexData(renderState, key);
    }
  };

  /**
   * Bind uniforms.
   *
   * @param {vgl.renderState} renderState
   */
  this.bindUniforms = function (renderState) {
    var i;
    for (i = 0; i < m_uniforms.length; i += 1) {
      m_uniformNameToLocation[m_uniforms[i].name()] = this.queryUniformLocation(renderState, m_uniforms[i].name());
    }
  };

  /**
   * Bind vertex attributes.
   *
   * @param {vgl.renderState} renderState
   */
  this.bindAttributes = function (renderState) {
    var key, name;
    for (key in m_vertexAttributes) {
      if (m_vertexAttributes.hasOwnProperty(key)) {
        name = m_vertexAttributes[key].name();
        renderState.m_context.bindAttribLocation(m_programHandle, key, name);
        m_vertexAttributeNameToLocation[name] = key;
      }
    }
  };
  return m_this;
};
inherit(vgl.shaderProgram, vgl.materialAttribute);

/***/ }),

/***/ 8888:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);

/**
 * Create a new instance of class texture.
 *
 * @class
 * @alias vgl.texture
 * @returns {vgl.texture}
 */
vgl.texture = function () {
  'use strict';

  if (!(this instanceof vgl.texture)) {
    return new vgl.texture();
  }
  vgl.materialAttribute.call(this, vgl.materialAttributeType.Texture);
  this.m_width = 0;
  this.m_height = 0;
  this.m_depth = 0;
  this.m_textureHandle = null;
  this.m_textureUnit = 0;
  this.m_pixelFormat = vgl.GL.RGBA;
  this.m_pixelDataType = vgl.GL.UNSIGNED_BYTE;
  this.m_internalFormat = vgl.GL.RGBA;
  this.m_nearestPixel = false;
  this.m_image = null;
  this.m_texture = null;
  var m_setupTimestamp = timestamp(),
    m_that = this;
  function activateTextureUnit(renderState) {
    if (m_that.m_textureUnit >= 0 && m_that.m_textureUnit < 32) {
      renderState.m_context.activeTexture(vgl.GL.TEXTURE0 + m_that.m_textureUnit);
    } else {
      throw '[error] Texture unit ' + m_that.m_textureUnit + ' is not supported';
    }
  }

  /**
   * Create texture, update parameters, and bind data.
   *
   * @param {vgl.renderState} renderState
   */
  this.setup = function (renderState) {
    // Activate the texture unit first
    activateTextureUnit(renderState);
    renderState.m_context.deleteTexture(this.m_textureHandle);
    this.m_textureHandle = renderState.m_context.createTexture();
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, this.m_textureHandle);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MIN_FILTER, this.m_nearestPixel ? vgl.GL.NEAREST : vgl.GL.LINEAR);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MAG_FILTER, this.m_nearestPixel ? vgl.GL.NEAREST : vgl.GL.LINEAR);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
    if (this.m_image !== null) {
      renderState.m_context.pixelStorei(vgl.GL.UNPACK_ALIGNMENT, 1);
      renderState.m_context.pixelStorei(vgl.GL.UNPACK_FLIP_Y_WEBGL, true);
      this.updateDimensions();
      this.computeInternalFormatUsingImage();

      // FOR now support only 2D textures
      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, this.m_internalFormat, this.m_pixelFormat, this.m_pixelDataType, this.m_image);
    } else if (this.m_texture !== null) {
      // Custom texture data object
      renderState.m_context.pixelStorei(vgl.GL.UNPACK_ALIGNMENT, 1);
      renderState.m_context.pixelStorei(vgl.GL.UNPACK_FLIP_Y_WEBGL, true);
      this.updateDimensions();
      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, this.m_internalFormat, this.m_texture.width, this.m_texture.height, 0, this.m_pixelFormat, this.m_pixelDataType, this.m_texture.data);
    } else {
      renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, this.m_internalFormat, this.m_width, this.m_height, 0, this.m_pixelFormat, this.m_pixelDataType, null);
    }
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
    m_setupTimestamp.modified();
  };

  /**
   * Create texture and if already created use it.
   *
   * @param {vgl.renderState} renderState
   */
  this.bind = function (renderState) {
    // TODO Call setup via material setup
    if (this.getMTime() > m_setupTimestamp.getMTime()) {
      this.setup(renderState);
    }
    activateTextureUnit(renderState);
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, this.m_textureHandle);
  };

  /**
   * Turn off the use of this texture.
   *
   * @param {vgl.renderState} renderState
   */
  this.undoBind = function (renderState) {
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
  };

  /**
   * Get image used by the texture.
   *
   * @returns {vgl.image}
   */
  this.image = function () {
    return this.m_image;
  };

  /**
   * Get image used by the texture.
   *
   * @returns {vgl.image}
   */
  this.texture = function () {
    return this.m_texture;
  };

  /**
   * Set image for the texture.
   *
   * @param {vgl.image} image
   * @returns {boolean}
   */
  this.setImage = function (image) {
    if (image !== null) {
      this.m_image = image;
      this.updateDimensions();
      this.modified();
      return true;
    }
    return false;
  };

  /**
   * Set Raw Texture data using Uint8Array
   *
   * @param {object} texture texture object to load.
   * @param {string?} texture.type One of 'RGBA' | 'Luminance' | 'LuminanceAlpha'.
   * @param {Uint8Array} texture.data Array representing the format based on the type
   * @param {number} texture.width width of the texture
   * @param {number} texture.height height of the texture
   * @returns {boolean}
   */
  this.setTexture = function (texture) {
    if (texture !== null) {
      this.m_texture = texture;
      if (texture.type === 'Luminance') {
        this.m_internalFormat = vgl.GL.LUMINANCE;
        this.m_pixelFormat = vgl.GL.LUMINANCE;
      } else if (texture.type === 'LuminanceAlpha') {
        this.m_internalFormat = vgl.GL.LUMINANCE_ALPHA;
        this.m_pixelFormat = vgl.GL.LUMINANCE_ALPHA;
      } else {
        this.m_internalFormat = vgl.GL.RGBA;
        this.m_pixelFormat = vgl.GL.RGBA;
      }
      this.updateDimensions();
      this.modified();
      return true;
    }
    return false;
  };
  /**
   * Get nearest pixel flag for the texture.
   *
   * @returns {boolean}
   */
  this.nearestPixel = function () {
    return this.m_nearestPixel;
  };

  /**
   * Set nearest pixel flag for the texture.
   *
   * @param {boolean} nearest pixel flag
   * @returns {boolean}
   */
  this.setNearestPixel = function (nearest) {
    nearest = nearest ? true : false;
    if (nearest !== this.m_nearestPixel) {
      this.m_nearestPixel = nearest;
      this.modified();
      return true;
    }
    return false;
  };

  /**
   * Get texture unit of the texture.
   *
   * @returns {number}
   */
  this.textureUnit = function () {
    return this.m_textureUnit;
  };

  /**
   * Set texture unit of the texture. Default is 0.
   *
   * @param {number} unit
   * @returns {boolean}
   */
  this.setTextureUnit = function (unit) {
    if (this.m_textureUnit === unit) {
      return false;
    }
    this.m_textureUnit = unit;
    this.modified();
    return true;
  };

  /**
   * Compute internal format of the texture.
   */
  this.computeInternalFormatUsingImage = function () {
    // Currently image does not define internal format
    // and hence it's pixel format is the only way to query
    // information on how color has been stored.
    // switch (this.m_image.pixelFormat()) {
    // case vgl.GL.RGB:
    // this.m_internalFormat = vgl.GL.RGB;
    // break;
    // case vgl.GL.RGBA:
    // this.m_internalFormat = vgl.GL.RGBA;
    // break;
    // case vgl.GL.Luminance:
    // this.m_internalFormat = vgl.GL.Luminance;
    // break;
    // case vgl.GL.LuminanceAlpha:
    // this.m_internalFormat = vgl.GL.LuminanceAlpha;
    // break;
    // // Do nothing when image pixel format is none or undefined.
    // default:
    // break;
    // };

    // TODO Fix this
    this.m_internalFormat = vgl.GL.RGBA;
    this.m_pixelFormat = vgl.GL.RGBA;
    this.m_pixelDataType = vgl.GL.UNSIGNED_BYTE;
  };

  /**
   * Update texture dimensions.
   */
  this.updateDimensions = function () {
    if (this.m_image !== null) {
      this.m_width = this.m_image.width;
      this.m_height = this.m_image.height;
      this.m_depth = 0; // Only 2D images are supported now
    }
    if (this.m_texture !== null) {
      this.m_width = this.m_texture.width;
      this.m_height = this.m_texture.height;
      this.m_depth = 0; // Only 2D images are supported now
    }
  };

  /**
   * Return the texture handle.
   *
   * @returns {number}
   */
  this.textureHandle = function () {
    return this.m_textureHandle;
  };
  return this;
};
inherit(vgl.texture, vgl.materialAttribute);

/**
 * Create a new instance of class lookupTable.
 *
 * @class
 * @alias vgl.lookupTable
 * @returns {vgl.lookupTable}
 */
vgl.lookupTable = function () {
  'use strict';

  if (!(this instanceof vgl.lookupTable)) {
    return new vgl.lookupTable();
  }
  vgl.texture.call(this);
  var m_setupTimestamp = timestamp();
  this.m_colorTable =
  // paraview bwr colortable
  [0.07514311, 0.468049805, 1, 1, 0.247872569, 0.498782363, 1, 1, 0.339526309, 0.528909511, 1, 1, 0.409505078, 0.558608486, 1, 1, 0.468487184, 0.588057293, 1, 1, 0.520796675, 0.617435078, 1, 1, 0.568724526, 0.646924167, 1, 1, 0.613686735, 0.676713218, 1, 1, 0.656658579, 0.707001303, 1, 1, 0.698372844, 0.738002964, 1, 1, 0.739424025, 0.769954435, 1, 1, 0.780330104, 0.803121429, 1, 1, 0.821573924, 0.837809045, 1, 1, 0.863634967, 0.874374691, 1, 1, 0.907017747, 0.913245283, 1, 1, 0.936129275, 0.938743558, 0.983038586, 1, 0.943467973, 0.943498599, 0.943398095, 1, 0.990146732, 0.928791426, 0.917447482, 1, 1, 0.88332677, 0.861943246, 1, 1, 0.833985467, 0.803839606, 1, 1, 0.788626485, 0.750707739, 1, 1, 0.746206642, 0.701389973, 1, 1, 0.70590052, 0.654994046, 1, 1, 0.667019783, 0.610806959, 1, 1, 0.6289553, 0.568237474, 1, 1, 0.591130233, 0.526775617, 1, 1, 0.552955184, 0.485962266, 1, 1, 0.513776083, 0.445364274, 1, 1, 0.472800903, 0.404551679, 1, 1, 0.428977855, 0.363073592, 1, 1, 0.380759558, 0.320428137, 1, 0.961891484, 0.313155629, 0.265499262, 1, 0.916482116, 0.236630659, 0.209939162, 1].map(function (x) {
    return x * 255;
  });

  /**
   * Create lookup table, initialize parameters, and bind data to it.
   *
   * @param {vgl.renderState} renderState
   */
  this.setup = function (renderState) {
    if (this.textureUnit() === 0) {
      renderState.m_context.activeTexture(vgl.GL.TEXTURE0);
    } else if (this.textureUnit() === 1) {
      renderState.m_context.activeTexture(vgl.GL.TEXTURE1);
    }
    renderState.m_context.deleteTexture(this.m_textureHandle);
    this.m_textureHandle = renderState.m_context.createTexture();
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, this.m_textureHandle);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MIN_FILTER, vgl.GL.LINEAR);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MAG_FILTER, vgl.GL.LINEAR);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
    renderState.m_context.pixelStorei(vgl.GL.UNPACK_ALIGNMENT, 1);
    this.m_width = this.m_colorTable.length / 4;
    this.m_height = 1;
    this.m_depth = 0;
    renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, vgl.GL.RGBA, this.m_width, this.m_height, this.m_depth, vgl.GL.RGBA, vgl.GL.UNSIGNED_BYTE, new Uint8Array(this.m_colorTable));
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
    m_setupTimestamp.modified();
  };

  /**
   * Get color table used by the lookup table.
   *
   * @returns {number[]}
   */
  this.colorTable = function () {
    return this.m_colorTable;
  };

  /**
   * Set color table used by the lookup table.
   *
   * @param {number[]} colors
   * @returns {boolean}
   */
  this.setColorTable = function (colors) {
    if (this.m_colorTable === colors) {
      return false;
    }
    this.m_colorTable = colors;
    this.modified();
    return true;
  };
  return this;
};
inherit(vgl.lookupTable, vgl.texture);

/***/ }),

/***/ 3471:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);
var mat4 = __webpack_require__(3503);

/**
 * Create a new instance of class uniform.
 *
 * @class
 * @alias vgl.uniform
 * @param {number} type The GL type, such as FLOAT or INT.
 * @param {string} name The name of the uniform.
 * @returns {vgl.uniform} OpenGL uniform encapsulation
 */
vgl.uniform = function (type, name) {
  'use strict';

  if (!(this instanceof vgl.uniform)) {
    return new vgl.uniform(type, name);
  }
  this.getTypeNumberOfComponents = function (type) {
    switch (type) {
      case vgl.GL.FLOAT:
      case vgl.GL.INT:
      case vgl.GL.BOOL:
        return 1;
      case vgl.GL.FLOAT_VEC2:
      case vgl.GL.INT_VEC2:
      case vgl.GL.BOOL_VEC2:
        return 2;
      case vgl.GL.FLOAT_VEC3:
      case vgl.GL.INT_VEC3:
      case vgl.GL.BOOL_VEC3:
        return 3;
      case vgl.GL.FLOAT_VEC4:
      case vgl.GL.INT_VEC4:
      case vgl.GL.BOOL_VEC4:
        return 4;
      case vgl.GL.FLOAT_MAT3:
        return 9;
      case vgl.GL.FLOAT_MAT4:
        return 16;
      default:
        return 0;
    }
  };
  var m_type = type,
    m_name = name,
    m_dataArray = new Array(this.getTypeNumberOfComponents(m_type)).fill(0);

  /**
   * Get name of the uniform.
   *
   * @returns {string}
   */
  this.name = function () {
    return m_name;
  };

  /**
   * Set value of the uniform.
   *
   * @param {Array|number} value
   */
  this.set = function (value) {
    var i = 0,
      lendata = m_dataArray.length;
    if (lendata !== 1) {
      for (i = 0; i < lendata; i += 1) {
        m_dataArray[i] = value[i];
      }
    } else {
      m_dataArray[0] = value;
    }
  };

  /**
   * Call GL and pass updated values to the current shader.
   *
   * @param {vgl.renderState} renderState The current render state with the
   *    current context.
   * @param {number} location The context location.
   */
  this.callGL = function (renderState, location) {
    switch (m_type) {
      case vgl.GL.BOOL:
      case vgl.GL.INT:
        renderState.m_context.uniform1iv(location, m_dataArray);
        break;
      case vgl.GL.FLOAT:
        renderState.m_context.uniform1fv(location, m_dataArray);
        break;
      case vgl.GL.BOOL_VEC2:
      case vgl.GL.INT_VEC2:
        renderState.m_context.uniform2iv(location, m_dataArray);
        break;
      case vgl.GL.FLOAT_VEC2:
        renderState.m_context.uniform2fv(location, m_dataArray);
        break;
      case vgl.GL.BOOL_VEC3:
      case vgl.GL.INT_VEC3:
        renderState.m_context.uniform3iv(location, m_dataArray);
        break;
      case vgl.GL.FLOAT_VEC3:
        renderState.m_context.uniform3fv(location, m_dataArray);
        break;
      case vgl.GL.BOOL_VEC4:
      case vgl.GL.INT_VEC4:
        renderState.m_context.uniform4iv(location, m_dataArray);
        break;
      case vgl.GL.FLOAT_VEC4:
        renderState.m_context.uniform4fv(location, m_dataArray);
        break;
      case vgl.GL.FLOAT_MAT3:
        renderState.m_context.uniformMatrix3fv(location, vgl.GL.FALSE, m_dataArray);
        break;
      case vgl.GL.FLOAT_MAT4:
        renderState.m_context.uniformMatrix4fv(location, vgl.GL.FALSE, m_dataArray);
        break;
      default:
        break;
    }
  };

  /**
   * Virtual method to update the uniform.
   *
   * Should be implemented by the derived class.
   *
   * @param {vgl.renderState} renderState
   * @param {vgl.shaderProgram} program
   */
  this.update = function (renderState, program) {
    // Should be implemented by the derived class
  };
  return this;
};

/**
 * Create new instance of class modelViewOriginUniform.
 *
 * @class
 * @alias vgl.modelViewUniform
 * @param {string} name
 * @param {number[]} origin a triplet of floats.
 * @returns {vgl.modelViewUniform}
 */
vgl.modelViewOriginUniform = function (name, origin) {
  'use strict';

  if (!(this instanceof vgl.modelViewOriginUniform)) {
    return new vgl.modelViewOriginUniform(name, origin);
  }
  if (!name) {
    name = 'modelViewMatrix';
  }
  origin = origin || [0, 0, 0];
  var m_origin = [origin[0], origin[1], origin[2] || 0];
  vgl.uniform.call(this, vgl.GL.FLOAT_MAT4, name);
  this.set(mat4.create());

  /**
   * Change the origin used by the uniform view matrix.
   *
   * @param {number[]} origin a triplet of floats.
   */
  this.setOrigin = function (origin) {
    origin = origin || [0, 0, 0];
    m_origin = [origin[0], origin[1], origin[2] || 0];
  };

  /**
   * Update the uniform given a render state and shader program.  This offsets
   * the modelViewMatrix by the origin, and, if the model view should be
   * aligned, aligns it appropriately.  The alignment must be done after the
   * origin offset to maintain precision.
   *
   * @param {vgl.renderState} renderState
   * @param {vgl.shaderProgram} program
   */
  this.update = function (renderState, program) {
    var view = renderState.m_modelViewMatrix;
    if (renderState.m_modelViewAlignment) {
      /* adjust alignment before origin.  Otherwise, a changing origin can
       * affect the rounding choice and result in a 1 pixe jitter. */
      var align = renderState.m_modelViewAlignment;
      /* Don't modify the original matrix.  If we are in an environment where
       * you can't slice an Float32Array, switch to a regular array */
      view = view.slice ? view.slice() : Array.prototype.slice.call(view);
      /* view[12] and view[13] are the x and y offsets.  align.round is the
       * units-per-pixel, and align.dx and .dy are either 0 or half the size of
       * a unit-per-pixel.  The alignment guarantees that the texels are
       * aligned with screen pixels. */
      view[12] = Math.round(view[12] / align.roundx) * align.roundx + align.dx;
      view[13] = Math.round(view[13] / align.roundy) * align.roundy + align.dy;
    }
    view = mat4.translate(mat4.create(), view, m_origin);
    this.set(view);
  };
  return this;
};
inherit(vgl.modelViewOriginUniform, vgl.uniform);

/**
 * Create a new instance of class projectionUniform.
 *
 * @class
 * @alias vgl.projectionUniform
 * @param {string} name
 * @returns {vgl.projectionUniform}
 */
vgl.projectionUniform = function (name) {
  'use strict';

  if (!(this instanceof vgl.projectionUniform)) {
    return new vgl.projectionUniform(name);
  }
  if (!name) {
    name = 'projectionMatrix';
  }
  vgl.uniform.call(this, vgl.GL.FLOAT_MAT4, name);
  this.set(mat4.create());

  /**
   * Update the uniform given a render state and shader program.
   *
   * @param {vgl.renderState} renderState
   * @param {vgl.shaderProgram} program
   */
  this.update = function (renderState, program) {
    this.set(renderState.m_projectionMatrix);
  };
  return this;
};
inherit(vgl.projectionUniform, vgl.uniform);

/**
 * Create a new instance of class floatUniform.
 *
 * @class
 * @alias vgl.floatUniform
 * @param {string} name
 * @param {number} value
 * @returns {vgl.floatUniform}
 */
vgl.floatUniform = function (name, value) {
  'use strict';

  if (!(this instanceof vgl.floatUniform)) {
    return new vgl.floatUniform(name, value);
  }
  if (!name) {
    name = 'floatUniform';
  }
  value = value === undefined ? 1.0 : value;
  vgl.uniform.call(this, vgl.GL.FLOAT, name);
  this.set(value);
};
inherit(vgl.floatUniform, vgl.uniform);

/***/ }),

/***/ 4933:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var vgl = __webpack_require__(698);
vgl.vertexAttributeKeys = {
  Position: 0,
  Normal: 1,
  TextureCoordinate: 2,
  Color: 3,
  Scalar: 4,
  CountAttributeIndex: 5
};
vgl.vertexAttributeKeysIndexed = {
  Zero: 0,
  One: 1,
  Two: 2,
  Three: 3,
  Four: 4,
  Five: 5,
  Six: 6,
  Seven: 7,
  Eight: 8,
  Nine: 9
};

/**
 * Create a new instance of vertexAttribute.
 *
 * @class
 * @alias vgl.vertexAttribute
 * @param {string} name Name of attribute.
 * @returns {vgl.vertexAttribute}
 */
vgl.vertexAttribute = function (name) {
  'use strict';

  if (!(this instanceof vgl.vertexAttribute)) {
    return new vgl.vertexAttribute(name);
  }
  var m_name = name;

  /**
   * Get name of the vertex attribute.
   *
   * @returns {string}
   */
  this.name = function () {
    return m_name;
  };

  /**
   * Bind vertex data to the given render state.
   *
   * @param {vgl.renderState} renderState
   * @param {vgl.vertexAttributeKeys} key
   */
  this.bindVertexData = function (renderState, key) {
    var geometryData = renderState.m_mapper.geometryData(),
      sourceData = geometryData.sourceData(key),
      program = renderState.m_material.shaderProgram();
    renderState.m_context.vertexAttribPointer(program.attributeLocation(m_name), sourceData.attributeNumberOfComponents(key), sourceData.attributeDataType(key), sourceData.normalized(key), sourceData.attributeStride(key), sourceData.attributeOffset(key));
    renderState.m_context.enableVertexAttribArray(program.attributeLocation(m_name));
  };

  /**
   * Undo bind vertex data for a given render state.
   *
   * @param {vgl.renderState} renderState
   * @param {vgl.vertexAttributeKeys} key
   */
  this.undoBindVertexData = function (renderState, key) {
    var program = renderState.m_material.shaderProgram();
    renderState.m_context.disableVertexAttribArray(program.attributeLocation(m_name));
  };
};

/***/ }),

/***/ 698:
/***/ (function(module) {

module.exports = {};

/***/ }),

/***/ 7205:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var vgl = __webpack_require__(698);
var inherit = __webpack_require__(4626);

/**
 * Create a new instance of class viewer.
 *
 * @class
 * @alias vgl.viewer
 * @extends vgl.object
 * @param {HTMLElement} canvas Canvas element associated with the viewer.
 * @param {object} options Options to send to the renderer.
 * @returns {vgl.viewer}
 */
vgl.viewer = function (canvas, options) {
  'use strict';

  if (!(this instanceof vgl.viewer)) {
    return new vgl.viewer(canvas, options);
  }
  vgl.object.call(this);
  var m_canvas = canvas,
    m_renderer = vgl.renderer(options),
    m_renderWindow = vgl.renderWindow(m_canvas);

  /**
   * Get canvas of the viewer.
   *
   * @returns {HTMLElement}
   */
  this.canvas = function () {
    return m_canvas;
  };

  /**
   * Return render window of the viewer.
   *
   * @returns {vgl.renderWindow}
   */
  this.renderWindow = function () {
    return m_renderWindow;
  };

  /**
   * Initialize the viewer.
   *
   * This is a must call or otherwise render context may not initialized
   * properly.
   */
  this.init = function () {
    if (m_renderWindow !== null) {
      m_renderWindow._setup();
    } else {
      console.log('[ERROR] No render window attached'); // eslint-disable-line no-console
    }
  };

  /**
   * Remove the viewer.
   *
   * @param {vgl.renderState} renderState Current render state.
   */
  this.exit = function (renderState) {
    if (m_renderWindow !== null) {
      m_renderWindow._cleanup(renderState);
    } else {
      console.log('[ERROR] No render window attached'); // eslint-disable-line no-console
    }
  };

  /**
   * Render.
   */
  this.render = function () {
    m_renderWindow.render();
  };

  /**
   * Bind canvas mouse events to their default handlers.
   */
  this.bindEventHandlers = function () {
    $(m_canvas).on('mousedown', this.handleMouseDown);
    $(m_canvas).on('mouseup', this.handleMouseUp);
    $(m_canvas).on('mousemove', this.handleMouseMove);
    $(m_canvas).on('mousewheel', this.handleMouseWheel);
    $(m_canvas).on('contextmenu', this.handleContextMenu);
  };

  /**
   * Undo earlier bound handlers for canvas mouse events.
   */
  this.unbindEventHandlers = function () {
    $(m_canvas).off('mousedown', this.handleMouseDown);
    $(m_canvas).off('mouseup', this.handleMouseUp);
    $(m_canvas).off('mousemove', this.handleMouseMove);
    $(m_canvas).off('mousewheel', this.handleMouseWheel);
    $(m_canvas).off('contextmenu', this.handleContextMenu);
  };

  /**
   * Initialize.
   */
  this._init = function () {
    this.bindEventHandlers();
    m_renderWindow.addRenderer(m_renderer);
  };
  this._init();
  return this;
};
inherit(vgl.viewer, vgl.object);

/***/ }),

/***/ 394:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @namespace geo.vtkjs
 */
module.exports = {
  pointFeature: __webpack_require__(5380),
  vtkjsRenderer: __webpack_require__(9897)
};

/***/ }),

/***/ 7015:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Vtk.js specific subclass of object which rerenders when the object is drawn.
 *
 * @class
 * @alias geo.vtkjs.object
 * @extends geo.sceneObject
 * @param {object} arg Options for the object.
 * @returns {geo.vtkjs.object}
 */
var _vtkjs_object = function vtkjs_object(arg) {
  'use strict';

  var object = __webpack_require__(1338);

  // this is used to extend other geojs classes, so only generate
  // a new object when that is not the case... like if this === window
  if (!(this instanceof object)) {
    return new _vtkjs_object(arg);
  }
  var m_this = this,
    s_draw = this.draw;

  /**
   * Redraw the object.
   *
   * @returns {this}
   */
  this.draw = function () {
    if (m_this.ready) {
      m_this._update();
      m_this.renderer()._render();
      s_draw();
    }
    return m_this;
  };
  return this;
};
module.exports = _vtkjs_object;

/***/ }),

/***/ 5380:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var pointFeature = __webpack_require__(7541);

/**
 * Create a new instance of vtkjs.pointFeature.
 *
 * @class
 * @alias geo.vtkjs.pointFeature
 * @extends geo.pointFeature
 * @param {geo.pointFeature.spec} arg
 * @returns {geo.vtkjs.pointFeature}
 */
var _vtkjs_pointFeature = function vtkjs_pointFeature(arg) {
  'use strict';

  if (!(this instanceof _vtkjs_pointFeature)) {
    return new _vtkjs_pointFeature(arg);
  }
  arg = arg || {};
  pointFeature.call(this, arg);
  var transform = __webpack_require__(5325);
  var object = __webpack_require__(7015);
  var vtk = (__webpack_require__(9897).vtkjs);
  var vtkActor = vtk.Rendering.Core.vtkActor;
  var vtkDataArray = vtk.Common.Core.vtkDataArray;
  var vtkGlyph3DMapper = vtk.Rendering.Core.vtkGlyph3DMapper;
  var vtkMapper = vtk.Rendering.Core.vtkMapper;
  var vtkPointSet = vtk.Common.DataModel.vtkPointSet;
  var vtkSphereSource = vtk.Filters.Sources.vtkSphereSource;
  object.call(this);
  var m_this = this,
    m_actor,
    m_pointSet,
    m_source,
    m_colorArray,
    m_diamArray,
    s_init = this._init,
    s_exit = this._exit,
    s_update = this._update;

  /**
   * Create pipeline.
   */
  this._createPipeline = function () {
    m_pointSet = vtkPointSet.newInstance();
    m_source = vtkSphereSource.newInstance();
    m_source.setThetaResolution(30);
    m_source.setPhiResolution(30);
    var mapper = vtkGlyph3DMapper.newInstance({
      // Orientation
      orient: false,
      // Color and Opacity
      colorByArrayName: 'color',
      scalarMode: vtkMapper.ScalarMode.USE_POINT_FIELD_DATA,
      colorMode: vtkMapper.ColorMode.DIRECT_SCALARS,
      // Scaling
      scaling: true,
      scaleArray: 'diam',
      scaleMode: vtkGlyph3DMapper.ScaleModes.SCALE_BY_MAGNITUDE
    });
    mapper.setInputData(m_pointSet, 0);
    mapper.setInputConnection(m_source.getOutputPort(), 1);
    m_actor = vtkActor.newInstance();
    m_actor.setMapper(mapper);
    m_actor.getProperty().setAmbient(1);
    m_this.renderer().contextRenderer().addActor(m_actor);
  };

  /**
   * Initialize.
   */
  this._init = function () {
    s_init.call(m_this, arg);
    m_this.renderer().contextRenderer().setLayer(0);
    m_this._createPipeline();
  };

  /**
   * Build this feature.
   */
  this._build = function () {
    var i,
      i3,
      i4,
      posVal,
      clrVal,
      nonzeroZ,
      numPts = m_this.data().length,
      position = new Array(numPts * 3),
      data = m_this.data(),
      posFunc = m_this.position(),
      radFunc = m_this.style.get('radius'),
      fillFunc = m_this.style.get('fill'),
      colorFunc = m_this.style.get('fillColor'),
      opacityFunc = m_this.style.get('fillOpacity'),
      unitsPerPixel = m_this.layer().map().unitsPerPixel(m_this.layer().map().zoom());
    if (!m_diamArray || m_diamArray.length !== numPts) {
      m_diamArray = new Float32Array(numPts);
    }
    if (!m_colorArray || m_colorArray.length !== numPts * 4) {
      m_colorArray = new Uint8Array(numPts * 4);
    }

    /* It is more efficient to do a transform on a single array rather than on
     * an array of arrays or an array of objects. */
    for (i = i3 = i4 = 0; i < numPts; i += 1, i3 += 3, i4 += 4) {
      posVal = posFunc(data[i], i);
      position[i3] = posVal.x;
      position[i3 + 1] = posVal.y;
      position[i3 + 2] = posVal.z || 0;
      nonzeroZ = nonzeroZ || position[i3 + 2];
      m_diamArray[i] = radFunc(data[i], i) * unitsPerPixel * 2;
      clrVal = colorFunc(data[i], i);
      m_colorArray[i4] = clrVal.r * 255;
      m_colorArray[i4 + 1] = clrVal.g * 255;
      m_colorArray[i4 + 2] = clrVal.b * 255;
      m_colorArray[i4 + 3] = fillFunc(data[i], i) ? opacityFunc(data[i], i) * 255 : 0;
    }
    position = transform.transformCoordinates(m_this.gcs(), m_this.layer().map().gcs(), position, 3);

    /* Some transforms modify the z-coordinate.  If we started with all zero z
     * coordinates, don't modify them.  This could be changed if the
     * z-coordinate space of the gl cube is scaled appropriately. */
    if (!nonzeroZ && m_this.gcs() !== m_this.layer().map().gcs()) {
      for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
        position[i3 + 2] = 0;
      }
    }
    m_pointSet.getPoints().setData(position, 3);

    // Attach fields
    m_pointSet.getPointData().addArray(vtkDataArray.newInstance({
      name: 'color',
      values: m_colorArray,
      numberOfComponents: 4
    }));
    m_pointSet.getPointData().addArray(vtkDataArray.newInstance({
      name: 'diam',
      values: m_diamArray
    }));
    m_this.buildTime().modified();
  };

  /**
   * Update.
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().getMTime() >= m_this.buildTime().getMTime() || m_this.updateTime().getMTime() < m_this.getMTime()) {
      m_this._build();
    } else {
      var data = m_this.data(),
        radFunc = m_this.style.get('radius');
      var scalingFactor = m_this.layer().map().unitsPerPixel(m_this.layer().map().zoom());
      var dataArray = m_pointSet.getPointData().getArray('diam');
      var newScaleArray = dataArray.getData().map(function (v, i) {
        return radFunc(data[i], i) * scalingFactor * 2;
      });
      dataArray.setData(newScaleArray);
      m_pointSet.modified();
    }
    m_this.updateTime().modified();
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    m_this.renderer().contextRenderer().removeActor(m_actor);
    s_exit();
  };
  m_this._init();
  return this;
};
inherit(_vtkjs_pointFeature, pointFeature);
var capabilities = {};
capabilities[pointFeature.capabilities.stroke] = false;

// Now register it
registerFeature('vtkjs', 'point', _vtkjs_pointFeature, capabilities);
module.exports = _vtkjs_pointFeature;

/***/ }),

/***/ 9897:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerRenderer = (__webpack_require__(1098).registerRenderer);
var renderer = __webpack_require__(2274);

/**
 * Create a new instance of class vtkjsRenderer.
 *
 * @class
 * @alias geo.vtkjs.vtkjsRenderer
 * @extends geo.renderer
 * @param {object} arg Options for the renderer.
 * @param {geo.layer} [arg.layer] Layer associated with the renderer.
 * @param {HTMLElement} [arg.canvas] Canvas element associated with the
 *   renderer.
 * @returns {geo.vtkjs.vtkjsRenderer}
 */
var _vtkjsRenderer = function vtkjsRenderer(arg) {
  'use strict';

  if (!(this instanceof _vtkjsRenderer)) {
    return new _vtkjsRenderer(arg);
  }
  arg = arg || {};
  renderer.call(this, arg);
  var mat4 = __webpack_require__(3503);
  var geo_event = __webpack_require__(6409);
  var vtkjs = _vtkjsRenderer.vtkjs;
  var vtkGenericRenderWindow = vtkjs.Rendering.Misc.vtkGenericRenderWindow;
  var m_this = this,
    s_init = this._init;
  var vtkRenderer = vtkGenericRenderWindow.newInstance({
    background: [0, 0, 0, 0]
  });
  vtkRenderer.setContainer(m_this.layer().node().get(0));
  // TODO: Is there a way to start with no interactor rather than unbinding it?
  vtkRenderer.getInteractor().unbindEvents();
  vtkRenderer.resize();
  var vtkjsren = vtkRenderer.getRenderer();
  var renderWindow = vtkRenderer.getRenderWindow();

  /**
   * Get context specific renderer.
   *
   * @returns {object} The vtkjs context renderer.
   */
  this.contextRenderer = function () {
    return vtkjsren;
  };

  /**
   * Get API used by the renderer.
   *
   * @returns {string} `vtkjs`.
   */
  this.api = function () {
    return _vtkjsRenderer.apiname;
  };

  /**
   * Initialize.
   *
   * @returns {this}
   */
  this._init = function () {
    if (m_this.initialized()) {
      return m_this;
    }
    s_init.call(m_this);

    /* Initialize the size of the renderer */
    var map = m_this.layer().map(),
      mapSize = map.size();
    m_this._resize(0, 0, mapSize.width, mapSize.height);
    // TODO: figure out what the clipbounds actually should be and handle
    // perspective modes properly.
    map.camera().clipbounds = {
      near: -map.unitsPerPixel(),
      far: map.unitsPerPixel()
    };
    return m_this;
  };

  /**
   * Handle resize event.
   *
   * @param {number} x The left coordinate.
   * @param {number} y The top coordinate.
   * @param {number} w The width in pixels.
   * @param {number} h The height in pixels.
   * @returns {this}
   */
  this._resize = function (x, y, w, h) {
    m_this._setWidthHeight(w, h);
    vtkRenderer.resize();
    m_this._render();
    return m_this;
  };

  /**
   * Render.  This actually schedules rendering for the next animation frame.
   *
   * @returns {this}
   */
  this._render = function () {
    /* If we are already scheduled to render, don't schedule again.  Rather,
     * mark that we should render after other animation frame requests occur.
     * It would be nice if we could just reschedule the call by removing and
     * re-adding the animation frame request, but this doesn't work for if the
     * reschedule occurs during another animation frame callback (it then waits
     * until a subsequent frame). */
    m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame, true);
    return m_this;
  };

  /**
   * This actually renders.
   */
  this._renderFrame = function () {
    var layer = m_this.layer(),
      features = layer.features(),
      i;
    // TODO: draw something else should trigger feature update
    for (i = 0; i < features.length; i += 1) {
      if (features[i].visible()) {
        features[i]._update();
      }
    }
    m_this._updateRendererCamera();
    renderWindow.render();
  };

  /**
   * Exit.
   */
  this._exit = function () {
    // DO NOTHING
  };
  this._updateRendererCamera = function () {
    var map = m_this.layer().map(),
      camera = map.camera(),
      view = camera.view,
      proj = camera.projectionMatrix;
    var viewmat = mat4.create();
    mat4.copy(viewmat, view);
    var projmat = mat4.create();
    mat4.copy(projmat, proj);
    m_this.contextRenderer().getActiveCamera().setViewMatrix(viewmat);
    m_this.contextRenderer().getActiveCamera().setProjectionMatrix(projmat);
  };

  /* Connect to pan event.  This is sufficient, as all zooms and rotations also
   * produce a pan */
  m_this.layer().geoOn(geo_event.pan, function (evt) {
    // TODO: We may only need to do this if the zoom level has changed.
    m_this._render();
  });

  /* Connect to parallelprojection event. */
  m_this.layer().geoOn(geo_event.parallelprojection, function (evt) {
    // DO NOTHING
  });
  return this;
};
_vtkjsRenderer.apiname = 'vtkjs';
inherit(_vtkjsRenderer, renderer);
registerRenderer('vtkjs', _vtkjsRenderer);

/**
 * Report if the vtkjs renderer is supported.  This is just a check if vtkjs is
 * available.
 *
 * @returns {boolean} true if available.
 */
_vtkjsRenderer.supported = function () {
  delete _vtkjsRenderer.vtkjs;
  // webpack expects optional dependencies to be wrapped in a try-catch
  try {
    _vtkjsRenderer.vtkjs = __webpack_require__(4436);
  } catch (_error) {}
  if ((!_vtkjsRenderer.vtkjs || !_vtkjsRenderer.vtkjs.Rendering) && window.vtk && window.vtk.Rendering) {
    _vtkjsRenderer.vtkjs = window.vtk;
  }
  if (!_vtkjsRenderer.vtkjs || !_vtkjsRenderer.vtkjs.Rendering) {
    _vtkjsRenderer.vtkjs = undefined;
  }
  return _vtkjsRenderer.vtkjs !== undefined;
};

/**
 * If the vtkjs renderer is not supported, supply the name of a renderer that
 * should be used instead.  This asks for the null renderer.
 *
 * @returns {null} `null` for the null renderer.
 */
_vtkjsRenderer.fallback = function () {
  return null;
};
_vtkjsRenderer.supported(); // cache reference to vtkjs if it is available

module.exports = _vtkjsRenderer;

/***/ }),

/***/ 3559:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var choroplethFeature = __webpack_require__(3561);

/**
 * Create a new instance of choroplethFeature.
 *
 * @class
 * @alias geo.webgl.choroplethFeature
 * @extends geo.choroplethFeature
 * @param {geo.choroplethFeature.spec} arg
 * @returns {geo.webgl.choroplethFeature}
 */
var _webgl_choroplethFeature = function webgl_choroplethFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_choroplethFeature)) {
    return new _webgl_choroplethFeature(arg);
  }
  arg = arg || {};
  choroplethFeature.call(this, arg);

  /**
   * @private
   */
  var m_this = this,
    m_polygons = null,
    s_exit = this._exit,
    s_draw = this.draw,
    s_update = this._update;

  /**
   * Draw each of the polygons associated with this feature.
   *
   * @returns {this}
   */
  this.draw = function () {
    m_this._update();
    if (m_polygons) {
      for (var idx = 0; idx < m_polygons.length; idx += 1) {
        m_polygons[idx].draw();
      }
    }
    s_draw();
    return m_this;
  };

  /**
   * Build.
   *
   * @returns {geo.featurePolygon[]}
   */
  this._build = function () {
    m_this.buildTime().modified();
    m_polygons = m_this.createChoropleth();
    return m_polygons;
  };

  /**
   * Update the choropleth if the data was updated since the last build or the
   * feature was updated.
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() <= m_this.timestamp()) {
      m_this._wipePolygons();
      m_this._build();
    }
    m_this.updateTime().modified();
  };

  /**
   * Destroy polygon sub-features.
   */
  this._wipePolygons = function () {
    if (m_polygons) {
      m_polygons.map(function (polygon) {
        return polygon._exit();
      });
    }
    m_polygons = null;
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    m_this._wipePolygons();
    s_exit();
  };
  this._init(arg);
  return this;
};
inherit(_webgl_choroplethFeature, choroplethFeature);

// Now register it
registerFeature('webgl', 'choropleth', _webgl_choroplethFeature);
module.exports = _webgl_choroplethFeature;

/***/ }),

/***/ 6791:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var contourFeature = __webpack_require__(6761);

/**
 * Create a new instance of contourFeature.
 *
 * @class
 * @alias geo.webgl.contourFeature
 * @extends geo.contourFeature
 * @extends geo.webgl.meshColored
 * @param {geo.contourFeature.spec} arg
 * @returns {geo.webgl.contourFeature}
 */
var _webgl_contourFeature = function webgl_contourFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_contourFeature)) {
    return new _webgl_contourFeature(arg);
  }
  arg = arg || {};
  contourFeature.call(this, arg);
  var meshColored = __webpack_require__(2778);
  meshColored.call(this, arg);
  var m_this = this;

  /**
   * Build.
   */
  this._build = function () {
    if (m_this.actors()[0]) {
      m_this.renderer().contextRenderer().removeActor(m_this.actors()[0]);
    }
    m_this.createGLMeshColored(m_this._createContours());
    m_this.renderer().contextRenderer().addActor(m_this.actors()[0]);
    m_this.buildTime().modified();
  };
  this._init(arg);
  return this;
};
inherit(_webgl_contourFeature, contourFeature);

// Now register it
registerFeature('webgl', 'contour', _webgl_contourFeature);
module.exports = _webgl_contourFeature;

/***/ }),

/***/ 8257:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var gridFeature = __webpack_require__(2499);

/**
 * Create a new instance of gridFeature.
 *
 * @class
 * @alias geo.webgl.gridFeature
 * @extends geo.gridFeature
 * @extends geo.webgl.meshColored
 * @param {geo.gridFeature.spec} arg
 * @returns {geo.webgl.gridFeature}
 */
var _webgl_gridFeature = function webgl_gridFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_gridFeature)) {
    return new _webgl_gridFeature(arg);
  }
  arg = arg || {};
  gridFeature.call(this, arg);
  var meshColored = __webpack_require__(2778);
  meshColored.call(this, arg);
  var m_this = this;

  /**
   * Build.
   */
  this._build = function () {
    if (m_this.actors()[0]) {
      m_this.renderer().contextRenderer().removeActor(m_this.actors()[0]);
    }
    m_this.createGLMeshColored(m_this._createGrids());
    m_this.renderer().contextRenderer().addActor(m_this.actors()[0]);
    m_this.buildTime().modified();
  };
  this._init(arg);
  return this;
};
inherit(_webgl_gridFeature, gridFeature);

// Now register it
registerFeature('webgl', 'grid', _webgl_gridFeature);
module.exports = _webgl_gridFeature;

/***/ }),

/***/ 8635:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @namespace geo.webgl
 */
module.exports = {
  choroplethFeature: __webpack_require__(3559),
  contourFeature: __webpack_require__(6791),
  gridFeature: __webpack_require__(8257),
  isolineFeature: __webpack_require__(960),
  layer: __webpack_require__(6982),
  lineFeature: __webpack_require__(5795),
  lookupTable2D: __webpack_require__(411),
  markerFeature: __webpack_require__(3403),
  meshColored: __webpack_require__(2778),
  pixelmapFeature: __webpack_require__(7759),
  pointFeature: __webpack_require__(5407),
  polygonFeature: __webpack_require__(8511),
  quadFeature: __webpack_require__(9304),
  tileLayer: __webpack_require__(1474),
  trackFeature: __webpack_require__(536),
  webglRenderer: __webpack_require__(7945)
};

/***/ }),

/***/ 960:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var isolineFeature = __webpack_require__(2586);

/**
 * Create a new instance of isolineFeature.
 *
 * @class
 * @alias geo.webgl.isolineFeature
 * @extends geo.isolineFeature
 * @param {geo.isolineFeature.spec} arg
 * @returns {geo.webgl.isolineFeature}
 */
var _webgl_isolineFeature = function webgl_isolineFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_isolineFeature)) {
    return new _webgl_isolineFeature(arg);
  }
  arg = arg || {};
  isolineFeature.call(this, arg);
  var object = __webpack_require__(4084);
  object.call(this);
  this._init(arg);
  return this;
};
inherit(_webgl_isolineFeature, isolineFeature);

// Now register it
registerFeature('webgl', 'isoline', _webgl_isolineFeature);
module.exports = _webgl_isolineFeature;

/***/ }),

/***/ 6982:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var registerLayerAdjustment = (__webpack_require__(1098).registerLayerAdjustment);
var webgl_layer = function webgl_layer() {
  'use strict';

  var createRenderer = (__webpack_require__(1098).createRenderer);
  var geo_event = __webpack_require__(6409);
  var webglRenderer = __webpack_require__(7945);
  var tileLayer = __webpack_require__(9264);
  var m_this = this,
    s_init = this._init,
    s_opacity = this.opacity,
    s_visible = this.visible,
    s_zIndex = this.zIndex;

  /**
   * Get or set the current layer opacity.  The opacity is in the range [0-1].
   *
   * @param {number} [opacity] If specified, set the opacity.  Otherwise,
   *    return the opacity.
   * @returns {number|this} The current opacity or the current layer.
   * @memberof geo.webgl.layer
   */
  this.opacity = function (opacity) {
    var result = s_opacity.apply(m_this, arguments);
    if (opacity !== undefined && m_this.initialized()) {
      m_this.map()._updateAutoshareRenderers();
    }
    return result;
  };

  /**
   * Get/Set visibility of the layer.
   *
   * @param {boolean} [val] If specified, change the visibility.  Otherwise,
   *    get it.
   * @returns {boolean|this} either the visibility (if getting) or the layer
   *    (if setting).
   * @memberof geo.webgl.layer
   */
  this.visible = function (val) {
    if (val === undefined) {
      return s_visible();
    }
    var origVal = s_visible(),
      result = s_visible.apply(m_this, arguments);
    if (origVal !== val && m_this.initialized()) {
      m_this.map().scheduleAnimationFrame(m_this._update, true);
      m_this.renderer()._render();
    }
    return result;
  };

  /**
   * Get or set the z-index of the layer.  The z-index controls the display
   * order of the layers in much the same way as the CSS z-index property.
   *
   * @param {number} [zIndex] The new z-index, or undefined to return the
   *    current z-index.
   * @param {boolean} [allowDuplicate] When setting the z index, if this is
   *    truthy, allow other layers to have the same z-index.  Otherwise,
   *    ensure that other layers have distinct z-indices from this one.
   * @returns {number|this}
   * @memberof geo.webgl.layer
   */
  this.zIndex = function (zIndex, allowDuplicate) {
    var result = s_zIndex.apply(m_this, arguments);
    if (zIndex !== undefined && m_this.initialized()) {
      /* If the z-index has changed, schedule rerendering the layer. */
      m_this.map().scheduleAnimationFrame(m_this._update, true);
      m_this.renderer()._render();
      m_this.map()._updateAutoshareRenderers();
    }
    return result;
  };

  /**
   * Move all of the objects associated with this layer to a different webgl
   * renderer.  This runs the _cleanup routine for any feature or child of the
   * layer (if it has one), removes all actors associated with this layer from
   * the existing renderer, then adds those actors to the new renderer and
   * calls `_update` on any feature that had a `_cleanup` routine.  If desired,
   * the old and new renderers are both asked to rerender.  If moving multiple
   * renderers for multiple layers, rerendering can be delayed.
   *
   * @param {geo.webgl.webglRenderer} newRenderer The renderer to move to.
   * @param {boolean} [rerender] If truthy, rerender after the switch.
   * @returns {this}
   * @memberof geo.webgl.layer
   */
  this.switchRenderer = function (newRenderer, rerender) {
    if (newRenderer instanceof webglRenderer && newRenderer !== m_this.renderer()) {
      var oldRenderer = m_this.renderer(),
        actors = [],
        updates = [];
      m_this.map().listSceneObjects([m_this]).forEach(function (obj) {
        if (obj._cleanup) {
          obj._cleanup();
          if (obj._update) {
            updates.push(obj);
          }
        }
        if (obj.actors) {
          actors = actors.concat(obj.actors());
        }
      });
      actors.forEach(function (actor) {
        oldRenderer.contextRenderer().removeActor(actor);
        newRenderer.contextRenderer().addActor(actor);
      });
      m_this._renderer(newRenderer);
      m_this._canvas(newRenderer.canvas());
      if (rerender && (actors.length || updates.length)) {
        oldRenderer._render();
        updates.forEach(function (obj) {
          obj._update();
        });
        newRenderer._render();
      }
    }
    return m_this;
  };

  /**
   * Initialize after the layer is added to the map.
   *
   * @returns {this}
   * @memberof geo.webgl.layer
   */
  this._init = function () {
    var map = m_this.map();
    if (!map._updateAutoshareRenderers) {
      /**
       * Update all webgl autoshareRenderer layers so that appropriate groups
       * of layers share renderers.  Each group must (a) be contiguous in
       * z-space (not separated by a non-autoshare layer or a non-webgl layer),
       * and (b) have the same opacity.  The lowest layer in each group will
       * contain the actual canvas and context.  This rerenders as needed.
       */
      map._updateAutoshareRenderers = function () {
        var layers = map.sortedLayers(),
          renderer,
          rerender_list = [],
          opacity,
          lowerTileLayers;
        layers.forEach(function (layer) {
          var autoshare = layer.autoshareRenderer(),
            isTileLayer = layer instanceof tileLayer;
          if (!autoshare || !layer.renderer() || layer.renderer().api() !== webglRenderer.apiname) {
            renderer = null;
          } else if (!renderer || layer.opacity() !== opacity || autoshare !== 'more' && (layer.opacity() > 0 && layer.opacity() < 1 || isTileLayer && !lowerTileLayers)) {
            if (!layer.node()[0].contains(layer.renderer().canvas()[0])) {
              layer.switchRenderer(createRenderer(webglRenderer.apiname, layer), false);
              rerender_list.push(layer.renderer());
            }
            renderer = layer.renderer();
            opacity = layer.opacity();
            lowerTileLayers = isTileLayer;
          } else {
            if (layer.renderer() !== renderer) {
              rerender_list.push(layer.renderer());
              layer.switchRenderer(renderer, false);
              rerender_list.push(layer.renderer());
            }
            lowerTileLayers &= isTileLayer;
          }
        });
        layers.forEach(function (layer) {
          if (rerender_list.indexOf(layer.renderer()) >= 0) {
            if (layer._update) {
              layer._update();
            }
          }
        });
        layers.forEach(function (layer) {
          if (rerender_list.indexOf(layer.renderer()) >= 0) {
            layer.renderer()._renderFrame();
            rerender_list = rerender_list.filter(function (val) {
              return val !== layer.renderer();
            });
          }
        });
        /* explicitly exit any renderers we no longer use */
        rerender_list.forEach(function (renderer) {
          renderer._exit();
        });
      };
      map.geoOn(geo_event.layerAdd, function () {
        return map._updateAutoshareRenderers();
      });
      map.geoOn(geo_event.layerRemove, function () {
        return map._updateAutoshareRenderers();
      });
    }
    return s_init.apply(m_this, arguments);
  };
};
registerLayerAdjustment('webgl', 'all', webgl_layer);
module.exports = webgl_layer;

/***/ }),

/***/ 5795:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var lineFeature = __webpack_require__(9281);
var MAX_MITER_LIMIT = 100;

/* Flags are passed to the vertex shader in a float.  Since a 32-bit float has
 * 24 bits of mantissa, including the sign bit, a maximum of 23 bits of flags
 * can be passed in a float without loss or complication.
 *   The flags*Shift values are the bit offsets within the flag value.  The
 * flags*Mult values are the bit-offset values converted to a multiplier (2
 * raised to the offset value).  The overall flags value is composed of:
 *  bits 0-1: vertex (corner, near, far) used by the shader to know where in
 *            the geometry the vertex is used.
 *       2-4: near cap/join style
 *       5-7: far cap/join style
 *       8-18: stroke offset as a signed value in the range [-1023,1023] which
 *             maps to a floating-point stroke offset of [-1,1].
 */
/* vertex flags specify which direction a vertex needs to be offset */
var flagsVertex = {
  // uses 2 bits
  corner: 0,
  near: 1,
  far: 3
};
var flagsLineCap = {
  // uses 3 bits with flagsLineJoin
  butt: 0,
  square: 1,
  round: 2
};
var flagsLineJoin = {
  // uses 3 bits with flagsLineCap
  passthrough: 3,
  miter: 4,
  bevel: 5,
  round: 6,
  'miter-clip': 7
};
var flagsNearLineShift = 2,
  flagsNearLineMult = 1 << flagsNearLineShift;
var flagsFarLineShift = 5,
  flagsFarLineMult = 1 << flagsFarLineShift;
var flagsNearOffsetShift = 8,
  // uses 11 bits
  flagsNearOffsetMult = 1 << flagsNearOffsetShift;
/* Fixed flags */
var flagsDebug = {
  // uses 1 bit
  normal: 0,
  debug: 1
};

/**
 * Create a new instance of lineFeature.
 *
 * @class
 * @alias geo.webgl.lineFeature
 * @extends geo.lineFeature
 * @param {geo.lineFeature.spec} arg
 * @returns {geo.webgl.lineFeature}
 */
var _webgl_lineFeature = function webgl_lineFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_lineFeature)) {
    return new _webgl_lineFeature(arg);
  }
  arg = arg || {};
  lineFeature.call(this, arg);
  var vgl = __webpack_require__(1611);
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var object = __webpack_require__(4084);
  var fragmentShader = __webpack_require__(5685);
  var fragmentShaderDebug = __webpack_require__(1388);
  var vertexShader = __webpack_require__(9336);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    m_actor,
    m_mapper,
    m_material,
    m_pixelWidthUnif,
    m_aspectUniform,
    m_miterLimitUniform,
    m_antialiasingUniform,
    m_flagsUniform,
    m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
    m_geometry,
    m_origin,
    m_modelViewUniform,
    s_init = this._init,
    s_update = this._update;

  /**
   * Create the vertex shader for lines.
   *
   * @returns {vgl.shader}
   */
  function createVertexShader() {
    var shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
    shader.setShaderSource(vertexShader);
    return shader;
  }

  /**
   * Create the fragment shader for lines.
   *
   * @param {boolean} [allowDebug] If truthy, include code that can render
   *    in debug mode.  This is mildly less efficient, even if debugging is
   *    not turned on.
   * @returns {vgl.shader}
   */
  function createFragmentShader(allowDebug) {
    var shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
    shader.setShaderSource(allowDebug ? fragmentShaderDebug : fragmentShader);
    return shader;
  }

  /**
   * Create and style the data needed to render the lines.
   *
   * @param {boolean} onlyStyle if true, use the existing geometry and just
   *    recalculate the style.
   */
  function createGLLines(onlyStyle) {
    var data = m_this.data(),
      d,
      i,
      j,
      k,
      v1,
      v2,
      lidx,
      maxj,
      numSegments = 0,
      len,
      lineItemList,
      lineItem,
      lineItemData,
      vert = [{
        strokeOffset: 0,
        posStrokeOffset: 0,
        negStrokeOffset: 0
      }, {
        strokeOffset: 0,
        posStrokeOffset: 0,
        negStrokeOffset: 0
      }],
      v = vert[1],
      target_gcs = m_this.gcs(),
      map_gcs = m_this.layer().map().gcs(),
      pos,
      posIdx3,
      firstpos,
      firstPosIdx3,
      lineFunc = m_this.line(),
      strokeWidthFunc = m_this.style.get('strokeWidth'),
      strokeWidthVal,
      strokeColorFunc = m_this.style.get('strokeColor'),
      strokeColorVal,
      strokeOpacityFunc = m_this.style.get('strokeOpacity'),
      strokeOpacityVal,
      lineCapFunc = m_this.style.get('lineCap'),
      lineCapVal,
      lineJoinFunc = m_this.style.get('lineJoin'),
      lineJoinVal,
      strokeOffsetFunc = m_this.style.get('strokeOffset'),
      strokeOffsetVal,
      miterLimit = m_this.style.get('miterLimit')(data),
      antialiasing = m_this.style.get('antialiasing')(data) || 0,
      uniformFunc = m_this.style.get('uniformLine'),
      uniformVal,
      uniform,
      drop,
      skipped,
      order = m_this.featureVertices(),
      orderk0,
      orderLen = order.length,
      // webgl buffers; see _init for details
      posBuf,
      prevBuf,
      nextBuf,
      farBuf,
      flagsBuf,
      fixedFlags = flagsDebug[m_this.style.get('debug')(data) ? 'debug' : 'normal'] || 0,
      strokeWidthBuf,
      strokeColorBuf,
      strokeOpacityBuf,
      dest,
      dest3,
      geom = m_mapper.geometryData(),
      closedFunc = m_this.style.get('closed'),
      closedVal,
      closed,
      updateFlags = true;
    closedVal = util.isFunction(m_this.style('closed')) ? undefined : closedFunc() || false;
    lineCapVal = util.isFunction(m_this.style('lineCap')) ? undefined : flagsLineCap[lineCapFunc() || 'butt'];
    lineJoinVal = util.isFunction(m_this.style('lineJoin')) ? undefined : flagsLineJoin[lineJoinFunc() || 'miter'];
    strokeColorVal = util.isFunction(m_this.style('strokeColor')) ? undefined : strokeColorFunc();
    strokeOffsetVal = util.isFunction(m_this.style('strokeOffset')) ? undefined : strokeOffsetFunc() || 0;
    strokeOpacityVal = util.isFunction(m_this.style('strokeOpacity')) ? undefined : strokeOpacityFunc();
    strokeWidthVal = util.isFunction(m_this.style('strokeWidth')) ? undefined : strokeWidthFunc();
    uniformVal = util.isFunction(m_this.style('uniformLine')) ? undefined : uniformFunc();
    if (miterLimit !== undefined) {
      /* We impose a limit no matter what, since otherwise the growth is
       * unbounded.  Values less than 1 make no sense, since we are using the
       * SVG definition of miter length. */
      m_miterLimitUniform.set(Math.max(1, Math.min(MAX_MITER_LIMIT, miterLimit)));
    }
    m_flagsUniform.set(fixedFlags);
    m_antialiasingUniform.set(antialiasing);
    if (!onlyStyle) {
      var position = [],
        posFunc = m_this.position();
      posFunc = posFunc === util.identityFunction ? null : posFunc;
      lineItemList = new Array(data.length);
      closed = new Array(data.length);
      for (i = 0; i < data.length; i += 1) {
        d = data[i];
        lineItem = lineFunc(d, i);
        lineItemList[i] = lineItem;
        if (lineItem.length < 2) {
          continue;
        }
        numSegments += lineItem.length - 1;
        for (j = 0; j < lineItem.length; j += 1) {
          pos = posFunc ? posFunc(lineItem[j], j, d, i) : lineItem[j];
          position.push(pos.x);
          position.push(pos.y);
          position.push(pos.z || 0.0);
          if (!j) {
            firstpos = pos;
          }
        }
        if (lineItem.length > 2 && (closedVal === undefined ? closedFunc(d, i) : closedVal)) {
          /* line is closed */
          if (pos.x !== firstpos.x || pos.y !== firstpos.y || pos.z !== firstpos.z) {
            numSegments += 1;
            closed[i] = 2; /* first and last points are distinct */
          } else {
            closed[i] = 1; /* first point is repeated as last point */
          }
        } else {
          closed[i] = 0;
        }
      }
      position = transform.transformCoordinates(target_gcs, map_gcs, position, 3);
      m_origin = new Float32Array(m_this.style.get('origin')(position));
      if (m_origin[0] || m_origin[1] || m_origin[2]) {
        var o0 = m_origin[0],
          o1 = m_origin[1],
          o2 = m_origin[2];
        for (i = 0; i < position.length; i += 3) {
          position[i] -= o0;
          position[i + 1] -= o1;
          position[i + 2] -= o2;
        }
      }
      m_modelViewUniform.setOrigin(m_origin);
      len = numSegments * orderLen;
      posBuf = util.getGeomBuffer(geom, 'pos', len * 3);
      prevBuf = util.getGeomBuffer(geom, 'prev', len * 3);
      nextBuf = util.getGeomBuffer(geom, 'next', len * 3);
      farBuf = util.getGeomBuffer(geom, 'far', len * 3);
      if (geom.primitive(0).numberOfIndices() !== len) {
        geom.primitive(0).numberOfIndices = function () {
          return len;
        };
      }
      // save some information to be reused when we update only style
      m_geometry = {
        numSegments: numSegments,
        closed: closed,
        lineItemList: lineItemList,
        lineCapVal: lineCapVal,
        lineJoinVal: lineJoinVal,
        strokeOffsetVal: strokeOffsetVal
      };
    } else {
      numSegments = m_geometry.numSegments;
      closed = m_geometry.closed;
      lineItemList = m_geometry.lineItemList;
      len = numSegments * orderLen;
      updateFlags = lineCapVal !== m_geometry.lineCapVal || lineCapVal === undefined || lineJoinVal !== m_geometry.lineJoinVal || lineJoinVal === undefined || strokeOffsetVal !== m_geometry.strokeOffsetVal || strokeOffsetVal === undefined;
    }
    flagsBuf = util.getGeomBuffer(geom, 'flags', len);
    strokeWidthBuf = util.getGeomBuffer(geom, 'strokeWidth', len);
    strokeColorBuf = util.getGeomBuffer(geom, 'strokeColor', len * 3);
    strokeOpacityBuf = util.getGeomBuffer(geom, 'strokeOpacity', len);
    for (i = posIdx3 = dest = dest3 = 0; i < data.length; i += 1) {
      lineItem = lineItemList[i];
      if (lineItem.length < 2) {
        continue;
      }
      uniform = uniformVal === undefined ? uniformFunc(lineItem, i) : uniformVal;
      drop = uniform === 'drop';
      d = data[i];
      closedVal = closed[i];
      firstPosIdx3 = posIdx3;
      maxj = lineItem.length + (closedVal === 2 ? 1 : 0);
      skipped = 0;
      for (j = 0; j < maxj; j += 1, posIdx3 += 3) {
        lidx = j;
        if (j === lineItem.length) {
          lidx = 0;
          posIdx3 -= 3;
        }
        lineItemData = lineItem[lidx];
        /* swap entries in vert so that vert[0] is the first vertex, and
         * vert[1] will be reused for the second vertex */
        if (j) {
          v = vert[0];
          vert[0] = vert[1];
          vert[1] = v;
        }
        if (!onlyStyle) {
          v.pos = j === lidx ? posIdx3 : firstPosIdx3;
          v.prev = lidx ? posIdx3 - 3 : closedVal ? firstPosIdx3 + (lineItem.length - 3 + closedVal) * 3 : posIdx3;
          v.next = j + 1 < lineItem.length ? posIdx3 + 3 : closedVal ? j !== lidx ? firstPosIdx3 + 3 : firstPosIdx3 + 6 - closedVal * 3 : posIdx3;
        }
        if (uniform && j > 0) {
          if (j === 1) {
            v.strokeWidth = vert[0].strokeWidth;
            v.strokeColor = vert[0].strokeColor;
            v.strokeOpacity = vert[0].strokeOpacity;
          }
        } else {
          v.strokeWidth = strokeWidthVal === undefined ? strokeWidthFunc(lineItemData, lidx, d, i) : strokeWidthVal;
          v.strokeColor = strokeColorVal === undefined ? strokeColorFunc(lineItemData, lidx, d, i) : strokeColorVal;
          v.strokeOpacity = strokeOpacityVal === undefined ? strokeOpacityFunc(lineItemData, lidx, d, i) : strokeOpacityVal;
        }
        if (updateFlags) {
          if (strokeOffsetVal !== 0) {
            if (uniform && j > 0) {
              if (j === 1) {
                v.strokeOffset = vert[0].strokeOffset;
              }
            } else {
              v.strokeOffset = (strokeOffsetVal === undefined ? strokeOffsetFunc(lineItemData, lidx, d, i) : strokeOffsetVal) || 0;
            }
            if (v.strokeOffset) {
              /* we use 11 bits to store the offset, and we want to store values
               * from -1 to 1, so multiply our values by 1023, and use some bit
               * manipulation to ensure that it is packed properly */
              v.posStrokeOffset = Math.round(2048 + 1023 * Math.min(1, Math.max(-1, v.strokeOffset))) & 0x7FF;
              v.negStrokeOffset = Math.round(2048 - 1023 * Math.min(1, Math.max(-1, v.strokeOffset))) & 0x7FF;
            } else {
              v.posStrokeOffset = v.negStrokeOffset = 0;
            }
          }
          if (!closedVal && (!j || j === lineItem.length - 1)) {
            v.flags = lineCapVal === undefined ? flagsLineCap[lineCapFunc(lineItemData, lidx, d, i)] || flagsLineCap.butt : lineCapVal;
          } else {
            v.flags = lineJoinVal === undefined ? flagsLineJoin[lineJoinFunc(lineItemData, lidx, d, i)] || flagsLineJoin.miter : lineJoinVal;
          }
        }
        if (j) {
          if (drop && j > 1 && position[vert[0].pos] === position[vert[1].pos] && position[vert[0].pos + 1] === position[vert[1].pos + 1]) {
            skipped += 1;
            continue;
          }
          /* zero out the z position.  This can be changed if we handle it in
           * the shader. */
          for (k = 0; k < orderLen; k += 1, dest += 1, dest3 += 3) {
            if (drop && vert[0].strokeOpacity <= 0 && vert[1].strokeOpacity <= 0) {
              strokeOpacityBuf[dest] = -1;
              continue;
            }
            orderk0 = order[k][0];
            v1 = vert[orderk0];
            v2 = vert[1 - orderk0];
            if (!onlyStyle) {
              posBuf[dest3] = position[v1.pos];
              posBuf[dest3 + 1] = position[v1.pos + 1];
              posBuf[dest3 + 2] = 0; // position[v1.pos + 2];
              prevBuf[dest3] = position[orderk0 ? v1.next : v1.prev];
              prevBuf[dest3 + 1] = position[(orderk0 ? v1.next : v1.prev) + 1];
              prevBuf[dest3 + 2] = 0; // position[(orderk0 ? v1.next : v1.prev) + 2];
              nextBuf[dest3] = position[orderk0 ? v1.prev : v1.next];
              nextBuf[dest3 + 1] = position[(orderk0 ? v1.prev : v1.next) + 1];
              nextBuf[dest3 + 2] = 0; // position[(orderk0 ? v1.prev : v1.next) + 2];
              farBuf[dest3] = position[orderk0 ? v2.prev : v2.next];
              farBuf[dest3 + 1] = position[(orderk0 ? v2.prev : v2.next) + 1];
              farBuf[dest3 + 2] = 0; // position[(orderk0 ? v2.prev : v2.next) + 2];
            }
            if (updateFlags) {
              flagsBuf[dest] = order[k][3] + v1.flags * flagsNearLineMult + v2.flags * flagsFarLineMult + (orderk0 ? v1.posStrokeOffset : v1.negStrokeOffset) * flagsNearOffsetMult;
            }
            strokeWidthBuf[dest] = v1.strokeWidth;
            strokeColorBuf[dest3] = v1.strokeColor.r;
            strokeColorBuf[dest3 + 1] = v1.strokeColor.g;
            strokeColorBuf[dest3 + 2] = v1.strokeColor.b;
            if (v1.strokeOpacity <= 0 && v2.strokeOpacity <= 0 || v1.strokeWidth <= 0 && v2.strokeWidth <= 0) {
              strokeOpacityBuf[dest] = -1;
            } else {
              strokeOpacityBuf[dest] = v1.strokeOpacity;
            }
          }
        }
      }
      if (skipped) {
        for (k = 0; k < skipped * orderLen; k += 1, dest += 1, dest3 += 3) {
          strokeOpacityBuf[dest] = -1;
        }
      }
    }
    if (!onlyStyle) {
      m_mapper.modified();
      geom.boundsDirty(true);
      m_mapper.boundsDirtyTimestamp().modified();
    } else {
      if (updateFlags) {
        m_mapper.updateSourceBuffer('flags');
      }
      m_mapper.updateSourceBuffer('strokeWidth');
      m_mapper.updateSourceBuffer('strokeOpacity');
      m_mapper.updateSourceBuffer('strokeColor');
    }
  }

  /**
   * Return the arrangement of vertices used for each line segment.  Each line
   * is rendered by two triangles.  This reports how the vertices of those
   * triangles are arranged.  Each entry is a triple: the line-end number, the
   * vertex use, and the side of the line that the vertex is on.
   *
   * @returns {array[]}
   */
  this.featureVertices = function () {
    return [[0, 'corner', -1, flagsVertex.corner], [0, 'near', 1, flagsVertex.near], [1, 'far', -1, flagsVertex.far], [1, 'corner', 1, flagsVertex.corner], [1, 'near', -1, flagsVertex.near], [0, 'far', 1, flagsVertex.far]];
  };

  /**
   * Return the number of vertices used for each line segment.
   *
   * @returns {number}
   */
  this.verticesPerFeature = function () {
    return m_this.featureVertices().length;
  };

  /**
   * Initialize.
   *
   * @param {geo.lineFeature.spec} arg The feature specification.
   * @returns {this}
   */
  this._init = function (arg) {
    var prog = vgl.shaderProgram(),
      vs = createVertexShader(),
      fs = createFragmentShader(((arg || {}).style || {}).debug !== undefined),
      // Vertex attributes
      posAttr = vgl.vertexAttribute('pos'),
      prvAttr = vgl.vertexAttribute('prev'),
      nxtAttr = vgl.vertexAttribute('next'),
      farAttr = vgl.vertexAttribute('far'),
      flagsAttr = vgl.vertexAttribute('flags'),
      strkWidthAttr = vgl.vertexAttribute('strokeWidth'),
      strkColorAttr = vgl.vertexAttribute('strokeColor'),
      strkOpacityAttr = vgl.vertexAttribute('strokeOpacity'),
      // Shader uniforms
      prjUnif = new vgl.projectionUniform('projectionMatrix'),
      geom = vgl.geometryData(),
      // Sources
      posData = vgl.sourceDataP3fv({
        name: 'pos'
      }),
      prvPosData = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Four, {
        name: 'prev'
      }),
      nxtPosData = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Five, {
        name: 'next'
      }),
      farPosData = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Six, {
        name: 'far'
      }),
      flagsData = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Seven, {
        name: 'flags'
      }),
      strkWidthData = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.One, {
        name: 'strokeWidth'
      }),
      strkColorData = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Two, {
        name: 'strokeColor'
      }),
      strkOpacityData = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Three, {
        name: 'strokeOpacity'
      }),
      // Primitive indices
      triangles = vgl.triangles();
    m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix');
    m_pixelWidthUnif = new vgl.floatUniform('pixelWidth', 1.0 / m_this.renderer().width());
    m_aspectUniform = new vgl.floatUniform('aspect', m_this.renderer().width() / m_this.renderer().height());
    m_miterLimitUniform = new vgl.floatUniform('miterLimit', 10);
    m_antialiasingUniform = new vgl.floatUniform('antialiasing', 0);
    m_flagsUniform = new vgl.floatUniform('fixedFlags', 0);
    s_init.call(m_this, arg);
    m_material = vgl.material();
    m_mapper = vgl.mapper({
      dynamicDraw: m_dynamicDraw
    });
    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
    prog.addVertexAttribute(strkWidthAttr, vgl.vertexAttributeKeysIndexed.One);
    prog.addVertexAttribute(strkColorAttr, vgl.vertexAttributeKeysIndexed.Two);
    prog.addVertexAttribute(strkOpacityAttr, vgl.vertexAttributeKeysIndexed.Three);
    prog.addVertexAttribute(prvAttr, vgl.vertexAttributeKeysIndexed.Four);
    prog.addVertexAttribute(nxtAttr, vgl.vertexAttributeKeysIndexed.Five);
    prog.addVertexAttribute(farAttr, vgl.vertexAttributeKeysIndexed.Six);
    prog.addVertexAttribute(flagsAttr, vgl.vertexAttributeKeysIndexed.Seven);
    prog.addUniform(m_modelViewUniform);
    prog.addUniform(prjUnif);
    prog.addUniform(m_pixelWidthUnif);
    prog.addUniform(m_aspectUniform);
    prog.addUniform(m_miterLimitUniform);
    prog.addUniform(m_antialiasingUniform);
    prog.addUniform(m_flagsUniform);
    prog.addShader(fs);
    prog.addShader(vs);
    m_material.addAttribute(prog);
    m_material.addAttribute(vgl.blend());
    m_actor = vgl.actor();
    m_actor.setMaterial(m_material);
    m_actor.setMapper(m_mapper);
    geom.addSource(posData);
    geom.addSource(prvPosData);
    geom.addSource(nxtPosData);
    geom.addSource(farPosData);
    geom.addSource(strkWidthData);
    geom.addSource(strkColorData);
    geom.addSource(strkOpacityData);
    geom.addSource(flagsData);
    /* put a very small array here.  We only use the length, and we'll override
     * that elsewhere. */
    triangles.setIndices(new Uint16Array(1));
    geom.addPrimitive(triangles);
    /* We don't need vgl to compute bounds, so make the geo.computeBounds just
     * set them to 0. */
    geom.computeBounds = function () {
      geom.setBounds(0, 0, 0, 0, 0, 0);
    };
    m_mapper.setGeometryData(geom);
    return m_this;
  };

  /**
   * List vgl actors.
   *
   * @returns {vgl.actor[]} The list of actors.
   */
  this.actors = function () {
    return m_actor ? [m_actor] : [];
  };

  /**
   * Build.  Create the necessary elements to render lines.
   *
   * There are several optimizations to do less work when possible.  If only
   * styles have changed, the geometry is not re-transformed.  If styles use
   * static values (rather than functions), they are only calculated once.  If
   * styles have not changed that would affect flags (lineCap, lineJoin, and
   * strokeOffset), the vertex flags are not recomputed -- this helps, as it is
   * a slow step due to most javascript interpreters not optimizing bit
   * operations.
   *
   * @returns {this}
   */
  this._build = function () {
    createGLLines(!!(m_this.dataTime().timestamp() < m_this.buildTime().timestamp() && m_geometry));
    if (!m_this.renderer().contextRenderer().hasActor(m_actor)) {
      m_this.renderer().contextRenderer().addActor(m_actor);
    }
    m_this.buildTime().modified();
    return m_this;
  };

  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() <= m_this.timestamp()) {
      m_this._build();
    }
    m_pixelWidthUnif.set(1.0 / m_this.renderer().width());
    m_aspectUniform.set(m_this.renderer().width() / m_this.renderer().height());
    m_actor.setVisible(m_this.visible());
    m_actor.material().setBinNumber(m_this.bin());
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Destroy.  Free used resources.
   */
  this._exit = function () {
    m_this.renderer().contextRenderer().removeActor(m_actor);
    m_actor = null;
    s_exit();
  };
  this._init(arg);
  return this;
};
inherit(_webgl_lineFeature, lineFeature);
var capabilities = {};
capabilities[lineFeature.capabilities.basic] = true;
capabilities[lineFeature.capabilities.multicolor] = true;

// Now register it
registerFeature('webgl', 'line', _webgl_lineFeature, capabilities);
module.exports = _webgl_lineFeature;

/***/ }),

/***/ 411:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var timestamp = __webpack_require__(77);
var vgl = __webpack_require__(1611);

/**
 * Switch to a specific texture unit.
 *
 * @param {vgl.renderState} renderState An object that contains the context
 *   used for drawing.
 * @param {number} textureUnit The number of the texture unit [0-15].
 * @private
 */
function activateTextureUnit(renderState, textureUnit) {
  if (textureUnit >= 0 && textureUnit <= 31) {
    renderState.m_context.activeTexture(vgl.GL.TEXTURE0 + textureUnit);
  } else {
    throw Error('[error] Texture unit ' + textureUnit + ' is not supported');
  }
}

/**
 * Create a new instance of class webgl_lookupTable2D.
 *
 * @class
 * @alias geo.webgl.lookupTable2D
 * @param {object} arg Options object.
 * @param {number} [arg.maxWidth] Maximum width to use for the texture.  If the
 *   number of colors set is less than this, the texture is 1D.  If greater, it
 *   will be a rectangle of maxWidth x whatever height is necessary.
 * @param {number[]} [arg.colorTable] Initial color table for the texture.
 *   This is of the form RGBARGBA... where each value is an integer on the
 *   scale [0,255].
 * @extends vgl.texture
 * @returns {geo.webgl.lookupTable2D}
 */
var _webgl_lookupTable2D = function webgl_lookupTable2D(arg) {
  'use strict';

  if (!(this instanceof _webgl_lookupTable2D)) {
    return new _webgl_lookupTable2D(arg);
  }
  arg = arg || {};
  vgl.texture.call(this);
  var m_setupTimestamp = timestamp(),
    m_maxWidth = arg.maxWidth || 4096,
    m_colorTable = new Uint8Array([0, 0, 0, 0]),
    m_colorTableOrig,
    m_this = this;

  /**
   * Create lookup table, initialize parameters, and bind data to it.
   *
   * @param {vgl.renderState} renderState An object that contains the context
   *   used for drawing.
   */
  this.setup = function (renderState) {
    activateTextureUnit(renderState, m_this.textureUnit());
    renderState.m_context.deleteTexture(m_this.m_textureHandle);
    m_this.m_textureHandle = renderState.m_context.createTexture();
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, m_this.m_textureHandle);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MIN_FILTER, vgl.GL.NEAREST);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MAG_FILTER, vgl.GL.NEAREST);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_WRAP_S, vgl.GL.CLAMP_TO_EDGE);
    renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_WRAP_T, vgl.GL.CLAMP_TO_EDGE);
    renderState.m_context.pixelStorei(vgl.GL.UNPACK_ALIGNMENT, 1);
    renderState.m_context.pixelStorei(vgl.GL.UNPACK_FLIP_Y_WEBGL, true);
    renderState.m_context.texImage2D(vgl.GL.TEXTURE_2D, 0, vgl.GL.RGBA, m_this.width, m_this.height, 0, vgl.GL.RGBA, vgl.GL.UNSIGNED_BYTE, m_colorTable);
    renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
    m_setupTimestamp.modified();
  };

  /**
   * Get/set color table.
   *
   * @param {number[]} [val] An array of RGBARGBA... integers on a scale
   *   of [0, 255].  `undefined` to get the current value.
   * @returns {number[]|this}
   */
  this.colorTable = function (val) {
    if (val === undefined) {
      return m_colorTableOrig;
    }
    m_colorTableOrig = val;
    if (val.length < 4) {
      val = [0, 0, 0, 0];
    }
    m_this.width = Math.min(m_maxWidth, val.length / 4);
    m_this.height = Math.ceil(val.length / 4 / m_maxWidth);
    if (!(val instanceof Uint8Array) || val.length !== m_this.width * m_this.height * 4) {
      if (val.length < m_this.width * m_this.height * 4) {
        val = val.concat(new Array(m_this.width * m_this.height * 4 - val.length).fill(0));
      }
      m_colorTable = new Uint8Array(val);
    } else {
      m_colorTable = val;
    }
    m_this.modified();
    return m_this;
  };

  /**
   * Get maxWidth value.
   *
   * @returns {number} The maxWidth of the texture used.
   */
  this.maxWidth = function () {
    return m_maxWidth;
  };
  this.colorTable(arg.colorTable || []);
  return this;
};
inherit(_webgl_lookupTable2D, vgl.texture);
module.exports = _webgl_lookupTable2D;

/***/ }),

/***/ 3403:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var markerFeature = __webpack_require__(2225);
var webglRenderer = __webpack_require__(7945);

/**
 * Create a new instance of webgl.markerFeature.
 *
 * @class
 * @alias geo.webgl.markerFeature
 * @extends geo.markerFeature
 * @param {geo.markerFeature.spec} arg
 * @returns {geo.webgl.markerFeature}
 */
var _webgl_markerFeature = function webgl_markerFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_markerFeature)) {
    return new _webgl_markerFeature(arg);
  }
  arg = arg || {};
  markerFeature.call(this, arg);
  var vgl = __webpack_require__(1611);
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var object = __webpack_require__(4084);
  var pointUtil = __webpack_require__(2709);
  var geo_event = __webpack_require__(6409);
  var fragmentShaderPoly = __webpack_require__(9923);
  var fragmentShaderSprite = __webpack_require__(3724);
  var vertexShaderPoly = __webpack_require__(1202);
  var vertexShaderSprite = __webpack_require__(7665);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    m_actor = null,
    m_mapper = null,
    m_uniforms = {},
    m_modelViewUniform,
    m_origin,
    s_init = this._init,
    s_update = this._update,
    s_updateStyleFromArray = this.updateStyleFromArray;
  pointUtil(m_this, arg);

  /**
   * Create the vertex shader for markers.
   *
   * @returns {vgl.shader}
   */
  function createVertexShader() {
    var shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
    shader.setShaderSource(m_this._primitiveShape === markerFeature.primitiveShapes.sprite ? vertexShaderSprite : vertexShaderPoly);
    return shader;
  }

  /**
   * Create the fragment shader for markers.
   *
   * @returns {vgl.shader}
   */
  function createFragmentShader() {
    var shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
    shader.setShaderSource(m_this._primitiveShape === markerFeature.primitiveShapes.sprite ? fragmentShaderSprite : fragmentShaderPoly);
    return shader;
  }

  /**
   * Create and style the data needed to render the markers.
   *
    @param {boolean} [onlyStyle] if true, use the existing geometry and just
   *    recalculate the style.
   */
  function createGLMarkers(onlyStyle) {
    // unit and associated data is not used when drawing sprite
    var i,
      j,
      numPts = m_this.data().length,
      unit = m_this._pointPolygon(0, 0, 1, 1),
      position = new Array(numPts * 3),
      posBuf,
      posVal,
      posFunc,
      indices,
      unitBuf,
      styleBuf = {},
      styleVal = {},
      styleFunc = {},
      styleUni = {},
      styleKeys = {
        radius: 1,
        fillColor: 3,
        fillOpacity: 1,
        strokeColor: 3,
        strokeOpacity: 1,
        strokeOffset: 0,
        strokeWidth: 1,
        symbol: 1,
        symbolValue: 1,
        rotation: 1,
        scaleWithZoom: 0,
        rotateWithMap: 0,
        radiusIncludesStroke: 0
      },
      vpf = m_this.verticesPerFeature(),
      data = m_this.data(),
      item,
      ivpf,
      ivpf3,
      iunit,
      i3,
      geom = m_mapper.geometryData();
    posFunc = m_this.position();
    for (var key in styleKeys) {
      styleFunc[key] = m_this.style.get(key);
      if (!util.isFunction(m_this.style(key))) {
        styleUni[key] = styleFunc[key]();
      }
      if (styleKeys[key]) {
        styleBuf[key] = util.getGeomBuffer(geom, key, vpf * numPts * styleKeys[key]);
      }
    }
    if (!onlyStyle) {
      /* It is more efficient to do a transform on a single array rather than on
       * an array of arrays or an array of objects. */
      for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
        posVal = posFunc(data[i], i);
        position[i3] = posVal.x;
        position[i3 + 1] = posVal.y;
        // ignore the z values until we support them
        position[i3 + 2] = 0; // posVal.z || 0;
      }
      position = transform.transformCoordinates(m_this.gcs(), m_this.layer().map().gcs(), position, 3);
      m_origin = new Float32Array(m_this.style.get('origin')(position));
      if (m_origin[0] || m_origin[1] || m_origin[2]) {
        for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
          position[i3] -= m_origin[0];
          position[i3 + 1] -= m_origin[1];
          position[i3 + 2] -= m_origin[2];
        }
      }
      m_modelViewUniform.setOrigin(m_origin);
      posBuf = util.getGeomBuffer(geom, 'pos', vpf * numPts * 3);
      if (m_this._primitiveShape !== markerFeature.primitiveShapes.sprite) {
        unitBuf = util.getGeomBuffer(geom, 'unit', vpf * numPts * 2);
      }
      indices = geom.primitive(0).indices();
      if (!(indices instanceof Uint16Array) || indices.length !== vpf * numPts) {
        indices = new Uint16Array(vpf * numPts);
        geom.primitive(0).setIndices(indices);
      }
    }
    for (i = ivpf = ivpf3 = iunit = i3 = 0; i < numPts; i += 1, i3 += 3) {
      item = data[i];
      if (!onlyStyle) {
        if (m_this._primitiveShape !== markerFeature.primitiveShapes.sprite) {
          for (j = 0; j < unit.length; j += 1, iunit += 1) {
            unitBuf[iunit] = unit[j];
          }
        }
      }
      // unrolling this would speed it up
      for (var _key in styleKeys) {
        styleVal[_key] = styleUni[_key] === undefined ? styleFunc[_key](item, i) : styleUni[_key];
      }
      styleVal.scaleWithZoom = markerFeature.scaleMode[styleVal.scaleWithZoom] || (styleVal.scaleWithZoom >= 1 && styleVal.scaleWithZoom <= 3 ? styleVal.scaleWithZoom : 0);
      styleVal.symbolComputed = styleVal.scaleWithZoom + (styleVal.rotateWithMap ? 4 : 0) +
      // bit 3 reserved
      (Math.sign(styleVal.radiusIncludesStroke !== undefined && styleVal.radiusIncludesStroke ? styleVal.strokeOffset : 1) + 1) * 16 + styleVal.symbol * 64;
      if (styleVal.symbolValue && styleVal.symbol >= markerFeature.symbols.arrow && styleVal.symbol < markerFeature.symbols.arrow + markerFeature.symbols.arrowMax) {
        styleVal.symbolValue = util.packFloats(styleVal.symbolValue);
      }
      for (j = 0; j < vpf; j += 1, ivpf += 1, ivpf3 += 3) {
        if (!onlyStyle) {
          posBuf[ivpf3] = position[i3];
          posBuf[ivpf3 + 1] = position[i3 + 1];
          posBuf[ivpf3 + 2] = position[i3 + 2];
        }
        styleBuf.radius[ivpf] = styleVal.radius;
        styleBuf.fillColor[ivpf3] = styleVal.fillColor.r;
        styleBuf.fillColor[ivpf3 + 1] = styleVal.fillColor.g;
        styleBuf.fillColor[ivpf3 + 2] = styleVal.fillColor.b;
        styleBuf.fillOpacity[ivpf] = styleVal.fillOpacity;
        styleBuf.strokeColor[ivpf3] = styleVal.strokeColor.r;
        styleBuf.strokeColor[ivpf3 + 1] = styleVal.strokeColor.g;
        styleBuf.strokeColor[ivpf3 + 2] = styleVal.strokeColor.b;
        styleBuf.strokeOpacity[ivpf] = styleVal.strokeOpacity;
        styleBuf.strokeWidth[ivpf] = styleVal.strokeWidth;
        styleBuf.symbol[ivpf] = styleVal.symbolComputed;
        styleBuf.symbolValue[ivpf] = styleVal.symbolValue;
        styleBuf.rotation[ivpf] = styleVal.rotation;
      }
    }
    if (m_this._primitiveShapeAuto) {
      var maxr = m_this._approximateMaxRadius(m_this.renderer().map().zoom());
      if (m_this._primitiveShape === markerFeature.primitiveShapes.sprite && maxr > webglRenderer._maxPointSize || m_this._primitiveShape !== markerFeature.primitiveShapes.sprite && maxr <= webglRenderer._maxPointSize) {
        // Switch primitive
        m_this._primitiveShape = maxr > webglRenderer._maxPointSize ? markerFeature.primitiveShapes.triangle : markerFeature.primitiveShapes.sprite;
        m_this.renderer().contextRenderer().removeActor(m_actor);
        m_actor = null;
        m_this._init(true);
        createGLMarkers();
        return;
      }
    }
    if (!onlyStyle) {
      geom.boundsDirty(true);
      m_mapper.modified();
      m_mapper.boundsDirtyTimestamp().modified();
    } else {
      Object.keys(styleBuf).forEach(function (key) {
        return m_mapper.updateSourceBuffer(key);
      });
    }
  }

  /**
   * List vgl actors.
   *
   * @returns {vgl.actor[]} The list of actors.
   */
  this.actors = function () {
    if (!m_actor) {
      return [];
    }
    return [m_actor];
  };

  /**
   * Set style(s) from array(s).  For each style, the array should have one
   * value per data item.  The values are not converted or validated.  Color
   * values are {@link geo.geoColorObject} objects.  If invalid values are
   * given the behavior is undefined.
   *   For some feature styles, if the first entry of an array is itself an
   * array, then each entry of the array is expected to be an array, and values
   * are used from these subarrays.  This allows a style to apply, for
   * instance, per vertex of a data item rather than per data item.
   *
   * For markers, there are two special keys: `symbolComputed` and
   * `symbolValueComputed`.  If these keys are used, they are assumed to be
   * processed values that can be set in the webgl buffer directly.  The style
   * is NOT updated with these values, as they may not be directly applicable.
   * Use `symbol` and `symbolValue` for a more expected behavior.
   *
   * @param {string|object} keyOrObject Either the name of a single style or
   *    an object where the keys are the names of styles and the values are
   *    each arrays.
   * @param {array} styleArray If keyOrObject is a string, an array of values
   *    for the style.  If keyOrObject is an object, this parameter is ignored.
   * @param {boolean} [refresh] `true` to redraw the feature when it has
   *    been updated.  If an object with styles is passed, the redraw is only
   *    done once.
   * @returns {this}
   */
  this.updateStyleFromArray = function (keyOrObject, styleArray, refresh) {
    var bufferedKeys = {
      radius: 1,
      fillColor: 3,
      fillOpacity: 1,
      strokeColor: 3,
      strokeOpacity: 1,
      strokeWidth: 1,
      symbolComputed: 1,
      symbolValueComputed: 1,
      rotation: 1
    };
    var needsRefresh, needsRender;
    if (typeof keyOrObject === 'string') {
      var obj = {};
      obj[keyOrObject] = styleArray;
      keyOrObject = obj;
    }
    $.each(keyOrObject, function (key, styleArray) {
      var sbkey = key === 'symbolComputed' ? 'symbol' : key === 'symbolValueComputed' ? 'symbolValue' : key;
      if (m_this.visible() && m_actor && bufferedKeys[key] && !needsRefresh && !m_this.clustering()) {
        var vpf, mapper, buffer, numPts, value, i, j, v, bpv;
        bpv = bufferedKeys[key];
        numPts = m_this.data().length;
        mapper = m_actor.mapper();
        buffer = mapper.getSourceBuffer(sbkey);
        vpf = m_this.verticesPerFeature();
        if (!buffer || !numPts || numPts * vpf * bpv !== buffer.length) {
          needsRefresh = true;
        } else {
          switch (bufferedKeys[key]) {
            case 1:
              for (i = 0, v = 0; i < numPts; i += 1) {
                value = styleArray[i];
                for (j = 0; j < vpf; j += 1, v += 1) {
                  buffer[v] = value;
                }
              }
              break;
            case 3:
              for (i = 0, v = 0; i < numPts; i += 1) {
                value = styleArray[i];
                for (j = 0; j < vpf; j += 1, v += 3) {
                  buffer[v] = value.r;
                  buffer[v + 1] = value.g;
                  buffer[v + 2] = value.b;
                }
              }
              break;
          }
          mapper.updateSourceBuffer(sbkey);
          /* This could probably be even faster than calling _render after
           * updating the buffer, if the context's buffer was bound and
           * updated.  This would requiring knowing the webgl context and
           * probably the source to buffer mapping. */
          needsRender = true;
        }
      } else {
        needsRefresh = true;
      }
      var mod = m_this.modified;
      if (!needsRefresh && key === sbkey) {
        // don't allow modified to be adjusted if we don't need to refresh
        m_this.modified = function () {};
      }
      s_updateStyleFromArray(key, styleArray, false);
      m_this.modified = mod;
    });
    if (refresh) {
      if (m_this.visible() && needsRefresh) {
        m_this.draw();
      } else if (needsRender) {
        m_this.renderer()._render();
      }
    }
    return m_this;
  };

  /**
   * Handle zoom events for automatic primitive shape adjustment.
   *
   * @param {number} zoom The new zoom level.
   */
  this._handleZoom = function (zoom) {
    if (!m_this._primitiveShapeAuto || m_this._primitiveShape !== markerFeature.primitiveShapes.sprite) {
      return;
    }
    if (m_this._approximateMaxRadius(zoom) * 2 > webglRenderer._maxPointSize) {
      m_this._primitiveShape = markerFeature.primitiveShapes.triangle;
      m_this.renderer().contextRenderer().removeActor(m_this.actors()[0]);
      m_this._init(true);
      m_this.dataTime().modified();
      m_this.draw();
    }
  };

  /**
   * Initialize.
   *
   * @param {boolean} [reinit] If truthy, skip the parent class's init method.
   */
  this._init = function (reinit) {
    var prog = vgl.shaderProgram(),
      vertexShader = createVertexShader(),
      fragmentShader = createFragmentShader(),
      mat = vgl.material(),
      blend = vgl.blend(),
      geom = vgl.geometryData(),
      sourcePositions = vgl.sourceDataP3fv({
        name: 'pos'
      }),
      attr = {
        fillColor: 3,
        fillOpacity: 1,
        radius: 1,
        rotation: 1,
        strokeColor: 3,
        strokeOpacity: 1,
        strokeWidth: 1,
        symbol: 1,
        symbolValue: 1
      },
      uniforms = {
        pixelWidth: vgl.GL.FLOAT,
        aspect: vgl.GL.FLOAT,
        zoom: vgl.GL.FLOAT,
        rotationUniform: vgl.GL.FLOAT
      },
      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
      primitive;
    m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix', m_origin);
    if (m_this._primitiveShape === markerFeature.primitiveShapes.sprite) {
      primitive = new vgl.points();
    } else {
      primitive = new vgl.triangles();
      attr.unit = 2;
    }
    primitive.setIndices(new Uint16Array());
    if (!reinit) {
      s_init.call(m_this, arg);
    }
    m_mapper = vgl.mapper();
    prog.addVertexAttribute(vgl.vertexAttribute('pos'), vgl.vertexAttributeKeys.Position);
    geom.addSource(sourcePositions);
    Object.keys(attr).forEach(function (key, idx) {
      prog.addVertexAttribute(vgl.vertexAttribute(key), idx + 1);
      geom.addSource(vgl.sourceDataAnyfv(attr[key], idx + 1, {
        name: key
      }));
    });
    m_uniforms = {};
    Object.keys(uniforms).forEach(function (key) {
      m_uniforms[key] = new vgl.uniform(uniforms[key], key);
      prog.addUniform(m_uniforms[key]);
    });
    prog.addUniform(m_modelViewUniform);
    prog.addUniform(projectionUniform);
    prog.addShader(fragmentShader);
    prog.addShader(vertexShader);
    mat.addAttribute(prog);
    mat.addAttribute(blend);
    m_actor = vgl.actor();
    m_actor.setMaterial(mat);
    m_actor.setMapper(m_mapper);
    geom.addPrimitive(primitive);
    /* We don't need vgl to compute bounds, so make the geo.computeBounds just
     * set them to 0. */
    geom.computeBounds = function () {
      geom.setBounds(0, 0, 0, 0, 0, 0);
    };
    m_mapper.setGeometryData(geom);
    if (!reinit) {
      m_this.geoOn(geo_event.zoom, function (evt) {
        m_this._handleZoom(evt.zoomLevel);
      });
    }
  };

  /**
   * Build.  Create the necessary elements to render markers.
   *
   * @returns {this}
   */
  this._build = function () {
    createGLMarkers(m_this.dataTime().timestamp() < m_this.buildTime().timestamp());
    if (!m_this.renderer().contextRenderer().hasActor(m_actor)) {
      m_this.renderer().contextRenderer().addActor(m_actor);
    }
    m_this.buildTime().modified();
    return m_this;
  };

  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);

    // For now build if the data or style changes. In the future we may
    // we able to partially update the data using dynamic gl buffers.
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }

    // Update uniforms
    m_uniforms.pixelWidth.set(2.0 / m_this.renderer().width());
    m_uniforms.aspect.set(m_this.renderer().width() / m_this.renderer().height());
    m_uniforms.zoom.set(m_this.renderer().map().zoom());
    m_uniforms.rotationUniform.set(m_this.renderer().map().rotation());
    m_actor.setVisible(m_this.visible());
    m_actor.material().setBinNumber(m_this.bin());
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Destroy.  Free used resources.
   */
  this._exit = function () {
    m_this.renderer().contextRenderer().removeActor(m_actor);
    m_actor = null;
    m_uniforms = {};
    s_exit();
  };
  m_this._init();
  return this;
};
inherit(_webgl_markerFeature, markerFeature);
var capabilities = {};

// Now register it
registerFeature('webgl', 'marker', _webgl_markerFeature, capabilities);
module.exports = _webgl_markerFeature;

/***/ }),

/***/ 2778:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * Create a new instance of meshColored.
 *
 * @class
 * @alias geo.webgl.meshColored
 * @param {geo.meshColored.spec} arg
 * @returns {geo.webgl.meshColored}
 */
var webgl_meshColored = function webgl_meshColored(arg) {
  'use strict';

  arg = arg || {};
  var vgl = __webpack_require__(1611);
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var fragmentShader = __webpack_require__(428);
  var vertexShader = __webpack_require__(4993);
  var object = __webpack_require__(4084);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    m_textureUnit = 7,
    m_actor = null,
    m_mapper = null,
    m_material = null,
    m_texture = null,
    m_minColorUniform = null,
    m_maxColorUniform = null,
    m_stepsUniform = null,
    m_steppedUniform = null,
    m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
    m_origin,
    m_modelViewUniform,
    s_init = this._init,
    s_update = this._update;
  function createVertexShader() {
    var shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
    shader.setShaderSource(vertexShader);
    return shader;
  }
  function createFragmentShader() {
    var shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
    shader.setShaderSource(fragmentShader);
    return shader;
  }

  /**
   * Create the colored mesh.  The generated geometry is loaded into the
   * various gl uniforms and buffers.
   *
   * @param {geo.meshFeature.meshColoredInfo} mesh The mesh to draw.
   */
  this.createGLMeshColored = function (mesh) {
    var numPts = mesh.elements.length,
      colorTable = [],
      i,
      i3,
      j,
      j3,
      e,
      posBuf,
      opacityBuf,
      valueBuf,
      indicesBuf,
      geom = m_mapper.geometryData();
    m_minColorUniform.set([mesh.minColor.r, mesh.minColor.g, mesh.minColor.b, mesh.minColor.a]);
    m_maxColorUniform.set([mesh.maxColor.r, mesh.maxColor.g, mesh.maxColor.b, mesh.maxColor.a]);
    m_stepsUniform.set(mesh.colorMap.length);
    m_steppedUniform.set(mesh.stepped);
    // pad the colortable by repeating the end colors an extra time to ensure
    // interpolation never goes off of the colormap.
    for (i = -1; i < mesh.colorMap.length + 1; i += 1) {
      j = Math.max(0, Math.min(mesh.colorMap.length - 1, i));
      colorTable.push(mesh.colorMap[j].r * 255);
      colorTable.push(mesh.colorMap[j].g * 255);
      colorTable.push(mesh.colorMap[j].b * 255);
      colorTable.push(mesh.colorMap[j].a * 255);
    }
    m_texture.setColorTable(colorTable);
    mesh.pos = transform.transformCoordinates(m_this.gcs(), m_this.layer().map().gcs(), mesh.pos, 3);
    m_origin = new Float32Array(m_this.style.get('origin')(mesh.pos));
    if (m_origin[0] || m_origin[1] || m_origin[2]) {
      for (i = 0; i < mesh.pos.length; i += 3) {
        mesh.pos[i] -= m_origin[0];
        mesh.pos[i + 1] -= m_origin[1];
        mesh.pos[i + 2] -= m_origin[2];
      }
    }
    m_modelViewUniform.setOrigin(m_origin);
    posBuf = util.getGeomBuffer(geom, 'pos', numPts * 3);
    opacityBuf = util.getGeomBuffer(geom, 'opacity', numPts);
    valueBuf = util.getGeomBuffer(geom, 'value', numPts);
    for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
      j = mesh.elements[i];
      j3 = j * 3;
      posBuf[i3] = mesh.pos[j3];
      posBuf[i3 + 1] = mesh.pos[j3 + 1];
      posBuf[i3 + 2] = mesh.pos[j3 + 2];
      e = mesh.elementValues ? Math.floor(i / 3) : j;
      opacityBuf[i] = mesh.opacity[e];
      valueBuf[i] = mesh.value[e];
    }
    indicesBuf = geom.primitive(0).indices();
    if (!(indicesBuf instanceof Uint16Array) || indicesBuf.length !== numPts) {
      indicesBuf = new Uint16Array(numPts);
      geom.primitive(0).setIndices(indicesBuf);
    }
    geom.boundsDirty(true);
    m_mapper.modified();
    m_mapper.boundsDirtyTimestamp().modified();
  };

  /**
   * Initialize.
   *
   * @param {geo.meshColored.spec} arg The contour feature specification.
   */
  this._init = function (arg) {
    var blend = vgl.blend(),
      prog = vgl.shaderProgram(),
      mat = vgl.material(),
      tex = vgl.lookupTable(),
      geom = vgl.geometryData(),
      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
      samplerUniform = new vgl.uniform(vgl.GL.INT, 'sampler2d'),
      vertexShader = createVertexShader(),
      fragmentShader = createFragmentShader(),
      posAttr = vgl.vertexAttribute('pos'),
      valueAttr = vgl.vertexAttribute('value'),
      opacityAttr = vgl.vertexAttribute('opacity'),
      sourcePositions = vgl.sourceDataP3fv({
        name: 'pos'
      }),
      sourceValues = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.One, {
        name: 'value'
      }),
      sourceOpacity = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Two, {
        name: 'opacity'
      }),
      primitive = new vgl.triangles();
    m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix');
    s_init.call(m_this, arg);
    m_mapper = vgl.mapper({
      dynamicDraw: m_dynamicDraw
    });
    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
    prog.addVertexAttribute(valueAttr, vgl.vertexAttributeKeysIndexed.One);
    prog.addVertexAttribute(opacityAttr, vgl.vertexAttributeKeysIndexed.Two);
    prog.addUniform(m_modelViewUniform);
    prog.addUniform(projectionUniform);
    m_minColorUniform = new vgl.uniform(vgl.GL.FLOAT_VEC4, 'minColor');
    prog.addUniform(m_minColorUniform);
    m_maxColorUniform = new vgl.uniform(vgl.GL.FLOAT_VEC4, 'maxColor');
    prog.addUniform(m_maxColorUniform);
    /* steps is always an integer, but it is more efficient if we use a float
     */
    m_stepsUniform = new vgl.uniform(vgl.GL.FLOAT, 'steps');
    prog.addUniform(m_stepsUniform);
    m_steppedUniform = new vgl.uniform(vgl.GL.BOOL, 'stepped');
    prog.addUniform(m_steppedUniform);
    prog.addShader(fragmentShader);
    prog.addShader(vertexShader);
    prog.addUniform(samplerUniform);
    tex.setTextureUnit(m_textureUnit);
    samplerUniform.set(m_textureUnit);
    m_material = mat;
    m_material.addAttribute(prog);
    m_material.addAttribute(blend);
    m_texture = tex;
    m_material.addAttribute(m_texture);
    m_actor = vgl.actor();
    m_actor.setMaterial(m_material);
    m_actor.setMapper(m_mapper);
    geom.addSource(sourcePositions);
    geom.addSource(sourceValues);
    geom.addSource(sourceOpacity);
    geom.addPrimitive(primitive);
    /* We don't need vgl to compute bounds, so make the geo.computeBounds just
     * set them to 0. */
    geom.computeBounds = function () {
      geom.setBounds(0, 0, 0, 0, 0, 0);
    };
    m_mapper.setGeometryData(geom);
  };

  /**
   * List vgl actors.
   *
   * @returns {vgl.actor[]} The list of actors.
   */
  this.actors = function () {
    return m_actor ? [m_actor] : [];
  };

  /**
   * Update.
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() <= m_this.timestamp()) {
      m_this._build();
    }
    m_actor.setVisible(m_this.visible());
    m_actor.material().setBinNumber(m_this.bin());
    m_this.updateTime().modified();
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    m_this.renderer().contextRenderer().removeActor(m_actor);
    s_exit();
  };
  return this;
};
module.exports = webgl_meshColored;

/***/ }),

/***/ 4084:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * WebGL specific subclass of object which rerenders when the object is drawn.
 *
 * @class
 * @alias geo.webgl.object
 * @extends geo.sceneObject
 * @param {object} arg Options for the object.
 * @returns {geo.webgl.object}
 */
var _webgl_object = function webgl_object(arg) {
  'use strict';

  var object = __webpack_require__(1338);

  // this is used to extend other geojs classes, so only generate
  // a new object when that is not the case... like if this === window
  if (!(this instanceof object)) {
    return new _webgl_object(arg);
  }
  var m_this = this,
    s_draw = this.draw;

  /**
   * Redraw the object.
   *
   * @returns {this}
   */
  this.draw = function () {
    if (m_this.ready) {
      m_this._update({
        mayDelay: true
      });
      m_this.renderer()._render();
      s_draw();
    }
    return m_this;
  };
  if (this.bin) {
    var s_bin = this.bin;

    /**
     * Get/Set bin of the feature.  The bin number is used to determine the
     * order of multiple features on the same layer.  It has no effect except
     * on the webgl renderer.  A negative value hides the feature without
     * stopping interaction with it.  Otherwise, features with higher bin
     * numbers are drawn above those with lower bin numbers.  If two features
     * have the same bin number, their order relative to one another is
     * indeterminate and may be unstable.
     *
     * @param {number} [val] The new bin number.  If `undefined`, return the
     *    current bin number.  If `null`, the bin is dynamically computed based
     *    on order within the parent.  If children are nested, this may not be
     *    what is desired.
     * @param {boolean} [actualValue] If truthy and `val` is undefined, return
     *    the actual value of bin, rather than the dynamically computed value.
     * @returns {number|this} The current bin number or a reference to `this`.
     */
    this.bin = function (val, actualValue) {
      if (val === undefined && !actualValue && s_bin(undefined, true) === null) {
        var layer = m_this.layer && m_this.layer(),
          map = layer && layer.map && layer.map(),
          objectList = map && map.listSceneObjects() || [],
          pos = objectList.indexOf(m_this);
        if (pos >= 0) {
          return pos;
        }
      }
      return s_bin.apply(m_this, arguments);
    };
  }
  return this;
};
module.exports = _webgl_object;

/***/ }),

/***/ 7759:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var pixelmapFeature = __webpack_require__(7761);
var lookupTable2D = __webpack_require__(411);
var util = __webpack_require__(642);

/**
 * Create a new instance of class webgl.pixelmapFeature.
 *
 * @class
 * @alias geo.webgl.pixelmapFeature
 * @extends geo.pixelmapFeature
 * @param {geo.pixelmapFeature.spec} arg
 * @returns {geo.webgl.pixelmapFeature}
 */
var _webgl_pixelmapFeature = function webgl_pixelmapFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_pixelmapFeature)) {
    return new _webgl_pixelmapFeature(arg);
  }
  pixelmapFeature.call(this, arg);
  var object = __webpack_require__(4084);
  object.call(this);
  var vgl = __webpack_require__(1611);
  var fragmentShader = __webpack_require__(3925);
  var m_quadFeature,
    m_quadFeatureInit,
    s_exit = this._exit,
    m_lookupTable,
    m_this = this;

  /**
   * If the specified coordinates are in the rendered quad, use the basis
   * information from the quad to determine the pixelmap index value so that it
   * can be included in the `found` results.
   *
   * @param {geo.geoPosition} geo Coordinate.
   * @param {string|geo.transform|null} [gcs] Input gcs.  `undefined` to use
   *    the interface gcs, `null` to use the map gcs, or any other transform.
   * @returns {geo.feature.searchResult} An object with a list of features and
   *    feature indices that are located at the specified point.
   */
  this.pointSearch = function (geo, gcs) {
    if (m_quadFeature && m_this.m_info) {
      var result = m_quadFeature.pointSearch(geo, gcs);
      return this._pointSearchProcess(result);
    }
    return {
      index: [],
      found: []
    };
  };

  /**
   * Given the loaded pixelmap image, create a texture for the colors and a
   * quad that will use it.
   */
  this._computePixelmap = function () {
    var data = m_this.data() || [],
      colorFunc = m_this.style.get('color');
    var indexRange = m_this.indexModified(undefined, 'clear');
    var fullUpdate = m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || indexRange === undefined;
    if (!m_lookupTable) {
      m_lookupTable = lookupTable2D();
      m_lookupTable.setTextureUnit(1);
      fullUpdate = true;
    }
    var clrLen = Math.max(1, data.length);
    var maxWidth = m_lookupTable.maxWidth();
    if (clrLen > maxWidth && clrLen % maxWidth) {
      clrLen += maxWidth - clrLen % maxWidth;
    }
    var colors;
    if (!fullUpdate) {
      colors = m_lookupTable.colorTable();
      fullUpdate = colors.length !== clrLen * 4;
      indexRange[0] = Math.max(0, indexRange[0]);
      indexRange[1] = Math.min(data.length, indexRange[1] + 1);
    }
    if (fullUpdate) {
      colors = new Uint8Array(clrLen * 4);
      indexRange = [0, data.length];
    }
    for (var i = indexRange[0]; i < indexRange[1]; i += 1) {
      var d = data[i];
      var color = util.convertColor(colorFunc.call(m_this, d, i));
      colors[i * 4] = color.r * 255;
      colors[i * 4 + 1] = color.g * 255;
      colors[i * 4 + 2] = color.b * 255;
      colors[i * 4 + 3] = color.a === undefined ? 255 : color.a * 255;
    }
    m_this.m_info = {
      colors: colors
    };
    // check if colors haven't changed
    var oldcolors = m_lookupTable.colorTable();
    if (oldcolors && oldcolors.length === colors.length) {
      var idx = indexRange[0] * 4;
      for (; idx < indexRange[1] * 4; idx += 1) {
        if (colors[idx] !== oldcolors[idx]) {
          break;
        }
      }
      if (idx === indexRange[1] * 4) {
        return;
      }
    }
    m_lookupTable.colorTable(colors);
    /* If we haven't made a quad feature, make one now */
    if (!m_quadFeature) {
      m_quadFeature = m_this.layer().createFeature('quad', {
        selectionAPI: false,
        gcs: m_this.gcs(),
        visible: m_this.visible(undefined, true),
        nearestPixel: true
      });
      m_quadFeatureInit = false;
    }
    if (!m_quadFeatureInit) {
      m_this.dependentFeatures([m_quadFeature]);
      m_quadFeature.setShader('image_fragment', fragmentShader);
      m_quadFeature._hookBuild = function (prog) {
        var lutSampler = new vgl.uniform(vgl.GL.INT, 'lutSampler');
        lutSampler.set(m_lookupTable.textureUnit());
        prog.addUniform(lutSampler);
        var lutWidth = new vgl.uniform(vgl.GL.INT, 'lutWidth');
        lutWidth.set(m_lookupTable.width);
        prog.addUniform(lutWidth);
        var lutHeight = new vgl.uniform(vgl.GL.INT, 'lutHeight');
        lutHeight.set(m_lookupTable.height);
        prog.addUniform(lutHeight);
      };
      m_quadFeature._hookRenderImageQuads = function (renderState, quads) {
        m_lookupTable.bind(renderState, quads);
      };
      if (m_quadFeatureInit === false) {
        m_quadFeature.style({
          image: m_this.m_srcImage,
          position: m_this.style.get('position')
        }).data([{}]).draw();
      }
      m_quadFeatureInit = true;
    }
  };

  /**
   * Destroy.  Deletes the associated quadFeature.
   *
   * @returns {this}
   */
  this._exit = function () {
    if (m_quadFeature && m_this.layer()) {
      m_this.layer().deleteFeature(m_quadFeature);
      m_quadFeature = null;
      m_this.dependentFeatures([]);
    }
    s_exit();
    return m_this;
  };
  if (arg.quadFeature) {
    m_quadFeature = arg.quadFeature;
    if (m_quadFeature.nearestPixel) {
      m_quadFeature.nearestPixel(true);
    }
  }
  this._init(arg);
  return this;
};
inherit(_webgl_pixelmapFeature, pixelmapFeature);

// Now register it
var capabilities = {};
capabilities[pixelmapFeature.capabilities.lookup] = true;
registerFeature('webgl', 'pixelmap', _webgl_pixelmapFeature, capabilities);
module.exports = _webgl_pixelmapFeature;

/***/ }),

/***/ 5407:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var $ = __webpack_require__(5616);
var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var pointFeature = __webpack_require__(7541);
var webglRenderer = __webpack_require__(7945);

/**
 * Create a new instance of webgl.pointFeature.
 *
 * @class
 * @alias geo.webgl.pointFeature
 * @extends geo.pointFeature
 * @param {geo.pointFeature.spec} arg
 * @returns {geo.webgl.pointFeature}
 */
var _webgl_pointFeature = function webgl_pointFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_pointFeature)) {
    return new _webgl_pointFeature(arg);
  }
  arg = arg || {};
  pointFeature.call(this, arg);
  var vgl = __webpack_require__(1611);
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var object = __webpack_require__(4084);
  var pointUtil = __webpack_require__(2709);
  var fragmentShaderPoly = __webpack_require__(4317);
  var fragmentShaderSprite = __webpack_require__(2682);
  var vertexShaderPoly = __webpack_require__(8208);
  var vertexShaderSprite = __webpack_require__(6979);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    m_actor = null,
    m_mapper = null,
    m_pixelWidthUniform = null,
    m_aspectUniform = null,
    m_dynamicDraw = arg.dynamicDraw === undefined ? false : arg.dynamicDraw,
    m_modelViewUniform,
    m_origin,
    s_init = this._init,
    s_update = this._update,
    s_updateStyleFromArray = this.updateStyleFromArray;
  pointUtil(m_this, arg);

  /**
   * Create the vertex shader for points.
   *
   * @returns {vgl.shader}
   */
  function createVertexShader() {
    var shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
    shader.setShaderSource(m_this._primitiveShape === pointFeature.primitiveShapes.sprite ? vertexShaderSprite : vertexShaderPoly);
    return shader;
  }

  /**
   * Create the fragment shader for points.
   *
   * @returns {vgl.shader}
   */
  function createFragmentShader() {
    var shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
    shader.setShaderSource(m_this._primitiveShape === pointFeature.primitiveShapes.sprite ? fragmentShaderSprite : fragmentShaderPoly);
    return shader;
  }

  /**
   * Create and style the data needed to render the points.
   *
   * @param {boolean} [onlyStyle] if true, use the existing geometry and just
   *    recalculate the style.
   */
  function createGLPoints(onlyStyle) {
    // unit and associated data is not used when drawing sprite
    var i,
      j,
      numPts = m_this.data().length,
      unit = m_this._pointPolygon(0, 0, 1, 1),
      position = new Array(numPts * 3),
      posBuf,
      posVal,
      posFunc,
      unitBuf,
      indices,
      radius,
      radiusVal,
      radFunc,
      stroke,
      strokeVal,
      strokeFunc,
      strokeWidth,
      strokeWidthVal,
      strokeWidthFunc,
      strokeOpacity,
      strokeOpacityVal,
      strokeOpacityFunc,
      strokeColor,
      strokeColorVal,
      strokeColorFunc,
      fill,
      fillVal,
      fillFunc,
      fillOpacity,
      fillOpacityVal,
      fillOpacityFunc,
      fillColor,
      fillColorVal,
      fillColorFunc,
      vpf = m_this.verticesPerFeature(),
      data = m_this.data(),
      item,
      ivpf,
      ivpf3,
      iunit,
      i3,
      maxr = 0,
      geom = m_mapper.geometryData();
    posFunc = m_this.position();
    radFunc = m_this.style.get('radius');
    strokeFunc = m_this.style.get('stroke');
    strokeWidthFunc = m_this.style.get('strokeWidth');
    strokeOpacityFunc = m_this.style.get('strokeOpacity');
    strokeColorFunc = m_this.style.get('strokeColor');
    fillFunc = m_this.style.get('fill');
    fillOpacityFunc = m_this.style.get('fillOpacity');
    fillColorFunc = m_this.style.get('fillColor');
    if (!onlyStyle) {
      /* It is more efficient to do a transform on a single array rather than on
       * an array of arrays or an array of objects. */
      for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
        posVal = posFunc(data[i], i);
        position[i3] = posVal.x;
        position[i3 + 1] = posVal.y;
        // ignore the z values until we support them
        position[i3 + 2] = 0; // posVal.z || 0;
      }
      position = transform.transformCoordinates(m_this.gcs(), m_this.layer().map().gcs(), position, 3);
      m_origin = new Float32Array(m_this.style.get('origin')(position));
      if (m_origin[0] || m_origin[1] || m_origin[2]) {
        for (i = i3 = 0; i < numPts; i += 1, i3 += 3) {
          position[i3] -= m_origin[0];
          position[i3 + 1] -= m_origin[1];
          position[i3 + 2] -= m_origin[2];
        }
      }
      m_modelViewUniform.setOrigin(m_origin);
      posBuf = util.getGeomBuffer(geom, 'pos', vpf * numPts * 3);
      unitBuf = util.getGeomBuffer(geom, 'unit', vpf * numPts * 2);
      indices = geom.primitive(0).indices();
      if (!(indices instanceof Uint16Array) || indices.length !== vpf * numPts) {
        indices = new Uint16Array(vpf * numPts);
        geom.primitive(0).setIndices(indices);
      }
    }
    radius = util.getGeomBuffer(geom, 'radius', vpf * numPts);
    stroke = util.getGeomBuffer(geom, 'stroke', vpf * numPts);
    strokeWidth = util.getGeomBuffer(geom, 'strokeWidth', vpf * numPts);
    strokeOpacity = util.getGeomBuffer(geom, 'strokeOpacity', vpf * numPts);
    strokeColor = util.getGeomBuffer(geom, 'strokeColor', vpf * numPts * 3);
    fill = util.getGeomBuffer(geom, 'fill', vpf * numPts);
    fillOpacity = util.getGeomBuffer(geom, 'fillOpacity', vpf * numPts);
    fillColor = util.getGeomBuffer(geom, 'fillColor', vpf * numPts * 3);
    for (i = ivpf = ivpf3 = iunit = i3 = 0; i < numPts; i += 1, i3 += 3) {
      item = data[i];
      if (!onlyStyle) {
        if (m_this._primitiveShape !== pointFeature.primitiveShapes.sprite) {
          for (j = 0; j < unit.length; j += 1, iunit += 1) {
            unitBuf[iunit] = unit[j];
          }
        }
      }
      /* We can ignore the indices (they will all be zero) */
      radiusVal = radFunc(item, i);
      strokeVal = strokeFunc(item, i) ? 1.0 : 0.0;
      strokeWidthVal = strokeWidthFunc(item, i);
      strokeOpacityVal = strokeOpacityFunc(item, i);
      strokeColorVal = strokeColorFunc(item, i);
      fillVal = fillFunc(item, i) ? 1.0 : 0.0;
      fillOpacityVal = fillOpacityFunc(item, i);
      fillColorVal = fillColorFunc(item, i);
      if (m_this._primitiveShapeAuto && (fillVal && fillOpacityVal || strokeVal && strokeOpacityVal) && radiusVal + (strokeVal && strokeOpacityVal ? strokeWidthVal : 0) > maxr) {
        maxr = radiusVal + (strokeVal && strokeOpacityVal ? strokeWidthVal : 0);
      }
      for (j = 0; j < vpf; j += 1, ivpf += 1, ivpf3 += 3) {
        if (!onlyStyle) {
          posBuf[ivpf3] = position[i3];
          posBuf[ivpf3 + 1] = position[i3 + 1];
          posBuf[ivpf3 + 2] = position[i3 + 2];
        }
        radius[ivpf] = radiusVal;
        stroke[ivpf] = strokeVal;
        strokeWidth[ivpf] = strokeWidthVal;
        strokeOpacity[ivpf] = strokeOpacityVal;
        strokeColor[ivpf3] = strokeColorVal.r;
        strokeColor[ivpf3 + 1] = strokeColorVal.g;
        strokeColor[ivpf3 + 2] = strokeColorVal.b;
        fill[ivpf] = fillVal;
        fillOpacity[ivpf] = fillOpacityVal;
        fillColor[ivpf3] = fillColorVal.r;
        fillColor[ivpf3 + 1] = fillColorVal.g;
        fillColor[ivpf3 + 2] = fillColorVal.b;
      }
    }
    if (m_this._primitiveShapeAuto && (m_this._primitiveShape === pointFeature.primitiveShapes.sprite && maxr > webglRenderer._maxPointSize || m_this._primitiveShape !== pointFeature.primitiveShapes.sprite && maxr <= webglRenderer._maxPointSize)) {
      // Switch primitive
      m_this._primitiveShape = maxr > webglRenderer._maxPointSize ? pointFeature.primitiveShapes.triangle : pointFeature.primitiveShapes.sprite;
      m_this.renderer().contextRenderer().removeActor(m_actor);
      m_actor = null;
      m_this._init(true);
      createGLPoints();
      return;
    }
    if (!onlyStyle) {
      geom.boundsDirty(true);
      m_mapper.modified();
      m_mapper.boundsDirtyTimestamp().modified();
    } else {
      m_mapper.updateSourceBuffer('radius');
      m_mapper.updateSourceBuffer('stroke');
      m_mapper.updateSourceBuffer('strokeWidth');
      m_mapper.updateSourceBuffer('strokeColor');
      m_mapper.updateSourceBuffer('strokeOpacity');
      m_mapper.updateSourceBuffer('fill');
      m_mapper.updateSourceBuffer('fillColor');
      m_mapper.updateSourceBuffer('fillOpacity');
    }
  }

  /**
   * List vgl actors.
   *
   * @returns {vgl.actor[]} The list of actors.
   */
  this.actors = function () {
    if (!m_actor) {
      return [];
    }
    return [m_actor];
  };

  /**
   * Set style(s) from array(s).  For each style, the array should have one
   * value per data item.  The values are not converted or validated.  Color
   * values are {@link geo.geoColorObject} objects.  If invalid values are
   * given the behavior is undefined.
   *   For some feature styles, if the first entry of an array is itself an
   * array, then each entry of the array is expected to be an array, and values
   * are used from these subarrays.  This allows a style to apply, for
   * instance, per vertex of a data item rather than per data item.
   *
   * @param {string|object} keyOrObject Either the name of a single style or
   *    an object where the keys are the names of styles and the values are
   *    each arrays.
   * @param {array} styleArray If keyOrObject is a string, an array of values
   *    for the style.  If keyOrObject is an object, this parameter is ignored.
   * @param {boolean} [refresh] `true` to redraw the feature when it has
   *    been updated.  If an object with styles is passed, the redraw is only
   *    done once.
   * @returns {this}
   */
  this.updateStyleFromArray = function (keyOrObject, styleArray, refresh) {
    var bufferedKeys = {
      fill: 'bool',
      fillColor: 3,
      fillOpacity: 1,
      radius: 1,
      stroke: 'bool',
      strokeColor: 3,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var needsRefresh, needsRender;
    if (typeof keyOrObject === 'string') {
      var obj = {};
      obj[keyOrObject] = styleArray;
      keyOrObject = obj;
    }
    $.each(keyOrObject, function (key, styleArray) {
      if (m_this.visible() && m_actor && bufferedKeys[key] && !needsRefresh && !m_this.clustering()) {
        var vpf, mapper, buffer, numPts, value, i, j, v, bpv;
        bpv = bufferedKeys[key] === 'bool' ? 1 : bufferedKeys[key];
        numPts = m_this.data().length;
        mapper = m_actor.mapper();
        buffer = mapper.getSourceBuffer(key);
        vpf = m_this.verticesPerFeature();
        if (!buffer || !numPts || numPts * vpf * bpv !== buffer.length) {
          needsRefresh = true;
        } else {
          switch (bufferedKeys[key]) {
            case 1:
              for (i = 0, v = 0; i < numPts; i += 1) {
                value = styleArray[i];
                for (j = 0; j < vpf; j += 1, v += 1) {
                  buffer[v] = value;
                }
              }
              break;
            case 3:
              for (i = 0, v = 0; i < numPts; i += 1) {
                value = styleArray[i];
                for (j = 0; j < vpf; j += 1, v += 3) {
                  buffer[v] = value.r;
                  buffer[v + 1] = value.g;
                  buffer[v + 2] = value.b;
                }
              }
              break;
            case 'bool':
              for (i = 0, v = 0; i < numPts; i += 1) {
                value = styleArray[i] ? 1.0 : 0.0;
                for (j = 0; j < vpf; j += 1, v += 1) {
                  buffer[v] = value;
                }
              }
              break;
          }
          mapper.updateSourceBuffer(key);
          /* This could probably be even faster than calling _render after
           * updating the buffer, if the context's buffer was bound and
           * updated.  This would requiring knowing the webgl context and
           * probably the source to buffer mapping. */
          needsRender = true;
        }
      } else {
        needsRefresh = true;
      }
      var mod = m_this.modified;
      if (!needsRefresh) {
        // don't allow modified to be adjusted if we don't need to refresh
        m_this.modified = function () {};
      }
      s_updateStyleFromArray(key, styleArray, false);
      m_this.modified = mod;
    });
    if (refresh) {
      if (m_this.visible() && needsRefresh) {
        m_this.draw();
      } else if (needsRender) {
        m_this.renderer()._render();
      }
    }
    return m_this;
  };

  /**
   * Initialize.
   *
   * @param {boolean} [reinit] If truthy, skip the parent class's init method.
   */
  this._init = function (reinit) {
    var prog = vgl.shaderProgram(),
      vertexShader = createVertexShader(),
      fragmentShader = createFragmentShader(),
      posAttr = vgl.vertexAttribute('pos'),
      unitAttr = vgl.vertexAttribute('unit'),
      radAttr = vgl.vertexAttribute('radius'),
      strokeWidthAttr = vgl.vertexAttribute('strokeWidth'),
      fillColorAttr = vgl.vertexAttribute('fillColor'),
      fillAttr = vgl.vertexAttribute('fill'),
      strokeColorAttr = vgl.vertexAttribute('strokeColor'),
      strokeAttr = vgl.vertexAttribute('stroke'),
      fillOpacityAttr = vgl.vertexAttribute('fillOpacity'),
      strokeOpacityAttr = vgl.vertexAttribute('strokeOpacity'),
      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
      mat = vgl.material(),
      blend = vgl.blend(),
      geom = vgl.geometryData(),
      sourcePositions = vgl.sourceDataP3fv({
        name: 'pos'
      }),
      sourceUnits = vgl.sourceDataAnyfv(2, vgl.vertexAttributeKeysIndexed.One, {
        name: 'unit'
      }),
      sourceRadius = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Two, {
        name: 'radius'
      }),
      sourceStrokeWidth = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Three, {
        name: 'strokeWidth'
      }),
      sourceFillColor = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Four, {
        name: 'fillColor'
      }),
      sourceFill = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Five, {
        name: 'fill'
      }),
      sourceStrokeColor = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Six, {
        name: 'strokeColor'
      }),
      sourceStroke = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Seven, {
        name: 'stroke'
      }),
      sourceAlpha = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Eight, {
        name: 'fillOpacity'
      }),
      sourceStrokeOpacity = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Nine, {
        name: 'strokeOpacity'
      }),
      primitive;
    m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix', m_origin);
    if (m_this._primitiveShape === pointFeature.primitiveShapes.sprite) {
      primitive = new vgl.points();
    } else {
      primitive = new vgl.triangles();
    }
    primitive.setIndices(new Uint16Array());
    m_pixelWidthUniform = new vgl.floatUniform('pixelWidth', 2.0 / m_this.renderer().width());
    m_aspectUniform = new vgl.floatUniform('aspect', m_this.renderer().width() / m_this.renderer().height());
    if (!reinit) {
      s_init.call(m_this, arg);
    }
    m_mapper = vgl.mapper({
      dynamicDraw: m_dynamicDraw
    });
    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
    if (m_this._primitiveShape !== pointFeature.primitiveShapes.sprite) {
      prog.addVertexAttribute(unitAttr, vgl.vertexAttributeKeysIndexed.One);
    }
    prog.addVertexAttribute(radAttr, vgl.vertexAttributeKeysIndexed.Two);
    prog.addVertexAttribute(strokeWidthAttr, vgl.vertexAttributeKeysIndexed.Three);
    prog.addVertexAttribute(fillColorAttr, vgl.vertexAttributeKeysIndexed.Four);
    prog.addVertexAttribute(fillAttr, vgl.vertexAttributeKeysIndexed.Five);
    prog.addVertexAttribute(strokeColorAttr, vgl.vertexAttributeKeysIndexed.Six);
    prog.addVertexAttribute(strokeAttr, vgl.vertexAttributeKeysIndexed.Seven);
    prog.addVertexAttribute(fillOpacityAttr, vgl.vertexAttributeKeysIndexed.Eight);
    prog.addVertexAttribute(strokeOpacityAttr, vgl.vertexAttributeKeysIndexed.Nine);
    prog.addUniform(m_pixelWidthUniform);
    prog.addUniform(m_aspectUniform);
    prog.addUniform(m_modelViewUniform);
    prog.addUniform(projectionUniform);
    prog.addShader(fragmentShader);
    prog.addShader(vertexShader);
    mat.addAttribute(prog);
    mat.addAttribute(blend);
    m_actor = vgl.actor();
    m_actor.setMaterial(mat);
    m_actor.setMapper(m_mapper);
    geom.addSource(sourcePositions);
    geom.addSource(sourceUnits);
    geom.addSource(sourceRadius);
    geom.addSource(sourceStrokeWidth);
    geom.addSource(sourceFillColor);
    geom.addSource(sourceFill);
    geom.addSource(sourceStrokeColor);
    geom.addSource(sourceStroke);
    geom.addSource(sourceAlpha);
    geom.addSource(sourceStrokeOpacity);
    geom.addPrimitive(primitive);
    /* We don't need vgl to compute bounds, so make the geo.computeBounds just
     * set them to 0. */
    geom.computeBounds = function () {
      geom.setBounds(0, 0, 0, 0, 0, 0);
    };
    m_mapper.setGeometryData(geom);
  };

  /**
   * Build.  Create the necessary elements to render points.
   *
   * @returns {this}
   */
  this._build = function () {
    createGLPoints(m_this.dataTime().timestamp() < m_this.buildTime().timestamp());
    if (!m_this.renderer().contextRenderer().hasActor(m_actor)) {
      m_this.renderer().contextRenderer().addActor(m_actor);
    }
    m_this.buildTime().modified();
    return m_this;
  };

  /**
   * Update.  Rebuild if necessary.
   *
   * @returns {this}
   */
  this._update = function () {
    s_update.call(m_this);

    // For now build if the data or style changes. In the future we may
    // we able to partially update the data using dynamic gl buffers.
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }

    // Update uniforms
    m_pixelWidthUniform.set(2.0 / m_this.renderer().width());
    m_aspectUniform.set(m_this.renderer().width() / m_this.renderer().height());
    m_actor.setVisible(m_this.visible());
    m_actor.material().setBinNumber(m_this.bin());
    m_this.updateTime().modified();
    return m_this;
  };

  /**
   * Destroy.  Free used resources.
   */
  this._exit = function () {
    m_this.renderer().contextRenderer().removeActor(m_actor);
    m_actor = null;
    s_exit();
  };
  m_this._init();
  return this;
};
inherit(_webgl_pointFeature, pointFeature);
var capabilities = {};
capabilities[pointFeature.capabilities.stroke] = true;

// Now register it
registerFeature('webgl', 'point', _webgl_pointFeature, capabilities);
module.exports = _webgl_pointFeature;

/***/ }),

/***/ 2709:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var pointFeature = __webpack_require__(7541);

/**
 * Extend a point-like feature with additional functions.
 *
 * @param {this} m_this The point-like feature.
 * @param {object} [arg] Feature definition object that might specify the
 *      primitive shape.
 * @memberof geo.webgl
 */
function pointUtil(m_this, arg) {
  arg = arg || {};
  m_this._primitiveShapeAuto = true;
  m_this._primitiveShape = pointFeature.primitiveShapes.auto;
  if (pointFeature.primitiveShapes[arg.primitiveShape] !== undefined) {
    m_this._primitiveShape = arg.primitiveShape;
  }
  m_this._primitiveShapeAuto = m_this._primitiveShape === pointFeature.primitiveShapes.auto;
  if (m_this._primitiveShapeAuto) {
    m_this._primitiveShape = pointFeature.primitiveShapes.sprite;
    m_this._primitiveShapeAuto = true;
  }

  /**
   * Given the current primitive shape and a basic size, return a set of
   * vertices that can be used for a generic point.
   *
   * @param {number} x The base x coordinate.  Usually 0.
   * @param {number} y The base y coordinate.  Usually 0.
   * @param {number} w The base width.  Usually 1.
   * @param {number} h The base height.  Usually 1.
   * @returns {number[]} A flat array of vertices in the form of
   *    `[x0, y0, x1, y1, ...]`.
   */
  m_this._pointPolygon = function (x, y, w, h) {
    var verts;
    switch (m_this._primitiveShape) {
      case pointFeature.primitiveShapes.triangle:
        /* Use an equilateral triangle.  While this has 30% more area than a
         * square, the reduction in vertices should help more than the
         * processing the additional fragments. */
        verts = [x, y - h * 2, x - w * Math.sqrt(3.0), y + h, x + w * Math.sqrt(3.0), y + h];
        break;
      case pointFeature.primitiveShapes.square:
        /* Use a surrounding square split diagonally into two triangles. */
        verts = [x - w, y + h, x - w, y - h, x + w, y + h, x - w, y - h, x + w, y - h, x + w, y + h];
        break;
      default:
        // sprite
        /* Point sprite uses only one vertex per point. */
        verts = [x, y];
        break;
    }
    return verts;
  };

  /**
   * Return the number of vertices used for each point.
   *
   * @returns {number}
   */
  m_this.verticesPerFeature = function () {
    var unit = m_this._pointPolygon(0, 0, 1, 1);
    return unit.length / 2;
  };

  /**
   * Get or set the primitiveShape.
   *
   * @param {geo.pointFeature.primitiveShapes} [primitiveShape] If specified,
   *   the new primitive shape.
   * @param {boolean} [currentShape] If truthy and getting the shape, return
   *   the shape currently in use if the shape is set to `auto`.  If falsy,
   *   return the specific primitiveShape, which may be `auto`.
   * @returns {geo.pointFeature.primitiveShapes|this} The primitiveShape or
   *   this instance of the feature.
   */
  m_this.primitiveShape = function (primitiveShape, currentShape) {
    if (primitiveShape === undefined) {
      return currentShape || !m_this._primitiveShapeAuto ? m_this._primitiveShape : pointFeature.primitiveShapes.auto;
    }
    if (pointFeature.primitiveShapes[primitiveShape] !== undefined) {
      var update = false;
      if (primitiveShape === pointFeature.primitiveShapes.auto) {
        update = !m_this._primitiveShapeAuto;
        m_this._primitiveShapeAuto = true;
      } else {
        update = m_this._primitiveShapeAuto || m_this._primitiveShape !== primitiveShape;
        m_this._primitiveShapeAuto = false;
        m_this._primitiveShape = primitiveShape;
      }
      if (update) {
        m_this.renderer().contextRenderer().removeActor(m_this.actors()[0]);
        m_this._init(true);
        m_this.dataTime().modified();
      }
    }
    return m_this;
  };
}
module.exports = pointUtil;

/***/ }),

/***/ 8511:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var polygonFeature = __webpack_require__(6645);

/**
 * Create a new instance of webgl.polygonFeature.
 *
 * @class
 * @alias geo.webgl.polygonFeature
 * @extends geo.polygonFeature
 * @param {geo.polygonFeature.spec} arg
 * @returns {geo.webgl.polygonFeature}
 */
var _webgl_polygonFeature = function webgl_polygonFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_polygonFeature)) {
    return new _webgl_polygonFeature(arg);
  }
  arg = arg || {};
  polygonFeature.call(this, arg);
  var vgl = __webpack_require__(1611);
  var earcut = __webpack_require__(9747);
  earcut = earcut.__esModule ? earcut.default : earcut;
  var transform = __webpack_require__(5325);
  var util = __webpack_require__(642);
  var object = __webpack_require__(4084);
  var markerFeature = __webpack_require__(2225);
  var fragmentShader = __webpack_require__(4547);
  var fragmentPatternShader = __webpack_require__(6207);
  var vertexShader = __webpack_require__(9506);
  var vertexPatternShader = __webpack_require__(1030);
  object.call(this);

  /**
   * @private
   */
  var m_this = this,
    s_exit = this._exit,
    m_actor = null,
    m_mapper = null,
    m_geometry,
    m_origin,
    m_uniforms,
    m_modelViewUniform,
    s_init = this._init,
    s_update = this._update,
    m_builtOnce,
    m_updateAnimFrameRef;
  function createVertexShader() {
    var shader = new vgl.shader(vgl.GL.VERTEX_SHADER);
    if (!m_this._hasPatterns) {
      shader.setShaderSource(vertexShader);
    } else {
      shader.setShaderSource(vertexPatternShader);
    }
    return shader;
  }
  function createFragmentShader() {
    var shader = new vgl.shader(vgl.GL.FRAGMENT_SHADER);
    if (!m_this._hasPatterns) {
      shader.setShaderSource(fragmentShader);
    } else {
      shader.setShaderSource(fragmentPatternShader);
    }
    return shader;
  }
  function _resolvePattern(val, func, d, idx, v0) {
    if (!val && func === undefined) {
      return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    var pattern = Array(16);
    var fillColor, strokeColor;
    if (val === undefined) {
      val = func(d, idx);
    }
    if (!val) {
      return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    if (val.fillColor === undefined) {
      fillColor = util.convertColor(m_this.style.get('strokeColor')(v0, 0, d, idx));
      fillColor.a = m_this.style.get('strokeOpacity')(v0, 0, d, idx);
    } else {
      fillColor = util.convertColor(val.fillColor);
    }
    pattern[0] = fillColor.r;
    pattern[1] = fillColor.g;
    pattern[2] = fillColor.b;
    pattern[3] = fillColor.a;
    if (val.strokeColor === undefined) {
      strokeColor = util.convertColor(m_this.style.get('fillColor')(v0, 0, d, idx));
      strokeColor.a = m_this.style.get('fillOpacity')(v0, 0, d, idx);
    } else {
      strokeColor = util.convertColor(val.strokeColor);
    }
    pattern[4] = strokeColor.r;
    pattern[5] = strokeColor.g;
    pattern[6] = strokeColor.b;
    pattern[7] = strokeColor.a;
    pattern[8] = val.strokeWidth === undefined ? 1.25 : val.strokeWidth;
    pattern[9] = val.radius === undefined ? 6.25 : val.radius;
    var scaleWithZoom = val.scaleWithZoom === undefined ? markerFeature.scaleMode.none : val.scaleWithZoom;
    scaleWithZoom = markerFeature.scaleMode[scaleWithZoom] || scaleWithZoom;
    var strokeOffset = val.strokeOffset === undefined || val.strokeOffset < 0 ? -1 : val.strokeOffset > 0 ? 1 : 0;
    pattern[10] = scaleWithZoom + (!val.rotateWithMap ? 4 : 0) + ((val.radiusIncludeStroke ? strokeOffset : 1) + 1) * 16 + (val.symbol || 0) * 64;
    if (val.symbol && val.symbolValue && val.symbol >= markerFeature.symbols.arrow && val.symbol < markerFeature.symbols.arrow + markerFeature.symbols.arrowMax) {
      pattern[11] = util.packFloats(val.symbolValue || 0);
    } else {
      pattern[11] = val.symbolValue || 0;
    }
    pattern[12] = val.rotation || 0;
    pattern[13] = val.spacing === undefined ? 20 : val.spacing;
    pattern[14] = val.origin === undefined ? 0 : val.origin[0];
    pattern[15] = val.origin === undefined ? 0 : val.origin[1];
    return pattern;
  }

  /**
   * Create and style the triangles needed to render the polygons.
   *
   * There are several optimizations to do less work when possible.  If only
   * styles have changed, the triangulation is not recomputed, nor is the
   * geometry re-transformed.  If styles use static values (rather than
   * functions), they are only calculated once.  If a polygon reports that it
   * has a uniform style, then styles are only calculated once for that polygon
   * (the uniform property may be different per polygon or per update).
   * Array.map is slower in Chrome that using a loop, so loops are used in
   * places that would be conceptually served by maps.
   *
   * @param {boolean} onlyStyle if true, use the existing geometry and just
   *    recalculate the style.
   */
  function createGLPolygons(onlyStyle) {
    var posBuf,
      posFunc,
      polyFunc,
      fillColor,
      fillColorFunc,
      fillColorVal,
      fillOpacity,
      fillOpacityFunc,
      fillOpacityVal,
      fillFunc,
      fillVal,
      patternFunc,
      patternVal,
      pattern,
      patternFillColor,
      patternStrokeColor,
      patternSymbolProps,
      patternPositionProps,
      uniformFunc,
      uniformVal,
      uniform,
      indices,
      items = [],
      itemsk,
      itemsktri,
      target_gcs = m_this.gcs(),
      map_gcs = m_this.layer().map().gcs(),
      numPts = 0,
      geom,
      color,
      opacity,
      fill,
      d,
      d3,
      vertices,
      i,
      j,
      k,
      n,
      record,
      item,
      itemIndex,
      original;
    fillColorFunc = m_this.style.get('fillColor');
    fillColorVal = util.isFunction(m_this.style('fillColor')) ? undefined : fillColorFunc();
    fillOpacityFunc = m_this.style.get('fillOpacity');
    fillOpacityVal = util.isFunction(m_this.style('fillOpacity')) ? undefined : fillOpacityFunc();
    fillFunc = m_this.style.get('fill');
    fillVal = util.isFunction(m_this.style('fill')) ? undefined : fillFunc();
    uniformFunc = m_this.style.get('uniformPolygon');
    uniformVal = util.isFunction(m_this.style('uniformPolygon')) ? undefined : uniformFunc();
    patternFunc = m_this.style.get('pattern');
    patternVal = util.isFunction(m_this.style('pattern')) ? undefined : patternFunc() || null;
    if (patternVal !== null && m_this._hasPatterns !== true) {
      m_this.renderer().contextRenderer().removeActor(m_actor);
      m_actor = null;
      m_this._init(true);
    }
    geom = m_mapper.geometryData();
    if (!onlyStyle) {
      posFunc = m_this.style.get('position');
      posFunc = posFunc === util.identityFunction ? null : posFunc;
      polyFunc = m_this.style.get('polygon');
      polyFunc = polyFunc === util.identityFunction ? null : polyFunc;
      m_this.data().forEach(function (item, itemIndex) {
        var polygon, outer, geometry, c;
        polygon = polyFunc ? polyFunc(item, itemIndex) : item;
        if (!polygon) {
          return;
        }
        outer = polygon.outer || (Array.isArray(polygon) ? polygon : []);
        if (outer.length < 3) {
          return;
        }

        /* expand to an earcut polygon geometry.  We had been using a map call,
         * but using loops is much faster in Chrome (4 versus 33 ms for one
         * test). */
        geometry = new Array(outer.length * 3);
        for (i = d3 = 0; i < outer.length; i += 1, d3 += 3) {
          c = posFunc ? posFunc(outer[i], i, item, itemIndex) : outer[i];
          geometry[d3] = c.x;
          geometry[d3 + 1] = c.y;
          // ignore the z values until we support them
          geometry[d3 + 2] = 0; // c.z || 0;
        }
        geometry = {
          vertices: geometry,
          dimensions: 3,
          holes: []
        };
        original = outer;
        if (polygon.inner) {
          polygon.inner.forEach(function (hole) {
            if (hole.length < 3) {
              return;
            }
            original = original.concat(hole);
            geometry.holes.push(d3 / 3);
            for (i = 0; i < hole.length; i += 1, d3 += 3) {
              c = posFunc ? posFunc(hole[i], i, item, itemIndex) : hole[i];
              geometry.vertices[d3] = c.x;
              geometry.vertices[d3 + 1] = c.y;
              // ignore the z values until we support them
              geometry.vertices[d3 + 2] = 0; // c.z || 0;
            }
          });
        }

        // transform to map gcs
        geometry.vertices = transform.transformCoordinates(target_gcs, map_gcs, geometry.vertices, geometry.dimensions);
        record = {
          // triangulate
          triangles: earcut(geometry.vertices, geometry.holes, geometry.dimensions),
          vertices: geometry.vertices,
          original: original,
          item: item,
          itemIndex: itemIndex
        };
        if (record.triangles.length) {
          items.push(record);
          numPts += record.triangles.length;
        }
      });
      posBuf = util.getGeomBuffer(geom, 'pos', numPts * 3);
      indices = geom.primitive(0).indices();
      if (!(indices instanceof Uint16Array) || indices.length !== numPts) {
        indices = new Uint16Array(numPts);
        geom.primitive(0).setIndices(indices);
      }
      m_geometry = {
        items: items,
        numPts: numPts
      };
      m_origin = new Float32Array(m_this.style.get('origin')(items));
      m_modelViewUniform.setOrigin(m_origin);
    } else {
      items = m_geometry.items;
      numPts = m_geometry.numPts;
    }
    fillColor = util.getGeomBuffer(geom, 'fillColor', numPts * 3);
    fillOpacity = util.getGeomBuffer(geom, 'fillOpacity', numPts);
    d = d3 = 0;
    color = fillColorVal;
    fill = fillVal;
    if (m_this._hasPatterns) {
      patternFillColor = util.getGeomBuffer(geom, 'patternFillColor', numPts * 4);
      patternStrokeColor = util.getGeomBuffer(geom, 'patternStrokeColor', numPts * 4);
      patternSymbolProps = util.getGeomBuffer(geom, 'patternSymbolProps', numPts * 4);
      patternPositionProps = util.getGeomBuffer(geom, 'patternPositionProps', numPts * 4);
    }
    for (k = 0; k < items.length; k += 1) {
      itemsk = items[k];
      itemsktri = itemsk.triangles;
      n = itemsktri.length;
      vertices = itemsk.vertices;
      item = itemsk.item;
      itemIndex = itemsk.itemIndex;
      original = itemsk.original;
      uniform = uniformVal === undefined ? uniformFunc(item, itemIndex) : uniformVal;
      opacity = fillOpacityVal;
      if (uniform) {
        if (fillColorVal === undefined) {
          color = fillColorFunc(vertices[0], 0, item, itemIndex);
        }
        if (fillOpacityVal === undefined) {
          opacity = fillOpacityFunc(vertices[0], 0, item, itemIndex);
        }
      }
      if (fillVal === undefined) {
        fill = fillFunc(item, itemIndex);
      }
      if (!fill) {
        opacity = 0;
      }
      if (m_this._hasPatterns) {
        if (pattern === undefined && patternVal || patternVal === undefined) {
          pattern = _resolvePattern(patternVal, patternFunc, item, itemIndex, vertices[0]);
        }
      }
      if (uniform && onlyStyle && itemsk.uniform && itemsk.color && color.r === itemsk.color.r && color.g === itemsk.color.g && color.b === itemsk.color.b && opacity === itemsk.opacity) {
        d += n;
        d3 += n * 3;
        continue;
      }
      for (i = 0; i < n; i += 1, d += 1, d3 += 3) {
        if (onlyStyle && uniform) {
          fillColor[d3] = color.r;
          fillColor[d3 + 1] = color.g;
          fillColor[d3 + 2] = color.b;
          fillOpacity[d] = opacity;
        } else {
          j = itemsktri[i] * 3;
          if (!onlyStyle) {
            posBuf[d3] = vertices[j] - m_origin[0];
            posBuf[d3 + 1] = vertices[j + 1] - m_origin[1];
            posBuf[d3 + 2] = vertices[j + 2] - m_origin[2];
            indices[d] = i;
          }
          if (!uniform && fillColorVal === undefined) {
            color = fillColorFunc(original[j], j, item, itemIndex);
          }
          fillColor[d3] = color.r;
          fillColor[d3 + 1] = color.g;
          fillColor[d3 + 2] = color.b;
          if (!uniform && fill && fillOpacityVal === undefined) {
            opacity = fillOpacityFunc(original[j], j, item, itemIndex);
          }
          fillOpacity[d] = opacity;
        }
        if (m_this._hasPatterns) {
          patternFillColor[d * 4] = pattern[0];
          patternFillColor[d * 4 + 1] = pattern[1];
          patternFillColor[d * 4 + 2] = pattern[2];
          patternFillColor[d * 4 + 3] = pattern[3];
          patternStrokeColor[d * 4] = pattern[4];
          patternStrokeColor[d * 4 + 1] = pattern[5];
          patternStrokeColor[d * 4 + 2] = pattern[6];
          patternStrokeColor[d * 4 + 3] = pattern[7];
          patternSymbolProps[d * 4] = pattern[8];
          patternSymbolProps[d * 4 + 1] = pattern[9];
          patternSymbolProps[d * 4 + 2] = pattern[10];
          patternSymbolProps[d * 4 + 3] = pattern[11];
          patternPositionProps[d * 4] = pattern[12];
          patternPositionProps[d * 4 + 1] = pattern[13];
          patternPositionProps[d * 4 + 2] = pattern[14];
          patternPositionProps[d * 4 + 3] = pattern[15];
        }
      }
      if (uniform || itemsk.uniform) {
        itemsk.uniform = uniform;
        itemsk.color = color;
        itemsk.opacity = opacity;
      }
    }
    if (!onlyStyle) {
      m_mapper.modified();
      geom.boundsDirty(true);
      m_mapper.boundsDirtyTimestamp().modified();
    } else {
      m_mapper.updateSourceBuffer('fillOpacity');
      m_mapper.updateSourceBuffer('fillColor');
      if (m_this._hasPatterns) {
        m_mapper.updateSourceBuffer('patternFillColor');
        m_mapper.updateSourceBuffer('patternStrokeColor');
        m_mapper.updateSourceBuffer('patternSymbolProps');
        m_mapper.updateSourceBuffer('patternPositionProps');
      }
    }
  }

  /**
   * Initialize.
   *
   * @param {geo.polygonFeature.spec} arg An object with options for the
   *    feature.
   */
  this._init = function (arg) {
    m_this._hasPatterns = arg === true;
    var prog = vgl.shaderProgram(),
      posAttr = vgl.vertexAttribute('pos'),
      fillColorAttr = vgl.vertexAttribute('fillColor'),
      fillOpacityAttr = vgl.vertexAttribute('fillOpacity'),
      projectionUniform = new vgl.projectionUniform('projectionMatrix'),
      vertexShader = createVertexShader(),
      fragmentShader = createFragmentShader(),
      blend = vgl.blend(),
      geom = vgl.geometryData(),
      sourcePositions = vgl.sourceDataP3fv({
        name: 'pos'
      }),
      sourceFillColor = vgl.sourceDataAnyfv(3, vgl.vertexAttributeKeysIndexed.Two, {
        name: 'fillColor'
      }),
      sourceFillOpacity = vgl.sourceDataAnyfv(1, vgl.vertexAttributeKeysIndexed.Three, {
        name: 'fillOpacity'
      }),
      trianglePrimitive = vgl.triangles(),
      mat = vgl.material();
    m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix');
    prog.addVertexAttribute(posAttr, vgl.vertexAttributeKeys.Position);
    prog.addVertexAttribute(fillColorAttr, vgl.vertexAttributeKeysIndexed.Two);
    prog.addVertexAttribute(fillOpacityAttr, vgl.vertexAttributeKeysIndexed.Three);
    if (m_this._hasPatterns) {
      var patternFillColorAttr = vgl.vertexAttribute('patternFillColor'),
        patternStrokeColorAttr = vgl.vertexAttribute('patternStrokeColor'),
        patternSymbolPropsAttr = vgl.vertexAttribute('patternSymbolProps'),
        patternPositionPropsAttr = vgl.vertexAttribute('patternPositionProps');
      prog.addVertexAttribute(patternFillColorAttr, vgl.vertexAttributeKeysIndexed.Four);
      prog.addVertexAttribute(patternStrokeColorAttr, vgl.vertexAttributeKeysIndexed.Five);
      prog.addVertexAttribute(patternSymbolPropsAttr, vgl.vertexAttributeKeysIndexed.Six);
      prog.addVertexAttribute(patternPositionPropsAttr, vgl.vertexAttributeKeysIndexed.Seven);
    }
    prog.addUniform(m_modelViewUniform);
    prog.addUniform(projectionUniform);
    prog.addShader(fragmentShader);
    prog.addShader(vertexShader);
    mat.addAttribute(prog);
    mat.addAttribute(blend);
    m_mapper = vgl.mapper();
    m_actor = vgl.actor();
    m_actor.setMaterial(mat);
    m_actor.setMapper(m_mapper);
    geom.addSource(sourcePositions);
    geom.addSource(sourceFillColor);
    geom.addSource(sourceFillOpacity);
    if (m_this._hasPatterns) {
      var uniforms = {
        pixelWidth: vgl.GL.FLOAT,
        aspect: vgl.GL.FLOAT,
        zoom: vgl.GL.FLOAT,
        rotationUniform: vgl.GL.FLOAT
      };
      m_uniforms = {};
      Object.keys(uniforms).forEach(function (key) {
        m_uniforms[key] = new vgl.uniform(uniforms[key], key);
        prog.addUniform(m_uniforms[key]);
      });
      var sourcePatternFillColor = vgl.sourceDataAnyfv(4, vgl.vertexAttributeKeysIndexed.Four, {
          name: 'patternFillColor'
        }),
        sourcePatternStrokeColor = vgl.sourceDataAnyfv(4, vgl.vertexAttributeKeysIndexed.Five, {
          name: 'patternStrokeColor'
        }),
        sourcePatternSymbolProps = vgl.sourceDataAnyfv(4, vgl.vertexAttributeKeysIndexed.Six, {
          name: 'patternSymbolProps'
        }),
        sourcePatternPositionProps = vgl.sourceDataAnyfv(4, vgl.vertexAttributeKeysIndexed.Seven, {
          name: 'patternPositionProps'
        });
      geom.addSource(sourcePatternFillColor);
      geom.addSource(sourcePatternStrokeColor);
      geom.addSource(sourcePatternSymbolProps);
      geom.addSource(sourcePatternPositionProps);
    }
    geom.addPrimitive(trianglePrimitive);
    /* We don't need vgl to compute bounds, so make the geo.computeBounds just
     * set them to 0. */
    geom.computeBounds = function () {
      geom.setBounds(0, 0, 0, 0, 0, 0);
    };
    m_mapper.setGeometryData(geom);
    if (arg !== true) {
      s_init.call(m_this, arg);
    }
  };

  /**
   * List vgl actors.
   *
   * @returns {vgl.actor[]} The list of actors.
   */
  this.actors = function () {
    return [m_actor];
  };

  /**
   * Build.
   */
  this._build = function () {
    createGLPolygons(!!(m_this.dataTime().timestamp() < m_this.buildTime().timestamp() && m_geometry));
    if (!m_this.renderer().contextRenderer().hasActor(m_actor)) {
      m_this.renderer().contextRenderer().addActor(m_actor);
      m_builtOnce = true;
    }
    m_this.buildTime().modified();
  };

  /**
   * Update.
   *
   * @param {object} [opts] Update options.
   * @param {boolean} [opts.mayDelay] If truthy, wait until the next animation
   *    frame for the update.
   */
  this._update = function (opts) {
    if (!m_this.ready) {
      return;
    }
    if (opts && opts.mayDelay && m_builtOnce) {
      m_updateAnimFrameRef = m_this.layer().map().scheduleAnimationFrame(m_this._update);
      return;
    }
    if (m_updateAnimFrameRef) {
      m_this.layer().map().scheduleAnimationFrame(m_this._update, 'remove');
      m_updateAnimFrameRef = null;
    }
    s_update.call(m_this);
    if (m_this.dataTime().timestamp() >= m_this.buildTime().timestamp() || m_this.updateTime().timestamp() <= m_this.timestamp()) {
      m_this._build();
    }
    if (m_this._hasPatterns) {
      // Update uniforms
      m_uniforms.pixelWidth.set(2.0 / m_this.renderer().width());
      m_uniforms.aspect.set(m_this.renderer().width() / m_this.renderer().height());
      m_uniforms.zoom.set(m_this.renderer().map().zoom());
      m_uniforms.rotationUniform.set(m_this.renderer().map().rotation());
    }
    m_actor.setVisible(m_this.visible());
    m_actor.material().setBinNumber(m_this.bin());
    m_this.updateTime().modified();
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    if (m_updateAnimFrameRef && m_this.layer()) {
      m_this.layer().map().scheduleAnimationFrame(m_this._update, 'remove');
      m_updateAnimFrameRef = null;
    }
    m_this.renderer().contextRenderer().removeActor(m_actor);
    m_actor = null;
    m_uniforms = {};
    s_exit();
  };
  this._init(arg);
  return this;
};
inherit(_webgl_polygonFeature, polygonFeature);

// Now register it
registerFeature('webgl', 'polygon', _webgl_polygonFeature);
module.exports = _webgl_polygonFeature;

/***/ }),

/***/ 9304:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var quadFeature = __webpack_require__(3842);
var timestamp = __webpack_require__(77);
var util = __webpack_require__(642);
var _memoryCheckLargestTested = 4096 * 4096;

/**
 * Create a new instance of class quadFeature.
 *
 * @class
 * @alias geo.webgl.quadFeature
 * @param {geo.quadFeature.spec} arg Options object.
 * @extends geo.quadFeature
 * @returns {geo.webgl.quadFeature}
 */
var _webgl_quadFeature = function webgl_quadFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_quadFeature)) {
    return new _webgl_quadFeature(arg);
  }
  quadFeature.call(this, arg);
  var $ = __webpack_require__(5616);
  var vgl = __webpack_require__(1611);
  var object = __webpack_require__(4084);
  var fragmentShaderImage = __webpack_require__(8711);
  var vertexShaderImage = __webpack_require__(6238);
  var fragmentShaderColor = __webpack_require__(8961);
  var vertexShaderColor = __webpack_require__(3260);
  object.call(this);
  var m_this = this,
    s_exit = this._exit,
    s_update = this._update,
    m_modelViewUniform,
    m_actor_image,
    m_actor_color,
    m_glBuffers = {},
    m_imgposbuf,
    m_clrposbuf,
    m_clrModelViewUniform,
    m_glCompileTimestamp = timestamp(),
    m_glColorCompileTimestamp = timestamp(),
    m_quads;

  /**
   * Allocate buffers that we need to control for image quads.  This mimics
   * the actions from vgl.mapper to some degree.
   *
   * @private
   * @param {vgl.renderState} renderState An object that contains the context
   *   used for drawing.
   */
  function setupDrawObjects(renderState) {
    var context = renderState.m_context,
      newbuf = false;
    if (m_quads.imgQuads.length) {
      if (!m_imgposbuf || m_imgposbuf.length < m_quads.imgQuads.length * 12 || !m_glBuffers.imgQuadsPosition) {
        if (m_glBuffers.imgQuadsPosition) {
          context.deleteBuffer(m_glBuffers.imgQuadsPosition);
        }
        m_glBuffers.imgQuadsPosition = context.createBuffer();
        m_imgposbuf = new Float32Array(Math.max(128, m_quads.imgQuads.length * 2) * 12);
        newbuf = true;
      }
      $.each(m_quads.imgQuads, function (idx, quad) {
        for (var i = 0; i < 12; i += 1) {
          m_imgposbuf[idx * 12 + i] = quad.pos[i] - m_quads.origin[i % 3];
        }
      });
      context.bindBuffer(context.ARRAY_BUFFER, m_glBuffers.imgQuadsPosition);
      if (newbuf) {
        context.bufferData(context.ARRAY_BUFFER, m_imgposbuf, context.DYNAMIC_DRAW);
      } else {
        context.bufferSubData(context.ARRAY_BUFFER, 0, m_imgposbuf);
      }
    }
    m_glCompileTimestamp.modified();
  }

  /**
   * Allocate buffers that we need to control for color quads.  This mimics
   * the actions from vgl.mapper to some degree.
   *
   * @private
   * @param {vgl.renderState} renderState An object that contains the context
   *   used for drawing.
   */
  function setupColorDrawObjects(renderState) {
    var context = renderState.m_context,
      newbuf = false;
    if (m_quads.clrQuads.length) {
      if (!m_clrposbuf || m_clrposbuf.length < m_quads.clrQuads.length * 12 || !m_glBuffers.clrQuadsPosition) {
        if (m_glBuffers.clrQuadsPosition) {
          context.deleteBuffer(m_glBuffers.clrQuadsPosition);
        }
        m_glBuffers.clrQuadsPosition = context.createBuffer();
        m_clrposbuf = new Float32Array(Math.max(128, m_quads.clrQuads.length * 2) * 12);
        newbuf = true;
      }
      $.each(m_quads.clrQuads, function (idx, quad) {
        for (var i = 0; i < 12; i += 1) {
          m_clrposbuf[idx * 12 + i] = quad.pos[i] - m_quads.origin[i % 3];
        }
      });
      context.bindBuffer(context.ARRAY_BUFFER, m_glBuffers.clrQuadsPosition);
      if (newbuf) {
        context.bufferData(context.ARRAY_BUFFER, m_clrposbuf, context.DYNAMIC_DRAW);
      } else {
        context.bufferSubData(context.ARRAY_BUFFER, 0, m_clrposbuf);
      }
    }
    m_glColorCompileTimestamp.modified();
  }

  /**
   * Get a vgl mapper, mark dynamicDraw, augment the timestamp and the render
   * function.
   *
   * @private
   * @param {Function} renderFunc Our own render function.
   * @returns {vgl.mapper} a vgl mapper object.
   */
  function getVGLMapper(renderFunc) {
    var mapper = new vgl.mapper({
      dynamicDraw: true
    });
    mapper.s_modified = mapper.modified;
    mapper.g_timestamp = timestamp();
    mapper.timestamp = mapper.g_timestamp.timestamp;
    mapper.modified = function () {
      mapper.s_modified();
      mapper.g_timestamp.modified();
      return mapper;
    };
    mapper.s_render = mapper.render;
    mapper.render = renderFunc;
    return mapper;
  }

  /**
   * List vgl actors.
   *
   * @returns {vgl.actor[]} The list of actors.
   */
  this.actors = function () {
    var actors = [];
    if (m_actor_image) {
      actors.push(m_actor_image);
    }
    if (m_actor_color) {
      actors.push(m_actor_color);
    }
    return actors;
  };

  /**
   * Build this feature.
   */
  this._build = function () {
    var mapper, mat, prog, srctex, unicrop, unicropsource, geom, context, sampler2d;
    if (!m_this.position()) {
      return;
    }
    m_quads = m_this._generateQuads();
    /* Create an actor to render image quads */
    if (m_quads.imgQuads.length && !m_actor_image) {
      m_this.visible(false);
      mapper = getVGLMapper(m_this._renderImageQuads);
      m_actor_image = new vgl.actor();
      /* This is similar to vgl.utils.createTextureMaterial */
      m_actor_image.setMapper(mapper);
      mat = new vgl.material();
      prog = new vgl.shaderProgram();
      prog.addVertexAttribute(new vgl.vertexAttribute('vertexPosition'), vgl.vertexAttributeKeys.Position);
      prog.addVertexAttribute(new vgl.vertexAttribute('textureCoord'), vgl.vertexAttributeKeys.TextureCoordinate);
      m_modelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix', m_quads.origin);
      prog.addUniform(m_modelViewUniform);
      prog.addUniform(new vgl.projectionUniform('projectionMatrix'));
      prog.addUniform(new vgl.floatUniform('opacity', 1.0));
      prog.addUniform(new vgl.floatUniform('zOffset', 0.0));
      /* Use texture unit 0 */
      sampler2d = new vgl.uniform(vgl.GL.INT, 'sampler2d');
      sampler2d.set(0);
      prog.addUniform(sampler2d);
      context = m_this.renderer()._glContext();
      unicrop = new vgl.uniform(context.FLOAT_VEC2, 'crop');
      unicrop.set([1.0, 1.0]);
      prog.addUniform(unicrop);
      unicropsource = new vgl.uniform(context.FLOAT_VEC4, 'cropsource');
      unicropsource.set([0.0, 0.0, 0.0, 0.0]);
      prog.addUniform(unicropsource);
      prog.addShader(vgl.getCachedShader(context.VERTEX_SHADER, context, vertexShaderImage));
      prog.addShader(vgl.getCachedShader(context.FRAGMENT_SHADER, context, fragmentShaderImage));
      if (m_this._hookBuild) {
        m_this._hookBuild(prog);
      }
      mat.addAttribute(prog);
      mat.addAttribute(new vgl.blend());
      /* This is similar to vgl.planeSource */
      geom = new vgl.geometryData();
      m_imgposbuf = undefined;
      srctex = new vgl.sourceDataT2fv();
      srctex.pushBack([0, 0, 1, 0, 0, 1, 1, 1]);
      geom.addSource(srctex);
      /* We deliberately do not add a primitive to our geometry -- we take care
       * of that ourselves. */

      mapper.setGeometryData(geom);
      m_actor_image.setMaterial(mat);
      m_this.renderer().contextRenderer().addActor(m_actor_image);
      m_this.visible(true);
    }
    /* Create an actor to render color quads */
    if (m_quads.clrQuads.length && !m_actor_color) {
      m_this.visible(false);
      mapper = getVGLMapper(m_this._renderColorQuads);
      m_actor_color = new vgl.actor();
      /* This is similar to vgl.utils.createTextureMaterial */
      m_actor_color.setMapper(mapper);
      mat = new vgl.material();
      prog = new vgl.shaderProgram();
      prog.addVertexAttribute(new vgl.vertexAttribute('vertexPosition'), vgl.vertexAttributeKeys.Position);
      m_clrModelViewUniform = new vgl.modelViewOriginUniform('modelViewMatrix', m_quads.origin);
      prog.addUniform(m_clrModelViewUniform);
      prog.addUniform(new vgl.projectionUniform('projectionMatrix'));
      prog.addUniform(new vgl.floatUniform('opacity', 1.0));
      prog.addUniform(new vgl.floatUniform('zOffset', 0.0));
      context = m_this.renderer()._glContext();
      prog.addUniform(new vgl.uniform(context.FLOAT_VEC3, 'vertexColor'));
      prog.addShader(vgl.getCachedShader(context.VERTEX_SHADER, context, vertexShaderColor));
      prog.addShader(vgl.getCachedShader(context.FRAGMENT_SHADER, context, fragmentShaderColor));
      mat.addAttribute(prog);
      mat.addAttribute(new vgl.blend());
      /* This is similar to vgl.planeSource */
      geom = new vgl.geometryData();
      m_clrposbuf = undefined;
      /* We deliberately do not add a primitive to our geometry -- we take care
       * of that ourselves. */

      mapper.setGeometryData(geom);
      m_actor_color.setMaterial(mat);
      m_this.renderer().contextRenderer().addActor(m_actor_color);
      m_this.visible(true);
    }
    if (m_modelViewUniform) {
      m_modelViewUniform.setOrigin(m_quads.origin);
    }
    if (m_clrModelViewUniform) {
      m_clrModelViewUniform.setOrigin(m_quads.origin);
    }
    m_this._updateTextures();
    m_this.buildTime().modified();
  };

  /**
   * Check all of the image quads.  If any do not have the correct texture,
   * update them.
   */
  this._updateTextures = function () {
    $.each(m_quads.imgQuads, function (idx, quad) {
      // pick source (imageTexture has priority)
      var source = quad.imageTexture || quad.image;
      if (!source) {
        return;
      }

      // use cached texture if it exists
      if (source._texture) {
        quad.texture = source._texture;
        return;
      }

      // create a new texture
      var texture = new vgl.texture();
      if (quad.imageTexture) {
        texture.setTexture(source);
      } else {
        texture.setImage(source);
      }

      // handle nearest pixel logic
      var nearestPixel = m_this.nearestPixel();
      if (nearestPixel !== undefined) {
        if (nearestPixel !== true && util.isNonNullFinite(nearestPixel)) {
          var curZoom = m_this.layer().map().zoom();
          nearestPixel = curZoom >= nearestPixel;
        }
      }
      if (nearestPixel) {
        texture.setNearestPixel(true);
      }
      quad.texture = source._texture = texture;
    });
  };

  /**
   * Render all of the color quads using a single mapper.
   *
   * @param {vgl.renderState} renderState An object that contains the context
   *   used for drawing.
   */
  this._renderColorQuads = function (renderState) {
    if (!m_quads.clrQuads.length) {
      return;
    }
    var mapper = this;
    if (mapper.timestamp() > m_glColorCompileTimestamp.timestamp() || m_this.dataTime().timestamp() > m_glColorCompileTimestamp.timestamp() || renderState.m_contextChanged || !m_clrposbuf || m_quads.clrQuads.length * 12 > m_clrposbuf.length) {
      setupColorDrawObjects(renderState);
    }
    mapper.s_render(renderState, true);
    var context = renderState.m_context,
      opacity,
      zOffset,
      color;
    context.bindBuffer(context.ARRAY_BUFFER, m_glBuffers.clrQuadsPosition);
    $.each(m_quads.clrQuads, function (idx, quad) {
      if (quad.opacity !== opacity) {
        opacity = quad.opacity;
        context.uniform1fv(renderState.m_material.shaderProgram().uniformLocation('opacity'), new Float32Array([opacity]));
      }
      if ((quad.zOffset || 0.0) !== zOffset) {
        zOffset = quad.zOffset || 0.0;
        context.uniform1fv(renderState.m_material.shaderProgram().uniformLocation('zOffset'), new Float32Array([zOffset]));
      }
      if (!color || color.r !== quad.color.r || color.g !== quad.color.g || color.b !== quad.color.b) {
        color = quad.color;
        context.uniform3fv(renderState.m_material.shaderProgram().uniformLocation('vertexColor'), new Float32Array([color.r, color.g, color.b]));
      }
      context.bindBuffer(context.ARRAY_BUFFER, m_glBuffers.clrQuadsPosition);
      context.vertexAttribPointer(vgl.vertexAttributeKeys.Position, 3, context.FLOAT, false, 12, idx * 12 * 4);
      context.enableVertexAttribArray(vgl.vertexAttributeKeys.Position);
      context.drawArrays(context.TRIANGLE_STRIP, 0, 4);
    });
    context.bindBuffer(context.ARRAY_BUFFER, null);
    mapper.undoBindVertexData(renderState);
  };

  /**
   * Render all of the image quads using a single mapper.
   *
   * @param {vgl.renderState} renderState An object that contains the context
   *   used for drawing.
   */
  this._renderImageQuads = function (renderState) {
    if (!m_quads.imgQuads.length) {
      return;
    }
    var mapper = this;
    if (mapper.timestamp() > m_glCompileTimestamp.timestamp() || m_this.dataTime().timestamp() > m_glCompileTimestamp.timestamp() || renderState.m_contextChanged || !m_imgposbuf || m_quads.imgQuads.length * 12 > m_imgposbuf.length) {
      setupDrawObjects(renderState);
    }
    mapper.s_render(renderState, true);
    var context = renderState.m_context,
      opacity,
      zOffset,
      crop = {
        x: 1,
        y: 1
      },
      quadcrop,
      cropsrc = {
        x0: 0,
        y0: 0,
        x1: 1,
        y1: 1
      },
      quadcropsrc,
      w,
      h,
      quadw,
      quadh;
    var nearestPixel = m_this.nearestPixel();
    if (nearestPixel !== undefined) {
      if (nearestPixel !== true && util.isNonNullFinite(nearestPixel)) {
        var curZoom = m_this.layer().map().zoom();
        nearestPixel = curZoom >= nearestPixel;
      }
      m_quads.imgQuads.forEach(function (quad) {
        if ((quad.image || quad.imageTexture) && quad.texture && quad.texture.nearestPixel() !== nearestPixel && quad.texture.textureHandle()) {
          /* This could just be
           *   quad.texture.setNearestPixel(nearestPixel);
           * but that needlessly redecodes the image.  Instead, just change the
           * the interpolation flags, then change the nearestPixel value
           * without triggering a complete re-setup. */
          renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, quad.texture.textureHandle());
          renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MIN_FILTER, nearestPixel ? vgl.GL.NEAREST : vgl.GL.LINEAR);
          renderState.m_context.texParameteri(vgl.GL.TEXTURE_2D, vgl.GL.TEXTURE_MAG_FILTER, nearestPixel ? vgl.GL.NEAREST : vgl.GL.LINEAR);
          renderState.m_context.bindTexture(vgl.GL.TEXTURE_2D, null);
          var oldmod = quad.texture.modified;
          quad.texture.modified = function () {};
          quad.texture.setNearestPixel(nearestPixel);
          quad.texture.modified = oldmod;
        }
      });
    }
    if (m_this._hookRenderImageQuads) {
      m_this._hookRenderImageQuads(renderState, m_quads.imgQuads);
    }
    context.bindBuffer(context.ARRAY_BUFFER, m_glBuffers.imgQuadsPosition);
    $.each(m_quads.imgQuads, function (idx, quad) {
      if (!quad.image && !quad.imageTexture) {
        return;
      }
      quad.texture.bind(renderState);
      if (quad.image) {
        w = quad.image.width;
        h = quad.image.height;
      }
      if (quad.imageTexture) {
        w = quad.imageTexture.width;
        h = quad.imageTexture.height;
      }
      // only check if the context is out of memory when using modestly large
      // textures.  The check is slow.
      if ((quad.image || quad.imageTexture) && w * h > _memoryCheckLargestTested) {
        _memoryCheckLargestTested = w * h;
        if (context.getError() === context.OUT_OF_MEMORY) {
          console.log('Insufficient GPU memory for texture'); // eslint-disable-line no-console
        }
      }
      if (quad.opacity !== opacity) {
        opacity = quad.opacity;
        context.uniform1fv(renderState.m_material.shaderProgram().uniformLocation('opacity'), new Float32Array([opacity]));
      }
      if ((quad.zOffset || 0.0) !== zOffset) {
        zOffset = quad.zOffset || 0.0;
        context.uniform1fv(renderState.m_material.shaderProgram().uniformLocation('zOffset'), new Float32Array([zOffset]));
      }
      quadcrop = quad.crop || {
        x: 1,
        y: 1
      };
      if (!crop || quadcrop.x !== crop.x || quadcrop.y !== crop.y) {
        crop = quadcrop;
        context.uniform2fv(renderState.m_material.shaderProgram().uniformLocation('crop'), new Float32Array([crop.x === undefined ? 1 : crop.x, crop.y === undefined ? 1 : crop.y]));
      }
      quadcropsrc = quad.crop || {
        left: 0,
        top: 0,
        right: w,
        bottom: h
      };
      if (!cropsrc || quadcropsrc.left !== cropsrc.left || quadcropsrc.top !== cropsrc.top || quadcropsrc.right !== cropsrc.right || quadcropsrc.bottom !== cropsrc.bottom || quadw !== w || quadh !== h) {
        cropsrc = quadcropsrc;
        quadw = w;
        quadh = h;
        context.uniform4fv(renderState.m_material.shaderProgram().uniformLocation('cropsource'), new Float32Array([cropsrc.left / w, cropsrc.top / h, cropsrc.right / w, cropsrc.bottom / h]));
      }
      context.bindBuffer(context.ARRAY_BUFFER, m_glBuffers.imgQuadsPosition);
      context.vertexAttribPointer(vgl.vertexAttributeKeys.Position, 3, context.FLOAT, false, 12, idx * 12 * 4);
      context.enableVertexAttribArray(vgl.vertexAttributeKeys.Position);
      context.drawArrays(context.TRIANGLE_STRIP, 0, 4);
      quad.texture.undoBind(renderState);
    });
    context.bindBuffer(context.ARRAY_BUFFER, null);
    mapper.undoBindVertexData(renderState);
  };

  /**
   * Update.
   */
  this._update = function () {
    s_update.call(m_this);
    if (m_this.buildTime().timestamp() <= m_this.dataTime().timestamp() || m_this.updateTime().timestamp() < m_this.timestamp()) {
      m_this._build();
    }
    if (m_actor_color) {
      m_actor_color.setVisible(m_this.visible());
      m_actor_color.material().setBinNumber(m_this.bin());
    }
    if (m_actor_image) {
      m_actor_image.setVisible(m_this.visible());
      m_actor_image.material().setBinNumber(m_this.bin());
    }
    m_this.updateTime().modified();
  };

  /**
   * Cleanup.
   */
  this._cleanup = function () {
    if (m_actor_image) {
      m_this.renderer().contextRenderer().removeActor(m_actor_image);
      m_actor_image = null;
    }
    if (m_actor_color) {
      m_this.renderer().contextRenderer().removeActor(m_actor_color);
      m_actor_color = null;
    }
    m_imgposbuf = undefined;
    m_clrposbuf = undefined;
    if (m_glBuffers) {
      Object.keys(m_glBuffers).forEach(function (key) {
        delete m_glBuffers[key];
      });
    }
    if (m_quads && m_quads.imgQuads) {
      m_quads.imgQuads.forEach(function (quad) {
        if (quad.texture) {
          delete quad.texture;
          if (quad.image && quad.image._texture) {
            delete quad.image._texture;
          }
        }
        if (quad.imageTexture) {
          delete quad.imageTexture._texture;
        }
      });
      m_this._updateTextures();
    }
    m_this.modified();
  };

  /**
   * Set the image or color vertex or fragment shader.
   *
   * @param {string} shaderType One of `image_vertex`, `image_fragment`,
   *   `color_vertex`, or `color_fragment`.
   * @param {string} shaderCode The shader program.
   * @returns {this?} The class instance on success, undefined in an unknown
   *    shaderType was specified.
   */
  this.setShader = function (shaderType, shaderCode) {
    switch (shaderType) {
      case 'image_vertex':
        vertexShaderImage = shaderCode;
        break;
      case 'image_fragment':
        fragmentShaderImage = shaderCode;
        break;
      case 'color_vertex':
        vertexShaderColor = shaderCode;
        break;
      case 'color_fragment':
        fragmentShaderColor = shaderCode;
        break;
      default:
        return undefined;
    }
    return m_this;
  };

  /**
   * Destroy.
   */
  this._exit = function () {
    m_this._cleanup();
    s_exit.call(m_this);
  };
  m_this._init(arg);
  return this;
};
inherit(_webgl_quadFeature, quadFeature);

// Now register it
var capabilities = {};
capabilities[quadFeature.capabilities.color] = true;
capabilities[quadFeature.capabilities.image] = true;
capabilities[quadFeature.capabilities.imageCrop] = true;
capabilities[quadFeature.capabilities.imageFixedScale] = false;
capabilities[quadFeature.capabilities.imageFull] = true;
capabilities[quadFeature.capabilities.canvas] = false;
capabilities[quadFeature.capabilities.video] = false;
capabilities[quadFeature.capabilities.texture] = true;
registerFeature('webgl', 'quad', _webgl_quadFeature, capabilities);
module.exports = _webgl_quadFeature;

/***/ }),

/***/ 1474:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var registerLayerAdjustment = (__webpack_require__(1098).registerLayerAdjustment);
var tileLayer = __webpack_require__(9264);
var webgl_tileLayer = function webgl_tileLayer() {
  'use strict';

  var geo_event = __webpack_require__(6409);
  var m_this = this,
    s_init = this._init,
    s_exit = this._exit,
    s_update = this._update,
    s_visible = this.visible,
    s_zIndex = this.zIndex,
    m_quadFeature,
    m_nextTileId = 0,
    m_tiles = [];

  /**
   * Add a tile to the list of quads.
   *
   * @param {geo.tile} tile The tile to add and draw.
   * @memberof geo.webgl.tileLayer
   */
  this._drawTile = function (tile) {
    if (!m_quadFeature) {
      return;
    }
    var bounds = m_this._tileBounds(tile),
      level = tile.index.level || 0,
      to = m_this._tileOffset(level),
      crop = m_this.tileCropFromBounds(tile),
      quad = {},
      offset,
      upperTileLayers,
      depthBits = m_this.renderer().contextRenderer().m_depthBits,
      z = 0; // this will change if tileLayers have topography

    if (crop) {
      quad.crop = {
        x: crop.x / m_this._options.tileWidth,
        y: crop.y / m_this._options.tileHeight
      };
    }
    quad.ul = m_this.fromLocal(m_this.fromLevel({
      x: bounds.left - to.x,
      y: bounds.top - to.y
    }, level), 0);
    quad.ll = m_this.fromLocal(m_this.fromLevel({
      x: bounds.left - to.x,
      y: bounds.bottom - to.y
    }, level), 0);
    quad.ur = m_this.fromLocal(m_this.fromLevel({
      x: bounds.right - to.x,
      y: bounds.top - to.y
    }, level), 0);
    quad.lr = m_this.fromLocal(m_this.fromLevel({
      x: bounds.right - to.x,
      y: bounds.bottom - to.y
    }, level), 0);
    quad.ul.z = quad.ll.z = quad.ur.z = quad.lr.z = z;

    /* Compute a zOffset per layer and level.  This ensures all tile levels in
     * all tile layers are sorted with the earlier layers and lower levels on
     * the bottom.  Ideally, don't change the z values, since the z-buffer may
     * be expected to have the correct values, but by shifting each layer a
     * small offset, the levels will appear in the correct order and avoid
     * z-fighting.  The zOffset is applied *after* matrix transformations, and
     * is in the webgl clip space of [0-1] with the resolution of the
     * DEPTH_BITS. */
    offset = m_this._options.keepLower ? m_this._options.maxLevel - level + 1 : 1;
    upperTileLayers = m_this.map().listSceneObjects().filter(function (object) {
      return object instanceof tileLayer;
    });
    upperTileLayers = upperTileLayers.slice(upperTileLayers.indexOf(m_this) + 1);
    upperTileLayers.forEach(function (object) {
      offset += object._options.keepLower ? object._options.maxLevel - object._options.minLevel + 1 : 1;
    });
    /* See the definition of `_zOffsetMultiple` for more details. */
    quad.zOffset = offset * Math.pow(2, -depthBits) * tileLayer._zOffsetMultiple;
    m_nextTileId += 1;
    quad.id = m_nextTileId;
    tile.quadId = quad.id;
    quad.image = tile.image;
    m_tiles.push(quad);
    m_quadFeature.data(m_tiles);
    m_quadFeature._update();
    m_this.draw();
  };

  /**
   * Remove a tile from the list of quads.   The quadFeature is redrawn.
   *
   * @param {geo.tile} tile The tile to remove.
   */
  this._remove = function (tile) {
    if (tile.quadId !== undefined && m_quadFeature) {
      for (var i = 0; i < m_tiles.length; i += 1) {
        if (m_tiles[i].id === tile.quadId) {
          m_tiles.splice(i, 1);
          break;
        }
      }
      m_quadFeature.data(m_tiles);
      m_quadFeature._update();
      m_this.draw();
    }
  };

  /**
   * Get/Set visibility of the layer.
   *
   * @param {boolean} [val] If specified, change the visibility, otherwise
   *    return it.
   * @returns {boolean|this} The current visibility or the layer.
   * @memberof geo.webgl.tileLayer
   */
  this.visible = function (val) {
    if (val === undefined) {
      return s_visible();
    }
    if (m_this.visible() !== val) {
      s_visible(val);
      if (m_quadFeature) {
        m_quadFeature.visible(m_quadFeature.visible(undefined, true), true);
      }
    }
    return m_this;
  };

  /**
   * Get or set the z-index of the layer.  The z-index controls the display
   * order of the layers in much the same way as the CSS z-index property.
   *
   * @param {number} [zIndex] The new z-index, or undefined to return the
   *    current z-index.
   * @param {boolean} [allowDuplicate] When setting the z index, if this is
   *    truthy, allow other layers to have the same z-index.  Otherwise,
   *    ensure that other layers have distinct z-indices from this one.
   * @returns {number|this}
   * @memberof geo.webgl.tileLayer
   */
  this.zIndex = function (zIndex, allowDuplicate) {
    if (zIndex !== undefined) {
      m_this._clearQuads();
    }
    return s_zIndex.apply(m_this, arguments);
  };

  /**
   * If the z-index has changed or layers are added or removed, clear the quads
   * so they are composited in the correct order.
   *
   * @param {geo.event} [evt] If specified, the layer add or remove event that
   *    triggered this.  If `undefined`, clear the quads but don't redraw.
   * @memberof geo.webgl.tileLayer
   */
  this._clearQuads = function (evt) {
    if (evt && (!evt.layer || !(evt.layer instanceof tileLayer) || !evt.layer.autoshareRenderer() || (evt.event === geo_event.layerAdd || evt.event === geo_event.layerRemove) && m_this.map().layers().every(function (l) {
      return l === evt.layer || evt.layer.zIndex() > l.zIndex();
    }))) {
      return;
    }
    m_this.clear();
    if (m_quadFeature) {
      m_quadFeature.modified();
    }
    if (evt) {
      m_this.draw();
    }
  };

  /**
   * Update layer.
   *
   * @param {object} request A value to pass to the parent class.
   * @returns {this}
   * @memberof geo.webgl.tileLayer
   */
  this._update = function (request) {
    s_update.call(m_this, request);
    if (m_quadFeature && m_quadFeature.nearestPixel) {
      m_quadFeature.nearestPixel(m_this.nearestPixel());
    }
    m_this._addBaseQuadToTiles(m_quadFeature, m_tiles);
    return m_this;
  };

  /**
   * Cleanup.  This purges the texture and tile cache.
   * @memberof geo.webgl.tileLayer
   */
  this._cleanup = function () {
    var tile;
    if (m_this.cache && m_this.cache._cache) {
      for (var hash in m_this.cache._cache) {
        tile = m_this.cache._cache[hash];
        if (tile._image && tile._image._texture) {
          delete tile._image._texture;
        }
      }
      m_this.cache.clear();
    }
    m_this.clear();
  };

  /**
   * Destroy.
   * @memberof geo.webgl.tileLayer
   */
  this._exit = function () {
    var map = m_this.map();
    map.geoOff(geo_event.layerAdd, m_this._clearQuads);
    map.geoOff(geo_event.layerRemove, m_this._clearQuads);
    m_this._cleanup();
    m_this.deleteFeature(m_quadFeature);
    m_quadFeature = null;
    m_tiles = [];
    s_exit.apply(m_this, arguments);
  };

  /**
   * Initialize after the layer is added to the map.
   * @memberof geo.webgl.tileLayer
   */
  this._init = function () {
    s_init.apply(m_this, arguments);
    m_quadFeature = m_this.createFeature('quad', {
      previewColor: m_this._options.previewColor,
      previewImage: m_this._options.previewImage
    });
    m_quadFeature.geoTrigger = undefined;
    m_quadFeature.gcs(m_this._options.gcs || m_this.map().gcs());
    m_quadFeature.data(m_tiles);
    m_quadFeature._update();
    var map = m_this.map();
    map.geoOn(geo_event.layerAdd, m_this._clearQuads);
    map.geoOn(geo_event.layerRemove, m_this._clearQuads);
    m_this.geoOn(geo_event.unhidden, function () {
      m_this.map().scheduleAnimationFrame(function () {
        m_this._clearQuads();
        m_this.map().draw();
      });
    });
  };

  /* These functions don't need to do anything. */
  this._getSubLayer = function () {};
  this._updateSubLayers = undefined;
};

/* Use a multiple of the minimum z delta provided by DEPTH_BITS so that
 * rounding won't accidentally merge two levels.  This may need to be higher
 * if the tile layer is not flat to the camera. */
tileLayer._zOffsetMultiple = 2;
registerLayerAdjustment('webgl', 'tile', webgl_tileLayer);
module.exports = webgl_tileLayer;

/***/ }),

/***/ 536:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerFeature = (__webpack_require__(1098).registerFeature);
var trackFeature = __webpack_require__(338);

/**
 * Create a new instance of trackFeature.
 *
 * @class
 * @alias geo.webgl.trackFeature
 * @extends geo.trackFeature
 * @param {geo.trackFeature.spec} arg
 * @returns {geo.webgl.trackFeature}
 */
var _webgl_trackFeature = function webgl_trackFeature(arg) {
  'use strict';

  if (!(this instanceof _webgl_trackFeature)) {
    return new _webgl_trackFeature(arg);
  }
  arg = arg || {};
  trackFeature.call(this, arg);
  var object = __webpack_require__(4084);
  object.call(this);
  this._init(arg);
  return this;
};
inherit(_webgl_trackFeature, trackFeature);

// Now register it
registerFeature('webgl', 'track', _webgl_trackFeature);
module.exports = _webgl_trackFeature;

/***/ }),

/***/ 7945:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var inherit = __webpack_require__(4626);
var registerRenderer = (__webpack_require__(1098).registerRenderer);
var renderer = __webpack_require__(2274);

/**
 * Create a new instance of class webglRenderer.
 *
 * @class
 * @alias geo.webgl.webglRenderer
 * @extends geo.renderer
 * @param {object} arg Options for the renderer.
 * @param {geo.layer} [arg.layer] Layer associated with the renderer.
 * @param {HTMLElement} [arg.canvas] Canvas element associated with the
 *   renderer.
 * @param {object} [arg.options] Additional options for the webgl renderer.
 * @returns {geo.webgl.webglRenderer}
 */
var _webglRenderer = function webglRenderer(arg) {
  'use strict';

  if (!(this instanceof _webglRenderer)) {
    return new _webglRenderer(arg);
  }
  arg = arg || {};
  renderer.call(this, arg);
  var $ = __webpack_require__(5616);
  var vgl = __webpack_require__(1611);
  var mat4 = __webpack_require__(3503);
  var util = __webpack_require__(642);
  var geo_event = __webpack_require__(6409);
  var m_this = this,
    m_contextRenderer = null,
    m_viewer = null,
    m_lastZoom,
    m_updateCamera = false,
    s_init = this._init,
    s_exit = this._exit;

  /**
   * Get context specific renderer.
   *
   * @returns {object} The vgl context renderer.
   */
  this.contextRenderer = function () {
    return m_contextRenderer;
  };

  /**
   * Get API used by the renderer.
   *
   * @returns {string} `webgl`.
   */
  this.api = function () {
    return _webglRenderer.apiname;
  };

  /**
   * Initialize.
   *
   * @returns {this}
   */
  this._init = function () {
    if (m_this.initialized()) {
      return m_this;
    }
    s_init.call(m_this);
    var canvas = arg.canvas || $(document.createElement('canvas'));
    canvas.addClass('webgl-canvas');
    $(m_this.layer().node().get(0)).append(canvas);
    if (window.overrideContextAttributes) {
      var elem = canvas.get(0);
      var getContext = elem.getContext;
      elem.getContext = function (contextType, contextAttributes) {
        contextAttributes = contextAttributes || {};
        if (window.overrideContextAttributes) {
          for (var key in window.overrideContextAttributes) {
            if (window.overrideContextAttributes.hasOwnProperty(key)) {
              contextAttributes[key] = window.overrideContextAttributes[key];
            }
          }
        }
        return getContext.call(elem, contextType, contextAttributes);
      };
    }
    m_viewer = vgl.viewer(canvas.get(0), arg.options);
    m_viewer.init();
    m_contextRenderer = m_viewer.renderWindow().activeRenderer();
    m_contextRenderer.setResetScene(false);
    canvas.get(0).addEventListener('webglcontextlost', function (evt) {
      return evt.preventDefault();
    }, false);
    canvas.get(0).addEventListener('webglcontextrestored', function () {
      return m_viewer.renderWindow()._init();
    }, false);
    if (m_viewer.renderWindow().renderers().length > 0) {
      m_contextRenderer.setLayer(m_viewer.renderWindow().renderers().length);
    }
    m_this.canvas(canvas);
    /* Initialize the size of the renderer */
    var map = m_this.layer().map(),
      mapSize = map.size();
    m_this._resize(0, 0, mapSize.width, mapSize.height);
    return m_this;
  };

  /**
   * Handle resize event.
   *
   * @param {number} x The left coordinate.
   * @param {number} y The top coordinate.
   * @param {number} w The width in pixels.
   * @param {number} h The height in pixels.
   * @returns {this}
   */
  this._resize = function (x, y, w, h) {
    var renderWindow = m_viewer.renderWindow();
    if (x !== renderWindow.windowPosition[0] || y !== renderWindow.windowPosition[1] || w !== m_this.width() || h !== m_this.height()) {
      m_this._setWidthHeight(w, h);
      m_this.canvas().attr('width', w);
      m_this.canvas().attr('height', h);
      renderWindow.positionAndResize(x, y, w, h);
      m_updateCamera = true;
      m_this._render();
    }
    return m_this;
  };

  /**
   * Render.  This actually schedules rendering for the next animation frame.
   *
   * @returns {this}
   */
  this._render = function () {
    /* If we are already scheduled to render, don't schedule again.  Rather,
     * mark that we should render after other animation frame requests occur.
     * It would be nice if we could just reschedule the call by removing and
     * re-adding the animation frame request, but this doesn't work for if the
     * reschedule occurs during another animation frame callback (it then waits
     * until a subsequent frame). */
    m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame, true);
    return m_this;
  };

  /**
   * This clears the render timer and actually renders.
   */
  this._renderFrame = function () {
    if (m_viewer) {
      if (m_updateCamera) {
        m_updateCamera = false;
        m_this._updateRendererCamera();
      }
      m_viewer.render();
    }
  };

  /**
   * Get the GL context for this renderer.
   *
   * @returns {WebGLRenderingContext} The current context.  If unavailable,
   *    falls back to the vgl generic context.
   */
  this._glContext = function () {
    if (m_viewer && m_viewer.renderWindow()) {
      return m_viewer.renderWindow().context();
    }
    return vgl.GL;
  };

  /**
   * Exit.
   */
  this._exit = function () {
    m_this.layer().map().scheduleAnimationFrame(m_this._renderFrame, 'remove');
    m_this.canvas().remove();
    if (m_viewer) {
      var renderState = new vgl.renderState();
      renderState.m_renderer = m_viewer;
      renderState.m_context = m_this._glContext();
      m_viewer.exit(renderState);
      var context = m_this._glContext();
      if (context !== vgl.GL && context.getExtension('WEBGL_lose_context') && context.getExtension('WEBGL_lose_context').loseContext) {
        context.getExtension('WEBGL_lose_context').loseContext();
      }
    }
    // make sure we clear shaders associated with the generated context, too
    vgl.clearCachedShaders(vgl.GL);
    m_viewer = null;
    s_exit();
  };

  /**
   * Update the vgl renderer's camera based on the map's camera class.
   */
  this._updateRendererCamera = function () {
    var renderWindow = m_viewer.renderWindow(),
      map = m_this.layer().map(),
      camera = map.camera(),
      rotation = map.rotation() || 0,
      view = camera.view,
      proj = camera.projectionMatrix;
    if (proj[15]) {
      /* In the parallel projection, we want the clipbounds [near, far] to map
       * to [0, 1].  The ortho matrix scales to [-1, 1]. */
      proj = mat4.copy(util.mat4AsArray(), proj);
      proj = mat4.scale(proj, proj, [1, 1, -0.5]);
      proj = mat4.translate(proj, proj, [0, 0, camera.clipbounds.far]);
    } else {
      /* This rescales the perspective projection to work with most gl
       * features.  It doesn't work with all clipbounds, and will probably need
       * to be refactored when we have tiltable maps. */
      var near = camera.clipbounds.near,
        far = camera.clipbounds.far;
      proj = mat4.copy(util.mat4AsArray(), proj);
      proj = mat4.scale(proj, proj, [1 / near, 1 / near, -1 / far]);
    }
    /* Check if the rotation is a multiple of 90 */
    var basis = Math.PI / 2,
      angle = rotation % basis,
      // move to range (-pi/2, pi/2)
      ortho = Math.min(Math.abs(angle), Math.abs(angle - basis)) < 0.00001;
    renderWindow.renderers().forEach(function (renderer) {
      var cam = renderer.camera();
      if (util.compareArrays(view, cam.viewMatrix()) && util.compareArrays(proj, cam.projectionMatrix()) && m_lastZoom === map.zoom()) {
        return;
      }
      m_lastZoom = map.zoom();
      cam.setViewMatrix(view, true);
      cam.setProjectionMatrix(proj);
      var viewport = camera.viewport;
      /* Test if we should align texels.  We won't if the projection matrix
       * is not simple, if there is a rotation that isn't a multiple of 90
       * degrees, if the viewport is not at an integer location, or if the zoom
       * level is not close to an integer.
       *   Note that the test for the viewport is strict (val % 1 is non-zero
       * if the value is not an integer), as, in general, the alignment is only
       * non-integral if a percent offset or calculation was used in css
       * somewhere.  The test for zoom level always has some allowance for
       * precision, as it is often the result of repeated computations. */
      if (proj[1] || proj[2] || proj[3] || proj[4] || proj[6] || proj[7] || proj[8] || proj[9] || proj[11] || proj[15] !== 1 || !ortho || viewport.left && viewport.left % 1 || viewport.top && viewport.top % 1 || parseFloat(m_lastZoom.toFixed(6)) !== parseFloat(m_lastZoom.toFixed(0))) {
        /* Don't align texels */
        cam.viewAlignment = function () {
          return null;
        };
      } else {
        /* Set information for texel alignment.  The rounding factors should
         * probably be divided by window.devicePixelRatio. */
        cam.viewAlignment = function () {
          var align = {
            roundx: 2.0 / viewport.width,
            roundy: 2.0 / viewport.height
          };
          align.dx = viewport.width % 2 ? align.roundx * 0.5 : 0;
          align.dy = viewport.height % 2 ? align.roundy * 0.5 : 0;
          return align;
        };
      }
    });
  };

  // Connect to pan event.  This is sufficient, as all zooms and rotations also
  // produce a pan
  m_this.layer().geoOn(geo_event.pan, function (_evt) {
    m_updateCamera = true;
  });

  // Connect to parallelprojection event
  m_this.layer().geoOn(geo_event.parallelprojection, function (evt) {
    var vglRenderer = m_this.contextRenderer(),
      camera,
      layer = m_this.layer();
    if (evt.geo && evt.geo._triggeredBy !== layer) {
      if (!vglRenderer || !vglRenderer.camera()) {
        console.log('Parallel projection event triggered on unconnected VGL renderer.'); // eslint-disable-line no-console
        return;
      }
      camera = vglRenderer.camera();
      camera.setEnableParallelProjection(evt.parallelProjection);
      m_updateCamera = true;
    }
  });
  return this;
};
_webglRenderer.apiname = 'webgl';
inherit(_webglRenderer, renderer);
registerRenderer('webgl', _webglRenderer);
// Also register under an alternate name (alias for backwards compatibility)
registerRenderer('vgl', _webglRenderer);

/* Code for checking if the renderer is supported */

var checkedWebGL;

/**
 * Report if the webgl renderer is supported.  This is just a check if webGL is
 * supported and available.
 *
 * @returns {boolean} true if available.
 */
_webglRenderer.supported = function () {
  if (checkedWebGL === undefined) {
    /* This is extracted from what Modernizr uses. */
    var canvas, ctx, exts;
    try {
      canvas = document.createElement('canvas');
      /** @type {WebGLRenderingContext} */
      ctx = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      /* getSupportExtensions will throw an exception if the context isn't
       * really supported. */
      exts = ctx.getSupportedExtensions();
      /* If available, store the unmasked renderer to aid in debugging. */
      if (exts.indexOf('WEBGL_debug_renderer_info') >= 0) {
        _webglRenderer._unmaskedRenderer = ctx.getParameter(ctx.getExtension('WEBGL_debug_renderer_info').UNMASKED_RENDERER_WEBGL);
      }
      // store some parameters for convenience
      _webglRenderer._maxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
      _webglRenderer._maxPointSize = ctx.getParameter(ctx.ALIASED_POINT_SIZE_RANGE)[1];
      checkedWebGL = true;
    } catch (e) {
      console.warn('No webGL support'); // eslint-disable-line no-console
      checkedWebGL = false;
    }
    canvas = undefined;
    ctx = undefined;
    exts = undefined;
  }
  return checkedWebGL;
};

/**
 * If the webgl renderer is not supported, supply the name of a renderer that
 * should be used instead.  This asks for the null renderer.
 *
 * @returns {null} null for the null renderer.
 */
_webglRenderer.fallback = function () {
  return null;
};
module.exports = _webglRenderer;

/***/ }),

/***/ 632:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4942);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3021);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(3158), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(5245), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(8546), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(9803), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(9463), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_3___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_4___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".geojs-map{position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden}.geojs-map .geo-attribution{position:absolute;right:0;bottom:0;padding-right:5px;cursor:auto;font:11px/1.5 \"Helvetica Neue\",Arial,Helvetica,sans-serif;z-index:1001;background:rgba(255,255,255,0.7);clear:both;display:block;pointer-events:auto}.geojs-map .geo-attribution .geo-attribution-layer{padding-left:5px}.geojs-map .canvas-canvas{display:block;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0}.geojs-map .webgl-canvas{display:block}.geojs-map .geojs-layer{position:absolute;width:100%;height:100%;left:0;top:0;pointer-events:none}.geojs-map .geojs-layer.active:not(.hidden) > *{pointer-events:auto}.geojs-map .geojs-layer.hidden{display:none}.geojs-map .geojs-layer.hidden[renderer=\"webgl\"]{display:inherit}.geojs-map .geo-tile-layer{-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;line-height:0;font-size:0}.geojs-map.annotation-input{cursor:crosshair}.geojs-map.annotation-input.annotation-intersect{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") 12 12,crosshair}.geojs-map.annotation-input.annotation-difference{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") 12 12,crosshair}.geojs-map.annotation-input.annotation-union{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") 12 12,crosshair}.geojs-map.annotation-input.annotation-xor{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") 12 12,crosshair}.geojs-map.annotation-input.annotation-cut{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_4___ + ") 12 12,crosshair}.geojs-map.annotation-cursor{cursor:crosshair}.geojs-map.annotation-cursor.annotation-intersect{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_0___ + ") 12 12,crosshair}.geojs-map.annotation-cursor.annotation-difference{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_1___ + ") 12 12,crosshair}.geojs-map.annotation-cursor.annotation-union{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_2___ + ") 12 12,crosshair}.geojs-map.annotation-cursor.annotation-xor{cursor:url(" + ___CSS_LOADER_URL_REPLACEMENT_3___ + ") 12 12,crosshair}.geojs-map.highlight-focus:after{content:\"\";display:block;position:absolute;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;left:0;top:0;right:0;bottom:0;border:3px solid Highlight;opacity:1;-ms-filter:none;filter:none;-webkit-transition:opacity 0s;-moz-transition:opacity 0s;-o-transition:opacity 0s;-ms-transition:opacity 0s;transition:opacity 0s;visibility:hidden}.geojs-map.highlight-focus:focus:after{visibility:visible;-webkit-transition:opacity 2.5s ease-in;-moz-transition:opacity 2.5s ease-in;-o-transition:opacity 2.5s ease-in;-ms-transition:opacity 2.5s ease-in;transition:opacity 2.5s ease-in;opacity:0;-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";filter:alpha(opacity=0)}.geo-tile-container{position:absolute}.geo-tile-container.crop{overflow:hidden}", "",{"version":3,"sources":["webpack://./main.styl","webpack://./../node_modules/nib/lib/nib/vendor.styl","webpack://./../node_modules/nib/lib/nib/overflow.styl","webpack://./../node_modules/nib/lib/nib/flex.styl","webpack://./../node_modules/nib/lib/nib/border.styl"],"names":[],"mappings":"AAEA,WACE,iBAAS,CCwCO,wBAAG,CAAH,qBAAG,CAAH,oBAAG,CARN,gBAAG,CChBd,eAAU,CFZZ,4BACE,iBAAS,CACT,OAAM,CACN,QAAO,CACP,iBAAc,CC4ed,WAAO,CD1eP,yDAA8B,CAC9B,YAAQ,CC6dR,gCAAW,CD3dX,UAAM,CGMN,aAAS,CHJT,mBAAe,CAEf,mDACE,gBAAa,CAEjB,0BGDE,aAAS,CFqBK,4BAAG,CAAH,yBAAG,CAAH,uBAAG,CAAH,wBAAG,CARN,oBAAG,CDThB,yBGJE,aAAS,CHOX,wBACE,iBAAS,CACT,UAAM,CACN,WAAO,CACP,MAAK,CACL,KAAI,CACJ,mBAAe,CAEb,gDACE,mBAAe,CACnB,+BGjBA,YAAS,CHmBT,iDGnBA,eAAS,CHsBX,2BCDgB,4BAAG,CAAH,yBAAG,CAAH,uBAAG,CAAH,wBAAG,CARN,oBAAG,CDWd,aAAY,CACZ,WAAU,CAEZ,4BCscE,gBAAO,CDpcP,iDCocA,8DAAO,CDlcP,kDCkcA,8DAAO,CDhcP,6CCgcA,8DAAO,CD9bP,2CC8bA,8DAAO,CD5bP,2CC4bA,8DAAO,CDzbT,6BCybE,gBAAO,CDvbP,kDCubA,8DAAO,CDrbP,mDCqbA,8DAAO,CDnbP,8CCmbA,8DAAO,CDjbP,4CCibA,8DAAO,CD7aP,iCACE,UAAQ,CGrDV,aAAS,CHuDP,iBAAS,CClCG,6BAAG,CAAH,0BAAG,CARN,qBAAG,CD4CZ,MAAK,CACL,KAAI,CACJ,OAAM,CACN,QAAO,CIzET,0BAAQ,CH4PV,SAAS,CAQH,eAAY,CACZ,WAAQ,CArOE,6BAAG,CAAH,0BAAG,CAAH,wBAAG,CAAH,yBAAG,CARN,qBAAG,CDuDZ,iBAAW,CACb,uCACE,kBAAW,CCjDC,uCAAG,CAAH,oCAAG,CAAH,kCAAG,CAAH,mCAAG,CARN,+BAAG,CAoOhB,SAAS,CAWH,+DAAyE,CACzE,uBAAiC,CDnLzC,oBACE,iBAAS,CACT,yBE7EE,eAAU","sourcesContent":["@import '~nib/index.styl'\n\n.geojs-map\n  position relative\n  user-select none\n  overflow hidden\n\n  .geo-attribution\n    position absolute\n    right 0\n    bottom 0\n    padding-right 5px\n    cursor auto\n    font 11px/1.5 \"Helvetica Neue\", Arial, Helvetica, sans-serif\n    z-index 1001\n    background rgba(255,255,255,0.7)\n    clear both\n    display block\n    pointer-events auto\n\n    .geo-attribution-layer\n      padding-left 5px\n\n  .canvas-canvas\n    display block\n    transform-origin 0px 0px\n  .webgl-canvas\n    display block\n\n  .geojs-layer\n    position absolute\n    width 100%\n    height 100%\n    left 0\n    top 0\n    pointer-events none\n    &.active:not(.hidden)\n      > *\n        pointer-events auto\n    &.hidden\n      display none\n    &.hidden[renderer=\"webgl\"]\n      display inherit\n\n  .geo-tile-layer\n    transform-origin 0px 0px\n    line-height 0\n    font-size 0\n\n  &.annotation-input\n    cursor crosshair\n    &.annotation-intersect\n      cursor embedurl(\"./css/cursor-crosshair-intersect.svg\") 12 12,crosshair\n    &.annotation-difference\n      cursor embedurl(\"./css/cursor-crosshair-difference.svg\") 12 12,crosshair\n    &.annotation-union\n      cursor embedurl(\"./css/cursor-crosshair-union.svg\") 12 12,crosshair\n    &.annotation-xor\n      cursor embedurl(\"./css/cursor-crosshair-xor.svg\") 12 12,crosshair\n    &.annotation-cut\n      cursor embedurl(\"./css/cursor-crosshair-cut.svg\") 12 12,crosshair\n\n  &.annotation-cursor\n    cursor crosshair\n    &.annotation-intersect\n      cursor embedurl(\"./css/cursor-crosshair-intersect.svg\") 12 12,crosshair\n    &.annotation-difference\n      cursor embedurl(\"./css/cursor-crosshair-difference.svg\") 12 12,crosshair\n    &.annotation-union\n      cursor embedurl(\"./css/cursor-crosshair-union.svg\") 12 12,crosshair\n    &.annotation-xor\n      cursor embedurl(\"./css/cursor-crosshair-xor.svg\") 12 12,crosshair\n\n  &.highlight-focus\n    &:after\n      content \"\"\n      display block\n      position absolute\n      box-sizing border-box\n      left 0px\n      top 0px\n      right 0px\n      bottom 0px\n      // Highlight is technically a css2 color.  We may need to specify it\n      // explicitly.  #3B66A6 seems close\n      border 3px solid Highlight\n      opacity 1\n      transition opacity 0s\n      visibility hidden\n    &:focus:after\n      visibility visible\n      transition opacity 2.5s ease-in\n      opacity 0\n\n.geo-tile-container\n  position absolute\n  &.crop\n    overflow hidden\n","use('../nodes/vendor-helpers.js')\n@import 'config'\n\n/*\n * Alias \"nowrap\" as \"no-wrap\".\n */\n\nno-wrap = unquote('nowrap')\n\n/*\n * Helper to find out if a given value is a width\n */\n\nis-width(val)\n  if auto == val\n    return true\n  else if val && 'unit' == type(val)\n    // Stylus does not short circuit so we need to perform this as a distinct\n    // operation to prevent errors\n    return '' != unit(val)\n  return false\n\n/*\n * Vendor support for the given prop / arguments, optionally specifying the\n * only prefixes to utilize, or those which should be ignored.\n */\n\nvendor(prop, args, only = null, ignore = null, vendor-property = true)\n  need_normalize = !vendor-property or prop in ('transition' 'transition-property' 'border-image' 'border-image-slice')\n  for prefix in vendor-prefixes\n    unless (only and !(prefix in only)) or (ignore and prefix in ignore)\n      if official == prefix\n        if need_normalize\n          {prop}: normalize(prop,('%s' % args))\n        else\n          {prop}: args\n      else\n        newprop = prop\n        newprop = '-' + prefix + '-' + prop if vendor-property\n\n        if need_normalize\n          {newprop}: normalize(prop,('%s' % args),prefix)\n        else\n          {newprop}: args\n/*\n * Vendorize the given value.\n */\n\nvendor-value(arg, only = null, ignore = null)\n  prop = current-property[0]\n  for prefix in vendor-prefixes\n    unless (only and !(prefix in only)) or (ignore and prefix in ignore) or official == prefix\n      add-property(prop, '-%s-%s' % (prefix arg))\n  arg\n\n/*\n * Vendor \"box-shadow\" support.\n */\n\nbox-shadow()\n  vendor('box-shadow', arguments, only: webkit official)\n\n/*\n * Vendor \"user-select\" support.\n */\n\nuser-select()\n  vendor('user-select', arguments, only: webkit moz ms official)\n\n/*\n * Vendor \"column-count\" support.\n */\n\ncolumn-count()\n  vendor('column-count', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-gap\" support.\n */\n\ncolumn-gap()\n  vendor('column-gap', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-rule\" support.\n */\n\ncolumn-rule()\n  vendor('column-rule', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-rule-color\" support.\n */\n\ncolumn-rule-color()\n  vendor('column-rule-color', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-rule-width\" support.\n */\n\ncolumn-rule-width()\n  vendor('column-rule-width', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-rule-style\" support.\n */\n\ncolumn-rule-style()\n  vendor('column-rule-style', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-width\" support.\n */\n\ncolumn-width()\n  vendor('column-width', arguments, only: webkit moz official)\n\n/*\n * Vendor \"column-span\" support.\n */\n\ncolumn-span()\n  vendor('column-span', arguments, only: webkit official)\n\n/*\n * Vendor \"column-fill\" support.\n */\n\ncolumn-fill()\n  vendor('column-fill', arguments, only: moz official)\n\n/*\n * Legacy syntax support for background-clip and background-origin\n */\n\nlegacy-bg-values(property, args)\n  legacy_args = ()\n  importance = unquote('')\n  for subargs in args\n    for arg in subargs\n      if arg in (border-box padding-box content-box)\n        arg = unquote('border')  if arg == border-box\n        arg = unquote('padding') if arg == padding-box\n        arg = unquote('content') if arg == content-box\n      if arg != '!important'\n        push(legacy_args,arg)\n      else\n        importance = !important\n  vendor(property, unquote(join(', ',legacy_args)) importance, only: moz webkit)\n\n/*\n * Vendor \"background-clip\" support.\n */\n\nbackground-clip()\n  if arguments[0] == text\n    vendor('background-clip', arguments, only: webkit)\n  else\n    legacy-bg-values('background-clip', arguments)\n    background-clip: arguments\n\n/*\n * Vendor \"background-origin\" support.\n */\n\nbackground-origin()\n  legacy-bg-values('background-origin', arguments)\n  background-origin: arguments\n\n/*\n * Vendor \"transform\" support.\n */\n\ntransform()\n  vendor('transform', arguments)\n\n/*\n * Vendor \"transform-origin\" support.\n */\ntransform-origin()\n    vendor('transform-origin', arguments)\n\n/*\n * Vendor \"transform-style\" support.\n */\n\ntransform-style()\n  vendor('transform-style', arguments)\n\n/*\n * Vendor \"border-image\" support.\n */\n\nborder-image()\n  vendor('border-image', arguments, only: webkit moz o official)\n\n/*\n * Vendor \"transition\" support.\n */\n\ntransition()\n  vendor('transition', arguments)\n\n/*\n * Vendor \"transition-property\" support.\n */\n\ntransition-property()\n  vendor('transition-property', arguments)\n\n/*\n * Vendor \"transition-duration\" support.\n */\n\ntransition-duration()\n  vendor('transition-duration', arguments)\n\n/*\n * Vendor \"transition-timing-function\" support.\n */\n\ntransition-timing-function()\n  vendor('transition-timing-function', arguments)\n\n/*\n * Vendor \"transition-delay\" support.\n */\n\ntransition-delay()\n  vendor('transition-delay', arguments)\n\n/*\n * Vendor \"backface-visibility\" support.\n */\n\nbackface-visibility()\n  vendor('backface-visibility', arguments, only: webkit moz ms official)\n\n/*\n * Vendor \"perspective\" support.\n */\n\nperspective()\n  if mixin\n    vendor('perspective', arguments, only: webkit moz ms official)\n  else\n    'perspective(%s)' % arguments\n\n/*\n * Vendor \"perspective-origin\" support.\n */\n\nperspective-origin()\n  vendor('perspective-origin', arguments, only: webkit moz ms official)\n\n/*\n * Opacity with conditional IE support.\n */\n\nopacity(n, args...)\n  opacity: n args\n  if support-for-ie\n    if n == inherit or n == initial\n      -ms-filter: n args\n      filter: n args\n    else\n      val = round(n * 100)\n      if val == 100\n        -ms-filter: none args\n        filter: none args\n      else\n        -ms-filter: '\"progid:DXImageTransform.Microsoft.Alpha(Opacity=%s)\"' % val args\n        filter: 'alpha(opacity=%s)' % val args\n\n/*\n * Vendor \"text-size-adjust\"\n */\n\ntext-size-adjust()\n  vendor('text-size-adjust', arguments)\n\n/*\n * Alias the \"white-space\" property.\n */\n\nwhitespace()\n  white-space: arguments\n\n/*\n * Vendor \"box-sizing\" support.\n */\n\nbox-sizing()\n  vendor('box-sizing', arguments, only: webkit moz official)\n\n/*\n * Vendor \"box-orient\" support.\n */\n\nbox-orient()\n  vendor('box-orient', arguments, only: webkit moz official)\n\n/*\n * Vendor \"box-flex-group\" support.\n */\n\nbox-flex-group()\n  vendor('box-flex-group', arguments, only: webkit moz official)\n\n/*\n * Vendor \"box-ordinal-group\" support.\n */\n\nbox-ordinal-group()\n  vendor('box-ordinal-group', arguments, only: webkit moz ms official)\n\n\n/*\n * Vendor \"box-align\" support.\n */\n\nbox-align()\n  vendor('box-align', arguments, only: webkit moz ms official)\n\n/*\n * Vendor \"box-pack\" support.\n */\n\nbox-pack()\n  vendor('box-pack', arguments, only: webkit moz ms official)\n\n/*\n * Vendor \"box-direction\" support.\n */\n\nbox-direction()\n  vendor('box-direction', arguments, only: webkit moz ms official)\n\n/*\n * Vendor \"animation\" support.\n */\n\nanimation()\n  vendor('animation', arguments)\n\n\n/*\n * Vendor \"animation-name\" support.\n */\n\nanimation-name()\n  vendor('animation-name', arguments)\n\n/*\n * Vendor \"animation-duration\" support.\n */\n\nanimation-duration()\n  vendor('animation-duration', arguments)\n\n/*\n * Vendor \"animation-delay\" support.\n */\n\nanimation-delay()\n  vendor('animation-delay', arguments)\n\n/*\n * Vendor \"animation-direction\" support.\n */\n\nanimation-direction()\n  vendor('animation-direction', arguments)\n\n/*\n * Vendor \"animation-iteration-count\" support.\n */\n\nanimation-iteration-count()\n  vendor('animation-iteration-count', arguments)\n\n/*\n * Vendor \"animation-timing-function\" support.\n */\n\nanimation-timing-function()\n  vendor('animation-timing-function', arguments)\n\n/*\n * Vendor \"animation-play-state\" support.\n */\n\nanimation-play-state()\n  vendor('animation-play-state', arguments)\n\n/*\n * Vendor \"animation-fill-mode\" support.\n */\n\nanimation-fill-mode()\n  vendor('animation-fill-mode', arguments)\n\n/*\n * Vendor \"hyphens\" support.\n */\n\nhyphens()\n  vendor('hyphens', arguments, only: webkit moz ms official)\n\n/*\n * Vendor \"appearance\" support.\n */\n\nappearance()\n  vendor('appearance', arguments, only: webkit moz official)\n\n/*\n * Vendor \"tab-size\" support.\n */\n\ntab-size()\n  vendor('tab-size', arguments, only: moz o official)\n\n/*\n * Vendor \"overflow-scrolling\" support.\n */\n\noverflow-scrolling()\n  vendor('overflow-scrolling', arguments, only: webkit official)\n\n/*\n * Vendor \"text-overflow\" support, , -o- for opera 9.* - 10.*\n */\n\ntext-overflow()\n  vendor('text-overflow', arguments, only: official o)\n\n/*\n * Vendor \"text-size-adjust\" support.\n */\ntext-size-adjust()\n  vendor('text-size-adjust', arguments, only: official webkit ms)\n\n/*\n * Vendor \"font-smoothing\" support, webkit only.\n */\nfont-smoothing()\n  vendor('font-smoothing', arguments, only: webkit)\n\n\n/**\n * Vendor input-placeholder/placeholder support.\n *\n * Examples:\n *    // Default syntax\n *    body\n *      placeholder(color #333, font-weight normal)\n *\n *    // The comma is important\n *    .placeholder-red\n *      placeholder(color red,)\n *\n *    // We can pass a function\n *    green-placeholder()\n *      color green\n *    .placeholder-green\n *      placeholder(green-placeholder)\n *\n *    // We can pass a hash\n *    textarea\n *      placeholder((font-style italic) (font-weight bold) (padding '4px 10px'))\n */\nplaceholder()\n  for v in ':-webkit-input' '-moz' ':-moz' '-ms-input'\n    &:{v}-placeholder\n      for pair in arguments\n        if typeof(pair) == 'function'\n          pair()\n        else if pair is not null && pair[0] is not null\n          {pair[0]}: type(pair[1]) == 'string' ? s(pair[1]) : pair[1]\ninput-placeholder = placeholder\n\n/*\n * Vendor background support (gradients).\n */\n\nbackground()\n  if match('-gradient\\(', ''+arguments)\n    vendor('background', arguments, vendor-property: false)\n  else\n    background arguments\n\nbackground-image()\n  if match('-gradient\\(', ''+arguments)\n    vendor('background-image', arguments, vendor-property: false)\n  else\n    background-image arguments\n\ncursor()\n  if match('-gradient\\(', ''+arguments)\n    vendor('cursor', arguments, vendor-property: false)\n  else\n    cursor arguments\n\nlist-style()\n  if match('-gradient\\(', ''+arguments)\n    vendor('list-style', arguments, vendor-property: false)\n  else\n    list-style arguments\n\nlist-style-image()\n  if match('-gradient\\(', ''+arguments)\n    vendor('list-style-image', arguments, vendor-property: false)\n  else\n    list-style-image arguments\n","/*\n * Overflow utility. Maps to regular overflow, and adds an ellipsis value.\n *\n * Synopsis:\n *\n *   overflow: <type>\n *\n * Examples:\n *\n *     overflow: auto\n *     overflow: hidden\n *     overflow: ellipsis\n *\n */\n\noverflow()\n  if arguments[0] == ellipsis\n    ellipsis()\n  else\n    overflow: arguments\n","/*\n * Vendor \"display: flex\" support with fallback to obsolete versions.\n */\n\nflex-version ?= box flex\n\n//\n// 1. Display values\n//    - http://www.w3.org/TR/css3-flexbox/#flex-containers\n//\ndisplay(type, args...)\n  if flex == type || inline-flex == type\n    if box in flex-version\n      if flex == type\n        display: -ms-flexbox args\n        display: vendor-value(box args, only: moz webkit)\n      else\n        display: -ms-inline-flexbox args\n        display: vendor-value(inline-box args, only: moz webkit)\n    if flex in flex-version\n      display: vendor-value(arguments, only: webkit official) // overwrites old webkit\n  else\n    display: arguments\n\n/*\n * New syntax for browsers like Google Chrome.\n * Plus a translation to the old syntax, if possible.\n */\n\n\n//\n// 5. Ordering and Orientation\n//    - http://www.w3.org/TR/css3-flexbox/#ordering-and-orientation\n//\n-flex-obsolete-direction(direction)\n  if box in flex-version\n    if row-reverse == direction || column-reverse == direction\n      vendor('box-direction', reverse, ignore: ms official)\n\n    if row == direction || row-reverse == direction\n      vendor('box-orient', horizontal, ignore: ms official)\n    else if column == direction || column-reverse == direction\n      vendor('box-orient', vertical, ignore: ms official)\n\n-flex-obsolete-wrap(value)\n  if box in flex-version\n    // WARN: wrap-reverse does not have a box equivalent. This will render in different manners\n    //    on box vs. flex values.\n    if 'wrap' == value || wrap-reverse == value\n      vendor('box-lines', multiple, ignore: ms official)\n    else if nowrap == value\n      vendor('box-lines', single, ignore: ms official)\n\nflex-direction(direction)\n  // obsolete\n  -flex-obsolete-direction(direction)\n\n  // new\n  if flex in flex-version\n    vendor('flex-direction', arguments, only: webkit ms official)\n\nflex-wrap(value)\n  // obsolete\n  -flex-obsolete-wrap(value)\n\n  if flex in flex-version\n    vendor('flex-wrap', arguments, only: webkit ms official)\n\nflex-flow()\n  // obsolete\n  -flex-obsolete-direction(arguments[0])\n  -flex-obsolete-direction(arguments[1])\n  -flex-obsolete-wrap(arguments[0])\n  -flex-obsolete-wrap(arguments[1])\n\n  // new\n  if flex in flex-version\n    vendor('flex-flow', arguments, only: webkit ms official)\n\n\norder()\n  // obsolete\n  if box in flex-version\n    vendor('box-ordinal-group', arguments, ignore: ms official)\n\n  // new\n  if flex in flex-version\n    vendor('flex-order', arguments, only: ms)\n    vendor('order', arguments, only: webkit official)\n\n\n//\n// 7. Flexibility\n//    - http://www.w3.org/TR/css3-flexbox/#flexibility\n//\nflex-grow(growth)\n  // obsolete\n  if box in flex-version\n    vendor('box-flex', growth)\n\n  // new\n  if flex in flex-version\n    vendor('flex-grow', arguments, only: webkit official)\n\nflex-basis()\n  if flex in flex-version\n    vendor('flex-basis', arguments, only: webkit official)\n\nflex-shrink()\n  if flex in flex-version\n    vendor('flex-shrink', arguments, only: webkit official)\n\nflex(growth)\n\n  // obsolete\n  if box in flex-version\n    shrink = 1\n\n    if none == growth || initial == growth\n      // Well known values\n      shrink = 0 if none == growth\n      growth = 0\n    else if is-width(growth) == true\n      // Basis is defined as the first parameter\n      growth = arguments[1] || 0\n      shrink = arguments[2] if 3 <= length(arguments)\n    else if arguments[1] && is-width(arguments[1]) == false\n      // Growth is first and shrink is second\n      shrink = arguments[1]\n\n    // Since we can't make the distinction between growing and shrinking in the box model, take\n    // the one that provides the most flexibility.\n    vendor('box-flex', max(growth, shrink), ignore: ms)\n\n  // new\n  if flex in flex-version\n    vendor('flex', arguments, only: webkit ms official)\n\n\n// converts the justification alignment\n-convert-justify(align)\n  if flex-start == align\n    return start\n  else if flex-end == align\n    return end\n  else if space-around == align\n    return distribute\n  else if space-between == align\n    return justify\n  else\n    return align\n\n//\n// 8. Alignment\n//    - http://www.w3.org/TR/css3-flexbox/#alignment\n//\njustify-content(align)\n  // obsolete\n  if box in flex-version\n    vendor('box-pack', -convert-justify(align), ignore: ms official)\n\n  // new\n  if flex in flex-version\n    vendor('flex-pack', -convert-justify(align), only: ms)\n    vendor('justify-content', align, only: webkit official)\n\nalign-content(align)\n  // WARN: Obsolete spec does not allow for adjustment here\n  if flex in flex-version\n    vendor('flex-line-pack', -convert-justify(align), only: ms)\n    vendor('align-content', align, only: webkit official)\n\n// converts alignment from 'flex' to normal value\n-convert-alignment(align)\n  if flex-start == align\n    return start\n  else if flex-end == align\n    return end\n  else\n    return align\n\nalign-items(align)\n  // obsolete\n  if box in flex-version\n    vendor('box-align', -convert-alignment(align), ignore: ms official)\n\n  // new\n  if flex in flex-version\n    vendor('flex-align', -convert-alignment(align), only: ms)\n    vendor('align-items', arguments, only: webkit official)\n\nalign-self(align)\n  // WARN: Obsolete spec does not allow for overriding alignment on individual items.\n  if flex in flex-version\n    vendor('align-self', align, only: webkit official)\n    vendor('flex-item-align', -convert-alignment(align), only: ms)\n","/*\n * border: <color>\n * border: ...\n */\n\nborder(color, args...)\n  if color is a 'color'\n    border: 1px solid color args\n  else\n    border: arguments\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 7046:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4942);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".color-legend-container{display:none;padding:10px;border:1.5px solid #000;border-radius:3px;transition:250ms background linear;background-color:rgba(255,255,255,0.75)}.color-legend-container:hover{background-color:#fff}.color-legend-container .geojs-color-legends .geojs-color-legend{margin-bottom:10px}.color-legend-container .geojs-color-legends .geojs-color-legend .geojs-title{text-align:center}.color-legend-container .geojs-color-legends .geojs-color-legend svg.svg{display:block}.color-legend-container .geojs-color-legends .geojs-color-legend svg.svg .axis.x path.domain,.color-legend-container .geojs-color-legends .geojs-color-legend svg.svg .axis.x line{fill:none;stroke:#000;stroke-width:.7}.color-legend-container .geojs-color-legends .geojs-color-legend svg.svg .axis.x text{font-size:12px}.color-legend-container .color-legend-popup{position:absolute;background:#fff;height:22px;font-size:14px;border:solid 1px #000;padding:0 5px;pointer-events:none;white-space:nowrap;z-index:100000;opacity:0}", "",{"version":3,"sources":["webpack://./ui/colorLegendWidget.styl"],"names":[],"mappings":"AAAA,wBACE,YAAQ,CACR,YAAQ,CACR,uBAAO,CACP,iBAAc,CACd,kCAAW,CACX,uCAAiB,CAEjB,8BACE,qBAAiB,CAIjB,iEACE,kBAAc,CAEd,8EACE,iBAAW,CAEb,yEACE,aAAQ,CAGN,mLACE,SAAK,CACL,WAAO,CACP,eAAa,CACf,sFACE,cAAU,CAEpB,4CACE,iBAAS,CACT,eAAW,CACX,WAAO,CACP,cAAU,CACV,qBAAO,CACP,aAAQ,CACR,mBAAe,CACf,kBAAY,CACZ,cAAQ,CACR,SAAQ","sourcesContent":[".color-legend-container\n  display none\n  padding 10px\n  border 1.5px solid black\n  border-radius 3px\n  transition 250ms background linear\n  background-color rgba(255, 255, 255, 0.75)\n\n  &:hover\n    background-color rgba(255, 255, 255, 1)\n\n  .geojs-color-legends\n\n    .geojs-color-legend\n      margin-bottom 10px\n\n      .geojs-title\n        text-align center\n\n      svg.svg\n        display block\n\n        .axis.x\n          path.domain, line\n            fill none\n            stroke black\n            stroke-width 0.7\n          text\n            font-size 12px\n\n  .color-legend-popup\n    position absolute\n    background white\n    height 22px\n    font-size 14px\n    border solid 1px black\n    padding 0 5px\n    pointer-events none\n    white-space nowrap\n    z-index 100000\n    opacity 0\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 5290:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4942);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".geojs-scale-widget-bar{stroke:#000}.geojs-scale-widget-text{font-weight:bold;font-size:16px;font-family:serif}", "",{"version":3,"sources":["webpack://./ui/scaleWidget.styl"],"names":[],"mappings":"AAAA,wBACE,WAAO,CACT,yBACE,gBAAY,CACZ,cAAU,CACV,iBAAY","sourcesContent":[".geojs-scale-widget-bar\n  stroke black\n.geojs-scale-widget-text\n  font-weight bold\n  font-size 16px\n  font-family serif\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ __webpack_exports__.A = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 278:
/***/ (function(module) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 3021:
/***/ (function(module) {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 4942:
/***/ (function(module) {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ 3369:
/***/ (function(module) {

module.exports = adjoint

/**
 * Calculates the adjugate of a mat3
 *
 * @alias mat3.adjoint
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]

  out[0] = (a11 * a22 - a12 * a21)
  out[1] = (a02 * a21 - a01 * a22)
  out[2] = (a01 * a12 - a02 * a11)
  out[3] = (a12 * a20 - a10 * a22)
  out[4] = (a00 * a22 - a02 * a20)
  out[5] = (a02 * a10 - a00 * a12)
  out[6] = (a10 * a21 - a11 * a20)
  out[7] = (a01 * a20 - a00 * a21)
  out[8] = (a00 * a11 - a01 * a10)

  return out
}


/***/ }),

/***/ 5723:
/***/ (function(module) {

module.exports = clone

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @alias mat3.clone
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new Float32Array(9)
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  out[4] = a[4]
  out[5] = a[5]
  out[6] = a[6]
  out[7] = a[7]
  out[8] = a[8]
  return out
}


/***/ }),

/***/ 817:
/***/ (function(module) {

module.exports = copy

/**
 * Copy the values from one mat3 to another
 *
 * @alias mat3.copy
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  out[4] = a[4]
  out[5] = a[5]
  out[6] = a[6]
  out[7] = a[7]
  out[8] = a[8]
  return out
}


/***/ }),

/***/ 6396:
/***/ (function(module) {

module.exports = create

/**
 * Creates a new identity mat3
 *
 * @alias mat3.create
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new Float32Array(9)
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 1
  out[5] = 0
  out[6] = 0
  out[7] = 0
  out[8] = 1
  return out
}


/***/ }),

/***/ 9133:
/***/ (function(module) {

module.exports = determinant

/**
 * Calculates the determinant of a mat3
 *
 * @alias mat3.determinant
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]

  return a00 * (a22 * a11 - a12 * a21)
       + a01 * (a12 * a20 - a22 * a10)
       + a02 * (a21 * a10 - a11 * a20)
}


/***/ }),

/***/ 7053:
/***/ (function(module) {

module.exports = frob

/**
 * Returns Frobenius norm of a mat3
 *
 * @alias mat3.frob
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(
      a[0]*a[0]
    + a[1]*a[1]
    + a[2]*a[2]
    + a[3]*a[3]
    + a[4]*a[4]
    + a[5]*a[5]
    + a[6]*a[6]
    + a[7]*a[7]
    + a[8]*a[8]
  )
}


/***/ }),

/***/ 7068:
/***/ (function(module) {

module.exports = fromMat2d

/**
 * Copies the values from a mat2d into a mat3
 *
 * @alias mat3.fromMat2d
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = 0

  out[3] = a[2]
  out[4] = a[3]
  out[5] = 0

  out[6] = a[4]
  out[7] = a[5]
  out[8] = 1

  return out
}


/***/ }),

/***/ 5018:
/***/ (function(module) {

module.exports = fromMat4

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @alias mat3.fromMat4
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[4]
  out[4] = a[5]
  out[5] = a[6]
  out[6] = a[8]
  out[7] = a[9]
  out[8] = a[10]
  return out
}


/***/ }),

/***/ 3955:
/***/ (function(module) {

module.exports = fromQuat

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @alias mat3.fromQuat
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0]
  var y = q[1]
  var z = q[2]
  var w = q[3]

  var x2 = x + x
  var y2 = y + y
  var z2 = z + z

  var xx = x * x2
  var yx = y * x2
  var yy = y * y2
  var zx = z * x2
  var zy = z * y2
  var zz = z * z2
  var wx = w * x2
  var wy = w * y2
  var wz = w * z2

  out[0] = 1 - yy - zz
  out[3] = yx - wz
  out[6] = zx + wy

  out[1] = yx + wz
  out[4] = 1 - xx - zz
  out[7] = zy - wx

  out[2] = zx - wy
  out[5] = zy + wx
  out[8] = 1 - xx - yy

  return out
}


/***/ }),

/***/ 6658:
/***/ (function(module) {

module.exports = identity

/**
 * Set a mat3 to the identity matrix
 *
 * @alias mat3.identity
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 1
  out[5] = 0
  out[6] = 0
  out[7] = 0
  out[8] = 1
  return out
}


/***/ }),

/***/ 3638:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = {
  adjoint: __webpack_require__(3369)
  , clone: __webpack_require__(5723)
  , copy: __webpack_require__(817)
  , create: __webpack_require__(6396)
  , determinant: __webpack_require__(9133)
  , frob: __webpack_require__(7053)
  , fromMat2: __webpack_require__(7068)
  , fromMat4: __webpack_require__(5018)
  , fromQuat: __webpack_require__(3955)
  , identity: __webpack_require__(6658)
  , invert: __webpack_require__(6028)
  , multiply: __webpack_require__(4980)
  , normalFromMat4: __webpack_require__(8093)
  , rotate: __webpack_require__(8163)
  , scale: __webpack_require__(2311)
  , str: __webpack_require__(6321)
  , translate: __webpack_require__(5068)
  , transpose: __webpack_require__(6333)
}


/***/ }),

/***/ 6028:
/***/ (function(module) {

module.exports = invert

/**
 * Inverts a mat3
 *
 * @alias mat3.invert
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]

  var b01 = a22 * a11 - a12 * a21
  var b11 = -a22 * a10 + a12 * a20
  var b21 = a21 * a10 - a11 * a20

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21

  if (!det) return null
  det = 1.0 / det

  out[0] = b01 * det
  out[1] = (-a22 * a01 + a02 * a21) * det
  out[2] = (a12 * a01 - a02 * a11) * det
  out[3] = b11 * det
  out[4] = (a22 * a00 - a02 * a20) * det
  out[5] = (-a12 * a00 + a02 * a10) * det
  out[6] = b21 * det
  out[7] = (-a21 * a00 + a01 * a20) * det
  out[8] = (a11 * a00 - a01 * a10) * det

  return out
}


/***/ }),

/***/ 4980:
/***/ (function(module) {

module.exports = multiply

/**
 * Multiplies two mat3's
 *
 * @alias mat3.multiply
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]

  var b00 = b[0], b01 = b[1], b02 = b[2]
  var b10 = b[3], b11 = b[4], b12 = b[5]
  var b20 = b[6], b21 = b[7], b22 = b[8]

  out[0] = b00 * a00 + b01 * a10 + b02 * a20
  out[1] = b00 * a01 + b01 * a11 + b02 * a21
  out[2] = b00 * a02 + b01 * a12 + b02 * a22

  out[3] = b10 * a00 + b11 * a10 + b12 * a20
  out[4] = b10 * a01 + b11 * a11 + b12 * a21
  out[5] = b10 * a02 + b11 * a12 + b12 * a22

  out[6] = b20 * a00 + b21 * a10 + b22 * a20
  out[7] = b20 * a01 + b21 * a11 + b22 * a21
  out[8] = b20 * a02 + b21 * a12 + b22 * a22

  return out
}


/***/ }),

/***/ 8093:
/***/ (function(module) {

module.exports = normalFromMat4

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @alias mat3.normalFromMat4
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3]
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7]
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11]
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]

  var b00 = a00 * a11 - a01 * a10
  var b01 = a00 * a12 - a02 * a10
  var b02 = a00 * a13 - a03 * a10
  var b03 = a01 * a12 - a02 * a11
  var b04 = a01 * a13 - a03 * a11
  var b05 = a02 * a13 - a03 * a12
  var b06 = a20 * a31 - a21 * a30
  var b07 = a20 * a32 - a22 * a30
  var b08 = a20 * a33 - a23 * a30
  var b09 = a21 * a32 - a22 * a31
  var b10 = a21 * a33 - a23 * a31
  var b11 = a22 * a33 - a23 * a32

  // Calculate the determinant
  var det = b00 * b11
          - b01 * b10
          + b02 * b09
          + b03 * b08
          - b04 * b07
          + b05 * b06

  if (!det) return null
  det = 1.0 / det

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det

  return out
}


/***/ }),

/***/ 8163:
/***/ (function(module) {

module.exports = rotate

/**
 * Rotates a mat3 by the given angle
 *
 * @alias mat3.rotate
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]

  var s = Math.sin(rad)
  var c = Math.cos(rad)

  out[0] = c * a00 + s * a10
  out[1] = c * a01 + s * a11
  out[2] = c * a02 + s * a12

  out[3] = c * a10 - s * a00
  out[4] = c * a11 - s * a01
  out[5] = c * a12 - s * a02

  out[6] = a20
  out[7] = a21
  out[8] = a22

  return out
}


/***/ }),

/***/ 2311:
/***/ (function(module) {

module.exports = scale

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @alias mat3.scale
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0]
  var y = v[1]

  out[0] = x * a[0]
  out[1] = x * a[1]
  out[2] = x * a[2]

  out[3] = y * a[3]
  out[4] = y * a[4]
  out[5] = y * a[5]

  out[6] = a[6]
  out[7] = a[7]
  out[8] = a[8]

  return out
}


/***/ }),

/***/ 6321:
/***/ (function(module) {

module.exports = str

/**
 * Returns a string representation of a mat3
 *
 * @alias mat3.str
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                   a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
                   a[6] + ', ' + a[7] + ', ' + a[8] + ')'
}


/***/ }),

/***/ 5068:
/***/ (function(module) {

module.exports = translate

/**
 * Translate a mat3 by the given vector
 *
 * @alias mat3.translate
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2]
  var a10 = a[3], a11 = a[4], a12 = a[5]
  var a20 = a[6], a21 = a[7], a22 = a[8]
  var x = v[0], y = v[1]

  out[0] = a00
  out[1] = a01
  out[2] = a02

  out[3] = a10
  out[4] = a11
  out[5] = a12

  out[6] = x * a00 + y * a10 + a20
  out[7] = x * a01 + y * a11 + a21
  out[8] = x * a02 + y * a12 + a22

  return out
}


/***/ }),

/***/ 6333:
/***/ (function(module) {

module.exports = transpose

/**
 * Transpose the values of a mat3
 *
 * @alias mat3.transpose
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5]
    out[1] = a[3]
    out[2] = a[6]
    out[3] = a01
    out[5] = a[7]
    out[6] = a02
    out[7] = a12
  } else {
    out[0] = a[0]
    out[1] = a[3]
    out[2] = a[6]
    out[3] = a[1]
    out[4] = a[4]
    out[5] = a[7]
    out[6] = a[2]
    out[7] = a[5]
    out[8] = a[8]
  }

  return out
}


/***/ }),

/***/ 5200:
/***/ (function(module) {

module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/***/ }),

/***/ 1130:
/***/ (function(module) {

module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/***/ }),

/***/ 74:
/***/ (function(module) {

module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/***/ }),

/***/ 3783:
/***/ (function(module) {

module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/***/ }),

/***/ 8844:
/***/ (function(module) {

module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/***/ }),

/***/ 5936:
/***/ (function(module) {

module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/***/ }),

/***/ 5405:
/***/ (function(module) {

module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}


/***/ }),

/***/ 3310:
/***/ (function(module) {

module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/***/ }),

/***/ 1826:
/***/ (function(module) {

module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}


/***/ }),

/***/ 4692:
/***/ (function(module) {

module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}


/***/ }),

/***/ 1349:
/***/ (function(module) {

module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}

/***/ }),

/***/ 8034:
/***/ (function(module) {

module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}

/***/ }),

/***/ 1655:
/***/ (function(module) {

module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}

/***/ }),

/***/ 3277:
/***/ (function(module) {

module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/***/ }),

/***/ 257:
/***/ (function(module) {

module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/***/ }),

/***/ 3503:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = {
  create: __webpack_require__(3783)
  , clone: __webpack_require__(1130)
  , copy: __webpack_require__(74)
  , identity: __webpack_require__(257)
  , transpose: __webpack_require__(2664)
  , invert: __webpack_require__(6583)
  , adjoint: __webpack_require__(5200)
  , determinant: __webpack_require__(8844)
  , multiply: __webpack_require__(9899)
  , translate: __webpack_require__(573)
  , scale: __webpack_require__(177)
  , rotate: __webpack_require__(648)
  , rotateX: __webpack_require__(5618)
  , rotateY: __webpack_require__(5345)
  , rotateZ: __webpack_require__(5208)
  , fromRotation: __webpack_require__(5405)
  , fromRotationTranslation: __webpack_require__(3310)
  , fromScaling: __webpack_require__(1826)
  , fromTranslation: __webpack_require__(4692)
  , fromXRotation: __webpack_require__(1349)
  , fromYRotation: __webpack_require__(8034)
  , fromZRotation: __webpack_require__(1655)
  , fromQuat: __webpack_require__(5936)
  , frustum: __webpack_require__(3277)
  , perspective: __webpack_require__(2649)
  , perspectiveFromFieldOfView: __webpack_require__(7733)
  , ortho: __webpack_require__(2337)
  , lookAt: __webpack_require__(8541)
  , str: __webpack_require__(6600)
}


/***/ }),

/***/ 6583:
/***/ (function(module) {

module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/***/ }),

/***/ 8541:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var identity = __webpack_require__(257);

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/***/ }),

/***/ 9899:
/***/ (function(module) {

module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/***/ }),

/***/ 2337:
/***/ (function(module) {

module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/***/ }),

/***/ 2649:
/***/ (function(module) {

module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/***/ }),

/***/ 7733:
/***/ (function(module) {

module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}



/***/ }),

/***/ 648:
/***/ (function(module) {

module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/***/ }),

/***/ 5618:
/***/ (function(module) {

module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/***/ }),

/***/ 5345:
/***/ (function(module) {

module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/***/ }),

/***/ 5208:
/***/ (function(module) {

module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/***/ }),

/***/ 177:
/***/ (function(module) {

module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/***/ }),

/***/ 6600:
/***/ (function(module) {

module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/***/ }),

/***/ 573:
/***/ (function(module) {

module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/***/ }),

/***/ 2664:
/***/ (function(module) {

module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/***/ }),

/***/ 3197:
/***/ (function(module) {

module.exports = add;

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
    out[0] = a[0] + b[0]
    out[1] = a[1] + b[1]
    out[2] = a[2] + b[2]
    return out
}

/***/ }),

/***/ 577:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = angle

var fromValues = __webpack_require__(9666)
var normalize = __webpack_require__(1205)
var dot = __webpack_require__(6517)

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2])
    var tempB = fromValues(b[0], b[1], b[2])
 
    normalize(tempA, tempA)
    normalize(tempB, tempB)
 
    var cosine = dot(tempA, tempB)

    if(cosine > 1.0){
        return 0
    } else {
        return Math.acos(cosine)
    }     
}


/***/ }),

/***/ 9913:
/***/ (function(module) {

module.exports = ceil

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0])
  out[1] = Math.ceil(a[1])
  out[2] = Math.ceil(a[2])
  return out
}


/***/ }),

/***/ 7091:
/***/ (function(module) {

module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}

/***/ }),

/***/ 3497:
/***/ (function(module) {

module.exports = copy;

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}

/***/ }),

/***/ 1220:
/***/ (function(module) {

module.exports = create;

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
    var out = new Float32Array(3)
    out[0] = 0
    out[1] = 0
    out[2] = 0
    return out
}

/***/ }),

/***/ 6902:
/***/ (function(module) {

module.exports = cross;

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2]

    out[0] = ay * bz - az * by
    out[1] = az * bx - ax * bz
    out[2] = ax * by - ay * bx
    return out
}

/***/ }),

/***/ 5140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(5055)


/***/ }),

/***/ 5055:
/***/ (function(module) {

module.exports = distance;

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return Math.sqrt(x*x + y*y + z*z)
}

/***/ }),

/***/ 6669:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(9737)


/***/ }),

/***/ 9737:
/***/ (function(module) {

module.exports = divide;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
    out[0] = a[0] / b[0]
    out[1] = a[1] / b[1]
    out[2] = a[2] / b[2]
    return out
}

/***/ }),

/***/ 6517:
/***/ (function(module) {

module.exports = dot;

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}

/***/ }),

/***/ 6532:
/***/ (function(module) {

module.exports = 0.000001


/***/ }),

/***/ 1077:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = equals

var EPSILON = __webpack_require__(6532)

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var b0 = b[0]
  var b1 = b[1]
  var b2 = b[2]
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))
}


/***/ }),

/***/ 5696:
/***/ (function(module) {

module.exports = exactEquals

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
}


/***/ }),

/***/ 1899:
/***/ (function(module) {

module.exports = floor

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0])
  out[1] = Math.floor(a[1])
  out[2] = Math.floor(a[2])
  return out
}


/***/ }),

/***/ 9436:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(1220)()

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach(a, stride, offset, count, fn, arg) {
        var i, l
        if(!stride) {
            stride = 3
        }

        if(!offset) {
            offset = 0
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length)
        } else {
            l = a.length
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i] 
            vec[1] = a[i+1] 
            vec[2] = a[i+2]
            fn(vec, vec, arg)
            a[i] = vec[0] 
            a[i+1] = vec[1] 
            a[i+2] = vec[2]
        }
        
        return a
}

/***/ }),

/***/ 9666:
/***/ (function(module) {

module.exports = fromValues;

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
    var out = new Float32Array(3)
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}

/***/ }),

/***/ 1982:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(6532)
  , create: __webpack_require__(1220)
  , clone: __webpack_require__(7091)
  , angle: __webpack_require__(577)
  , fromValues: __webpack_require__(9666)
  , copy: __webpack_require__(3497)
  , set: __webpack_require__(3926)
  , equals: __webpack_require__(1077)
  , exactEquals: __webpack_require__(5696)
  , add: __webpack_require__(3197)
  , subtract: __webpack_require__(1040)
  , sub: __webpack_require__(8560)
  , multiply: __webpack_require__(8044)
  , mul: __webpack_require__(8516)
  , divide: __webpack_require__(9737)
  , div: __webpack_require__(6669)
  , min: __webpack_require__(4370)
  , max: __webpack_require__(7484)
  , floor: __webpack_require__(1899)
  , ceil: __webpack_require__(9913)
  , round: __webpack_require__(4622)
  , scale: __webpack_require__(9404)
  , scaleAndAdd: __webpack_require__(8544)
  , distance: __webpack_require__(5055)
  , dist: __webpack_require__(5140)
  , squaredDistance: __webpack_require__(2340)
  , sqrDist: __webpack_require__(3108)
  , length: __webpack_require__(9852)
  , len: __webpack_require__(4001)
  , squaredLength: __webpack_require__(2775)
  , sqrLen: __webpack_require__(9249)
  , negate: __webpack_require__(2926)
  , inverse: __webpack_require__(3346)
  , normalize: __webpack_require__(1205)
  , dot: __webpack_require__(6517)
  , cross: __webpack_require__(6902)
  , lerp: __webpack_require__(1817)
  , random: __webpack_require__(1844)
  , transformMat4: __webpack_require__(9564)
  , transformMat3: __webpack_require__(553)
  , transformQuat: __webpack_require__(4997)
  , rotateX: __webpack_require__(6899)
  , rotateY: __webpack_require__(8028)
  , rotateZ: __webpack_require__(5493)
  , forEach: __webpack_require__(9436)
}


/***/ }),

/***/ 3346:
/***/ (function(module) {

module.exports = inverse;

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0]
  out[1] = 1.0 / a[1]
  out[2] = 1.0 / a[2]
  return out
}

/***/ }),

/***/ 4001:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(9852)


/***/ }),

/***/ 9852:
/***/ (function(module) {

module.exports = length;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return Math.sqrt(x*x + y*y + z*z)
}

/***/ }),

/***/ 1817:
/***/ (function(module) {

module.exports = lerp;

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2]
    out[0] = ax + t * (b[0] - ax)
    out[1] = ay + t * (b[1] - ay)
    out[2] = az + t * (b[2] - az)
    return out
}

/***/ }),

/***/ 7484:
/***/ (function(module) {

module.exports = max;

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0])
    out[1] = Math.max(a[1], b[1])
    out[2] = Math.max(a[2], b[2])
    return out
}

/***/ }),

/***/ 4370:
/***/ (function(module) {

module.exports = min;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0])
    out[1] = Math.min(a[1], b[1])
    out[2] = Math.min(a[2], b[2])
    return out
}

/***/ }),

/***/ 8516:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(8044)


/***/ }),

/***/ 8044:
/***/ (function(module) {

module.exports = multiply;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
    out[0] = a[0] * b[0]
    out[1] = a[1] * b[1]
    out[2] = a[2] * b[2]
    return out
}

/***/ }),

/***/ 2926:
/***/ (function(module) {

module.exports = negate;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
    out[0] = -a[0]
    out[1] = -a[1]
    out[2] = -a[2]
    return out
}

/***/ }),

/***/ 1205:
/***/ (function(module) {

module.exports = normalize;

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    var len = x*x + y*y + z*z
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len)
        out[0] = a[0] * len
        out[1] = a[1] * len
        out[2] = a[2] * len
    }
    return out
}

/***/ }),

/***/ 1844:
/***/ (function(module) {

module.exports = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
    scale = scale || 1.0

    var r = Math.random() * 2.0 * Math.PI
    var z = (Math.random() * 2.0) - 1.0
    var zScale = Math.sqrt(1.0-z*z) * scale

    out[0] = Math.cos(r) * zScale
    out[1] = Math.sin(r) * zScale
    out[2] = z * scale
    return out
}

/***/ }),

/***/ 6899:
/***/ (function(module) {

module.exports = rotateX;

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
    var by = b[1]
    var bz = b[2]

    // Translate point to the origin
    var py = a[1] - by
    var pz = a[2] - bz

    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = a[0]
    out[1] = by + py * cc - pz * sc
    out[2] = bz + py * sc + pz * cc

    return out
}


/***/ }),

/***/ 8028:
/***/ (function(module) {

module.exports = rotateY;

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
    var bx = b[0]
    var bz = b[2]

    // translate point to the origin
    var px = a[0] - bx
    var pz = a[2] - bz
    
    var sc = Math.sin(c)
    var cc = Math.cos(c)
  
    // perform rotation and translate to correct position
    out[0] = bx + pz * sc + px * cc
    out[1] = a[1]
    out[2] = bz + pz * cc - px * sc
  
    return out
}


/***/ }),

/***/ 5493:
/***/ (function(module) {

module.exports = rotateZ;

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
    var bx = b[0]
    var by = b[1]

    //Translate point to the origin
    var px = a[0] - bx
    var py = a[1] - by
  
    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = bx + px * cc - py * sc
    out[1] = by + px * sc + py * cc
    out[2] = a[2]
  
    return out
}


/***/ }),

/***/ 4622:
/***/ (function(module) {

module.exports = round

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0])
  out[1] = Math.round(a[1])
  out[2] = Math.round(a[2])
  return out
}


/***/ }),

/***/ 9404:
/***/ (function(module) {

module.exports = scale;

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    out[2] = a[2] * b
    return out
}

/***/ }),

/***/ 8544:
/***/ (function(module) {

module.exports = scaleAndAdd;

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale)
    out[1] = a[1] + (b[1] * scale)
    out[2] = a[2] + (b[2] * scale)
    return out
}

/***/ }),

/***/ 3926:
/***/ (function(module) {

module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}

/***/ }),

/***/ 3108:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(2340)


/***/ }),

/***/ 9249:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(2775)


/***/ }),

/***/ 2340:
/***/ (function(module) {

module.exports = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return x*x + y*y + z*z
}

/***/ }),

/***/ 2775:
/***/ (function(module) {

module.exports = squaredLength;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return x*x + y*y + z*z
}

/***/ }),

/***/ 8560:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(1040)


/***/ }),

/***/ 1040:
/***/ (function(module) {

module.exports = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
    out[0] = a[0] - b[0]
    out[1] = a[1] - b[1]
    out[2] = a[2] - b[2]
    return out
}

/***/ }),

/***/ 553:
/***/ (function(module) {

module.exports = transformMat3;

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2]
    out[0] = x * m[0] + y * m[3] + z * m[6]
    out[1] = x * m[1] + y * m[4] + z * m[7]
    out[2] = x * m[2] + y * m[5] + z * m[8]
    return out
}

/***/ }),

/***/ 9564:
/***/ (function(module) {

module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}

/***/ }),

/***/ 4997:
/***/ (function(module) {

module.exports = transformQuat;

/**
 * Transforms the vec3 with a quat
 *
 * Note: the quaternion must be a unit quaternion (|q| = 1) in
 * order for this operation to be valid.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q unit quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
    // Fast Vector Rotation using Quaternions by Robert Eisele
    // https://raw.org/proof/vector-rotation-using-quaternions/

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3]

    // t = q x v
    var tx = qy * z - qz * y
    var ty = qz * x - qx * z
    var tz = qx * y - qy * x

    // t = 2t
    tx *= 2
    ty *= 2
    tz *= 2

    // v + w t + q x t
    out[0] = x + qw * tx + qy * tz - qz * ty
    out[1] = y + qw * ty + qz * tx - qx * tz
    out[2] = z + qw * tz + qx * ty - qy * tx

    return out
}


/***/ }),

/***/ 2108:
/***/ (function(module) {

module.exports = add

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add (out, a, b) {
  out[0] = a[0] + b[0]
  out[1] = a[1] + b[1]
  out[2] = a[2] + b[2]
  out[3] = a[3] + b[3]
  return out
}


/***/ }),

/***/ 7682:
/***/ (function(module) {

module.exports = clone

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone (a) {
  var out = new Float32Array(4)
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}


/***/ }),

/***/ 9298:
/***/ (function(module) {

module.exports = copy

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy (out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}


/***/ }),

/***/ 3071:
/***/ (function(module) {

module.exports = create

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create () {
  var out = new Float32Array(4)
  out[0] = 0
  out[1] = 0
  out[2] = 0
  out[3] = 0
  return out
}


/***/ }),

/***/ 5476:
/***/ (function(module) {

module.exports = distance

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance (a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1],
    z = b[2] - a[2],
    w = b[3] - a[3]
  return Math.sqrt(x * x + y * y + z * z + w * w)
}


/***/ }),

/***/ 1350:
/***/ (function(module) {

module.exports = divide

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide (out, a, b) {
  out[0] = a[0] / b[0]
  out[1] = a[1] / b[1]
  out[2] = a[2] / b[2]
  out[3] = a[3] / b[3]
  return out
}


/***/ }),

/***/ 216:
/***/ (function(module) {

module.exports = dot

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot (a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
}


/***/ }),

/***/ 8741:
/***/ (function(module) {

module.exports = fromValues

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues (x, y, z, w) {
  var out = new Float32Array(4)
  out[0] = x
  out[1] = y
  out[2] = z
  out[3] = w
  return out
}


/***/ }),

/***/ 4663:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = {
  create: __webpack_require__(3071),
  clone: __webpack_require__(7682),
  fromValues: __webpack_require__(8741),
  copy: __webpack_require__(9298),
  set: __webpack_require__(6675),
  add: __webpack_require__(2108),
  subtract: __webpack_require__(6919),
  multiply: __webpack_require__(9363),
  divide: __webpack_require__(1350),
  min: __webpack_require__(9271),
  max: __webpack_require__(2045),
  scale: __webpack_require__(7705),
  scaleAndAdd: __webpack_require__(2869),
  distance: __webpack_require__(5476),
  squaredDistance: __webpack_require__(6733),
  length: __webpack_require__(7159),
  squaredLength: __webpack_require__(2678),
  negate: __webpack_require__(6977),
  inverse: __webpack_require__(3095),
  normalize: __webpack_require__(8308),
  dot: __webpack_require__(216),
  lerp: __webpack_require__(2710),
  random: __webpack_require__(9960),
  transformMat4: __webpack_require__(8773),
  transformQuat: __webpack_require__(2508)
}


/***/ }),

/***/ 3095:
/***/ (function(module) {

module.exports = inverse

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse (out, a) {
  out[0] = 1.0 / a[0]
  out[1] = 1.0 / a[1]
  out[2] = 1.0 / a[2]
  out[3] = 1.0 / a[3]
  return out
}


/***/ }),

/***/ 7159:
/***/ (function(module) {

module.exports = length

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length (a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3]
  return Math.sqrt(x * x + y * y + z * z + w * w)
}


/***/ }),

/***/ 2710:
/***/ (function(module) {

module.exports = lerp

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
function lerp (out, a, b, t) {
  var ax = a[0],
    ay = a[1],
    az = a[2],
    aw = a[3]
  out[0] = ax + t * (b[0] - ax)
  out[1] = ay + t * (b[1] - ay)
  out[2] = az + t * (b[2] - az)
  out[3] = aw + t * (b[3] - aw)
  return out
}


/***/ }),

/***/ 2045:
/***/ (function(module) {

module.exports = max

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max (out, a, b) {
  out[0] = Math.max(a[0], b[0])
  out[1] = Math.max(a[1], b[1])
  out[2] = Math.max(a[2], b[2])
  out[3] = Math.max(a[3], b[3])
  return out
}


/***/ }),

/***/ 9271:
/***/ (function(module) {

module.exports = min

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min (out, a, b) {
  out[0] = Math.min(a[0], b[0])
  out[1] = Math.min(a[1], b[1])
  out[2] = Math.min(a[2], b[2])
  out[3] = Math.min(a[3], b[3])
  return out
}


/***/ }),

/***/ 9363:
/***/ (function(module) {

module.exports = multiply

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply (out, a, b) {
  out[0] = a[0] * b[0]
  out[1] = a[1] * b[1]
  out[2] = a[2] * b[2]
  out[3] = a[3] * b[3]
  return out
}


/***/ }),

/***/ 6977:
/***/ (function(module) {

module.exports = negate

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate (out, a) {
  out[0] = -a[0]
  out[1] = -a[1]
  out[2] = -a[2]
  out[3] = -a[3]
  return out
}


/***/ }),

/***/ 8308:
/***/ (function(module) {

module.exports = normalize

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize (out, a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3]
  var len = x * x + y * y + z * z + w * w
  if (len > 0) {
    len = 1 / Math.sqrt(len)
    out[0] = x * len
    out[1] = y * len
    out[2] = z * len
    out[3] = w * len
  }
  return out
}


/***/ }),

/***/ 9960:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var vecNormalize = __webpack_require__(8308)
var vecScale = __webpack_require__(7705)

module.exports = random

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random (out, scale) {
  scale = scale || 1.0

  // TODO: This is a pretty awful way of doing this. Find something better.
  out[0] = Math.random()
  out[1] = Math.random()
  out[2] = Math.random()
  out[3] = Math.random()
  vecNormalize(out, out)
  vecScale(out, out, scale)
  return out
}


/***/ }),

/***/ 7705:
/***/ (function(module) {

module.exports = scale

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale (out, a, b) {
  out[0] = a[0] * b
  out[1] = a[1] * b
  out[2] = a[2] * b
  out[3] = a[3] * b
  return out
}


/***/ }),

/***/ 2869:
/***/ (function(module) {

module.exports = scaleAndAdd

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd (out, a, b, scale) {
  out[0] = a[0] + (b[0] * scale)
  out[1] = a[1] + (b[1] * scale)
  out[2] = a[2] + (b[2] * scale)
  out[3] = a[3] + (b[3] * scale)
  return out
}


/***/ }),

/***/ 6675:
/***/ (function(module) {

module.exports = set

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set (out, x, y, z, w) {
  out[0] = x
  out[1] = y
  out[2] = z
  out[3] = w
  return out
}


/***/ }),

/***/ 6733:
/***/ (function(module) {

module.exports = squaredDistance

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance (a, b) {
  var x = b[0] - a[0],
    y = b[1] - a[1],
    z = b[2] - a[2],
    w = b[3] - a[3]
  return x * x + y * y + z * z + w * w
}


/***/ }),

/***/ 2678:
/***/ (function(module) {

module.exports = squaredLength

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength (a) {
  var x = a[0],
    y = a[1],
    z = a[2],
    w = a[3]
  return x * x + y * y + z * z + w * w
}


/***/ }),

/***/ 6919:
/***/ (function(module) {

module.exports = subtract

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract (out, a, b) {
  out[0] = a[0] - b[0]
  out[1] = a[1] - b[1]
  out[2] = a[2] - b[2]
  out[3] = a[3] - b[3]
  return out
}


/***/ }),

/***/ 8773:
/***/ (function(module) {

module.exports = transformMat4

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4 (out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3]
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w
  return out
}


/***/ }),

/***/ 2508:
/***/ (function(module) {

module.exports = transformQuat

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat (out, a, q) {
  var x = a[0], y = a[1], z = a[2],
    qx = q[0], qy = q[1], qz = q[2], qw = q[3],

    // calculate quat * vec
    ix = qw * x + qy * z - qz * y,
    iy = qw * y + qz * x - qx * z,
    iz = qw * z + qx * y - qy * x,
    iw = -qx * x - qy * y - qz * z

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
  out[3] = a[3]
  return out
}


/***/ }),

/***/ 5616:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket trac-14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var version = "3.7.1",

	rhtmlSuffix = /HTML$/i,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},


	// Retrieve the text value of an array of DOM nodes
	text: function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {

			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {

				// Do not traverse comment nodes
				ret += jQuery.text( node );
			}
		}
		if ( nodeType === 1 || nodeType === 11 ) {
			return elem.textContent;
		}
		if ( nodeType === 9 ) {
			return elem.documentElement.textContent;
		}
		if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}

		// Do not include comment or processing instruction nodes

		return ret;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	isXMLDoc: function( elem ) {
		var namespace = elem && elem.namespaceURI,
			docElem = elem && ( elem.ownerDocument || elem ).documentElement;

		// Assume HTML when documentElement doesn't yet exist, such as inside
		// document fragments.
		return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}


function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var pop = arr.pop;


var sort = arr.sort;


var splice = arr.splice;


var whitespace = "[\\x20\\t\\r\\n\\f]";


var rtrimCSS = new RegExp(
	"^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
	"g"
);




// Note: an element does not contain itself
jQuery.contains = function( a, b ) {
	var bup = b && b.parentNode;

	return a === bup || !!( bup && bup.nodeType === 1 && (

		// Support: IE 9 - 11+
		// IE doesn't have `contains` on SVG.
		a.contains ?
			a.contains( bup ) :
			a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
	) );
};




// CSS string/identifier serialization
// https://drafts.csswg.org/cssom/#common-serializing-idioms
var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

function fcssescape( ch, asCodePoint ) {
	if ( asCodePoint ) {

		// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
		if ( ch === "\0" ) {
			return "\uFFFD";
		}

		// Control characters and (dependent upon position) numbers get escaped as code points
		return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
	}

	// Other potentially-special ASCII characters get backslash-escaped
	return "\\" + ch;
}

jQuery.escapeSelector = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};




var preferredDoc = document,
	pushNative = push;

( function() {

var i,
	Expr,
	outermostContext,
	sortInput,
	hasDuplicate,
	push = pushNative,

	// Local document vars
	document,
	documentElement,
	documentIsHTML,
	rbuggyQSA,
	matches,

	// Instance-specific data
	expando = jQuery.expando,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
		"loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rleadingCombinator = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
		whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		ID: new RegExp( "^#(" + identifier + ")" ),
		CLASS: new RegExp( "^\\.(" + identifier + ")" ),
		TAG: new RegExp( "^(" + identifier + "|[*])" ),
		ATTR: new RegExp( "^" + attributes ),
		PSEUDO: new RegExp( "^" + pseudos ),
		CHILD: new RegExp(
			"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		needsContext: new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		if ( nonHex ) {

			// Strip the backslash prefix from a non-hex escape sequence
			return nonHex;
		}

		// Replace a hexadecimal escape sequence with the encoded Unicode code point
		// Support: IE <=11+
		// For values outside the Basic Multilingual Plane (BMP), manually construct a
		// surrogate pair
		return high < 0 ?
			String.fromCharCode( high + 0x10000 ) :
			String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes; see `setDocument`.
	// Support: IE 9 - 11+, Edge 12 - 18+
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE/Edge.
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && nodeName( elem, "fieldset" );
		},
		{ dir: "parentNode", next: "legend" }
	);

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android <=4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = {
		apply: function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		},
		call: function( target ) {
			pushNative.apply( target, slice.call( arguments, 1 ) );
		}
	};
}

function find( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE 9 only
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								push.call( results, elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE 9 only
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							find.contains( context, elem ) &&
							elem.id === m ) {

							push.call( results, elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( !nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rleadingCombinator.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when
					// strict-comparing two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( newContext != context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = jQuery.escapeSelector( nid );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrimCSS, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties
		// (see https://github.com/jquery/sizzle/issues/157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by jQuery selector module
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		return nodeName( elem, "input" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
			elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11+
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a jQuery selector context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [node] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
function setDocument( node ) {
	var subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	documentElement = document.documentElement;
	documentIsHTML = !jQuery.isXMLDoc( document );

	// Support: iOS 7 only, IE 9 - 11+
	// Older browsers didn't support unprefixed `matches`.
	matches = documentElement.matches ||
		documentElement.webkitMatchesSelector ||
		documentElement.msMatchesSelector;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors
	// (see trac-13936).
	// Limit the fix to IE & Edge Legacy; despite Edge 15+ implementing `matches`,
	// all IE 9+ and Edge Legacy versions implement `msMatchesSelector` as well.
	if ( documentElement.msMatchesSelector &&

		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 9 - 11+, Edge 12 - 18+
		subWindow.addEventListener( "unload", unloadHandler );
	}

	// Support: IE <10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		documentElement.appendChild( el ).id = jQuery.expando;
		return !document.getElementsByName ||
			!document.getElementsByName( jQuery.expando ).length;
	} );

	// Support: IE 9 only
	// Check to see if it's possible to do matchesSelector
	// on a disconnected node.
	support.disconnectedMatch = assert( function( el ) {
		return matches.call( el, "*" );
	} );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	support.scope = assert( function() {
		return document.querySelectorAll( ":scope" );
	} );

	// Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
	// Make sure the `:has()` argument is parsed unforgivingly.
	// We include `*` in the test to detect buggy implementations that are
	// _selectively_ forgiving (specifically when the list includes at least
	// one valid selector).
	// Note that we treat complete lack of support for `:has()` as if it were
	// spec-compliant support, which is fine because use of `:has()` in such
	// environments will fail in the qSA path and fall back to jQuery traversal
	// anyway.
	support.cssHas = assert( function() {
		try {
			document.querySelector( ":has(*,:jqfake)" );
			return false;
		} catch ( e ) {
			return true;
		}
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter.ID = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter.ID =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find.ID = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find.TAG = function( tag, context ) {
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			return context.getElementsByTagName( tag );

		// DocumentFragment nodes don't have gEBTN
		} else {
			return context.querySelectorAll( tag );
		}
	};

	// Class
	Expr.find.CLASS = function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	rbuggyQSA = [];

	// Build QSA regex
	// Regex strategy adopted from Diego Perini
	assert( function( el ) {

		var input;

		documentElement.appendChild( el ).innerHTML =
			"<a id='" + expando + "' href='' disabled='disabled'></a>" +
			"<select id='" + expando + "-\r\\' disabled='disabled'>" +
			"<option selected=''></option></select>";

		// Support: iOS <=7 - 8 only
		// Boolean attributes and "value" are not treated correctly in some XML documents
		if ( !el.querySelectorAll( "[selected]" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
		}

		// Support: iOS <=7 - 8 only
		if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
			rbuggyQSA.push( "~=" );
		}

		// Support: iOS 8 only
		// https://bugs.webkit.org/show_bug.cgi?id=136851
		// In-page `selector#id sibling-combinator selector` fails
		if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
			rbuggyQSA.push( ".#.+[+~]" );
		}

		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		if ( !el.querySelectorAll( ":checked" ).length ) {
			rbuggyQSA.push( ":checked" );
		}

		// Support: Windows 8 Native Apps
		// The type and name attributes are restricted during .innerHTML assignment
		input = document.createElement( "input" );
		input.setAttribute( "type", "hidden" );
		el.appendChild( input ).setAttribute( "name", "D" );

		// Support: IE 9 - 11+
		// IE's :disabled selector does not pick up the children of disabled fieldsets
		// Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
		// In some of the document kinds, these selectors wouldn't work natively.
		// This is probably OK but for backwards compatibility we want to maintain
		// handling them through jQuery traversal in jQuery 3.x.
		documentElement.appendChild( el ).disabled = true;
		if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
			rbuggyQSA.push( ":enabled", ":disabled" );
		}

		// Support: IE 11+, Edge 15 - 18+
		// IE 11/Edge don't find elements on a `[name='']` query in some cases.
		// Adding a temporary attribute to the document before the selection works
		// around the issue.
		// Interestingly, IE 10 & older don't seem to have the issue.
		input = document.createElement( "input" );
		input.setAttribute( "name", "" );
		el.appendChild( input );
		if ( !el.querySelectorAll( "[name='']" ).length ) {
			rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
				whitespace + "*(?:''|\"\")" );
		}
	} );

	if ( !support.cssHas ) {

		// Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
		// Our regular `try-catch` mechanism fails to detect natively-unsupported
		// pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
		// in browsers that parse the `:has()` argument as a forgiving selector list.
		// https://drafts.csswg.org/selectors/#relational now requires the argument
		// to be parsed unforgivingly, but browsers have not yet fully adjusted.
		rbuggyQSA.push( ":has" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a === document || a.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b === document || b.ownerDocument == preferredDoc &&
				find.contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	};

	return document;
}

find.matches = function( expr, elements ) {
	return find( expr, null, null, elements );
};

find.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyQSA || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return find( expr, document, null, [ elem ] ).length > 0;
};

find.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return jQuery.contains( context, elem );
};


find.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (see trac-13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	if ( val !== undefined ) {
		return val;
	}

	return elem.getAttribute( name );
};

find.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
jQuery.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	//
	// Support: Android <=4.0+
	// Testing for detecting duplicates is unpredictable so instead assume we can't
	// depend on duplicate detection in all browsers without a stable sort.
	hasDuplicate = !support.sortStable;
	sortInput = !support.sortStable && slice.call( results, 0 );
	sort.call( results, sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			splice.call( results, duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

jQuery.fn.uniqueSort = function() {
	return this.pushStack( jQuery.uniqueSort( slice.apply( this ) ) );
};

Expr = jQuery.expr = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		ATTR: function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
				.replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		CHILD: function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					find.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
				);
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

			// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				find.error( match[ 0 ] );
			}

			return match;
		},

		PSEUDO: function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		TAG: function( nodeNameSelector ) {
			var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return nodeName( elem, expectedNodeName );
				};
		},

		CLASS: function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace + ")" + className +
					"(" + whitespace + "|$)" ) ) &&
				classCache( className, function( elem ) {
					return pattern.test(
						typeof elem.className === "string" && elem.className ||
							typeof elem.getAttribute !== "undefined" &&
								elem.getAttribute( "class" ) ||
							""
					);
				} );
		},

		ATTR: function( name, operator, check ) {
			return function( elem ) {
				var result = find.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				if ( operator === "=" ) {
					return result === check;
				}
				if ( operator === "!=" ) {
					return result !== check;
				}
				if ( operator === "^=" ) {
					return check && result.indexOf( check ) === 0;
				}
				if ( operator === "*=" ) {
					return check && result.indexOf( check ) > -1;
				}
				if ( operator === "$=" ) {
					return check && result.slice( -check.length ) === check;
				}
				if ( operator === "~=" ) {
					return ( " " + result.replace( rwhitespace, " " ) + " " )
						.indexOf( check ) > -1;
				}
				if ( operator === "|=" ) {
					return result === check || result.slice( 0, check.length + 1 ) === check + "-";
				}

				return false;
			};
		},

		CHILD: function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || ( parent[ expando ] = {} );
							cache = outerCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {
								outerCache = elem[ expando ] || ( elem[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										nodeName( node, name ) :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );
											outerCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		PSEUDO: function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// https://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					find.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as jQuery does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		not: markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrimCSS, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element
					// (see https://github.com/jquery/sizzle/issues/299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		has: markFunction( function( selector ) {
			return function( elem ) {
				return find( selector, elem ).length > 0;
			};
		} ),

		contains: markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || jQuery.text( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// https://www.w3.org/TR/selectors/#lang-pseudo
		lang: markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				find.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		target: function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		root: function( elem ) {
			return elem === documentElement;
		},

		focus: function( elem ) {
			return elem === safeActiveElement() &&
				document.hasFocus() &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		enabled: createDisabledPseudo( false ),
		disabled: createDisabledPseudo( true ),

		checked: function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			return ( nodeName( elem, "input" ) && !!elem.checked ) ||
				( nodeName( elem, "option" ) && !!elem.selected );
		},

		selected: function( elem ) {

			// Support: IE <=11+
			// Accessing the selectedIndex property
			// forces the browser to treat the default option as
			// selected when in an optgroup.
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		empty: function( elem ) {

			// https://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		parent: function( elem ) {
			return !Expr.pseudos.empty( elem );
		},

		// Element/input types
		header: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		input: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		button: function( elem ) {
			return nodeName( elem, "input" ) && elem.type === "button" ||
				nodeName( elem, "button" );
		},

		text: function( elem ) {
			var attr;
			return nodeName( elem, "input" ) && elem.type === "text" &&

				// Support: IE <10 only
				// New HTML5 attribute values (e.g., "search") appear
				// with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		first: createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		last: createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		even: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		odd: createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i;

			if ( argument < 0 ) {
				i = argument + length;
			} else if ( argument > length ) {
				i = length;
			} else {
				i = argument;
			}

			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos.nth = Expr.pseudos.eq;

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rleadingCombinator.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrimCSS, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	if ( parseOnly ) {
		return soFar.length;
	}

	return soFar ?
		find.error( selector ) :

		// Cache the tokens
		tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						if ( skip && nodeName( elem, skip ) ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = outerCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							outerCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		find( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem, matcherOut,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed ||
				multipleContexts( selector || "*",
					context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems;

		if ( matcher ) {

			// If we have a postFinder, or filtered seed, or non-seed postFilter
			// or preexisting results,
			matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

				// ...intermediate processing is necessary
				[] :

				// ...otherwise use results directly
				results;

			// Find primary matches
			matcher( matcherIn, matcherOut, context, xml );
		} else {
			matcherOut = matcherIn;
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf.call( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			var ret = ( !leadingRelative && ( xml || context != outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element
			// (see https://github.com/jquery/sizzle/issues/299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrimCSS, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find.TAG( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: iOS <=7 - 9 only
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
			// elements by id. (see trac-14142)
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							push.call( results, elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					jQuery.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

function compile( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
}

/**
 * A low-level selection function that works with jQuery's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with jQuery selector compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find.ID(
				token.matches[ 0 ].replace( runescape, funescape ),
				context
			) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) &&
						testContext( context.parentNode ) || context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
}

// One-time assignments

// Support: Android <=4.0 - 4.1+
// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Initialize against the default document
setDocument();

// Support: Android <=4.0 - 4.1+
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

jQuery.find = find;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.unique = jQuery.uniqueSort;

// These have always been private, but they used to be documented as part of
// Sizzle so let's maintain them for now for backwards compatibility purposes.
find.compile = compile;
find.select = select;
find.setDocument = setDocument;
find.tokenize = tokenize;

find.escape = jQuery.escapeSelector;
find.getText = jQuery.text;
find.isXML = jQuery.isXMLDoc;
find.selectors = jQuery.expr;
find.support = jQuery.support;
find.uniqueSort = jQuery.uniqueSort;

	/* eslint-enable */

} )();


var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
	// Strict HTML recognition (trac-11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to jQuery#find
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.error );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the error, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getErrorHook ) {
									process.error = jQuery.Deferred.getErrorHook();

								// The deprecated alias of the above. While the name suggests
								// returning the stack, not an error instance, jQuery just passes
								// it directly to `console.warn` so both will work; an instance
								// just better cooperates with source maps.
								} else if ( jQuery.Deferred.getStackHook ) {
									process.error = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

// If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
// captured before the async barrier to get the original error cause
// which may otherwise be hidden.
jQuery.Deferred.exceptionHook = function( error, asyncError ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message,
			error.stack, asyncError );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See trac-6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (trac-9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see trac-8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (trac-14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (trac-11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (trac-14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (trac-13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (trac-12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (trac-13208)
				// Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (trac-13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", true );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, isSetup ) {

	// Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
	if ( !isSetup ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				if ( !saved ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					this[ type ]();
					result = dataPriv.get( this, type );
					dataPriv.set( this, type, false );

					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						return result;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering
				// the native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved ) {

				// ...and capture the result
				dataPriv.set( this, type, jQuery.event.trigger(
					saved[ 0 ],
					saved.slice( 1 ),
					this
				) );

				// Abort handling of the native event by all jQuery handlers while allowing
				// native handlers on the same element to run. On target, this is achieved
				// by stopping immediate propagation just on the jQuery event. However,
				// the native event is re-wrapped by a jQuery one on each level of the
				// propagation so the only way to stop it for jQuery is to stop it for
				// everyone via native `stopPropagation()`. This is not a problem for
				// focus/blur which don't bubble, but it does also stop click on checkboxes
				// and radios. We accept this limitation.
				event.stopPropagation();
				event.isImmediatePropagationStopped = returnTrue;
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (trac-504, trac-13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {

	function focusMappedHandler( nativeEvent ) {
		if ( document.documentMode ) {

			// Support: IE 11+
			// Attach a single focusin/focusout handler on the document while someone wants
			// focus/blur. This is because the former are synchronous in IE while the latter
			// are async. In other browsers, all those handlers are invoked synchronously.

			// `handle` from private data would already wrap the event, but we need
			// to change the `type` here.
			var handle = dataPriv.get( this, "handle" ),
				event = jQuery.event.fix( nativeEvent );
			event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
			event.isSimulated = true;

			// First, handle focusin/focusout
			handle( nativeEvent );

			// ...then, handle focus/blur
			//
			// focus/blur don't bubble while focusin/focusout do; simulate the former by only
			// invoking the handler at the lower level.
			if ( event.target === event.currentTarget ) {

				// The setup part calls `leverageNative`, which, in turn, calls
				// `jQuery.event.add`, so event handle will already have been set
				// by this point.
				handle( event );
			}
		} else {

			// For non-IE browsers, attach a single capturing handler on the document
			// while someone wants focusin/focusout.
			jQuery.event.simulate( delegateType, nativeEvent.target,
				jQuery.event.fix( nativeEvent ) );
		}
	}

	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			var attaches;

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, true );

			if ( document.documentMode ) {

				// Support: IE 9 - 11+
				// We use the same native handler for focusin & focus (and focusout & blur)
				// so we need to coordinate setup & teardown parts between those events.
				// Use `delegateType` as the key as `type` is already used by `leverageNative`.
				attaches = dataPriv.get( this, delegateType );
				if ( !attaches ) {
					this.addEventListener( delegateType, focusMappedHandler );
				}
				dataPriv.set( this, delegateType, ( attaches || 0 ) + 1 );
			} else {

				// Return false to allow normal processing in the caller
				return false;
			}
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		teardown: function() {
			var attaches;

			if ( document.documentMode ) {
				attaches = dataPriv.get( this, delegateType ) - 1;
				if ( !attaches ) {
					this.removeEventListener( delegateType, focusMappedHandler );
					dataPriv.remove( this, delegateType );
				} else {
					dataPriv.set( this, delegateType, attaches );
				}
			} else {

				// Return false to indicate standard teardown should be applied
				return false;
			}
		},

		// Suppress native focus or blur if we're currently inside
		// a leveraged native-event stack
		_default: function( event ) {
			return dataPriv.get( event.target, type );
		},

		delegateType: delegateType
	};

	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	//
	// Support: IE 9 - 11+
	// To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
	// attach a single handler for both events in IE.
	jQuery.event.special[ delegateType ] = {
		setup: function() {

			// Handle: regular nodes (via `this.ownerDocument`), window
			// (via `this.document`) & document (via `this`).
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType );

			// Support: IE 9 - 11+
			// We use the same native handler for focusin & focus (and focusout & blur)
			// so we need to coordinate setup & teardown parts between those events.
			// Use `delegateType` as the key as `type` is already used by `leverageNative`.
			if ( !attaches ) {
				if ( document.documentMode ) {
					this.addEventListener( delegateType, focusMappedHandler );
				} else {
					doc.addEventListener( type, focusMappedHandler, true );
				}
			}
			dataPriv.set( dataHolder, delegateType, ( attaches || 0 ) + 1 );
		},
		teardown: function() {
			var doc = this.ownerDocument || this.document || this,
				dataHolder = document.documentMode ? this : doc,
				attaches = dataPriv.get( dataHolder, delegateType ) - 1;

			if ( !attaches ) {
				if ( document.documentMode ) {
					this.removeEventListener( delegateType, focusMappedHandler );
				} else {
					doc.removeEventListener( type, focusMappedHandler, true );
				}
				dataPriv.remove( dataHolder, delegateType );
			} else {
				dataPriv.set( dataHolder, delegateType, attaches );
			}
		}
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,

	rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (trac-8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Re-enable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {

							// Unwrap a CDATA section containing script contents. This shouldn't be
							// needed as in XML documents they're already not visible when
							// inspecting element contents and in HTML documents they have no
							// meaning but we're preserving that logic for backwards compatibility.
							// This will be removed completely in 4.0. See gh-4904.
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew jQuery#find here for performance reasons:
			// https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var rcustomProp = /^--/;


var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (trac-8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "box-sizing:content-box;border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is `display: block`
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		isCustomProp = rcustomProp.test( name ),

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, trac-12537)
	//   .css('--customProperty) (gh-3144)
	if ( computed ) {

		// Support: IE <=9 - 11+
		// IE only supports `"float"` in `getPropertyValue`; in computed styles
		// it's only available as `"cssFloat"`. We no longer modify properties
		// sent to `.css()` apart from camelCasing, so we need to check both.
		// Normally, this would create difference in behavior: if
		// `getPropertyValue` returns an empty string, the value returned
		// by `.css()` would be `undefined`. This is usually the case for
		// disconnected elements. However, in IE even disconnected elements
		// with no styles return `"none"` for `getPropertyValue( "float" )`
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( isCustomProp && ret ) {

			// Support: Firefox 105+, Chrome <=105+
			// Spec requires trimming whitespace for custom properties (gh-4926).
			// Firefox only trims leading whitespace. Chrome just collapses
			// both leading & trailing whitespace to a single space.
			//
			// Fall back to `undefined` if empty string returned.
			// This collapses a missing definition with property defined
			// and set to an empty string but there's no standard API
			// allowing us to differentiate them without a performance penalty
			// and returning `undefined` aligns with older jQuery.
			//
			// rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
			// as whitespace while CSS does not, but this is not a problem
			// because CSS preprocessing replaces them with U+000A LINE FEED
			// (which *is* CSS whitespace)
			// https://www.w3.org/TR/css-syntax-3/#input-preprocessing
			ret = ret.replace( rtrimCSS, "$1" ) || undefined;
		}

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0,
		marginDelta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		// Count margin delta separately to only add it after scroll gutter adjustment.
		// This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
		if ( box === "margin" ) {
			marginDelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta + marginDelta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		animationIterationCount: true,
		aspectRatio: true,
		borderImageSlice: true,
		columnCount: true,
		flexGrow: true,
		flexShrink: true,
		fontWeight: true,
		gridArea: true,
		gridColumn: true,
		gridColumnEnd: true,
		gridColumnStart: true,
		gridRow: true,
		gridRowEnd: true,
		gridRowStart: true,
		lineHeight: true,
		opacity: true,
		order: true,
		orphans: true,
		scale: true,
		widows: true,
		zIndex: true,
		zoom: true,

		// SVG-related
		fillOpacity: true,
		floodOpacity: true,
		stopOpacity: true,
		strokeMiterlimit: true,
		strokeOpacity: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (trac-7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug trac-9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (trac-7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// Use proper attribute retrieval (trac-12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];
						if ( cur.indexOf( " " + className + " " ) < 0 ) {
							cur += className + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, cur, curValue, className, i, finalValue;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classNames = classesToArray( value );

		if ( classNames.length ) {
			return this.each( function() {
				curValue = getClass( this );

				// This expression is here for better compressibility (see addClass)
				cur = this.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					for ( i = 0; i < classNames.length; i++ ) {
						className = classNames[ i ];

						// Remove *all* instances
						while ( cur.indexOf( " " + className + " " ) > -1 ) {
							cur = cur.replace( " " + className + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						this.setAttribute( "class", finalValue );
					}
				}
			} );
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var classNames, className, i, self,
			type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		classNames = classesToArray( value );

		return this.each( function() {
			if ( isValidValue ) {

				// Toggle individual class names
				self = jQuery( this );

				for ( i = 0; i < classNames.length; i++ ) {
					className = classNames[ i ];

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (trac-14686, trac-14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (trac-2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (trac-9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (trac-6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// trac-7653, trac-8125, trac-8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes trac-9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (trac-10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket trac-12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// trac-9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (trac-11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// trac-1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see trac-8605, trac-14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// trac-14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this
			.on( "mouseenter", fnOver )
			.on( "mouseleave", fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
// Require that the "whitespace run" starts from a non-whitespace
// to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.
var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "$1" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (trac-13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ 7549:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.5
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
        // not the initial event target in the shadow tree. Note that not all events cross the
        // shadow boundary.
        // For shadow trees with `mode: 'open'`, the initial event target is the first element in
        // the events composed path. For shadow trees with `mode: 'closed'`, the initial event
        // target cannot be obtained.
        if ('composedPath' in e && typeof e.composedPath === 'function') {
            // For open shadow trees, update `element` so that the following check works.
            var initialEventTarget = e.composedPath()[0];
            if (initialEventTarget !== e.target) {
                element = initialEventTarget;
            }
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if ( true && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return Mousetrap;
        }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);


/***/ }),

/***/ 9689:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./aea.js": 4894,
	"./aeqd.js": 6014,
	"./bonne.js": 9265,
	"./cass.js": 3245,
	"./cea.js": 8104,
	"./eqc.js": 780,
	"./eqdc.js": 7724,
	"./eqearth.js": 8197,
	"./equi.js": 63,
	"./etmerc.js": 3426,
	"./gauss.js": 4025,
	"./geocent.js": 5904,
	"./geos.js": 1017,
	"./gnom.js": 5106,
	"./gstmerc.js": 6500,
	"./krovak.js": 6167,
	"./laea.js": 8506,
	"./lcc.js": 993,
	"./longlat.js": 2308,
	"./merc.js": 9402,
	"./mill.js": 969,
	"./moll.js": 6155,
	"./nzmg.js": 6731,
	"./ob_tran.js": 4076,
	"./omerc.js": 431,
	"./ortho.js": 6145,
	"./poly.js": 741,
	"./qsc.js": 2513,
	"./robin.js": 8067,
	"./sinu.js": 1034,
	"./somerc.js": 9872,
	"./stere.js": 3084,
	"./sterea.js": 6789,
	"./tmerc.js": 5518,
	"./tpers.js": 251,
	"./utm.js": 2924,
	"./vandg.js": 6671
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 9689;

/***/ }),

/***/ 5685:
/***/ (function(module) {

module.exports = "/* lineFeature fragment shader */\n\n#ifdef GL_ES\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n  #else\n    precision mediump float;\n  #endif\n#endif\nvarying vec4 strokeColorVar;\nvarying vec4 subpos;\nvarying vec4 info;\nvarying vec4 angles;\nuniform float antialiasing;\nuniform float miterLimit;\nuniform float fixedFlags;\n\nvoid main () {\n  vec4 color = strokeColorVar;\n  float opacity = 1.0;\n  int nearMode = int(floor(info.x + 0.5));\n  int farMode = int(floor(info.y + 0.5));\n  float cosABC = angles.x;\n  float sinABC = angles.y;\n  float cosBCD = angles.z;\n  float sinBCD = angles.w;\n  // never render on the opposite side of a miter.  This uses a bit of\n  // slop, via pow(smoothstep()) instead of step(), since there are\n  // precision issues in this calculation.  This doesn't wholly solve\n  // the precision issue; sometimes pixels are missed or double\n  // rendered along the inside seam of a miter.\n  if (nearMode >= 4) {\n    float dist = cosABC * subpos.x - sinABC * subpos.y;\n    opacity = min(opacity, pow(smoothstep(-0.02, 0.02, dist), 0.5));\n    if (opacity == 0.0) {\n      discard;\n    }\n  }\n  if (farMode >= 4) {\n    float dist = cosBCD * subpos.z - sinBCD * subpos.y;\n    opacity = min(opacity, pow(smoothstep(-0.02, 0.02, dist), 0.5));\n    if (opacity == 0.0) {\n      discard;\n    }\n  }\n  // butt or square cap\n  if ((nearMode == 0 || nearMode == 1) && subpos.x < antialiasing) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.x + subpos.w * float(nearMode)));\n  }\n  if ((farMode == 0 || farMode == 1) && subpos.z < antialiasing) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.z + subpos.w * float(farMode)));\n  }\n  // round cap\n  if (nearMode == 2 && subpos.x <= 0.0) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.w - sqrt(pow(subpos.x, 2.0) + pow(subpos.y - info.z * subpos.w, 2.0))));\n  }\n  if (farMode == 2 && subpos.z <= 0.0) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.w - sqrt(pow(subpos.z, 2.0) + pow(subpos.y - info.z * subpos.w, 2.0))));\n  }\n  // bevel and clip joins\n  if ((nearMode == 5 || nearMode == 7) && subpos.x < antialiasing) {\n    float dist = (sinABC * subpos.x + cosABC * subpos.y) * sign(sinABC);\n    float w = subpos.w * (1.0 - info.z * sign(sinABC));\n    float maxDist;\n    if (nearMode == 5)  maxDist = cosABC * w;\n    else                maxDist = miterLimit * w;\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, maxDist + dist));\n  }\n  if ((farMode == 5 || farMode == 7) && subpos.z < antialiasing) {\n    float dist = (sinBCD * subpos.z + cosBCD * subpos.y) * sign(sinBCD);\n    float w = subpos.w * (1.0 - info.z * sign(sinBCD));\n    float maxDist;\n    if (farMode == 5)  maxDist = cosBCD * w;\n    else               maxDist = miterLimit * w;\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, maxDist + dist));\n  }\n  // round join\n  if (nearMode == 6 && subpos.x <= 0.0) {\n    float w = subpos.w * (1.0 - info.z * sign(sinABC));\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, w - sqrt(pow(subpos.x, 2.0) + pow(subpos.y, 2.0))));\n  }\n  if (farMode == 6 && subpos.z <= 0.0) {\n    float w = subpos.w * (1.0 - info.z * sign(sinBCD));\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, w - sqrt(pow(subpos.z, 2.0) + pow(subpos.y, 2.0))));\n  }\n  // antialias along main edges\n  if (antialiasing > 0.0) {\n    if (subpos.y > subpos.w * (1.0 + info.z) - antialiasing) {\n      opacity = min(opacity, smoothstep(antialiasing, -antialiasing, subpos.y - subpos.w * (1.0 + info.z)));\n    }\n    if (subpos.y < subpos.w * (-1.0 + info.z) + antialiasing) {\n      opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.y - subpos.w * (-1.0 + info.z)));\n    }\n  }\n  if (opacity == 0.0) {\n    discard;\n  }\n  color.a *= opacity;\n  gl_FragColor = color;\n}\n"

/***/ }),

/***/ 9336:
/***/ (function(module) {

module.exports = "/* lineFeature vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nattribute vec3 pos;\nattribute vec3 prev;\nattribute vec3 next;\nattribute vec3 far;\nattribute float flags;\n\nattribute vec3 strokeColor;\nattribute float strokeOpacity;\nattribute float strokeWidth;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float pixelWidth;\nuniform float aspect;\nuniform float miterLimit;\nuniform float antialiasing;\n\nvarying vec4 strokeColorVar;\nvarying vec4 subpos;  /* px, py, length - px, width */\nvarying vec4 info;  /* near mode, far mode, offset */\nvarying vec4 angles; /* near angle cos, sin, far angle cos, sin */\n\nconst float PI = 3.14159265358979323846264;\n\nvec4 viewCoord(vec3 c) {\n  vec4 result = projectionMatrix * modelViewMatrix * vec4(c.xyz, 1.0);\n  if (result.w != 0.0)  result = result / result.w;\n  return result;\n}\n\nfloat atan2(float y, float x) {\n  if (x > 0.0)  return atan(y / x);\n  if (x < 0.0 && y >= 0.0)  return atan(y / x) + PI;\n  if (x < 0.0)  return atan(y / x) - PI;\n  return sign(y) * 0.5 * PI;\n}\n\nvoid main(void)\n{\n  /* If any vertex has been deliberately set to a negative opacity,\n   * skip doing computations on it. */\n  if (strokeOpacity < 0.0) {\n    gl_Position = vec4(2.0, 2.0, 0.0, 1.0);\n    return;\n  }\n  /* convert coordinates.  We have four values, since we need to\n   * calculate the angles between the lines formed by prev-pos and\n   * pos-next, and between pos-next and next-far, plus know the angle\n   *   (prev)---(pos)---(next)---(far) => A---B---C---D */\n  vec4 A = viewCoord(prev);\n  vec4 B = viewCoord(pos);\n  vec4 C = viewCoord(next);\n  vec4 D = viewCoord(far);\n  // calculate line segment vector and angle\n  vec2 deltaCB = C.xy - B.xy;\n  if (deltaCB == vec2(0.0, 0.0)) {\n    gl_Position = vec4(2.0, 2.0, 0.0, 1.0);\n    return;\n  }\n  float lineLength = length(vec2(deltaCB.x, deltaCB.y / aspect)) / pixelWidth;\n  // if lines reverse upon themselves and are not nearly the same length, skip\n  // joins.  This is a heuristic; the correct method would to be to pass some\n  // sort of length of the adjacent line to the fragment renderer and adjust\n  // which fragments are rendered, but this is much more complex.\n  float abLimit = length(vec2(A.x - B.x, (A.y - B.y) / aspect)) / pixelWidth;\n  float dcLimit = length(vec2(D.x - C.x, (D.y - C.y) / aspect)) / pixelWidth;\n  if (abLimit >= lineLength - antialiasing - strokeWidth * 0.5 && abLimit <= lineLength + antialiasing + strokeWidth * 0.5) {\n    abLimit = 0.0001;\n  } else {\n    if (abLimit < lineLength)  abLimit = lineLength;\n    abLimit = (strokeWidth - antialiasing) / (abLimit + antialiasing);\n    if (abLimit < 0.0001) abLimit = 0.0001;\n    if (abLimit > 0.1) abLimit = 0.1;\n  }\n  if (dcLimit >= lineLength - antialiasing - strokeWidth * 0.5 && dcLimit <= lineLength + antialiasing + strokeWidth * 0.5) {\n    dcLimit = 0.0001;\n  } else {\n    if (dcLimit < lineLength)  dcLimit = lineLength;\n    dcLimit = (strokeWidth - antialiasing) / (dcLimit + antialiasing);\n    if (dcLimit < 0.0001) dcLimit = 0.0001;\n    if (dcLimit > 0.1) dcLimit = 0.1;\n  }\n  float angleCB = atan2(deltaCB.y, deltaCB.x * aspect);\n  // values we need to pass along\n  strokeColorVar = vec4(strokeColor, strokeOpacity);\n  // extract values from our flags field\n  int vertex = int(mod(flags, 4.0));\n  int nearMode = int(mod(floor(flags / 4.0), 8.0));\n  int farMode = int(mod(floor(flags / 32.0), 8.0));\n  // we use 11 bits of the flags for the offset, where -1023 to 1023\n  // maps to -1 to 1.  The 11 bits are a signed value, so simply\n  // selecting the bits will result in an unsigned values that may be\n  // greater than 1, in which case we have to subtract appropriately.\n  float offset = mod(floor(flags / 256.0), 2048.0) / 1023.0;\n  if (offset > 1.0)  offset -= 2048.0 / 1023.0;\n  // by default, offset by the width and don't extend lines.  Later,\n  // calculate line extensions based on end cap and end join modes\n  float yOffset = strokeWidth + antialiasing;\n  if (vertex == 0)  yOffset *= -1.0;\n  yOffset += strokeWidth * offset;\n  float xOffset = 0.0;\n  // end caps\n  if (nearMode == 0) {\n    xOffset = antialiasing;\n  } else if (nearMode == 1 || nearMode == 2) {\n    xOffset = strokeWidth + antialiasing;\n  }\n\n  // If joining lines, calculate the angles in screen space formed by\n  // the near end (A-B-C) and far end (B-C-D), and determine how much\n  // space is needed for the particular join.\n  //   This could be changed: if the lines are not a uniform width and\n  // offset, then the functional join angle is not simply half the\n  // angle between the two lines, but rather half the angle of the\n  // inside edge of the the two lines.\n  float cosABC = 1.0, sinABC = 0.0, cosBCD = 1.0, sinBCD = 0.0;  // of half angles\n  // handle near end\n  if (nearMode >= 4) {\n    float angleBA = atan2(B.y - A.y, (B.x - A.x) * aspect);\n    if (A.xy == B.xy)  angleBA = angleCB;\n    float angleABC = angleCB - angleBA;\n    // ensure angle is in the range [-PI, PI], then take the half angle\n    angleABC = (mod(angleABC + 3.0 * PI, 2.0 * PI) - PI) / 2.0;\n    cosABC = cos(angleABC);  sinABC = sin(angleABC);\n    // if this angle is close to flat, pass-through the join\n    if (nearMode >= 4 && (cosABC > 0.999999 || cosABC < abLimit)) {\n      nearMode = 3;\n    }\n    // miter, miter-clip\n    if (nearMode == 4 || nearMode == 7) {\n      if (cosABC < 0.000001 || 1.0 / cosABC > miterLimit) {\n        if (nearMode == 4) {\n          nearMode = 5;\n        } else {\n          xOffset = miterLimit * strokeWidth * (1.0 - offset * sign(sinABC)) + antialiasing;\n        }\n      } else {\n        // we add an extra 1.0 to the xOffset to make sure that fragment\n        // shader is doing the clipping\n        xOffset = abs(sinABC / cosABC) * strokeWidth * (1.0 - offset * sign(sinABC)) + antialiasing + 1.0;\n        nearMode = 4;\n      }\n    }\n    // bevel or round join\n    if (nearMode == 5 || nearMode == 6) {\n      xOffset = strokeWidth * (1.0 - offset * sign(sinABC)) + antialiasing;\n    }\n  }\n\n  // handle far end\n  if (farMode >= 4) {\n    float angleDC = atan2(D.y - C.y, (D.x - C.x) * aspect);\n    if (D.xy == C.xy)  angleDC = angleCB;\n    float angleBCD = angleDC - angleCB;\n    // ensure angle is in the range [-PI, PI], then take the half angle\n    angleBCD = (mod(angleBCD + 3.0 * PI, 2.0 * PI) - PI) / 2.0;\n    cosBCD = cos(angleBCD);  sinBCD = sin(angleBCD);\n    // if this angle is close to flat, pass-through the join\n    if (farMode >= 4 && (cosBCD > 0.999999 || cosBCD < dcLimit)) {\n      farMode = 3;\n    }\n    // miter, miter-clip\n    if (farMode == 4 || farMode == 7) {\n      if (cosBCD < 0.000001 || 1.0 / cosBCD > miterLimit) {\n        if (farMode == 4)  farMode = 5;\n      } else {\n        farMode = 4;\n      }\n    }\n  }\n\n  // compute the location of a vertex to include everything that might\n  // need to be rendered\n  xOffset *= -1.0;\n  gl_Position = vec4(\n    B.x + (xOffset * cos(angleCB) - yOffset * sin(angleCB)) * pixelWidth,\n    B.y + (xOffset * sin(angleCB) + yOffset * cos(angleCB)) * pixelWidth * aspect,\n    B.z, 1.0);\n  // store other values needed to determine which pixels to plot.\n  if (vertex == 0 || vertex == 1) {\n    subpos = vec4(xOffset, yOffset, lineLength - xOffset, strokeWidth);\n    info = vec4(float(nearMode), float(farMode), offset, 0.0);\n    angles = vec4(cosABC, sinABC, cosBCD, sinBCD);\n  } else {\n    subpos = vec4(lineLength - xOffset, -yOffset, xOffset, strokeWidth);\n    info = vec4(float(farMode), float(nearMode), -offset, 0.0);\n    angles = vec4(cosBCD, -sinBCD, cosABC, -sinABC);\n  }\n}\n"

/***/ }),

/***/ 1388:
/***/ (function(module) {

module.exports = "/* lineFeature debug fragment shader */\n\n#ifdef GL_ES\n  #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n  #else\n    precision mediump float;\n  #endif\n#endif\nvarying vec4 strokeColorVar;\nvarying vec4 subpos;\nvarying vec4 info;\nvarying vec4 angles;\nuniform float antialiasing;\nuniform float miterLimit;\nuniform float fixedFlags;\n\nvoid main () {\n  vec4 color = strokeColorVar;\n  bool debug = bool(mod(fixedFlags, 2.0));\n  float opacity = 1.0;\n  int nearMode = int(floor(info.x + 0.5));\n  int farMode = int(floor(info.y + 0.5));\n  float cosABC = angles.x;\n  float sinABC = angles.y;\n  float cosBCD = angles.z;\n  float sinBCD = angles.w;\n  // never render on the opposite side of a miter.  This uses a bit of\n  // slop, via pow(smoothstep()) instead of step(), since there are\n  // precision issues in this calculation.  This doesn't wholly solve\n  // the precision issue; sometimes pixels are missed or double\n  // rendered along the inside seam of a miter.\n  if (nearMode >= 4) {\n    float dist = cosABC * subpos.x - sinABC * subpos.y;\n    opacity = min(opacity, pow(smoothstep(-0.02, 0.02, dist), 0.5));\n    if (opacity == 0.0) {\n      if (debug) {\n        color.r = 255.0 / 255.0;\n        gl_FragColor = color;\n        return;\n      }\n      discard;\n    }\n  }\n  if (farMode >= 4) {\n    float dist = cosBCD * subpos.z - sinBCD * subpos.y;\n    opacity = min(opacity, pow(smoothstep(-0.02, 0.02, dist), 0.5));\n    if (opacity == 0.0) {\n      if (debug) {\n        color.r = 254.0 / 255.0;\n        gl_FragColor = color;\n        return;\n      }\n      discard;\n    }\n  }\n  // butt or square cap\n  if ((nearMode == 0 || nearMode == 1) && subpos.x < antialiasing) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.x + subpos.w * float(nearMode)));\n  }\n  if ((farMode == 0 || farMode == 1) && subpos.z < antialiasing) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.z + subpos.w * float(farMode)));\n  }\n  // round cap\n  if (nearMode == 2 && subpos.x <= 0.0) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.w - sqrt(pow(subpos.x, 2.0) + pow(subpos.y - info.z * subpos.w, 2.0))));\n  }\n  if (farMode == 2 && subpos.z <= 0.0) {\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.w - sqrt(pow(subpos.z, 2.0) + pow(subpos.y - info.z * subpos.w, 2.0))));\n  }\n  // bevel and clip joins\n  if ((nearMode == 5 || nearMode == 7) && subpos.x < antialiasing) {\n    float dist = (sinABC * subpos.x + cosABC * subpos.y) * sign(sinABC);\n    float w = subpos.w * (1.0 - info.z * sign(sinABC));\n    float maxDist;\n    if (nearMode == 5)  maxDist = cosABC * w;\n    else                maxDist = miterLimit * w;\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, maxDist + dist));\n  }\n  if ((farMode == 5 || farMode == 7) && subpos.z < antialiasing) {\n    float dist = (sinBCD * subpos.z + cosBCD * subpos.y) * sign(sinBCD);\n    float w = subpos.w * (1.0 - info.z * sign(sinBCD));\n    float maxDist;\n    if (farMode == 5)  maxDist = cosBCD * w;\n    else               maxDist = miterLimit * w;\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, maxDist + dist));\n  }\n  // round join\n  if (nearMode == 6 && subpos.x <= 0.0) {\n    float w = subpos.w * (1.0 - info.z * sign(sinABC));\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, w - sqrt(pow(subpos.x, 2.0) + pow(subpos.y, 2.0))));\n  }\n  if (farMode == 6 && subpos.z <= 0.0) {\n    float w = subpos.w * (1.0 - info.z * sign(sinBCD));\n    opacity = min(opacity, smoothstep(-antialiasing, antialiasing, w - sqrt(pow(subpos.z, 2.0) + pow(subpos.y, 2.0))));\n  }\n  // antialias along main edges\n  if (antialiasing > 0.0) {\n    if (subpos.y > subpos.w * (1.0 + info.z) - antialiasing) {\n      opacity = min(opacity, smoothstep(antialiasing, -antialiasing, subpos.y - subpos.w * (1.0 + info.z)));\n    }\n    if (subpos.y < subpos.w * (-1.0 + info.z) + antialiasing) {\n      opacity = min(opacity, smoothstep(-antialiasing, antialiasing, subpos.y - subpos.w * (-1.0 + info.z)));\n    }\n  }\n  if (opacity == 0.0) {\n    if (debug) {\n      color.r = 253.0 / 255.0;\n      gl_FragColor = color;\n      return;\n    }\n    discard;\n  }\n  color.a *= opacity;\n  gl_FragColor = color;\n}\n"

/***/ }),

/***/ 9923:
/***/ (function(module) {

module.exports = "/* markerFeature square/triangle fragment shader */\n\n/* markerFeature common fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nvarying float radiusVar;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float strokeWidthVar;\nvarying float symbolVar;  /* contains some bit fields */\nvarying float symbolValueVar;\nvarying float rotationVar;\n// the square/triangle shader defines unitVar\nconst int symbolEllipse = 0;\nconst int symbolFlowerBase = 1;\nconst int symbolFlowerMax = 16;\nconst int symbolTriangle = 16;\nconst int symbolStarBase = 17;\nconst int symbolStarMax = 16;\nconst int symbolRectangle = 32;\nconst int symbolCrossBase = 33;\nconst int symbolCrossMax = 16;\nconst int symbolOval = 48;\nconst int symbolJackBase = 49;\nconst int symbolJackMax = 16;\nconst int symbolDrop = 64;\nconst int symbolDropBase = 65;\nconst int symbolDropMax = 16;\nconst int symbolArrow = 80;\nconst int symbolArrowBase = 81;\nconst int symbolArrowMax = 16;\n// Distance to antialias in pixels\nconst float antialiasDist = 1.5;\n\n/* Compute the distance from a point to an arrow defined by the radiusVar and a\n * packed value containing\n *   headWidth: ratio to radius (0, 1]\n *   headLength: ratio to diameter (0, 1]\n *   stemWidth: ratio to headWidth [0, 1]\n *   sweep: boolean\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float packed: the packed value.\n * Exit:  float dist: the distance to the drop in pixels.  Negative is inside.\n */\nfloat distanceToArrow(vec2 pos, float value) {\n  bool sweep = value < 0.0;\n  value = abs(value);\n  float pack0 = (mod(value, 252.0) - 1.0) / 250.0;\n  value = floor(value / 252.0);\n  float pack1 = (mod(value, 252.0) - 1.0) / 250.0;\n  value = floor(value / 252.0);\n  float pack2 = (mod(value, 252.0) - 1.0) / 250.0;\n\n  float headWidth = (pack0 > 0.0 ? pack0 : 2.0 / 3.0);\n  float headEnd = 1.0 - 2.0 * (pack1 > 0.0 ? pack1 : 1.0 / 2.0);\n  float stemWidth = headWidth * (pack2 >= 0.0 ? pack2 : 1.0 / 3.0);\n  if (length(vec2(headWidth, headEnd)) > 1.0) {\n    vec2 scaledHead = normalize(vec2(headWidth, headEnd));\n    headWidth = scaledHead.x;\n    headEnd = scaledHead.y;\n  }\n  float stemEnd = -cos(asin(stemWidth));\n\n  headWidth *= radiusVar;\n  headEnd *= radiusVar;\n  stemWidth *= radiusVar;\n  stemEnd *= radiusVar;\n  pos.y = abs(pos.y);\n  float stemDist = pos.y - stemWidth;\n  float stemEndDist = stemEnd - pos.x;\n  float B = (radiusVar - headEnd) / headWidth;\n  float headDist = (pos.x + B * pos.y - radiusVar) / sqrt(1.0 + B * B);\n  float headEndDist;\n  if (sweep) {\n    B = (radiusVar - headEnd) / 3.0 / headWidth;\n    headEndDist = -(pos.x + B * pos.y - (radiusVar + headEnd * 2.0) / 3.0) / sqrt(1.0 + B * B);\n  } else {\n    headEndDist = headEnd - pos.x;\n  }\n  headEndDist = min(headEndDist, stemDist);\n  return max(max(headDist, headEndDist), stemEndDist);\n}\n\n/* Compute the distance from a point to a drop defined by the radiusVar (the\n * semimajor axis) and ratio (between the minor and major radii).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the drop in pixels.  Negative is inside.\n */\nfloat distanceToDrop(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0 || ratio >= 1.0) {\n    ratio = 1.0;\n  }\n  float r = radiusVar * ratio;\n  float cx = radiusVar - r;\n  float rad = distance(pos.xy, vec2(cx, 0.0)) - r;\n  if (ratio < 0.5) {\n    float x = radiusVar - r - r * r / cx;\n    float y = sqrt(r * r - (cx - x) * (cx - x));\n    float Bt = (cx - x) / y;\n    if ((pos.x + Bt * abs(pos.y) - cx) / sqrt(1.0 + Bt * Bt) < 0.0) {\n      float B = -x / y;\n      return -(pos.x + B * abs(pos.y)) / sqrt(1.0 + B * B);\n    }\n  }\n  return rad;\n}\n\n/* Compute the distance from a point to the ellipse defined by the radiusVar\n * (the semimajor axis) and ratio (between the minor and major axes).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the ellipse in pixels.  Negative is\n *   inside.\n */\nfloat distanceToEllipse(vec2 pos, float ratio) {\n  // a and b are the semi-major and semi-minor axes\n  // ratio is the between the minor and major axes.  If > 1, swap these and\n  // rotate 90 degrees.\n  if (ratio == 0.0) {\n    ratio = 1.0;\n  }\n  float a = radiusVar, b = abs(radiusVar * ratio);\n  if (b > a) {\n    pos = vec2(pos.y, -pos.x);\n    b = abs(radiusVar / ratio);\n  }\n  float a2 = a * a, b2 = b * b;\n  // compute the distance to the ellipse.  See this discussion:\n  // https://stackoverflow.com/questions/22959698\n  float f = sqrt(a2 - b2),\n        // this value will be positive if outside and negative if inside.  If\n        // we used it directly, the stroke would be too thick along the long\n        // edges of the ellipse\n        d = (distance(pos, vec2(f, 0.0)) + distance(pos, vec2(-f, 0.0))) * 0.5 - a;\n  // if we are outside of the ellipse, accuracy is not important, so return\n  // early.\n  if (d >= 0.0) {\n    return d;\n  }\n  // work in one quadrant\n  pos = abs(pos);\n  // t (the angle from center) could start as `atan(pos.y, pos.x)`, but this\n  // results in a slower solution near narrow ends\n  float t = 0.7;\n  float cost = cos(t), sint = sin(t), x = a * cost, y = b * sint;\n  vec2 lastxy;\n  for (int iter = 0; iter < 10; iter += 1) {\n    lastxy = vec2(x, y);\n    float ex = (a2 - b2) * pow(cost, 3.0) / a,\n          ey = (b2 - a2) * pow(sint, 3.0) / b;\n    vec2 r = vec2(x - ex, y - ey),\n         q = vec2(pos.x - ex, pos.y - ey);\n    float lenr = length(r);\n    t += lenr * asin((r.x * q.y - r.y * q.x) / lenr / length(q)) / sqrt(a2 + b2 - x * x - y * y);\n    t = clamp(t, 0.0, acos(0.0));\n    cost = cos(t);\n    sint = sin(t);\n    x = a * cost;\n    y = b * sint;\n    if (distance(lastxy, vec2(x, y)) < 0.05) {\n      break;\n    }\n  }\n  return sign(d) * distance(pos, vec2(x, y));\n}\n\n/* Compute the distance from a point to an isosceles triangle.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: length of the base compared to the other sides.\n * Exit:  float dist: the distance to the rectangle in pixels.  Negative is\n *   inside.\n */\nfloat distanceToIsoscelesTriangle(vec2 pos, float ratio) {\n  ratio = clamp(abs(ratio), 0.0, 2.0);\n  if (ratio == 0.0 || ratio == 2.0) {\n    ratio = 1.0;\n  }\n  float s1, s2, x0, x1, y1;\n  if (ratio < sqrt(2.0)) {\n    s1 = radiusVar * sqrt(4.0 - ratio * ratio); // length of equal sides\n    s2 = s1 * ratio;\n    y1 = s2 / 2.0;\n    x0 = radiusVar;\n    x1 = x0 - sqrt(s1 * s1 - y1 * y1);\n  } else {\n    s2 = radiusVar * 2.0;\n    s1 = s2 / ratio;\n    y1 = s2 / 2.0;\n    x0 = sqrt(s1 * s1 - y1 * y1);\n    x1 = 0.0;\n  }\n  float B = (x0 - x1) / y1;\n  return max(x1 - pos.x, (pos.x + B * abs(pos.y) - x0) / sqrt(1.0 + B * B));\n}\n\n/* Compute the distance from a point to an oval defined by the radiusVar (the\n * semimajor axis) and ratio (between the minor and major axes).  Here an oval\n * is defined as two semicircles connected by straight line segments.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the oval in pixels.  Negative is inside.\n */\nfloat distanceToOval(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0 || ratio >= 1.0) {\n    ratio = 1.0;\n  }\n  float minor = radiusVar * ratio;\n  float center = radiusVar - minor;\n  pos = abs(pos);\n  if (pos.x <= center) {\n    return pos.y - minor;\n  }\n  return distance(pos, vec2(center, 0.0)) - minor;\n}\n\n/* Compute the distance from a point to a rectangle defined by the radiusVar\n * (the semidiagonal) and ratio (between the minor and major axes).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the rectangle in pixels.  Negative is\n *   inside.\n */\nfloat distanceToRectangle(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0) {\n    ratio = 1.0;\n  }\n  vec2 wh = normalize(vec2(1.0, abs(ratio))) * radiusVar;\n  vec2 dist = abs(pos) - wh;\n  return max(dist.x, dist.y);\n}\n\n/* Based on a repetition value, return a position for rotational symmetry.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        int repetitions: number of repetitions on the cross.\n * Exit:  float dist: a point in the primary position.\n */\nvec2 rotationalSymmetry(vec2 pos, int repetitions) {\n  float pi = acos(-1.0);\n  float limit = pi / float(repetitions);\n  float ang = atan(pos.y, pos.x);\n  ang = mod(ang + pi * 2.0, limit * 2.0);\n  if (ang > limit) {\n    ang -= limit * 2.0;\n  }\n  return vec2(cos(ang), sin(ang)) * length(pos);\n}\n\nfloat markerFeatureFragment(vec3 posAndSpacing) {\n  vec2 pos = posAndSpacing.xy;\n  float spacing = posAndSpacing.z;\n  // square lattice\n  if (spacing > 0.0) {\n    pos.x = mod(pos.x + spacing * 0.5, spacing) - spacing * 0.5;\n    pos.y = mod(pos.y + spacing * 0.5, spacing) - spacing * 0.5;\n  }\n  // triangular lattice\n  if (spacing < 0.0) {\n    spacing = spacing * -1.0;\n    float cz = (2.0 * pos.y) / (sqrt(3.0) * spacing);\n    float cx = pos.x / spacing - 0.5 * cz;\n    float cy = -cx - cz;\n    float rx = floor(cx + 0.5);\n    float ry = floor(cy + 0.5);\n    float rz = floor(cz + 0.5);\n    float dx = abs(rx - cx);\n    float dy = abs(ry - cy);\n    float dz = abs(rz - cz);\n    if (dx > dy && dx > dz) {\n      rx = -ry - rz;\n    } else if (dy > dz) {\n      ry = -rx - rz;\n    } else {\n      rz = -rx - ry;\n    }\n    vec2 center = vec2(spacing * (rx + 0.5 * rz), (sqrt(3.0) * spacing * 0.5) * rz);\n    pos = pos - center;\n  }\n  // rad is a value in pixels from the edge of the symbol where negative is\n  // inside the shape\n  float rad = length(pos.xy) - radiusVar;\n  // never allow points outside of the main radius\n  if (rad > 0.0) {\n    return 0.0;\n  }\n  // apply clockwise rotation\n  if (rotationVar != 0.0) {\n    float cosr = cos(rotationVar), sinr = sin(rotationVar);\n    pos = vec2(pos.x * cosr + pos.y * sinr, -pos.x * sinr + pos.y * cosr);\n  }\n\n  int symbol = int(floor(symbolVar / 64.0));\n  bool isimage = bool(mod(floor(symbolVar / 8.0), 2.0));\n  vec4 fillColor, strokeColor;\n  float endStep;\n\n  float ratio = symbolValueVar;\n  // When ratio is 0, it usually gets changed to 1; some shapes could have\n  // better defaults\n  /* Symbol shapes */\n  if (symbol == symbolTriangle) {\n    rad = distanceToIsoscelesTriangle(pos, ratio);\n  } else if (symbol == symbolRectangle) {\n    rad = distanceToRectangle(pos, ratio);\n  } else if (symbol == symbolOval) {\n    rad = distanceToOval(pos, ratio);\n  } else if (symbol == symbolDrop) {\n    rad = distanceToDrop(pos, ratio);\n  } else if (symbol == symbolArrow) {\n    rad = distanceToArrow(pos, ratio);\n  } else if (symbol >= symbolCrossBase && symbol <= symbolCrossBase + symbolCrossMax - 2) {\n    rad = distanceToRectangle(rotationalSymmetry(pos, symbol - symbolCrossBase + 2), ratio);\n  } else if (symbol >= symbolFlowerBase && symbol <= symbolFlowerBase + symbolFlowerMax - 2) {\n    rad = distanceToEllipse(rotationalSymmetry(pos, symbol - symbolFlowerBase + 2), ratio);\n  } else if (symbol >= symbolStarBase && symbol <= symbolStarBase + symbolStarMax - 2) {\n    rad = distanceToIsoscelesTriangle(rotationalSymmetry(pos, symbol - symbolStarBase + 2), ratio);\n  } else if (symbol >= symbolJackBase && symbol <= symbolJackBase + symbolJackMax - 2) {\n    rad = distanceToOval(rotationalSymmetry(pos, symbol - symbolJackBase + 2), ratio);\n  } else if (symbol >= symbolDropBase && symbol <= symbolDropBase + symbolDropMax - 2) {\n    rad = distanceToDrop(rotationalSymmetry(pos, symbol - symbolDropBase + 2), ratio);\n  } else if (symbol >= symbolArrowBase && symbol <= symbolArrowBase + symbolArrowMax - 2) {\n    rad = distanceToArrow(rotationalSymmetry(pos, symbol - symbolArrowBase + 2), ratio);\n  } else { // default - circle or ellipse; a value of 0 or 1 is a circle\n    if (ratio != 0.0 && ratio != 1.0) {\n      rad = distanceToEllipse(pos, ratio);\n    }\n  }\n\n  if (rad >= 0.0) {\n    return 0.0;\n  }\n  // If there is no stroke, the fill region should transition to nothing\n  if (strokeColorVar.a == 0.0 || strokeWidthVar <= 0.0) {\n    strokeColor = vec4(fillColorVar.rgb, 0.0);\n    endStep = 0.0;\n  } else {\n    strokeColor = strokeColorVar;\n    endStep = -strokeWidthVar;\n  }\n  // Likewise, if there is no fill, the stroke should transition to nothing\n  if (fillColorVar.a == 0.0) {\n    fillColor = vec4(strokeColorVar.rgb, 0.0);\n  } else {\n    fillColor = fillColorVar;\n  }\n  float alpha = 1.0;\n  if (rad <= endStep) {\n    float step = smoothstep(endStep - antialiasDist, endStep, rad);\n    vec4 color = mix(fillColor, strokeColor, step);\n    float step2 = smoothstep(-antialiasDist, 0.0, rad);\n    gl_FragColor = mix(color, vec4(color.rgb, 0.0), step2);\n    if (color.a > 0.0)\n      alpha = gl_FragColor.a / color.a;\n  } else {\n    float step = smoothstep(-antialiasDist, 0.0, rad);\n    gl_FragColor = mix(strokeColor, vec4(strokeColor.rgb, 0.0), step);\n    if (strokeColor.a > 0.0)\n      alpha = gl_FragColor.a / strokeColor.a;\n  }\n  return alpha;\n}\n\n\nvarying vec2 unitVar;  // distinct for square/triangle\n\nvoid main() {\n  if (fillColorVar.a == 0.0 && strokeColorVar.a == 0.0)\n    discard;\n  if (markerFeatureFragment(vec3(unitVar, 0.0)) == 0.0)\n    discard;\n}\n"

/***/ }),

/***/ 1202:
/***/ (function(module) {

module.exports = "/* markerFeature square/triangle vertex shader */\n\n/* markerFeature common vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nattribute vec3 pos;\nattribute float radius;\nattribute vec3 fillColor;\nattribute float fillOpacity;\nattribute vec3 strokeColor;\nattribute float strokeOpacity;\nattribute float strokeWidth;\nattribute float symbol;  /* contains some bit fields */\nattribute float symbolValue;\nattribute float rotation;\nuniform float zoom;\nuniform float rotationUniform;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// non-sprite has other definitions.\nvarying float radiusVar;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float strokeWidthVar;\nvarying float symbolVar;  /* contains some bit fields */\nvarying float symbolValueVar;\nvarying float rotationVar;\n\nfloat markerFeaturePrep(void)\n{\n  // No stroke or fill implies nothing to draw\n  if (radius <= 0.0 || (strokeOpacity <= 0.0 && fillOpacity <= 0.0)) {\n    gl_Position = vec4(2.0, 2.0, 0.0, 1.0);\n    return 0.0;\n  }\n  radiusVar = radius;\n  strokeWidthVar = strokeWidth;\n  int scaleMode = int(mod(symbol, 4.0));\n  float strokeOffset = mod(floor(symbol / 16.0), 4.0) - 1.0;\n  radiusVar += (strokeOffset + 1.0) / 2.0 * strokeWidthVar;\n  if (scaleMode == 1) { // fill\n    radiusVar = (radiusVar - strokeWidthVar) * exp2(zoom) + strokeWidthVar;\n  } else if (scaleMode == 2) { // stroke\n    radiusVar += strokeWidthVar * (exp2(zoom) - 1.0);\n    strokeWidthVar *= exp2(zoom);\n  } else if (scaleMode == 3) { // all\n    radiusVar *= exp2(zoom);\n    strokeWidthVar *= exp2(zoom);\n  }\n  fillColorVar = vec4(fillColor, fillOpacity);\n  strokeColorVar = vec4(strokeColor, strokeOpacity);\n  symbolVar = symbol;\n  symbolValueVar = symbolValue;\n  rotationVar = rotation;\n  if (bool(mod(floor(symbolVar / 4.0), 2.0))) {\n    rotationVar += rotationUniform;\n  }\n  return radiusVar;\n}\n\n\nuniform float pixelWidth; // for non-sprite\nuniform float aspect; // for non-sprite\nattribute vec2 unit; // for non-sprite\nvarying vec2 unitVar; // for non-sprite\n\nvoid main(void)\n{\n  radiusVar = markerFeaturePrep();\n  if (radiusVar == 0.0) {\n    return;\n  }\n  // for non-sprite\n  unitVar = unit * radiusVar;\n  unitVar.y *= -1.0;\n  vec4 p = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;\n  if (p.w != 0.0) {\n    p = p / p.w;\n  }\n  p += radiusVar * vec4(unit.x * pixelWidth, unit.y * pixelWidth * aspect, 0.0, 1.0);\n  gl_Position = vec4(p.xyz, 1.0);\n}\n"

/***/ }),

/***/ 3724:
/***/ (function(module) {

module.exports = "/* markerFeature sprite fragment shader */\n\n/* markerFeature common fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nvarying float radiusVar;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float strokeWidthVar;\nvarying float symbolVar;  /* contains some bit fields */\nvarying float symbolValueVar;\nvarying float rotationVar;\n// the square/triangle shader defines unitVar\nconst int symbolEllipse = 0;\nconst int symbolFlowerBase = 1;\nconst int symbolFlowerMax = 16;\nconst int symbolTriangle = 16;\nconst int symbolStarBase = 17;\nconst int symbolStarMax = 16;\nconst int symbolRectangle = 32;\nconst int symbolCrossBase = 33;\nconst int symbolCrossMax = 16;\nconst int symbolOval = 48;\nconst int symbolJackBase = 49;\nconst int symbolJackMax = 16;\nconst int symbolDrop = 64;\nconst int symbolDropBase = 65;\nconst int symbolDropMax = 16;\nconst int symbolArrow = 80;\nconst int symbolArrowBase = 81;\nconst int symbolArrowMax = 16;\n// Distance to antialias in pixels\nconst float antialiasDist = 1.5;\n\n/* Compute the distance from a point to an arrow defined by the radiusVar and a\n * packed value containing\n *   headWidth: ratio to radius (0, 1]\n *   headLength: ratio to diameter (0, 1]\n *   stemWidth: ratio to headWidth [0, 1]\n *   sweep: boolean\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float packed: the packed value.\n * Exit:  float dist: the distance to the drop in pixels.  Negative is inside.\n */\nfloat distanceToArrow(vec2 pos, float value) {\n  bool sweep = value < 0.0;\n  value = abs(value);\n  float pack0 = (mod(value, 252.0) - 1.0) / 250.0;\n  value = floor(value / 252.0);\n  float pack1 = (mod(value, 252.0) - 1.0) / 250.0;\n  value = floor(value / 252.0);\n  float pack2 = (mod(value, 252.0) - 1.0) / 250.0;\n\n  float headWidth = (pack0 > 0.0 ? pack0 : 2.0 / 3.0);\n  float headEnd = 1.0 - 2.0 * (pack1 > 0.0 ? pack1 : 1.0 / 2.0);\n  float stemWidth = headWidth * (pack2 >= 0.0 ? pack2 : 1.0 / 3.0);\n  if (length(vec2(headWidth, headEnd)) > 1.0) {\n    vec2 scaledHead = normalize(vec2(headWidth, headEnd));\n    headWidth = scaledHead.x;\n    headEnd = scaledHead.y;\n  }\n  float stemEnd = -cos(asin(stemWidth));\n\n  headWidth *= radiusVar;\n  headEnd *= radiusVar;\n  stemWidth *= radiusVar;\n  stemEnd *= radiusVar;\n  pos.y = abs(pos.y);\n  float stemDist = pos.y - stemWidth;\n  float stemEndDist = stemEnd - pos.x;\n  float B = (radiusVar - headEnd) / headWidth;\n  float headDist = (pos.x + B * pos.y - radiusVar) / sqrt(1.0 + B * B);\n  float headEndDist;\n  if (sweep) {\n    B = (radiusVar - headEnd) / 3.0 / headWidth;\n    headEndDist = -(pos.x + B * pos.y - (radiusVar + headEnd * 2.0) / 3.0) / sqrt(1.0 + B * B);\n  } else {\n    headEndDist = headEnd - pos.x;\n  }\n  headEndDist = min(headEndDist, stemDist);\n  return max(max(headDist, headEndDist), stemEndDist);\n}\n\n/* Compute the distance from a point to a drop defined by the radiusVar (the\n * semimajor axis) and ratio (between the minor and major radii).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the drop in pixels.  Negative is inside.\n */\nfloat distanceToDrop(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0 || ratio >= 1.0) {\n    ratio = 1.0;\n  }\n  float r = radiusVar * ratio;\n  float cx = radiusVar - r;\n  float rad = distance(pos.xy, vec2(cx, 0.0)) - r;\n  if (ratio < 0.5) {\n    float x = radiusVar - r - r * r / cx;\n    float y = sqrt(r * r - (cx - x) * (cx - x));\n    float Bt = (cx - x) / y;\n    if ((pos.x + Bt * abs(pos.y) - cx) / sqrt(1.0 + Bt * Bt) < 0.0) {\n      float B = -x / y;\n      return -(pos.x + B * abs(pos.y)) / sqrt(1.0 + B * B);\n    }\n  }\n  return rad;\n}\n\n/* Compute the distance from a point to the ellipse defined by the radiusVar\n * (the semimajor axis) and ratio (between the minor and major axes).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the ellipse in pixels.  Negative is\n *   inside.\n */\nfloat distanceToEllipse(vec2 pos, float ratio) {\n  // a and b are the semi-major and semi-minor axes\n  // ratio is the between the minor and major axes.  If > 1, swap these and\n  // rotate 90 degrees.\n  if (ratio == 0.0) {\n    ratio = 1.0;\n  }\n  float a = radiusVar, b = abs(radiusVar * ratio);\n  if (b > a) {\n    pos = vec2(pos.y, -pos.x);\n    b = abs(radiusVar / ratio);\n  }\n  float a2 = a * a, b2 = b * b;\n  // compute the distance to the ellipse.  See this discussion:\n  // https://stackoverflow.com/questions/22959698\n  float f = sqrt(a2 - b2),\n        // this value will be positive if outside and negative if inside.  If\n        // we used it directly, the stroke would be too thick along the long\n        // edges of the ellipse\n        d = (distance(pos, vec2(f, 0.0)) + distance(pos, vec2(-f, 0.0))) * 0.5 - a;\n  // if we are outside of the ellipse, accuracy is not important, so return\n  // early.\n  if (d >= 0.0) {\n    return d;\n  }\n  // work in one quadrant\n  pos = abs(pos);\n  // t (the angle from center) could start as `atan(pos.y, pos.x)`, but this\n  // results in a slower solution near narrow ends\n  float t = 0.7;\n  float cost = cos(t), sint = sin(t), x = a * cost, y = b * sint;\n  vec2 lastxy;\n  for (int iter = 0; iter < 10; iter += 1) {\n    lastxy = vec2(x, y);\n    float ex = (a2 - b2) * pow(cost, 3.0) / a,\n          ey = (b2 - a2) * pow(sint, 3.0) / b;\n    vec2 r = vec2(x - ex, y - ey),\n         q = vec2(pos.x - ex, pos.y - ey);\n    float lenr = length(r);\n    t += lenr * asin((r.x * q.y - r.y * q.x) / lenr / length(q)) / sqrt(a2 + b2 - x * x - y * y);\n    t = clamp(t, 0.0, acos(0.0));\n    cost = cos(t);\n    sint = sin(t);\n    x = a * cost;\n    y = b * sint;\n    if (distance(lastxy, vec2(x, y)) < 0.05) {\n      break;\n    }\n  }\n  return sign(d) * distance(pos, vec2(x, y));\n}\n\n/* Compute the distance from a point to an isosceles triangle.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: length of the base compared to the other sides.\n * Exit:  float dist: the distance to the rectangle in pixels.  Negative is\n *   inside.\n */\nfloat distanceToIsoscelesTriangle(vec2 pos, float ratio) {\n  ratio = clamp(abs(ratio), 0.0, 2.0);\n  if (ratio == 0.0 || ratio == 2.0) {\n    ratio = 1.0;\n  }\n  float s1, s2, x0, x1, y1;\n  if (ratio < sqrt(2.0)) {\n    s1 = radiusVar * sqrt(4.0 - ratio * ratio); // length of equal sides\n    s2 = s1 * ratio;\n    y1 = s2 / 2.0;\n    x0 = radiusVar;\n    x1 = x0 - sqrt(s1 * s1 - y1 * y1);\n  } else {\n    s2 = radiusVar * 2.0;\n    s1 = s2 / ratio;\n    y1 = s2 / 2.0;\n    x0 = sqrt(s1 * s1 - y1 * y1);\n    x1 = 0.0;\n  }\n  float B = (x0 - x1) / y1;\n  return max(x1 - pos.x, (pos.x + B * abs(pos.y) - x0) / sqrt(1.0 + B * B));\n}\n\n/* Compute the distance from a point to an oval defined by the radiusVar (the\n * semimajor axis) and ratio (between the minor and major axes).  Here an oval\n * is defined as two semicircles connected by straight line segments.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the oval in pixels.  Negative is inside.\n */\nfloat distanceToOval(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0 || ratio >= 1.0) {\n    ratio = 1.0;\n  }\n  float minor = radiusVar * ratio;\n  float center = radiusVar - minor;\n  pos = abs(pos);\n  if (pos.x <= center) {\n    return pos.y - minor;\n  }\n  return distance(pos, vec2(center, 0.0)) - minor;\n}\n\n/* Compute the distance from a point to a rectangle defined by the radiusVar\n * (the semidiagonal) and ratio (between the minor and major axes).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the rectangle in pixels.  Negative is\n *   inside.\n */\nfloat distanceToRectangle(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0) {\n    ratio = 1.0;\n  }\n  vec2 wh = normalize(vec2(1.0, abs(ratio))) * radiusVar;\n  vec2 dist = abs(pos) - wh;\n  return max(dist.x, dist.y);\n}\n\n/* Based on a repetition value, return a position for rotational symmetry.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        int repetitions: number of repetitions on the cross.\n * Exit:  float dist: a point in the primary position.\n */\nvec2 rotationalSymmetry(vec2 pos, int repetitions) {\n  float pi = acos(-1.0);\n  float limit = pi / float(repetitions);\n  float ang = atan(pos.y, pos.x);\n  ang = mod(ang + pi * 2.0, limit * 2.0);\n  if (ang > limit) {\n    ang -= limit * 2.0;\n  }\n  return vec2(cos(ang), sin(ang)) * length(pos);\n}\n\nfloat markerFeatureFragment(vec3 posAndSpacing) {\n  vec2 pos = posAndSpacing.xy;\n  float spacing = posAndSpacing.z;\n  // square lattice\n  if (spacing > 0.0) {\n    pos.x = mod(pos.x + spacing * 0.5, spacing) - spacing * 0.5;\n    pos.y = mod(pos.y + spacing * 0.5, spacing) - spacing * 0.5;\n  }\n  // triangular lattice\n  if (spacing < 0.0) {\n    spacing = spacing * -1.0;\n    float cz = (2.0 * pos.y) / (sqrt(3.0) * spacing);\n    float cx = pos.x / spacing - 0.5 * cz;\n    float cy = -cx - cz;\n    float rx = floor(cx + 0.5);\n    float ry = floor(cy + 0.5);\n    float rz = floor(cz + 0.5);\n    float dx = abs(rx - cx);\n    float dy = abs(ry - cy);\n    float dz = abs(rz - cz);\n    if (dx > dy && dx > dz) {\n      rx = -ry - rz;\n    } else if (dy > dz) {\n      ry = -rx - rz;\n    } else {\n      rz = -rx - ry;\n    }\n    vec2 center = vec2(spacing * (rx + 0.5 * rz), (sqrt(3.0) * spacing * 0.5) * rz);\n    pos = pos - center;\n  }\n  // rad is a value in pixels from the edge of the symbol where negative is\n  // inside the shape\n  float rad = length(pos.xy) - radiusVar;\n  // never allow points outside of the main radius\n  if (rad > 0.0) {\n    return 0.0;\n  }\n  // apply clockwise rotation\n  if (rotationVar != 0.0) {\n    float cosr = cos(rotationVar), sinr = sin(rotationVar);\n    pos = vec2(pos.x * cosr + pos.y * sinr, -pos.x * sinr + pos.y * cosr);\n  }\n\n  int symbol = int(floor(symbolVar / 64.0));\n  bool isimage = bool(mod(floor(symbolVar / 8.0), 2.0));\n  vec4 fillColor, strokeColor;\n  float endStep;\n\n  float ratio = symbolValueVar;\n  // When ratio is 0, it usually gets changed to 1; some shapes could have\n  // better defaults\n  /* Symbol shapes */\n  if (symbol == symbolTriangle) {\n    rad = distanceToIsoscelesTriangle(pos, ratio);\n  } else if (symbol == symbolRectangle) {\n    rad = distanceToRectangle(pos, ratio);\n  } else if (symbol == symbolOval) {\n    rad = distanceToOval(pos, ratio);\n  } else if (symbol == symbolDrop) {\n    rad = distanceToDrop(pos, ratio);\n  } else if (symbol == symbolArrow) {\n    rad = distanceToArrow(pos, ratio);\n  } else if (symbol >= symbolCrossBase && symbol <= symbolCrossBase + symbolCrossMax - 2) {\n    rad = distanceToRectangle(rotationalSymmetry(pos, symbol - symbolCrossBase + 2), ratio);\n  } else if (symbol >= symbolFlowerBase && symbol <= symbolFlowerBase + symbolFlowerMax - 2) {\n    rad = distanceToEllipse(rotationalSymmetry(pos, symbol - symbolFlowerBase + 2), ratio);\n  } else if (symbol >= symbolStarBase && symbol <= symbolStarBase + symbolStarMax - 2) {\n    rad = distanceToIsoscelesTriangle(rotationalSymmetry(pos, symbol - symbolStarBase + 2), ratio);\n  } else if (symbol >= symbolJackBase && symbol <= symbolJackBase + symbolJackMax - 2) {\n    rad = distanceToOval(rotationalSymmetry(pos, symbol - symbolJackBase + 2), ratio);\n  } else if (symbol >= symbolDropBase && symbol <= symbolDropBase + symbolDropMax - 2) {\n    rad = distanceToDrop(rotationalSymmetry(pos, symbol - symbolDropBase + 2), ratio);\n  } else if (symbol >= symbolArrowBase && symbol <= symbolArrowBase + symbolArrowMax - 2) {\n    rad = distanceToArrow(rotationalSymmetry(pos, symbol - symbolArrowBase + 2), ratio);\n  } else { // default - circle or ellipse; a value of 0 or 1 is a circle\n    if (ratio != 0.0 && ratio != 1.0) {\n      rad = distanceToEllipse(pos, ratio);\n    }\n  }\n\n  if (rad >= 0.0) {\n    return 0.0;\n  }\n  // If there is no stroke, the fill region should transition to nothing\n  if (strokeColorVar.a == 0.0 || strokeWidthVar <= 0.0) {\n    strokeColor = vec4(fillColorVar.rgb, 0.0);\n    endStep = 0.0;\n  } else {\n    strokeColor = strokeColorVar;\n    endStep = -strokeWidthVar;\n  }\n  // Likewise, if there is no fill, the stroke should transition to nothing\n  if (fillColorVar.a == 0.0) {\n    fillColor = vec4(strokeColorVar.rgb, 0.0);\n  } else {\n    fillColor = fillColorVar;\n  }\n  float alpha = 1.0;\n  if (rad <= endStep) {\n    float step = smoothstep(endStep - antialiasDist, endStep, rad);\n    vec4 color = mix(fillColor, strokeColor, step);\n    float step2 = smoothstep(-antialiasDist, 0.0, rad);\n    gl_FragColor = mix(color, vec4(color.rgb, 0.0), step2);\n    if (color.a > 0.0)\n      alpha = gl_FragColor.a / color.a;\n  } else {\n    float step = smoothstep(-antialiasDist, 0.0, rad);\n    gl_FragColor = mix(strokeColor, vec4(strokeColor.rgb, 0.0), step);\n    if (strokeColor.a > 0.0)\n      alpha = gl_FragColor.a / strokeColor.a;\n  }\n  return alpha;\n}\n\n\n// the square/triangle shader defines unitVar\n\nvoid main(void) {\n  // No stroke or fill implies nothing to draw\n  if (fillColorVar.a == 0.0 && strokeColorVar.a == 0.0)\n    discard;\n  // for sprites, convert the position to [-radius,radius],[-radius,radius]\n  vec2 pos = (gl_PointCoord.xy - 0.5) * 2.0 * radiusVar;\n  if (markerFeatureFragment(vec3(pos, 0.0)) == 0.0)\n    discard;\n}\n"

/***/ }),

/***/ 7665:
/***/ (function(module) {

module.exports = "/* markerFeature sprite vertex shader */\n\n/* markerFeature common vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nattribute vec3 pos;\nattribute float radius;\nattribute vec3 fillColor;\nattribute float fillOpacity;\nattribute vec3 strokeColor;\nattribute float strokeOpacity;\nattribute float strokeWidth;\nattribute float symbol;  /* contains some bit fields */\nattribute float symbolValue;\nattribute float rotation;\nuniform float zoom;\nuniform float rotationUniform;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n// non-sprite has other definitions.\nvarying float radiusVar;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float strokeWidthVar;\nvarying float symbolVar;  /* contains some bit fields */\nvarying float symbolValueVar;\nvarying float rotationVar;\n\nfloat markerFeaturePrep(void)\n{\n  // No stroke or fill implies nothing to draw\n  if (radius <= 0.0 || (strokeOpacity <= 0.0 && fillOpacity <= 0.0)) {\n    gl_Position = vec4(2.0, 2.0, 0.0, 1.0);\n    return 0.0;\n  }\n  radiusVar = radius;\n  strokeWidthVar = strokeWidth;\n  int scaleMode = int(mod(symbol, 4.0));\n  float strokeOffset = mod(floor(symbol / 16.0), 4.0) - 1.0;\n  radiusVar += (strokeOffset + 1.0) / 2.0 * strokeWidthVar;\n  if (scaleMode == 1) { // fill\n    radiusVar = (radiusVar - strokeWidthVar) * exp2(zoom) + strokeWidthVar;\n  } else if (scaleMode == 2) { // stroke\n    radiusVar += strokeWidthVar * (exp2(zoom) - 1.0);\n    strokeWidthVar *= exp2(zoom);\n  } else if (scaleMode == 3) { // all\n    radiusVar *= exp2(zoom);\n    strokeWidthVar *= exp2(zoom);\n  }\n  fillColorVar = vec4(fillColor, fillOpacity);\n  strokeColorVar = vec4(strokeColor, strokeOpacity);\n  symbolVar = symbol;\n  symbolValueVar = symbolValue;\n  rotationVar = rotation;\n  if (bool(mod(floor(symbolVar / 4.0), 2.0))) {\n    rotationVar += rotationUniform;\n  }\n  return radiusVar;\n}\n\n\nvoid main(void)\n{\n  radiusVar = markerFeaturePrep();\n  if (radiusVar == 0.0) {\n    return;\n  }\n  // for sprite\n  gl_Position = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;\n  gl_PointSize = 2.0 * radiusVar;\n}\n"

/***/ }),

/***/ 428:
/***/ (function(module) {

module.exports = "/* contourFeature fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nuniform vec4 minColor;\nuniform vec4 maxColor;\nuniform float steps;\nuniform bool stepped;\nuniform sampler2D sampler2d;\nvarying float valueVar;\nvarying float opacityVar;\n\nvoid main () {\n  vec4 clr;\n  if (valueVar < 0.0) {\n    clr = minColor;\n  } else if (valueVar > steps) {\n    clr = maxColor;\n  } else {\n    float step;\n    if (stepped) {\n      step = floor(valueVar) + 0.5;\n      if (step > steps) {\n        step = steps - 0.5;\n      }\n    } else {\n      step = valueVar + 0.5;\n    }\n    // our texture is padded on either end by a repeated value to ensure\n    // we interpolate smoothly at the ends.\n    clr = texture2D(sampler2d, vec2((step + 1.0) / (steps + 2.0), 0.0));\n  }\n  gl_FragColor = vec4(clr.rgb, clr.a * opacityVar);\n}\n"

/***/ }),

/***/ 4993:
/***/ (function(module) {

module.exports = "/* contourFeature vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nattribute vec3 pos;\nattribute float value;\nattribute float opacity;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying float valueVar;\nvarying float opacityVar;\n\nvoid main(void)\n{\n  /* Don't use z values */\n  vec4 scrPos = projectionMatrix * modelViewMatrix * vec4(pos.xy, 0, 1);\n  if (scrPos.w != 0.0) {\n    scrPos = scrPos / scrPos.w;\n  }\n  valueVar = value;\n  opacityVar = opacity;\n  gl_Position = scrPos;\n}\n"

/***/ }),

/***/ 3925:
/***/ (function(module) {

module.exports = "/* pixelmapFeature fragment shader */\n\nvarying highp vec2 iTextureCoord;\nuniform sampler2D sampler2d;\nuniform sampler2D lutSampler;\nuniform int lutWidth;\nuniform int lutHeight;\nuniform mediump float opacity;\nuniform highp vec2 crop;\n\nvoid main(void) {\n  if ((crop.s < 1.0 && iTextureCoord.s > crop.s) || (crop.t < 1.0 && 1.0 - iTextureCoord.t > crop.t)) {\n    discard;\n  }\n  // to add anti-aliasing, we would need to know the current pixel size\n  // (probably computed in the vertex shader) and then sample the base image at\n  // multiple points, then average the output color.\n  highp vec4 lutValue = texture2D(sampler2d, iTextureCoord);\n  highp vec2 lutCoord;\n  lutCoord.s = (\n    mod(\n      // add 0.5 to handle float imprecision\n      floor(lutValue.r * 255.0 + 0.5) +\n      floor(lutValue.g * 255.0 + 0.5) * 256.0,\n      float(lutWidth)\n    // center in pixel\n    ) + 0.5) / float(lutWidth);\n  // Our image is top-down, so invert the coordinate\n  lutCoord.t = 1.0 - (\n    floor(\n      (\n        // add 0.5 to handle float imprecision\n        floor(lutValue.r * 255.0 + 0.5) +\n        floor(lutValue.g * 255.0 + 0.5) * 256.0 +\n        floor(lutValue.b * 255.0 + 0.5) * 256.0 * 256.0\n        // We may want an option to use the alpha channel to allow more indices\n      ) / float(lutWidth)\n    // center in pixel\n    ) + 0.5) / float(lutHeight);\n  if (lutCoord.t < 0.0) {\n    discard;\n  }\n  mediump vec4 color = texture2D(lutSampler, lutCoord);\n\n  color.a *= opacity;\n  gl_FragColor = color;\n}\n"

/***/ }),

/***/ 4317:
/***/ (function(module) {

module.exports = "/* pointFeature square/triangle fragment shader */\n\n/* pointFeature common fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float radiusVar;\nvarying float strokeWidthVar;\n\nvoid pointFeatureFragment(float rad) {\n  vec4 strokeColor, fillColor;\n  float endStep;\n  // No stroke or fill implies nothing to draw\n  if (rad > 1.0)\n    discard;\n  // If there is no stroke, the fill region should transition to nothing\n  if (strokeColorVar.a == 0.0) {\n    strokeColor = vec4(fillColorVar.rgb, 0.0);\n    endStep = 1.0;\n  } else {\n    strokeColor = strokeColorVar;\n    endStep = radiusVar / (radiusVar + strokeWidthVar);\n  }\n  // Likewise, if there is no fill, the stroke should transition to nothing\n  if (fillColorVar.a == 0.0)\n    fillColor = vec4(strokeColor.rgb, 0.0);\n  else\n    fillColor = fillColorVar;\n  // Distance to antialias over.  First number is in pixels\n  float antialiasDist = 1.5 / (radiusVar + strokeWidthVar);\n  if (rad < endStep) {\n    float step = smoothstep(max(0.0, endStep - antialiasDist), endStep, rad);\n    vec4 color = mix(fillColor, strokeColor, step);\n    float step2 = smoothstep(max(0.0, 1.0 - antialiasDist), 1.0, rad);\n    gl_FragColor = mix(color, vec4(color.rgb, 0.0), step2);\n  } else {\n    float step = smoothstep(max(0.0, 1.0 - antialiasDist), 1.0, rad);\n    gl_FragColor = mix(strokeColor, vec4(strokeColor.rgb, 0.0), step);\n  }\n}\n\n\nvarying vec3 unitVar;  // distinct for square/triangle\n\nvoid main () {\n  if (fillColorVar.a == 0.0 && strokeColorVar.a == 0.0)\n    discard;\n  float rad = length(unitVar.xy); // distinct for square/triangle\n  pointFeatureFragment(rad);\n}\n"

/***/ }),

/***/ 8208:
/***/ (function(module) {

module.exports = "/* pointFeature square/triangle vertex shader */\n\n/* pointFeature common vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nattribute vec3 pos;\nattribute float radius;\nattribute vec3 fillColor;\nattribute vec3 strokeColor;\nattribute float fillOpacity;\nattribute float strokeWidth;\nattribute float strokeOpacity;\nattribute float fill;\nattribute float stroke;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float radiusVar;\nvarying float strokeWidthVar;\n\nfloat pointFeaturePrep() {\n  strokeWidthVar = strokeWidth;\n  fillColorVar = vec4(fillColor, fillOpacity);\n  strokeColorVar = vec4(strokeColor, strokeOpacity);\n  // No stroke or fill implies nothing to draw\n  if (stroke < 1.0 || strokeWidth <= 0.0 || strokeOpacity <= 0.0) {\n    strokeColorVar.a = 0.0;\n    strokeWidthVar = 0.0;\n  }\n  if (fill < 1.0 || radius <= 0.0 || fillOpacity <= 0.0)\n    fillColorVar.a = 0.0;\n  /* If the point has no visible pixels, skip doing computations on it. */\n  if (fillColorVar.a == 0.0 && strokeColorVar.a == 0.0) {\n    gl_Position = vec4(2, 2, 0, 1);\n    return 0.0;\n  }\n  return radius;\n}\n\n\nuniform float pixelWidth; // for non-sprite\nuniform float aspect; // for non-sprite\nattribute vec2 unit; // for non-sprite\nvarying vec3 unitVar; // for non-sprite\n\nvoid main(void)\n{\n  radiusVar = pointFeaturePrep();\n  if (radiusVar == 0.0) {\n    return;\n  }\n  // for non-sprite\n  unitVar = vec3(unit, 1.0);\n  vec4 p = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;\n  if (p.w != 0.0) {\n    p = p / p.w;\n  }\n  p += (radius + strokeWidthVar) *\n       vec4(unit.x * pixelWidth, unit.y * pixelWidth * aspect, 0.0, 1.0);\n  gl_Position = vec4(p.xyz, 1.0);\n}\n"

/***/ }),

/***/ 2682:
/***/ (function(module) {

module.exports = "/* pointFeature sprite fragment shader */\n\n/* pointFeature common fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float radiusVar;\nvarying float strokeWidthVar;\n\nvoid pointFeatureFragment(float rad) {\n  vec4 strokeColor, fillColor;\n  float endStep;\n  // No stroke or fill implies nothing to draw\n  if (rad > 1.0)\n    discard;\n  // If there is no stroke, the fill region should transition to nothing\n  if (strokeColorVar.a == 0.0) {\n    strokeColor = vec4(fillColorVar.rgb, 0.0);\n    endStep = 1.0;\n  } else {\n    strokeColor = strokeColorVar;\n    endStep = radiusVar / (radiusVar + strokeWidthVar);\n  }\n  // Likewise, if there is no fill, the stroke should transition to nothing\n  if (fillColorVar.a == 0.0)\n    fillColor = vec4(strokeColor.rgb, 0.0);\n  else\n    fillColor = fillColorVar;\n  // Distance to antialias over.  First number is in pixels\n  float antialiasDist = 1.5 / (radiusVar + strokeWidthVar);\n  if (rad < endStep) {\n    float step = smoothstep(max(0.0, endStep - antialiasDist), endStep, rad);\n    vec4 color = mix(fillColor, strokeColor, step);\n    float step2 = smoothstep(max(0.0, 1.0 - antialiasDist), 1.0, rad);\n    gl_FragColor = mix(color, vec4(color.rgb, 0.0), step2);\n  } else {\n    float step = smoothstep(max(0.0, 1.0 - antialiasDist), 1.0, rad);\n    gl_FragColor = mix(strokeColor, vec4(strokeColor.rgb, 0.0), step);\n  }\n}\n\n\n// the square/triangle shader defines unitVar\n\nvoid main () {\n  // No stroke or fill implies nothing to draw\n  if (fillColorVar.a == 0.0 && strokeColorVar.a == 0.0)\n    discard;\n  float rad = 2.0 * length(gl_PointCoord - vec2(0.5));  // distinct for sprite\n  pointFeatureFragment(rad);\n}\n"

/***/ }),

/***/ 6979:
/***/ (function(module) {

module.exports = "/* pointFeature sprite vertex shader */\n\n/* pointFeature common vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nattribute vec3 pos;\nattribute float radius;\nattribute vec3 fillColor;\nattribute vec3 strokeColor;\nattribute float fillOpacity;\nattribute float strokeWidth;\nattribute float strokeOpacity;\nattribute float fill;\nattribute float stroke;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float radiusVar;\nvarying float strokeWidthVar;\n\nfloat pointFeaturePrep() {\n  strokeWidthVar = strokeWidth;\n  fillColorVar = vec4(fillColor, fillOpacity);\n  strokeColorVar = vec4(strokeColor, strokeOpacity);\n  // No stroke or fill implies nothing to draw\n  if (stroke < 1.0 || strokeWidth <= 0.0 || strokeOpacity <= 0.0) {\n    strokeColorVar.a = 0.0;\n    strokeWidthVar = 0.0;\n  }\n  if (fill < 1.0 || radius <= 0.0 || fillOpacity <= 0.0)\n    fillColorVar.a = 0.0;\n  /* If the point has no visible pixels, skip doing computations on it. */\n  if (fillColorVar.a == 0.0 && strokeColorVar.a == 0.0) {\n    gl_Position = vec4(2, 2, 0, 1);\n    return 0.0;\n  }\n  return radius;\n}\n\n\nvoid main(void)\n{\n  radiusVar = pointFeaturePrep();\n  if (radiusVar == 0.0) {\n    return;\n  }\n  // for sprite\n  gl_Position = (projectionMatrix * modelViewMatrix * vec4(pos, 1.0)).xyzw;\n  gl_PointSize = 2.0 * (radius + strokeWidthVar);\n}\n"

/***/ }),

/***/ 4547:
/***/ (function(module) {

module.exports = "/* polygonFeature fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nvarying vec4 fillColorVar;\n\nvoid main () {\n  gl_FragColor = fillColorVar;\n}\n"

/***/ }),

/***/ 9506:
/***/ (function(module) {

module.exports = "/* polygonFeature vertex shader */\n\nattribute vec3 pos;\nattribute vec3 fillColor;\nattribute float fillOpacity;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying vec4 fillColorVar;\n\nvoid main(void)\n{\n  vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1.0);\n  if (clipPos.w != 0.0) {\n    clipPos = clipPos/clipPos.w;\n  }\n  fillColorVar = vec4(fillColor, fillOpacity);\n  gl_Position = clipPos;\n}\n"

/***/ }),

/***/ 6207:
/***/ (function(module) {

module.exports = "/* polygonFeature fragment shader */\n\n/* markerFeature common fragment shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nvarying float radiusVar;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float strokeWidthVar;\nvarying float symbolVar;  /* contains some bit fields */\nvarying float symbolValueVar;\nvarying float rotationVar;\n// the square/triangle shader defines unitVar\nconst int symbolEllipse = 0;\nconst int symbolFlowerBase = 1;\nconst int symbolFlowerMax = 16;\nconst int symbolTriangle = 16;\nconst int symbolStarBase = 17;\nconst int symbolStarMax = 16;\nconst int symbolRectangle = 32;\nconst int symbolCrossBase = 33;\nconst int symbolCrossMax = 16;\nconst int symbolOval = 48;\nconst int symbolJackBase = 49;\nconst int symbolJackMax = 16;\nconst int symbolDrop = 64;\nconst int symbolDropBase = 65;\nconst int symbolDropMax = 16;\nconst int symbolArrow = 80;\nconst int symbolArrowBase = 81;\nconst int symbolArrowMax = 16;\n// Distance to antialias in pixels\nconst float antialiasDist = 1.5;\n\n/* Compute the distance from a point to an arrow defined by the radiusVar and a\n * packed value containing\n *   headWidth: ratio to radius (0, 1]\n *   headLength: ratio to diameter (0, 1]\n *   stemWidth: ratio to headWidth [0, 1]\n *   sweep: boolean\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float packed: the packed value.\n * Exit:  float dist: the distance to the drop in pixels.  Negative is inside.\n */\nfloat distanceToArrow(vec2 pos, float value) {\n  bool sweep = value < 0.0;\n  value = abs(value);\n  float pack0 = (mod(value, 252.0) - 1.0) / 250.0;\n  value = floor(value / 252.0);\n  float pack1 = (mod(value, 252.0) - 1.0) / 250.0;\n  value = floor(value / 252.0);\n  float pack2 = (mod(value, 252.0) - 1.0) / 250.0;\n\n  float headWidth = (pack0 > 0.0 ? pack0 : 2.0 / 3.0);\n  float headEnd = 1.0 - 2.0 * (pack1 > 0.0 ? pack1 : 1.0 / 2.0);\n  float stemWidth = headWidth * (pack2 >= 0.0 ? pack2 : 1.0 / 3.0);\n  if (length(vec2(headWidth, headEnd)) > 1.0) {\n    vec2 scaledHead = normalize(vec2(headWidth, headEnd));\n    headWidth = scaledHead.x;\n    headEnd = scaledHead.y;\n  }\n  float stemEnd = -cos(asin(stemWidth));\n\n  headWidth *= radiusVar;\n  headEnd *= radiusVar;\n  stemWidth *= radiusVar;\n  stemEnd *= radiusVar;\n  pos.y = abs(pos.y);\n  float stemDist = pos.y - stemWidth;\n  float stemEndDist = stemEnd - pos.x;\n  float B = (radiusVar - headEnd) / headWidth;\n  float headDist = (pos.x + B * pos.y - radiusVar) / sqrt(1.0 + B * B);\n  float headEndDist;\n  if (sweep) {\n    B = (radiusVar - headEnd) / 3.0 / headWidth;\n    headEndDist = -(pos.x + B * pos.y - (radiusVar + headEnd * 2.0) / 3.0) / sqrt(1.0 + B * B);\n  } else {\n    headEndDist = headEnd - pos.x;\n  }\n  headEndDist = min(headEndDist, stemDist);\n  return max(max(headDist, headEndDist), stemEndDist);\n}\n\n/* Compute the distance from a point to a drop defined by the radiusVar (the\n * semimajor axis) and ratio (between the minor and major radii).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the drop in pixels.  Negative is inside.\n */\nfloat distanceToDrop(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0 || ratio >= 1.0) {\n    ratio = 1.0;\n  }\n  float r = radiusVar * ratio;\n  float cx = radiusVar - r;\n  float rad = distance(pos.xy, vec2(cx, 0.0)) - r;\n  if (ratio < 0.5) {\n    float x = radiusVar - r - r * r / cx;\n    float y = sqrt(r * r - (cx - x) * (cx - x));\n    float Bt = (cx - x) / y;\n    if ((pos.x + Bt * abs(pos.y) - cx) / sqrt(1.0 + Bt * Bt) < 0.0) {\n      float B = -x / y;\n      return -(pos.x + B * abs(pos.y)) / sqrt(1.0 + B * B);\n    }\n  }\n  return rad;\n}\n\n/* Compute the distance from a point to the ellipse defined by the radiusVar\n * (the semimajor axis) and ratio (between the minor and major axes).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the ellipse in pixels.  Negative is\n *   inside.\n */\nfloat distanceToEllipse(vec2 pos, float ratio) {\n  // a and b are the semi-major and semi-minor axes\n  // ratio is the between the minor and major axes.  If > 1, swap these and\n  // rotate 90 degrees.\n  if (ratio == 0.0) {\n    ratio = 1.0;\n  }\n  float a = radiusVar, b = abs(radiusVar * ratio);\n  if (b > a) {\n    pos = vec2(pos.y, -pos.x);\n    b = abs(radiusVar / ratio);\n  }\n  float a2 = a * a, b2 = b * b;\n  // compute the distance to the ellipse.  See this discussion:\n  // https://stackoverflow.com/questions/22959698\n  float f = sqrt(a2 - b2),\n        // this value will be positive if outside and negative if inside.  If\n        // we used it directly, the stroke would be too thick along the long\n        // edges of the ellipse\n        d = (distance(pos, vec2(f, 0.0)) + distance(pos, vec2(-f, 0.0))) * 0.5 - a;\n  // if we are outside of the ellipse, accuracy is not important, so return\n  // early.\n  if (d >= 0.0) {\n    return d;\n  }\n  // work in one quadrant\n  pos = abs(pos);\n  // t (the angle from center) could start as `atan(pos.y, pos.x)`, but this\n  // results in a slower solution near narrow ends\n  float t = 0.7;\n  float cost = cos(t), sint = sin(t), x = a * cost, y = b * sint;\n  vec2 lastxy;\n  for (int iter = 0; iter < 10; iter += 1) {\n    lastxy = vec2(x, y);\n    float ex = (a2 - b2) * pow(cost, 3.0) / a,\n          ey = (b2 - a2) * pow(sint, 3.0) / b;\n    vec2 r = vec2(x - ex, y - ey),\n         q = vec2(pos.x - ex, pos.y - ey);\n    float lenr = length(r);\n    t += lenr * asin((r.x * q.y - r.y * q.x) / lenr / length(q)) / sqrt(a2 + b2 - x * x - y * y);\n    t = clamp(t, 0.0, acos(0.0));\n    cost = cos(t);\n    sint = sin(t);\n    x = a * cost;\n    y = b * sint;\n    if (distance(lastxy, vec2(x, y)) < 0.05) {\n      break;\n    }\n  }\n  return sign(d) * distance(pos, vec2(x, y));\n}\n\n/* Compute the distance from a point to an isosceles triangle.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: length of the base compared to the other sides.\n * Exit:  float dist: the distance to the rectangle in pixels.  Negative is\n *   inside.\n */\nfloat distanceToIsoscelesTriangle(vec2 pos, float ratio) {\n  ratio = clamp(abs(ratio), 0.0, 2.0);\n  if (ratio == 0.0 || ratio == 2.0) {\n    ratio = 1.0;\n  }\n  float s1, s2, x0, x1, y1;\n  if (ratio < sqrt(2.0)) {\n    s1 = radiusVar * sqrt(4.0 - ratio * ratio); // length of equal sides\n    s2 = s1 * ratio;\n    y1 = s2 / 2.0;\n    x0 = radiusVar;\n    x1 = x0 - sqrt(s1 * s1 - y1 * y1);\n  } else {\n    s2 = radiusVar * 2.0;\n    s1 = s2 / ratio;\n    y1 = s2 / 2.0;\n    x0 = sqrt(s1 * s1 - y1 * y1);\n    x1 = 0.0;\n  }\n  float B = (x0 - x1) / y1;\n  return max(x1 - pos.x, (pos.x + B * abs(pos.y) - x0) / sqrt(1.0 + B * B));\n}\n\n/* Compute the distance from a point to an oval defined by the radiusVar (the\n * semimajor axis) and ratio (between the minor and major axes).  Here an oval\n * is defined as two semicircles connected by straight line segments.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the oval in pixels.  Negative is inside.\n */\nfloat distanceToOval(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0 || ratio >= 1.0) {\n    ratio = 1.0;\n  }\n  float minor = radiusVar * ratio;\n  float center = radiusVar - minor;\n  pos = abs(pos);\n  if (pos.x <= center) {\n    return pos.y - minor;\n  }\n  return distance(pos, vec2(center, 0.0)) - minor;\n}\n\n/* Compute the distance from a point to a rectangle defined by the radiusVar\n * (the semidiagonal) and ratio (between the minor and major axes).\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        float ratio: ratio of minor / major axes.\n * Exit:  float dist: the distance to the rectangle in pixels.  Negative is\n *   inside.\n */\nfloat distanceToRectangle(vec2 pos, float ratio) {\n  ratio = abs(ratio);\n  if (ratio == 0.0) {\n    ratio = 1.0;\n  }\n  vec2 wh = normalize(vec2(1.0, abs(ratio))) * radiusVar;\n  vec2 dist = abs(pos) - wh;\n  return max(dist.x, dist.y);\n}\n\n/* Based on a repetition value, return a position for rotational symmetry.\n *\n * Enter: vec2 pos: the point in pixel coordinates.\n *        int repetitions: number of repetitions on the cross.\n * Exit:  float dist: a point in the primary position.\n */\nvec2 rotationalSymmetry(vec2 pos, int repetitions) {\n  float pi = acos(-1.0);\n  float limit = pi / float(repetitions);\n  float ang = atan(pos.y, pos.x);\n  ang = mod(ang + pi * 2.0, limit * 2.0);\n  if (ang > limit) {\n    ang -= limit * 2.0;\n  }\n  return vec2(cos(ang), sin(ang)) * length(pos);\n}\n\nfloat markerFeatureFragment(vec3 posAndSpacing) {\n  vec2 pos = posAndSpacing.xy;\n  float spacing = posAndSpacing.z;\n  // square lattice\n  if (spacing > 0.0) {\n    pos.x = mod(pos.x + spacing * 0.5, spacing) - spacing * 0.5;\n    pos.y = mod(pos.y + spacing * 0.5, spacing) - spacing * 0.5;\n  }\n  // triangular lattice\n  if (spacing < 0.0) {\n    spacing = spacing * -1.0;\n    float cz = (2.0 * pos.y) / (sqrt(3.0) * spacing);\n    float cx = pos.x / spacing - 0.5 * cz;\n    float cy = -cx - cz;\n    float rx = floor(cx + 0.5);\n    float ry = floor(cy + 0.5);\n    float rz = floor(cz + 0.5);\n    float dx = abs(rx - cx);\n    float dy = abs(ry - cy);\n    float dz = abs(rz - cz);\n    if (dx > dy && dx > dz) {\n      rx = -ry - rz;\n    } else if (dy > dz) {\n      ry = -rx - rz;\n    } else {\n      rz = -rx - ry;\n    }\n    vec2 center = vec2(spacing * (rx + 0.5 * rz), (sqrt(3.0) * spacing * 0.5) * rz);\n    pos = pos - center;\n  }\n  // rad is a value in pixels from the edge of the symbol where negative is\n  // inside the shape\n  float rad = length(pos.xy) - radiusVar;\n  // never allow points outside of the main radius\n  if (rad > 0.0) {\n    return 0.0;\n  }\n  // apply clockwise rotation\n  if (rotationVar != 0.0) {\n    float cosr = cos(rotationVar), sinr = sin(rotationVar);\n    pos = vec2(pos.x * cosr + pos.y * sinr, -pos.x * sinr + pos.y * cosr);\n  }\n\n  int symbol = int(floor(symbolVar / 64.0));\n  bool isimage = bool(mod(floor(symbolVar / 8.0), 2.0));\n  vec4 fillColor, strokeColor;\n  float endStep;\n\n  float ratio = symbolValueVar;\n  // When ratio is 0, it usually gets changed to 1; some shapes could have\n  // better defaults\n  /* Symbol shapes */\n  if (symbol == symbolTriangle) {\n    rad = distanceToIsoscelesTriangle(pos, ratio);\n  } else if (symbol == symbolRectangle) {\n    rad = distanceToRectangle(pos, ratio);\n  } else if (symbol == symbolOval) {\n    rad = distanceToOval(pos, ratio);\n  } else if (symbol == symbolDrop) {\n    rad = distanceToDrop(pos, ratio);\n  } else if (symbol == symbolArrow) {\n    rad = distanceToArrow(pos, ratio);\n  } else if (symbol >= symbolCrossBase && symbol <= symbolCrossBase + symbolCrossMax - 2) {\n    rad = distanceToRectangle(rotationalSymmetry(pos, symbol - symbolCrossBase + 2), ratio);\n  } else if (symbol >= symbolFlowerBase && symbol <= symbolFlowerBase + symbolFlowerMax - 2) {\n    rad = distanceToEllipse(rotationalSymmetry(pos, symbol - symbolFlowerBase + 2), ratio);\n  } else if (symbol >= symbolStarBase && symbol <= symbolStarBase + symbolStarMax - 2) {\n    rad = distanceToIsoscelesTriangle(rotationalSymmetry(pos, symbol - symbolStarBase + 2), ratio);\n  } else if (symbol >= symbolJackBase && symbol <= symbolJackBase + symbolJackMax - 2) {\n    rad = distanceToOval(rotationalSymmetry(pos, symbol - symbolJackBase + 2), ratio);\n  } else if (symbol >= symbolDropBase && symbol <= symbolDropBase + symbolDropMax - 2) {\n    rad = distanceToDrop(rotationalSymmetry(pos, symbol - symbolDropBase + 2), ratio);\n  } else if (symbol >= symbolArrowBase && symbol <= symbolArrowBase + symbolArrowMax - 2) {\n    rad = distanceToArrow(rotationalSymmetry(pos, symbol - symbolArrowBase + 2), ratio);\n  } else { // default - circle or ellipse; a value of 0 or 1 is a circle\n    if (ratio != 0.0 && ratio != 1.0) {\n      rad = distanceToEllipse(pos, ratio);\n    }\n  }\n\n  if (rad >= 0.0) {\n    return 0.0;\n  }\n  // If there is no stroke, the fill region should transition to nothing\n  if (strokeColorVar.a == 0.0 || strokeWidthVar <= 0.0) {\n    strokeColor = vec4(fillColorVar.rgb, 0.0);\n    endStep = 0.0;\n  } else {\n    strokeColor = strokeColorVar;\n    endStep = -strokeWidthVar;\n  }\n  // Likewise, if there is no fill, the stroke should transition to nothing\n  if (fillColorVar.a == 0.0) {\n    fillColor = vec4(strokeColorVar.rgb, 0.0);\n  } else {\n    fillColor = fillColorVar;\n  }\n  float alpha = 1.0;\n  if (rad <= endStep) {\n    float step = smoothstep(endStep - antialiasDist, endStep, rad);\n    vec4 color = mix(fillColor, strokeColor, step);\n    float step2 = smoothstep(-antialiasDist, 0.0, rad);\n    gl_FragColor = mix(color, vec4(color.rgb, 0.0), step2);\n    if (color.a > 0.0)\n      alpha = gl_FragColor.a / color.a;\n  } else {\n    float step = smoothstep(-antialiasDist, 0.0, rad);\n    gl_FragColor = mix(strokeColor, vec4(strokeColor.rgb, 0.0), step);\n    if (strokeColor.a > 0.0)\n      alpha = gl_FragColor.a / strokeColor.a;\n  }\n  return alpha;\n}\n\n\nvarying vec4 polyFillColorVar;\nvarying vec3 patternPosVar;\n\nvoid main () {\n\n  float used = 0.0;\n  if (fillColorVar.a != 0.0 || strokeColorVar.a != 0.0)\n    used = markerFeatureFragment(patternPosVar);\n  if (used != 1.0)\n    gl_FragColor = polyFillColorVar * (1.0 - used) + gl_FragColor * used;\n}\n"

/***/ }),

/***/ 1030:
/***/ (function(module) {

module.exports = "/* polygonPatternFeature vertex shader */\n\n#ifdef GL_ES\n  precision highp float;\n#endif\nuniform float pixelWidth;\nuniform float aspect;\nuniform float zoom;\nuniform float rotationUniform;\nattribute vec3 pos;\nattribute vec3 fillColor;\nattribute float fillOpacity;\nattribute vec4 patternFillColor;\nattribute vec4 patternStrokeColor;\n/* Symbol props are strokeWidth, radius, symbol + flags, symbolValue */\nattribute vec4 patternSymbolProps;\n/* Position props are rotation, spacing, origin x, origin y */\nattribute vec4 patternPositionProps;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying vec4 polyFillColorVar;\nvarying float radiusVar;\nvarying vec4 fillColorVar;\nvarying vec4 strokeColorVar;\nvarying float strokeWidthVar;\nvarying float symbolVar;  /* contains some bit fields */\nvarying float symbolValueVar;\nvarying float rotationVar;\nvarying vec3 patternPosVar;\nconst float PI = 3.14159265358979323846264;\n\nvoid main(void)\n{\n  polyFillColorVar = vec4(fillColor, fillOpacity);\n  /* This is _nearly_ the same as what is in markerFeatureVS.glsl, but the\n   * attributes are named differently. */\n  radiusVar = patternSymbolProps.y;\n  strokeWidthVar = patternSymbolProps.x;\n  int scaleMode = int(mod(patternSymbolProps.z, 4.0));\n  float strokeOffset = mod(floor(patternSymbolProps.z / 16.0), 4.0) - 1.0;\n  if (radiusVar < 0.0 || (patternFillColor.a < 0.0 && patternStrokeColor.a < 0.0)) {\n    radiusVar = 0.0;\n  } else {\n    radiusVar += (strokeOffset + 1.0) / 2.0 * strokeWidthVar;\n    if (scaleMode == 1) { // fill\n      radiusVar = (radiusVar - strokeWidthVar) * exp2(zoom) + strokeWidthVar;\n    } else if (scaleMode == 2) { // stroke\n      radiusVar += strokeWidthVar * (exp2(zoom) - 1.0);\n      strokeWidthVar *= exp2(zoom);\n    } else if (scaleMode == 3) { // all\n      radiusVar *= exp2(zoom);\n      strokeWidthVar *= exp2(zoom);\n    }\n  }\n  fillColorVar = patternFillColor;\n  strokeColorVar = patternStrokeColor;\n  symbolVar = patternSymbolProps.z;\n  symbolValueVar = patternSymbolProps.w;\n  rotationVar = patternPositionProps.x;\n  if (bool(mod(floor(symbolVar / 4.0), 2.0))) {\n    rotationVar += rotationUniform;\n  }\n  /* This is distinct for polygonPattern */\n  vec4 clipPos = projectionMatrix * modelViewMatrix * vec4(pos.xyz, 1.0);\n  if (clipPos.w != 0.0) {\n    clipPos = clipPos / clipPos.w;\n  }\n  if (radiusVar > 0.0) {\n    vec4 origPos = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n    if (origPos.w != 0.0)\n      origPos = origPos / origPos.w;\n    patternPosVar.x = (clipPos.x - origPos.x) / pixelWidth;\n    patternPosVar.y = -(clipPos.y - origPos.y) / pixelWidth / aspect;\n    float spacing = patternPositionProps.y;\n    if (scaleMode == 0) {\n      patternPosVar.x -= patternPositionProps.z;\n      patternPosVar.y -= patternPositionProps.w;\n    } else {\n      spacing = spacing * exp2(zoom);\n      patternPosVar.x -= patternPositionProps.z * exp2(zoom);\n      patternPosVar.y -= patternPositionProps.w * exp2(zoom);\n    }\n    if (rotationUniform != 0.0) {\n      float cosR = cos(rotationUniform);\n      float sinR = sin(rotationUniform);\n      patternPosVar.xy = vec2(cosR * patternPosVar.x + sinR * patternPosVar.y, sinR * patternPosVar.x - cosR * patternPosVar.y);\n    }\n    patternPosVar.z = spacing;\n  }\n  gl_Position = clipPos;\n}\n"

/***/ }),

/***/ 8961:
/***/ (function(module) {

module.exports = "/* quadFeature Color fragment shader */\n\nvarying mediump vec3 iVertexColor;\nuniform mediump float opacity;\n\nvoid main(void) {\n  gl_FragColor = vec4(iVertexColor, opacity);\n}\n"

/***/ }),

/***/ 3260:
/***/ (function(module) {

module.exports = "/* quadFeature Color vertex shader */\n\nattribute vec3 vertexPosition;\nuniform float zOffset;\nuniform vec3 vertexColor;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying mediump vec3 iVertexColor;\n\nvoid main(void) {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);\n  gl_Position.z += zOffset;\n  iVertexColor = vertexColor;\n}\n"

/***/ }),

/***/ 8711:
/***/ (function(module) {

module.exports = "/* quadFeature Image fragment shader */\n\nvarying highp vec2 iTextureCoord;\nuniform sampler2D sampler2d;\nuniform mediump float opacity;\nuniform highp vec2 crop;\n\nvoid main(void) {\n  mediump vec4 color = texture2D(sampler2d, iTextureCoord);\n  if ((crop.s < 1.0 && iTextureCoord.s > crop.s) || (crop.t < 1.0 && 1.0 - iTextureCoord.t > crop.t)) {\n    discard;\n  }\n  color.w *= opacity;\n  gl_FragColor = color;\n}\n"

/***/ }),

/***/ 6238:
/***/ (function(module) {

module.exports = "/* quadFeature Image vertex shader */\n\nattribute vec3 vertexPosition;\nattribute vec2 textureCoord;\nuniform float zOffset;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nvarying highp vec2 iTextureCoord;\nuniform highp vec4 cropsource;\n\nvoid main(void) {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);\n  gl_Position.z += zOffset;\n  if (cropsource.p > cropsource.s && cropsource.q > cropsource.t && (cropsource.p < 1.0 || cropsource.s > 0.0 || cropsource.q < 1.0 || cropsource.t > 0.0)) {\n    iTextureCoord.s = textureCoord.s * (cropsource.p - cropsource.s) + cropsource.s;\n    iTextureCoord.t = textureCoord.t * (cropsource.q - cropsource.t) + cropsource.t;\n  } else {\n    iTextureCoord = textureCoord;\n  }\n}\n"

/***/ }),

/***/ 7605:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5292);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9893);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9383);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6884);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9088);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7997);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_main_styl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(632);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_main_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_main_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_main_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_main_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 1159:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5292);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9893);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9383);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6884);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9088);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7997);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_colorLegendWidget_styl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7046);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_colorLegendWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_colorLegendWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_colorLegendWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_colorLegendWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 615:
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5292);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9893);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9383);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6884);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9088);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7997);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_scaleWidget_styl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5290);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_scaleWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ __webpack_exports__["default"] = (_node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_scaleWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_scaleWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_stylus_loader_dist_cjs_js_scaleWidget_styl__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 5292:
/***/ (function(module) {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 9383:
/***/ (function(module) {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 9088:
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 6884:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 9893:
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 7997:
/***/ (function(module) {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 9463:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KICAgIDxwYXRoIGQ9Ik0wLDExbDExLDBsMCwtMTFsMiwwbDAsMTFsMTEsMGwwLDJsLTExLDBsMCwxMWwtMiwwbDAsLTExbC0xMSwweiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMCIvPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzIsIDE5Ljc3Nykgc2NhbGUoMC40KSByb3RhdGUoOTApIj4KICAgICAgICA8cGF0aCBkPSJNMjYuMzExLDIzLjIyNGMtMC44MTItMS40MTYtMi4wNzItMi4zNzUtMy40MDItMi43MzZjLTEuMDUxLTAuMjg3LTIuMTQxLTAuMTk5LTMuMDg0LDAuMzM0bC0yLjgwNS00LjkwNAogICAgICAgIGMxLjczNi0zLjQ2Myw1LjYzMy0xMS4yMjcsNi4zMzItMTIuNDUxQzI0LjI1OCwxLjg4NCwyMi42MzcsMCwyMi42MzcsMGwtNy4zNiwxMi44NzJMNy45MTksMGMwLDAtMS42MiwxLjg4NC0wLjcxNSwzLjQ2NgogICAgICAgIGMwLjcsMS4yMjUsNC41OTgsOC45ODgsNi4zMzIsMTIuNDUxbC0yLjgwNCw0LjkwNGMtMC45NDMtMC41MzMtMi4wMzUtMC42MjEtMy4wODQtMC4zMzRjLTEuMzMyLDAuMzYxLTIuNTkxLDEuMzItMy40MDMsMi43MzYKICAgICAgICBjLTEuNDU4LDIuNTQ3LTAuOTAxLDUuNjAyLDEuMjM5LDYuODI3YzAuOTQ5LDAuNTQ1LDIuMDQ4LDAuNjMyLDMuMTA3LDAuMzQ1YzEuMzI5LTAuMzYzLDIuNTkxLTEuMzIyLDMuNDAyLTIuNzM1CiAgICAgICAgYzAuMzU1LTAuNjI0LDAuNTktMS4yNzcsMC43MS0xLjkyNnYwLjAwMWMwLjAwMS0wLjAwNSwwLjAwMS0wLjAxLDAuMDA2LTAuMDE1YzAuMDA3LTAuMDU0LDAuMDE3LTAuMTA4LDAuMDIyLTAuMTY3CiAgICAgICAgYzAuNjAyLTQuMDM5LDEuNzQtNi4xMDIsMi41NDUtNy4xMDRjMC44MDcsMS4wMDIsMS45NDYsMy4wNjQsMi41NDcsNy4xMDRjMC4wMDYsMC4wNTksMC4wMTYsMC4xMTMsMC4wMjEsMC4xNjcKICAgICAgICBjMC4wMDQsMC4wMDUsMC4wMDQsMC4wMSwwLjAwNiwwLjAxNXYtMC4wMDFjMC4xMjEsMC42NDgsMC4zNTUsMS4zMDIsMC43MDksMS45MjZjMC44MTIsMS40MTMsMi4wNzQsMi4zNzIsMy40MDQsMi43MzUKICAgICAgICBjMS4wNTksMC4yODcsMi4xNTgsMC4yLDMuMTA5LTAuMzQ1QzI3LjIxMywyOC44MjUsMjcuNzY4LDI1Ljc3MSwyNi4zMTEsMjMuMjI0eiBNOS45MTEsMjYuNDY4CiAgICAgICAgYy0wLjQ2LDAuODAzLTEuMTg5LDEuNDA4LTEuOTQ4LDEuNjE1Yy0wLjMzOCwwLjA5Mi0wLjgzNCwwLjE0OC0xLjI4OS0wLjExM2MtMC45Ny0wLjU1NS0xLjEyOS0yLjE4Ni0wLjM0Ni0zLjU1NgogICAgICAgIGMwLjQ2OC0wLjgxMiwxLjE3Ny0xLjQwMywxLjk1LTEuNjE0YzAuMzM1LTAuMDkxLDAuODMxLTAuMTQ2LDEuMjg4LDAuMTEzQzEwLjUzNywyMy40NywxMC42OTUsMjUuMDk3LDkuOTExLDI2LjQ2OHogTTIzLjg4MSwyNy45NwogICAgICAgIGMtMC40NTUsMC4yNjItMC45NDksMC4yMDUtMS4yODcsMC4xMTNjLTAuNzYtMC4yMDctMS40ODgtMC44MTItMS45NDktMS42MTVjLTAuNzgzLTEuMzcxLTAuNjI1LTIuOTk4LDAuMzQ2LTMuNTU1CiAgICAgICAgYzAuNDU3LTAuMjYsMC45NTMtMC4yMDQsMS4yODktMC4xMTNjMC43NzEsMC4yMTEsMS40ODIsMC44MDIsMS45NDcsMS42MTRDMjUuMDEsMjUuNzg0LDI0Ljg1MiwyNy40MTUsMjMuODgxLDI3Ljk3eiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMCIvPgogICAgPC9nPgo8L3N2Zz4K";

/***/ }),

/***/ 5245:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KPHBhdGggZD0iTTAsMTFsMTEsMGwwLC0xMWwyLDBsMCwxMWwxMSwwbDAsMmwtMTEsMGwwLDExbC0yLDBsMCwtMTFsLTExLDB6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+CjxwYXRoIGQ9Ik0yNCwyN2w4LDBsMCwybC04LDB6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+Cjwvc3ZnPgo=";

/***/ }),

/***/ 8546:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KPHBhdGggZD0iTTAsMTFsMTEsMGwwLC0xMWwyLDBsMCwxMWwxMSwwbDAsMmwtMTEsMGwwLDExbC0yLDBsMCwtMTFsLTExLDB6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+CjxwYXRoIGQ9Ik0yNCwyN2wzLDBsMCwtM2wyLDBsMCwzbDMsMGwwLDJsLTMsMGwwLDNsLTIsMGwwLC0zbC0zLDB6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+Cjwvc3ZnPgo=";

/***/ }),

/***/ 3158:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KPHBhdGggZD0iTTAsMTFsMTEsMGwwLC0xMWwyLDBsMCwxMWwxMSwwbDAsMmwtMTEsMGwwLDExbC0yLDBsMCwtMTFsLTExLDB6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+CjxwYXRoIGQ9Ik0yNCwzMmwwLC00YTQsNCwwLDAsMSw4LDBsMCw0bC0yLDBsMCwtNGEyLDIsMCwwLDAsLTQsMGwwLDR6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+Cjwvc3ZnPgo=";

/***/ }),

/***/ 9803:
/***/ (function(module) {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KPHBhdGggZD0iTTAsMTFsMTEsMGwwLC0xMWwyLDBsMCwxMWwxMSwwbDAsMmwtMTEsMGwwLDExbC0yLDBsMCwtMTFsLTExLDB6IiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwIi8+CjxwYXRoIGQ9Ik0zMiwzMC41OWwtMS40MSwxLjQxbC0yLjEyLC0yLjEybC0yLjEyLDIuMTJsLTEuNDEsLTEuNDFsMi4xMiwtMi4xMmwtMi4xMiwtMi4xMmwxLjQxLC0xLjQxbDIuMTIsMi4xMmwyLjEyLC0yLjEybDEuNDEsMS40MWwtMi4xMiwyLjEyeiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMCIvPgo8L3N2Zz4K";

/***/ }),

/***/ 3893:
/***/ (function(module) {

"use strict";
if(typeof __WEBPACK_EXTERNAL_MODULE__3893__ === 'undefined') { var e = new Error("Cannot find module 'd3'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE__3893__;

/***/ }),

/***/ 4436:
/***/ (function(module) {

"use strict";
if(typeof __WEBPACK_EXTERNAL_MODULE__4436__ === 'undefined') { var e = new Error("Cannot find module 'vtk.js'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE__4436__;

/***/ }),

/***/ 7606:
/***/ (function(module) {

"use strict";
if(typeof __WEBPACK_EXTERNAL_MODULE__7606__ === 'undefined') { var e = new Error("Cannot find module 'hammerjs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE__7606__;

/***/ }),

/***/ 9061:
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

//
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
function lerp(a, b, t) {
  return a + (b - a) * t;
}
function lerpVec2(a, b, t) {
  return [lerp(a[0], b[0], t), lerp(a[1], b[1], t)];
}
function boundingBoxesIntersect(bbox1, bbox2) {
  var _bbox = _slicedToArray(bbox1, 2),
    b1min = _bbox[0],
    b1max = _bbox[1];
  var _bbox2 = _slicedToArray(bbox2, 2),
    b2min = _bbox2[0],
    b2max = _bbox2[1];
  return !(b1min[0] > b2max[0] || b1max[0] < b2min[0] || b1min[1] > b2max[1] || b1max[1] < b2min[1]);
}
var Geometry = /*#__PURE__*/_createClass(function Geometry() {
  _classCallCheck(this, Geometry);
});
var GeometryEpsilon = /*#__PURE__*/function (_Geometry) {
  function GeometryEpsilon() {
    var _this;
    var epsilon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0000000001;
    _classCallCheck(this, GeometryEpsilon);
    _this = _callSuper(this, GeometryEpsilon);
    _this.epsilon = epsilon;
    return _this;
  }
  _inherits(GeometryEpsilon, _Geometry);
  return _createClass(GeometryEpsilon, [{
    key: "snap0",
    value: function snap0(v) {
      if (Math.abs(v) < this.epsilon) {
        return 0;
      }
      return v;
    }
  }, {
    key: "snap01",
    value: function snap01(v) {
      if (Math.abs(v) < this.epsilon) {
        return 0;
      }
      if (Math.abs(1 - v) < this.epsilon) {
        return 1;
      }
      return v;
    }
  }, {
    key: "isCollinear",
    value: function isCollinear(p1, p2, p3) {
      // does pt1->pt2->pt3 make a straight line?
      // essentially this is just checking to see if
      //   slope(pt1->pt2) === slope(pt2->pt3)
      // if slopes are equal, then they must be collinear, because they share pt2
      var dx1 = p1[0] - p2[0];
      var dy1 = p1[1] - p2[1];
      var dx2 = p2[0] - p3[0];
      var dy2 = p2[1] - p3[1];
      return Math.abs(dx1 * dy2 - dx2 * dy1) < this.epsilon;
    }
  }, {
    key: "solveCubicNormalized",
    value: function solveCubicNormalized(a, b, c) {
      // based somewhat on gsl_poly_solve_cubic from GNU Scientific Library
      var a3 = a / 3;
      var b3 = b / 3;
      var Q = a3 * a3 - b3;
      var R = a3 * (a3 * a3 - b / 2) + c / 2;
      if (Math.abs(R) < this.epsilon && Math.abs(Q) < this.epsilon) {
        return [-a3];
      }
      var F = a3 * (a3 * (4 * a3 * c - b3 * b) - 2 * b * c) + 4 * b3 * b3 * b3 + c * c;
      if (Math.abs(F) < this.epsilon) {
        var sqrtQ = Math.sqrt(Q);
        return R > 0 ? [-2 * sqrtQ - a / 3, sqrtQ - a / 3] : [-sqrtQ - a / 3, 2 * sqrtQ - a / 3];
      }
      var Q3 = Q * Q * Q;
      var R2 = R * R;
      if (R2 < Q3) {
        var ratio = (R < 0 ? -1 : 1) * Math.sqrt(R2 / Q3);
        var theta = Math.acos(ratio);
        var norm = -2 * Math.sqrt(Q);
        var x0 = norm * Math.cos(theta / 3) - a3;
        var x1 = norm * Math.cos((theta + 2 * Math.PI) / 3) - a3;
        var x2 = norm * Math.cos((theta - 2 * Math.PI) / 3) - a3;
        return [x0, x1, x2].sort(function (x, y) {
          return x - y;
        });
      } else {
        var A = (R < 0 ? 1 : -1) * Math.pow(Math.abs(R) + Math.sqrt(R2 - Q3), 1 / 3);
        var B = Math.abs(A) >= this.epsilon ? Q / A : 0;
        return [A + B - a3];
      }
    }
  }, {
    key: "solveCubic",
    value: function solveCubic(a, b, c, d) {
      if (Math.abs(a) < this.epsilon) {
        // quadratic
        if (Math.abs(b) < this.epsilon) {
          // linear case
          if (Math.abs(c) < this.epsilon) {
            // horizontal line
            return Math.abs(d) < this.epsilon ? [0] : [];
          }
          return [-d / c];
        }
        var b2 = 2 * b;
        var D = c * c - 4 * b * d;
        if (Math.abs(D) < this.epsilon) {
          return [-c / b2];
        } else if (D > 0) {
          D = Math.sqrt(D);
          return [(-c + D) / b2, (-c - D) / b2].sort(function (x, y) {
            return x - y;
          });
        }
        return [];
      }
      return this.solveCubicNormalized(b / a, c / a, d / a);
    }
  }, {
    key: "isEqualVec2",
    value: function isEqualVec2(a, b) {
      return Math.abs(a[0] - b[0]) < this.epsilon && Math.abs(a[1] - b[1]) < this.epsilon;
    }
  }, {
    key: "compareVec2",
    value: function compareVec2(a, b) {
      // returns -1 if a is smaller, 1 if b is smaller, 0 if equal
      if (Math.abs(b[0] - a[0]) < this.epsilon) {
        return Math.abs(b[1] - a[1]) < this.epsilon ? 0 : a[1] < b[1] ? -1 : 1;
      }
      return a[0] < b[0] ? -1 : 1;
    }
  }]);
}(Geometry); //
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
var SegmentTValuesBuilder = /*#__PURE__*/function () {
  function SegmentTValuesBuilder(geo) {
    _classCallCheck(this, SegmentTValuesBuilder);
    this.tValues = [];
    this.geo = geo;
  }
  return _createClass(SegmentTValuesBuilder, [{
    key: "addArray",
    value: function addArray(ts) {
      var _iterator = _createForOfIteratorHelper(ts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var t = _step.value;
          this.tValues.push(t);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return this;
    }
  }, {
    key: "add",
    value: function add(t) {
      t = this.geo.snap01(t);
      // ignore values outside 0-1 range
      if (t < 0 || t > 1) {
        return this;
      }
      var _iterator2 = _createForOfIteratorHelper(this.tValues),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var tv = _step2.value;
          if (this.geo.snap0(t - tv) === 0) {
            // already have this location
            return this;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this.tValues.push(t);
      return this;
    }
  }, {
    key: "list",
    value: function list() {
      this.tValues.sort(function (a, b) {
        return a - b;
      });
      return this.tValues;
    }
  }]);
}();
var SegmentTValuePairsBuilder = /*#__PURE__*/function () {
  function SegmentTValuePairsBuilder(allowOutOfRange, geo) {
    _classCallCheck(this, SegmentTValuePairsBuilder);
    this.tValuePairs = [];
    this.allowOutOfRange = allowOutOfRange;
    this.geo = geo;
  }
  return _createClass(SegmentTValuePairsBuilder, [{
    key: "add",
    value: function add(t1, t2) {
      t1 = this.geo.snap01(t1);
      t2 = this.geo.snap01(t2);
      // ignore values outside 0-1 range
      if (!this.allowOutOfRange && (t1 < 0 || t1 > 1 || t2 < 0 || t2 > 1)) {
        return this;
      }
      var _iterator3 = _createForOfIteratorHelper(this.tValuePairs),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tv = _step3.value;
          if (this.geo.snap0(t1 - tv[0]) === 0 || this.geo.snap0(t2 - tv[1]) === 0) {
            // already have this location
            return this;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      this.tValuePairs.push([t1, t2]);
      return this;
    }
  }, {
    key: "list",
    value: function list() {
      this.tValuePairs.sort(function (a, b) {
        return a[0] - b[0];
      });
      return this.tValuePairs;
    }
  }, {
    key: "done",
    value: function done() {
      return this.tValuePairs.length <= 0 ? null : {
        kind: "tValuePairs",
        tValuePairs: this.list()
      };
    }
  }]);
}();
var SegmentBase = /*#__PURE__*/_createClass(function SegmentBase() {
  _classCallCheck(this, SegmentBase);
});
var SegmentLine = /*#__PURE__*/function (_SegmentBase) {
  function SegmentLine(p0, p1, geo) {
    var _this2;
    _classCallCheck(this, SegmentLine);
    _this2 = _callSuper(this, SegmentLine);
    _this2.p0 = p0;
    _this2.p1 = p1;
    _this2.geo = geo;
    return _this2;
  }
  _inherits(SegmentLine, _SegmentBase);
  return _createClass(SegmentLine, [{
    key: "copy",
    value: function copy() {
      return new SegmentLine(this.p0, this.p1, this.geo);
    }
  }, {
    key: "isEqual",
    value: function isEqual(other) {
      return this.geo.isEqualVec2(this.p0, other.p0) && this.geo.isEqualVec2(this.p1, other.p1);
    }
  }, {
    key: "start",
    value: function start() {
      return this.p0;
    }
  }, {
    key: "start2",
    value: function start2() {
      return this.p1;
    }
  }, {
    key: "end2",
    value: function end2() {
      return this.p0;
    }
  }, {
    key: "end",
    value: function end() {
      return this.p1;
    }
  }, {
    key: "setStart",
    value: function setStart(p0) {
      this.p0 = p0;
    }
  }, {
    key: "setEnd",
    value: function setEnd(p1) {
      this.p1 = p1;
    }
  }, {
    key: "point",
    value: function point(t) {
      var p0 = this.p0;
      var p1 = this.p1;
      if (t === 0) {
        return p0;
      } else if (t === 1) {
        return p1;
      }
      return [p0[0] + (p1[0] - p0[0]) * t, p0[1] + (p1[1] - p0[1]) * t];
    }
  }, {
    key: "split",
    value: function split(ts) {
      var _this3 = this;
      if (ts.length <= 0) {
        return [this];
      }
      var pts = ts.map(function (t) {
        return _this3.point(t);
      });
      pts.push(this.p1);
      var result = [];
      var last = this.p0;
      var _iterator4 = _createForOfIteratorHelper(pts),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var p = _step4.value;
          result.push(new SegmentLine(last, p, this.geo));
          last = p;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return result;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      return new SegmentLine(this.p1, this.p0, this.geo);
    }
  }, {
    key: "boundingBox",
    value: function boundingBox() {
      var p0 = this.p0;
      var p1 = this.p1;
      return [[Math.min(p0[0], p1[0]), Math.min(p0[1], p1[1])], [Math.max(p0[0], p1[0]), Math.max(p0[1], p1[1])]];
    }
  }, {
    key: "pointOn",
    value: function pointOn(p) {
      return this.geo.isCollinear(p, this.p0, this.p1);
    }
  }, {
    key: "draw",
    value: function draw(ctx) {
      var p0 = this.p0;
      var p1 = this.p1;
      ctx.moveTo(p0[0], p0[1]);
      ctx.lineTo(p1[0], p1[1]);
      return ctx;
    }
  }]);
}(SegmentBase);
var SegmentCurve = /*#__PURE__*/function (_SegmentBase2) {
  function SegmentCurve(p0, p1, p2, p3, geo) {
    var _this4;
    _classCallCheck(this, SegmentCurve);
    _this4 = _callSuper(this, SegmentCurve);
    _this4.p0 = p0;
    _this4.p1 = p1;
    _this4.p2 = p2;
    _this4.p3 = p3;
    _this4.geo = geo;
    return _this4;
  }
  _inherits(SegmentCurve, _SegmentBase2);
  return _createClass(SegmentCurve, [{
    key: "copy",
    value: function copy() {
      return new SegmentCurve(this.p0, this.p1, this.p2, this.p3, this.geo);
    }
  }, {
    key: "isEqual",
    value: function isEqual(other) {
      return this.geo.isEqualVec2(this.p0, other.p0) && this.geo.isEqualVec2(this.p1, other.p1) && this.geo.isEqualVec2(this.p2, other.p2) && this.geo.isEqualVec2(this.p3, other.p3);
    }
  }, {
    key: "start",
    value: function start() {
      return this.p0;
    }
  }, {
    key: "start2",
    value: function start2() {
      return this.p1;
    }
  }, {
    key: "end2",
    value: function end2() {
      return this.p2;
    }
  }, {
    key: "end",
    value: function end() {
      return this.p3;
    }
  }, {
    key: "setStart",
    value: function setStart(p0) {
      this.p0 = p0;
    }
  }, {
    key: "setEnd",
    value: function setEnd(p3) {
      this.p3 = p3;
    }
  }, {
    key: "point",
    value: function point(t) {
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      var p3 = this.p3;
      if (t === 0) {
        return p0;
      } else if (t === 1) {
        return p3;
      }
      var t1t = (1 - t) * (1 - t);
      var tt = t * t;
      var t0 = t1t * (1 - t);
      var t1 = 3 * t1t * t;
      var t2 = 3 * tt * (1 - t);
      var t3 = tt * t;
      return [p0[0] * t0 + p1[0] * t1 + p2[0] * t2 + p3[0] * t3, p0[1] * t0 + p1[1] * t1 + p2[1] * t2 + p3[1] * t3];
    }
  }, {
    key: "split",
    value: function split(ts) {
      var _this5 = this;
      if (ts.length <= 0) {
        return [this];
      }
      var result = [];
      var splitSingle = function splitSingle(pts, t) {
        var _pts = _slicedToArray(pts, 4),
          p0 = _pts[0],
          p1 = _pts[1],
          p2 = _pts[2],
          p3 = _pts[3];
        var p4 = lerpVec2(p0, p1, t);
        var p5 = lerpVec2(p1, p2, t);
        var p6 = lerpVec2(p2, p3, t);
        var p7 = lerpVec2(p4, p5, t);
        var p8 = lerpVec2(p5, p6, t);
        var p9 = lerpVec2(p7, p8, t);
        result.push(new SegmentCurve(p0, p4, p7, p9, _this5.geo));
        return [p9, p8, p6, p3];
      };
      var last = [this.p0, this.p1, this.p2, this.p3];
      var lastT = 0;
      var _iterator5 = _createForOfIteratorHelper(ts),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var t = _step5.value;
          last = splitSingle(last, (t - lastT) / (1 - lastT));
          lastT = t;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      result.push(new SegmentCurve(last[0], last[1], last[2], last[3], this.geo));
      return result;
    }
  }, {
    key: "reverse",
    value: function reverse() {
      return new SegmentCurve(this.p3, this.p2, this.p1, this.p0, this.geo);
    }
  }, {
    key: "getCubicCoefficients",
    value: function getCubicCoefficients(axis) {
      var p0 = this.p0[axis];
      var p1 = this.p1[axis];
      var p2 = this.p2[axis];
      var p3 = this.p3[axis];
      return [p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0];
    }
  }, {
    key: "boundingTValues",
    value: function boundingTValues() {
      var _this6 = this;
      var result = new SegmentTValuesBuilder(this.geo);
      var bounds = function bounds(x0, x1, x2, x3) {
        var a = 3 * x3 - 9 * x2 + 9 * x1 - 3 * x0;
        var b = 6 * x0 - 12 * x1 + 6 * x2;
        var c = 3 * x1 - 3 * x0;
        if (_this6.geo.snap0(a) === 0) {
          result.add(-c / b);
        } else {
          var disc = b * b - 4 * a * c;
          if (disc >= 0) {
            var sq = Math.sqrt(disc);
            result.add((-b + sq) / (2 * a));
            result.add((-b - sq) / (2 * a));
          }
        }
        return result;
      };
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      var p3 = this.p3;
      bounds(p0[0], p1[0], p2[0], p3[0]);
      bounds(p0[1], p1[1], p2[1], p3[1]);
      return result.list();
    }
  }, {
    key: "inflectionTValues",
    value: function inflectionTValues() {
      var result = new SegmentTValuesBuilder(this.geo);
      result.addArray(this.boundingTValues());
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      var p3 = this.p3;
      var p10x = 3 * (p1[0] - p0[0]);
      var p10y = 3 * (p1[1] - p0[1]);
      var p21x = 6 * (p2[0] - p1[0]);
      var p21y = 6 * (p2[1] - p1[1]);
      var p32x = 3 * (p3[0] - p2[0]);
      var p32y = 3 * (p3[1] - p2[1]);
      var p210x = 6 * (p2[0] - 2 * p1[0] + p0[0]);
      var p210y = 6 * (p2[1] - 2 * p1[1] + p0[1]);
      var p321x = 6 * (p3[0] - 2 * p2[0] + p1[0]);
      var p321y = 6 * (p3[1] - 2 * p2[1] + p1[1]);
      var qx = p10x - p21x + p32x;
      var qy = p10y - p21y + p32y;
      var rx = p21x - 2 * p10x;
      var ry = p21y - 2 * p10y;
      var sx = p10x;
      var sy = p10y;
      var ux = p321x - p210x;
      var uy = p321y - p210y;
      var vx = p210x;
      var vy = p210y;
      var A = qx * uy - qy * ux;
      var B = qx * vy + rx * uy - qy * vx - ry * ux;
      var C = rx * vy + sx * uy - ry * vx - sy * ux;
      var D = sx * vy - sy * vx;
      var _iterator6 = _createForOfIteratorHelper(this.geo.solveCubic(A, B, C, D)),
        _step6;
      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var s = _step6.value;
          result.add(s);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
      return result.list();
    }
  }, {
    key: "boundingBox",
    value: function boundingBox() {
      var p0 = this.p0;
      var p3 = this.p3;
      var min = [Math.min(p0[0], p3[0]), Math.min(p0[1], p3[1])];
      var max = [Math.max(p0[0], p3[0]), Math.max(p0[1], p3[1])];
      var _iterator7 = _createForOfIteratorHelper(this.boundingTValues()),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var t = _step7.value;
          var p = this.point(t);
          min[0] = Math.min(min[0], p[0]);
          min[1] = Math.min(min[1], p[1]);
          max[0] = Math.max(max[0], p[0]);
          max[1] = Math.max(max[1], p[1]);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      return [min, max];
    }
  }, {
    key: "mapXtoT",
    value: function mapXtoT(x) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.geo.snap0(this.p0[0] - x) === 0) {
        return 0;
      }
      if (this.geo.snap0(this.p3[0] - x) === 0) {
        return 1;
      }
      var p0 = this.p0[0] - x;
      var p1 = this.p1[0] - x;
      var p2 = this.p2[0] - x;
      var p3 = this.p3[0] - x;
      var R = [p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0];
      var _iterator8 = _createForOfIteratorHelper(this.geo.solveCubic(R[0], R[1], R[2], R[3])),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _t = _step8.value;
          var _ts = this.geo.snap01(_t);
          if (_ts >= 0 && _ts <= 1) {
            return _t;
          }
        }
        // force a solution if we know there is one...
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
      if (force || x >= Math.min(this.p0[0], this.p3[0]) && x <= Math.max(this.p0[0], this.p3[0])) {
        for (var attempt = 0; attempt < 4; attempt++) {
          // collapse an R value to 0, this is so wrong!!!
          var ii = -1;
          for (var i = 0; i < 4; i++) {
            if (R[i] !== 0 && (ii < 0 || Math.abs(R[i]) < Math.abs(R[ii]))) {
              ii = i;
            }
          }
          if (ii < 0) {
            return 0;
          }
          R[ii] = 0;
          // solve again, but with another 0 to help
          var _iterator9 = _createForOfIteratorHelper(this.geo.solveCubic(R[0], R[1], R[2], R[3])),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var t = _step9.value;
              var ts = this.geo.snap01(t);
              if (ts >= 0 && ts <= 1) {
                return t;
              }
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      }
      return false;
    }
  }, {
    key: "mapXtoY",
    value: function mapXtoY(x) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var t = this.mapXtoT(x, force);
      if (t === false) {
        return false;
      }
      return this.point(t)[1];
    }
  }, {
    key: "pointOn",
    value: function pointOn(p) {
      if (this.geo.isEqualVec2(this.p0, p) || this.geo.isEqualVec2(this.p3, p)) {
        return true;
      }
      var y = this.mapXtoY(p[0]);
      if (y === false) {
        return false;
      }
      return this.geo.snap0(y - p[1]) === 0;
    }
  }, {
    key: "toLine",
    value: function toLine() {
      // note: this won't work for arbitrary curves, because they could loop back on themselves,
      // but will work fine for curves that have already been split at all inflection points
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      var p3 = this.p3;
      if (
      // vertical line
      this.geo.snap0(p0[0] - p1[0]) === 0 && this.geo.snap0(p0[0] - p2[0]) === 0 && this.geo.snap0(p0[0] - p3[0]) === 0 ||
      // horizontal line
      this.geo.snap0(p0[1] - p1[1]) === 0 && this.geo.snap0(p0[1] - p2[1]) === 0 && this.geo.snap0(p0[1] - p3[1]) === 0) {
        return new SegmentLine(p0, p3, this.geo);
      }
      return null;
    }
  }, {
    key: "draw",
    value: function draw(ctx) {
      var p0 = this.p0;
      var p1 = this.p1;
      var p2 = this.p2;
      var p3 = this.p3;
      ctx.moveTo(p0[0], p0[1]);
      ctx.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      return ctx;
    }
  }]);
}(SegmentBase);
function projectPointOntoSegmentLine(p, seg) {
  var dx = seg.p1[0] - seg.p0[0];
  var dy = seg.p1[1] - seg.p0[1];
  var px = p[0] - seg.p0[0];
  var py = p[1] - seg.p0[1];
  var dist = dx * dx + dy * dy;
  var dot = px * dx + py * dy;
  return dot / dist;
}
function segmentLineIntersectSegmentLine(segA, segB, allowOutOfRange) {
  var geo = segA.geo;
  var a0 = segA.p0;
  var a1 = segA.p1;
  var b0 = segB.p0;
  var b1 = segB.p1;
  var adx = a1[0] - a0[0];
  var ady = a1[1] - a0[1];
  var bdx = b1[0] - b0[0];
  var bdy = b1[1] - b0[1];
  var axb = adx * bdy - ady * bdx;
  if (geo.snap0(axb) === 0) {
    // lines are coincident or parallel
    if (!geo.isCollinear(a0, a1, b0)) {
      // they're not coincident, so they're parallel, with no intersections
      return null;
    }
    // otherwise, segments are on top of each other somehow (aka coincident)
    var tB0onA = projectPointOntoSegmentLine(segB.p0, segA);
    var tB1onA = projectPointOntoSegmentLine(segB.p1, segA);
    var tAMin = geo.snap01(Math.min(tB0onA, tB1onA));
    var tAMax = geo.snap01(Math.max(tB0onA, tB1onA));
    if (tAMax < 0 || tAMin > 1) {
      return null;
    }
    var tA0onB = projectPointOntoSegmentLine(segA.p0, segB);
    var tA1onB = projectPointOntoSegmentLine(segA.p1, segB);
    var tBMin = geo.snap01(Math.min(tA0onB, tA1onB));
    var tBMax = geo.snap01(Math.max(tA0onB, tA1onB));
    if (tBMax < 0 || tBMin > 1) {
      return null;
    }
    return {
      kind: "tRangePairs",
      tStart: [Math.max(0, tAMin), Math.max(0, tBMin)],
      tEnd: [Math.min(1, tAMax), Math.min(1, tBMax)]
    };
  }
  // otherwise, not coincident, so they intersect somewhere
  var dx = a0[0] - b0[0];
  var dy = a0[1] - b0[1];
  return new SegmentTValuePairsBuilder(allowOutOfRange, geo).add((bdx * dy - bdy * dx) / axb, (adx * dy - ady * dx) / axb).done();
}
function segmentLineIntersectSegmentCurve(segA, segB, allowOutOfRange, invert) {
  var geo = segA.geo;
  var a0 = segA.p0;
  var a1 = segA.p1;
  var A = a1[1] - a0[1];
  var B = a0[0] - a1[0];
  if (geo.snap0(B) === 0) {
    // vertical line
    var t = segB.mapXtoT(a0[0], false);
    if (t === false) {
      return null;
    }
    var y = segB.point(t)[1];
    var s = (y - a0[1]) / A;
    var _result = new SegmentTValuePairsBuilder(allowOutOfRange, geo);
    if (invert) {
      _result.add(t, s);
    } else {
      _result.add(s, t);
    }
    return _result.done();
  }
  var C = A * a0[0] + B * a0[1];
  var bx = segB.getCubicCoefficients(0);
  var by = segB.getCubicCoefficients(1);
  var rA = A * bx[0] + B * by[0];
  var rB = A * bx[1] + B * by[1];
  var rC = A * bx[2] + B * by[2];
  var rD = A * bx[3] + B * by[3] - C;
  var roots = geo.solveCubic(rA, rB, rC, rD);
  var result = new SegmentTValuePairsBuilder(allowOutOfRange, geo);
  if (geo.snap0(A) === 0) {
    // project curve's X component onto line
    var _iterator0 = _createForOfIteratorHelper(roots),
      _step0;
    try {
      for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
        var _t2 = _step0.value;
        var X = bx[0] * _t2 * _t2 * _t2 + bx[1] * _t2 * _t2 + bx[2] * _t2 + bx[3];
        var _s = (a0[0] - X) / B;
        if (invert) {
          result.add(_t2, _s);
        } else {
          result.add(_s, _t2);
        }
      }
    } catch (err) {
      _iterator0.e(err);
    } finally {
      _iterator0.f();
    }
  } else {
    // project curve's Y component onto line
    var _iterator1 = _createForOfIteratorHelper(roots),
      _step1;
    try {
      for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
        var _t3 = _step1.value;
        var Y = by[0] * _t3 * _t3 * _t3 + by[1] * _t3 * _t3 + by[2] * _t3 + by[3];
        var _s2 = (Y - a0[1]) / A;
        if (invert) {
          result.add(_t3, _s2);
        } else {
          result.add(_s2, _t3);
        }
      }
    } catch (err) {
      _iterator1.e(err);
    } finally {
      _iterator1.f();
    }
  }
  return result.done();
}
function segmentCurveIntersectSegmentCurve(segA, segB, allowOutOfRange) {
  var geo = segA.geo;
  // dummy coincident calculation for now
  // TODO: implement actual range/equality testing
  if (geo.isEqualVec2(segA.p0, segB.p0)) {
    if (geo.isEqualVec2(segA.p3, segB.p3)) {
      if (geo.isEqualVec2(segA.p1, segB.p1) && geo.isEqualVec2(segA.p2, segB.p2)) {
        return {
          kind: "tRangePairs",
          tStart: [0, 0],
          tEnd: [1, 1]
        };
      } else {
        return {
          kind: "tValuePairs",
          tValuePairs: [[0, 0], [1, 1]]
        };
      }
    } else {
      return {
        kind: "tValuePairs",
        tValuePairs: [[0, 0]]
      };
    }
  } else if (geo.isEqualVec2(segA.p0, segB.p3)) {
    return {
      kind: "tValuePairs",
      tValuePairs: [[0, 1]]
    };
  } else if (geo.isEqualVec2(segA.p3, segB.p0)) {
    return {
      kind: "tValuePairs",
      tValuePairs: [[1, 0]]
    };
  } else if (geo.isEqualVec2(segA.p3, segB.p3)) {
    return {
      kind: "tValuePairs",
      tValuePairs: [[1, 1]]
    };
  }
  var result = new SegmentTValuePairsBuilder(allowOutOfRange, geo);
  var _checkCurves = function checkCurves(c1, t1L, t1R, c2, t2L, t2R) {
    var bbox1 = c1.boundingBox();
    var bbox2 = c2.boundingBox();
    if (!boundingBoxesIntersect(bbox1, bbox2)) {
      return;
    }
    var t1M = (t1L + t1R) / 2;
    var t2M = (t2L + t2R) / 2;
    if (geo.snap0(t1R - t1L) === 0 && geo.snap0(t2R - t2L) === 0) {
      result.add(t1M, t2M);
      return;
    }
    var _c1$split = c1.split([0.5]),
      _c1$split2 = _slicedToArray(_c1$split, 2),
      c1L = _c1$split2[0],
      c1R = _c1$split2[1];
    var _c2$split = c2.split([0.5]),
      _c2$split2 = _slicedToArray(_c2$split, 2),
      c2L = _c2$split2[0],
      c2R = _c2$split2[1];
    _checkCurves(c1L, t1L, t1M, c2L, t2L, t2M);
    _checkCurves(c1R, t1M, t1R, c2L, t2L, t2M);
    _checkCurves(c1L, t1L, t1M, c2R, t2M, t2R);
    _checkCurves(c1R, t1M, t1R, c2R, t2M, t2R);
  };
  _checkCurves(segA, 0, 1, segB, 0, 1);
  return result.done();
}
// return value:
//   null               => no intersection
//   SegmentTValuePairs => the segments intersect along a series of points, whose position is
//                         represented by T values pairs [segA_tValue, segB_tValue]
//                         note: a T value pair is returned even if it's just a shared vertex!
//   SegmentTRangePairs => the segments are coincident (on top of each other), and intersect along a
//                         segment, ranged by T values
function segmentsIntersect(segA, segB, allowOutOfRange) {
  if (segA instanceof SegmentLine) {
    if (segB instanceof SegmentLine) {
      return segmentLineIntersectSegmentLine(segA, segB, allowOutOfRange);
    } else if (segB instanceof SegmentCurve) {
      return segmentLineIntersectSegmentCurve(segA, segB, allowOutOfRange, false);
    }
  } else if (segA instanceof SegmentCurve) {
    if (segB instanceof SegmentLine) {
      return segmentLineIntersectSegmentCurve(segB, segA, allowOutOfRange, true);
    } else if (segB instanceof SegmentCurve) {
      return segmentCurveIntersectSegmentCurve(segA, segB, allowOutOfRange);
    }
  }
  throw new Error("PolyBool: Unknown segment instance in segmentsIntersect");
}

//
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
var SegmentBoolBase = /*#__PURE__*/_createClass(function SegmentBoolBase(data) {
  var fill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var closed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  _classCallCheck(this, SegmentBoolBase);
  var _a, _b, _c;
  this.otherFill = null;
  this.id = (_a = log === null || log === void 0 ? void 0 : log.segmentId()) !== null && _a !== void 0 ? _a : -1;
  this.data = data;
  this.myFill = {
    above: (_b = fill === null || fill === void 0 ? void 0 : fill.above) !== null && _b !== void 0 ? _b : null,
    below: (_c = fill === null || fill === void 0 ? void 0 : fill.below) !== null && _c !== void 0 ? _c : null
  };
  this.closed = closed;
});
var SegmentBoolLine = /*#__PURE__*/function (_SegmentBoolBase) {
  function SegmentBoolLine() {
    _classCallCheck(this, SegmentBoolLine);
    return _callSuper(this, SegmentBoolLine, arguments);
  }
  _inherits(SegmentBoolLine, _SegmentBoolBase);
  return _createClass(SegmentBoolLine);
}(SegmentBoolBase);
var SegmentBoolCurve = /*#__PURE__*/function (_SegmentBoolBase2) {
  function SegmentBoolCurve() {
    _classCallCheck(this, SegmentBoolCurve);
    return _callSuper(this, SegmentBoolCurve, arguments);
  }
  _inherits(SegmentBoolCurve, _SegmentBoolBase2);
  return _createClass(SegmentBoolCurve);
}(SegmentBoolBase);
function copySegmentBool(seg, log) {
  if (seg instanceof SegmentBoolLine) {
    return new SegmentBoolLine(seg.data, seg.myFill, seg.closed, log);
  } else if (seg instanceof SegmentBoolCurve) {
    return new SegmentBoolCurve(seg.data, seg.myFill, seg.closed, log);
  }
  throw new Error("PolyBool: Unknown SegmentBool in copySegmentBool");
}
var EventBool = /*#__PURE__*/_createClass(function EventBool(isStart, p, seg, primary) {
  _classCallCheck(this, EventBool);
  this.status = null;
  this.isStart = isStart;
  this.p = p;
  this.seg = seg;
  this.primary = primary;
});
var ListBool = /*#__PURE__*/function () {
  function ListBool() {
    _classCallCheck(this, ListBool);
    this.nodes = [];
  }
  return _createClass(ListBool, [{
    key: "remove",
    value: function remove(node) {
      var i = this.nodes.indexOf(node);
      if (i >= 0) {
        this.nodes.splice(i, 1);
      }
    }
  }, {
    key: "getIndex",
    value: function getIndex(node) {
      return this.nodes.indexOf(node);
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.nodes.length <= 0;
    }
  }, {
    key: "getHead",
    value: function getHead() {
      return this.nodes[0];
    }
  }, {
    key: "removeHead",
    value: function removeHead() {
      this.nodes.shift();
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(node, check) {
      this.findTransition(node, check).insert(node);
    }
  }, {
    key: "findTransition",
    value: function findTransition(node, check) {
      var _this7 = this;
      var _a, _b;
      // bisect to find the transition point
      var compare = function compare(a, b) {
        return check(b) - check(a);
      };
      var i = 0;
      var high = this.nodes.length;
      while (i < high) {
        var mid = i + high >> 1;
        if (compare(this.nodes[mid], node) > 0) {
          high = mid;
        } else {
          i = mid + 1;
        }
      }
      return {
        before: i <= 0 ? null : (_a = this.nodes[i - 1]) !== null && _a !== void 0 ? _a : null,
        after: (_b = this.nodes[i]) !== null && _b !== void 0 ? _b : null,
        insert: function insert(node) {
          _this7.nodes.splice(i, 0, node);
          return node;
        }
      };
    }
  }]);
}();
var Intersecter = /*#__PURE__*/function () {
  function Intersecter(selfIntersection, geo) {
    var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    _classCallCheck(this, Intersecter);
    this.events = new ListBool();
    this.status = new ListBool();
    this.currentPath = [];
    this.selfIntersection = selfIntersection;
    this.geo = geo;
    this.log = log;
  }
  return _createClass(Intersecter, [{
    key: "compareEvents",
    value: function compareEvents(aStart, a1, a2, aSeg, bStart, b1, b2, bSeg) {
      // compare the selected points first
      var comp = this.geo.compareVec2(a1, b1);
      if (comp !== 0) {
        return comp;
      }
      // the selected points are the same
      if (aSeg instanceof SegmentLine && bSeg instanceof SegmentLine && this.geo.isEqualVec2(a2, b2)) {
        // if the non-selected points are the same too...
        return 0; // then the segments are equal
      }
      if (aStart !== bStart) {
        // if one is a start and the other isn't...
        return aStart ? 1 : -1; // favor the one that isn't the start
      }
      return this.compareSegments(bSeg, aSeg);
    }
  }, {
    key: "addEvent",
    value: function addEvent(ev) {
      var _this8 = this;
      this.events.insertBefore(ev, function (here) {
        if (here === ev) {
          return 0;
        }
        return _this8.compareEvents(ev.isStart, ev.p, ev.other.p, ev.seg.data, here.isStart, here.p, here.other.p, here.seg.data);
      });
    }
  }, {
    key: "divideEvent",
    value: function divideEvent(ev, t, p) {
      var _a, _b;
      (_a = this.log) === null || _a === void 0 ? void 0 : _a.segmentDivide(ev.seg, p);
      var _ev$seg$data$split = ev.seg.data.split([t]),
        _ev$seg$data$split2 = _slicedToArray(_ev$seg$data$split, 2),
        left = _ev$seg$data$split2[0],
        right = _ev$seg$data$split2[1];
      // set the *exact* intersection point
      left.setEnd(p);
      right.setStart(p);
      var ns = right instanceof SegmentLine ? new SegmentBoolLine(right, ev.seg.myFill, ev.seg.closed, this.log) : right instanceof SegmentCurve ? new SegmentBoolCurve(right, ev.seg.myFill, ev.seg.closed, this.log) : null;
      if (!ns) {
        throw new Error("PolyBool: Unknown segment data in divideEvent");
      }
      // slides an end backwards
      //   (start)------------(end)    to:
      //   (start)---(end)
      this.events.remove(ev.other);
      ev.seg.data = left;
      (_b = this.log) === null || _b === void 0 ? void 0 : _b.segmentChop(ev.seg);
      ev.other.p = p;
      this.addEvent(ev.other);
      return this.addSegment(ns, ev.primary);
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      this.currentPath = [];
    }
  }, {
    key: "closePath",
    value: function closePath() {
      var _iterator10 = _createForOfIteratorHelper(this.currentPath),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var seg = _step10.value;
          seg.closed = true;
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  }, {
    key: "addSegment",
    value: function addSegment(seg, primary) {
      var evStart = new EventBool(true, seg.data.start(), seg, primary);
      var evEnd = new EventBool(false, seg.data.end(), seg, primary);
      evStart.other = evEnd;
      evEnd.other = evStart;
      this.addEvent(evStart);
      this.addEvent(evEnd);
      return evStart;
    }
  }, {
    key: "addLine",
    value: function addLine(from, to) {
      var primary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var f = this.geo.compareVec2(from, to);
      if (f === 0) {
        // points are equal, so we have a zero-length segment
        return; // skip it
      }
      var seg = new SegmentBoolLine(new SegmentLine(f < 0 ? from : to, f < 0 ? to : from, this.geo), null, false, this.log);
      this.currentPath.push(seg);
      this.addSegment(seg, primary);
    }
  }, {
    key: "addCurve",
    value: function addCurve(from, c1, c2, to) {
      var primary = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
      var original = new SegmentCurve(from, c1, c2, to, this.geo);
      var curves = original.split(original.inflectionTValues());
      var _iterator11 = _createForOfIteratorHelper(curves),
        _step11;
      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var curve = _step11.value;
          var f = this.geo.compareVec2(curve.start(), curve.end());
          if (f === 0) {
            // points are equal AFTER splitting... this only happens for zero-length segments
            continue; // skip it
          }
          // convert horizontal/vertical curves to lines
          var line = curve.toLine();
          if (line) {
            this.addLine(line.p0, line.p1, primary);
          } else {
            var seg = new SegmentBoolCurve(f < 0 ? curve : curve.reverse(), null, false, this.log);
            this.currentPath.push(seg);
            this.addSegment(seg, primary);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
  }, {
    key: "compareSegments",
    value: function compareSegments(seg1, seg2) {
      // TODO:
      //  This is where some of the curve instability comes from... we need to reliably sort
      //  segments, but this is surprisingly hard when it comes to curves.
      //
      //  The easy case is something like:
      //
      //             C   A - - - D
      //               \
      //                 \
      //                   B
      //  A is clearly above line C-B, which is easily calculated... however, once curves are
      //  introduced, it's not so obvious without using some heuristic which will fail at times.
      //
      var A = seg1.start();
      var B = seg2.start2();
      var C = seg2.start();
      if (seg2.pointOn(A)) {
        // A intersects seg2 somehow (possibly sharing a start point, or maybe just splitting it)
        //
        //   AC - - - - D
        //      \
        //        \
        //          B
        //
        // so grab seg1's second point (D) instead
        A = seg1.start2();
        if (seg2.pointOn(A)) {
          if (seg1 instanceof SegmentLine) {
            if (seg2 instanceof SegmentLine) {
              // oh... D is on the line too... so these are the same
              return 0;
            }
            if (seg2 instanceof SegmentCurve) {
              A = seg1.point(0.5); // TODO: ???
            }
          }
          if (seg1 instanceof SegmentCurve) {
            A = seg1.end();
          }
        }
        if (seg2 instanceof SegmentCurve) {
          if (this.geo.snap0(A[0] - C[0]) === 0 && this.geo.snap0(B[0] - C[0]) === 0) {
            // seg2 is a curve, but the tangent line (C-B) at the start point is vertical, and
            // collinear with A... so... just sort based on the Y values I guess?
            return Math.sign(C[1] - A[1]);
          }
        }
      } else {
        if (seg2 instanceof SegmentCurve) {
          // find seg2's position at A[0] and see if it's above or below A[1]
          var y = seg2.mapXtoY(A[0], true);
          if (y !== false) {
            return Math.sign(y - A[1]);
          }
        }
        if (seg1 instanceof SegmentCurve) {
          // unfortunately, in order to sort against curved segments, we need to check the
          // intersection point... this means a lot more intersection tests, but I'm not sure how else
          // to sort correctly
          var i = segmentsIntersect(seg1, seg2, true);
          if (i && i.kind === "tValuePairs") {
            // find the intersection point on seg1
            var _iterator12 = _createForOfIteratorHelper(i.tValuePairs),
              _step12;
            try {
              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                var pair = _step12.value;
                var t = this.geo.snap01(pair[0]);
                if (t > 0 && t < 1) {
                  B = seg1.point(t);
                  break;
                }
              }
            } catch (err) {
              _iterator12.e(err);
            } finally {
              _iterator12.f();
            }
          }
        }
      }
      // fallthrough to this calculation which determines if A is on one side or another of C-B
      var _A = A,
        _A2 = _slicedToArray(_A, 2),
        Ax = _A2[0],
        Ay = _A2[1];
      var _B = B,
        _B2 = _slicedToArray(_B, 2),
        Bx = _B2[0],
        By = _B2[1];
      var _C = _slicedToArray(C, 2),
        Cx = _C[0],
        Cy = _C[1];
      return Math.sign((Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax));
    }
  }, {
    key: "statusFindSurrounding",
    value: function statusFindSurrounding(ev) {
      var _this9 = this;
      return this.status.findTransition(ev, function (here) {
        if (ev === here) {
          return 0;
        }
        var c = _this9.compareSegments(ev.seg.data, here.seg.data);
        return c === 0 ? -1 : c;
      });
    }
  }, {
    key: "checkIntersection",
    value: function checkIntersection(ev1, ev2) {
      var _a;
      // returns the segment equal to ev1, or null if nothing equal
      var seg1 = ev1.seg;
      var seg2 = ev2.seg;
      (_a = this.log) === null || _a === void 0 ? void 0 : _a.checkIntersection(seg1, seg2);
      var i = segmentsIntersect(seg1.data, seg2.data, false);
      if (i === null) {
        // no intersections
        return null;
      } else if (i.kind === "tRangePairs") {
        // segments are parallel or coincident
        var _i$tStart = _slicedToArray(i.tStart, 2),
          tA1 = _i$tStart[0],
          tB1 = _i$tStart[1],
          _i$tEnd = _slicedToArray(i.tEnd, 2),
          tA2 = _i$tEnd[0],
          tB2 = _i$tEnd[1];
        if (tA1 === 1 && tA2 === 1 && tB1 === 0 && tB2 === 0 || tA1 === 0 && tA2 === 0 && tB1 === 1 && tB2 === 1) {
          return null; // segments touch at endpoints... no intersection
        }
        if (tA1 === 0 && tA2 === 1 && tB1 === 0 && tB2 === 1) {
          return ev2; // segments are exactly equal
        }
        var a1 = seg1.data.start();
        var a2 = seg1.data.end();
        var b2 = seg2.data.end();
        if (tA1 === 0 && tB1 === 0) {
          if (tA2 === 1) {
            //  (a1)---(a2)
            //  (b1)----------(b2)
            this.divideEvent(ev2, tB2, a2);
          } else {
            //  (a1)----------(a2)
            //  (b1)---(b2)
            this.divideEvent(ev1, tA2, b2);
          }
          return ev2;
        } else if (tB1 > 0 && tB1 < 1) {
          if (tA2 === 1 && tB2 === 1) {
            //         (a1)---(a2)
            //  (b1)----------(b2)
            this.divideEvent(ev2, tB1, a1);
          } else {
            // make a2 equal to b2
            if (tA2 === 1) {
              //         (a1)---(a2)
              //  (b1)-----------------(b2)
              this.divideEvent(ev2, tB2, a2);
            } else {
              //         (a1)----------(a2)
              //  (b1)----------(b2)
              this.divideEvent(ev1, tA2, b2);
            }
            //         (a1)---(a2)
            //  (b1)----------(b2)
            this.divideEvent(ev2, tB1, a1);
          }
        }
        return null;
      } else if (i.kind === "tValuePairs") {
        if (i.tValuePairs.length <= 0) {
          return null;
        }
        // process a single intersection
        // skip intersections where endpoints meet
        var minPair = i.tValuePairs[0];
        for (var j = 1; j < i.tValuePairs.length && (minPair[0] === 0 && minPair[1] === 0 || minPair[0] === 0 && minPair[1] === 1 || minPair[0] === 1 && minPair[1] === 0 || minPair[0] === 1 && minPair[1] === 1); j++) {
          minPair = i.tValuePairs[j];
        }
        var _minPair = minPair,
          _minPair2 = _slicedToArray(_minPair, 2),
          tA = _minPair2[0],
          tB = _minPair2[1];
        // even though *in theory* seg1.data.point(tA) === seg2.data.point(tB), that isn't exactly
        // correct in practice because intersections aren't exact... so we need to calculate a single
        // intersection point that everyone can share
        var p = tB === 0 ? seg2.data.start() : tB === 1 ? seg2.data.end() : tA === 0 ? seg1.data.start() : tA === 1 ? seg1.data.end() : seg1.data.point(tA);
        // is A divided between its endpoints? (exclusive)
        if (tA > 0 && tA < 1) {
          this.divideEvent(ev1, tA, p);
        }
        // is B divided between its endpoints? (exclusive)
        if (tB > 0 && tB < 1) {
          this.divideEvent(ev2, tB, p);
        }
        return null;
      }
      throw new Error("PolyBool: Unknown intersection type");
    }
  }, {
    key: "calculate",
    value: function calculate() {
      var _this0 = this;
      var _a, _b, _c, _d, _e, _f, _g, _h;
      var segments = [];
      var _loop = function _loop() {
        var ev = _this0.events.getHead();
        (_a = _this0.log) === null || _a === void 0 ? void 0 : _a.vert(ev.p[0]);
        if (ev.isStart) {
          (_b = _this0.log) === null || _b === void 0 ? void 0 : _b.segmentNew(ev.seg, ev.primary);
          var surrounding = _this0.statusFindSurrounding(ev);
          var above = surrounding.before;
          var below = surrounding.after;
          (_c = _this0.log) === null || _c === void 0 ? void 0 : _c.tempStatus(ev.seg, above ? above.seg : false, below ? below.seg : false);
          var checkBothIntersections = function checkBothIntersections() {
            if (above) {
              var _eve = _this0.checkIntersection(ev, above);
              if (_eve) {
                return _eve;
              }
            }
            if (below) {
              return _this0.checkIntersection(ev, below);
            }
            return null;
          };
          var eve = checkBothIntersections();
          if (eve) {
            // ev and eve are equal
            // we'll keep eve and throw away ev
            // merge ev.seg's fill information into eve.seg
            if (_this0.selfIntersection) {
              var toggle; // are we a toggling edge?
              if (ev.seg.myFill.below === null) {
                toggle = ev.seg.closed;
              } else {
                toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
              }
              // merge two segments that belong to the same polygon
              // think of this as sandwiching two segments together, where
              // `eve.seg` is the bottom -- this will cause the above fill flag to
              // toggle
              if (toggle) {
                eve.seg.myFill.above = !eve.seg.myFill.above;
              }
            } else {
              // merge two segments that belong to different polygons
              // each segment has distinct knowledge, so no special logic is
              // needed
              // note that this can only happen once per segment in this phase,
              // because we are guaranteed that all self-intersections are gone
              eve.seg.otherFill = ev.seg.myFill;
            }
            (_d = _this0.log) === null || _d === void 0 ? void 0 : _d.segmentUpdate(eve.seg);
            _this0.events.remove(ev.other);
            _this0.events.remove(ev);
          }
          if (_this0.events.getHead() !== ev) {
            // something was inserted before us in the event queue, so loop back
            // around and process it before continuing
            (_e = _this0.log) === null || _e === void 0 ? void 0 : _e.rewind(ev.seg);
            return 1; // continue
          }
          //
          // calculate fill flags
          //
          if (_this0.selfIntersection) {
            var _toggle; // are we a toggling edge?
            if (ev.seg.myFill.below === null) {
              // if we are new then we toggle if we're part of a closed path
              _toggle = ev.seg.closed;
            } else {
              // we are a segment that has previous knowledge from a division
              // calculate toggle
              _toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
            }
            // next, calculate whether we are filled below us
            if (!below) {
              // if nothing is below us, then we're not filled
              ev.seg.myFill.below = false;
            } else {
              // otherwise, we know the answer -- it's the same if whatever is
              // below us is filled above it
              ev.seg.myFill.below = below.seg.myFill.above;
            }
            // since now we know if we're filled below us, we can calculate
            // whether we're filled above us by applying toggle to whatever is
            // below us
            ev.seg.myFill.above = _toggle ? !ev.seg.myFill.below : ev.seg.myFill.below;
          } else {
            // now we fill in any missing transition information, since we are
            // all-knowing at this point
            if (ev.seg.otherFill === null) {
              // if we don't have other information, then we need to figure out if
              // we're inside the other polygon
              var inside;
              if (!below) {
                // if nothing is below us, then we're not filled
                inside = false;
              } else {
                // otherwise, something is below us
                // so copy the below segment's other polygon's above
                if (ev.primary === below.primary) {
                  if (below.seg.otherFill === null) {
                    throw new Error("PolyBool: Unexpected state of otherFill (null)");
                  }
                  inside = below.seg.otherFill.above;
                } else {
                  inside = below.seg.myFill.above;
                }
              }
              ev.seg.otherFill = {
                above: inside,
                below: inside
              };
            }
          }
          (_f = _this0.log) === null || _f === void 0 ? void 0 : _f.status(ev.seg, above ? above.seg : false, below ? below.seg : false);
          // insert the status and remember it for later removal
          ev.other.status = surrounding.insert(ev);
        } else {
          // end
          var st = ev.status;
          if (st === null) {
            throw new Error("PolyBool: Zero-length segment detected; your epsilon is " + "probably too small or too large");
          }
          // removing the status will create two new adjacent edges, so we'll need
          // to check for those
          var i = _this0.status.getIndex(st);
          if (i > 0 && i < _this0.status.nodes.length - 1) {
            var before = _this0.status.nodes[i - 1];
            var after = _this0.status.nodes[i + 1];
            _this0.checkIntersection(before, after);
          }
          (_g = _this0.log) === null || _g === void 0 ? void 0 : _g.statusRemove(st.seg);
          // remove the status
          _this0.status.remove(st);
          // if we've reached this point, we've calculated everything there is to
          // know, so save the segment for reporting
          if (!ev.primary) {
            // make sure `seg.myFill` actually points to the primary polygon
            // though
            if (!ev.seg.otherFill) {
              throw new Error("PolyBool: Unexpected state of otherFill (null)");
            }
            var s = ev.seg.myFill;
            ev.seg.myFill = ev.seg.otherFill;
            ev.seg.otherFill = s;
          }
          segments.push(ev.seg);
        }
        // remove the event and continue
        _this0.events.removeHead();
      };
      while (!this.events.isEmpty()) {
        if (_loop()) continue;
      }
      (_h = this.log) === null || _h === void 0 ? void 0 : _h.done();
      return segments;
    }
  }]);
}(); //
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
//
// filter a list of segments based on boolean operations
//
function select(segments, selection, log) {
  var result = [];
  var _iterator13 = _createForOfIteratorHelper(segments),
    _step13;
  try {
    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
      var seg = _step13.value;
      var index = (seg.myFill.above ? 8 : 0) + (seg.myFill.below ? 4 : 0) + (seg.otherFill && seg.otherFill.above ? 2 : 0) + (seg.otherFill && seg.otherFill.below ? 1 : 0);
      var flags = selection[index];
      var above = (flags & 1) !== 0; // bit 1 if filled above
      var below = (flags & 2) !== 0; // bit 2 if filled below
      if (!seg.closed && flags !== 0 || seg.closed && above !== below) {
        // copy the segment to the results, while also calculating the fill status
        var fill = {
          above: above,
          below: below
        };
        if (seg instanceof SegmentBoolLine) {
          result.push(new SegmentBoolLine(seg.data, fill, seg.closed, log));
        } else if (seg instanceof SegmentBoolCurve) {
          result.push(new SegmentBoolCurve(seg.data, fill, seg.closed, log));
        } else {
          throw new Error("PolyBool: Unknown SegmentBool type in SegmentSelector");
        }
      }
    }
  } catch (err) {
    _iterator13.e(err);
  } finally {
    _iterator13.f();
  }
  log === null || log === void 0 ? void 0 : log.selected(result);
  return result;
}
var SegmentSelector = /*#__PURE__*/function () {
  function SegmentSelector() {
    _classCallCheck(this, SegmentSelector);
  }
  return _createClass(SegmentSelector, null, [{
    key: "union",
    value:
    // prettier-ignore
    function union(segments, log) {
      // primary | secondary
      // above1 below1 above2 below2    Keep?               Value
      //    0      0      0      0   =>   yes if open         4
      //    0      0      0      1   =>   yes filled below    2
      //    0      0      1      0   =>   yes filled above    1
      //    0      0      1      1   =>   no                  0
      //    0      1      0      0   =>   yes filled below    2
      //    0      1      0      1   =>   yes filled below    2
      //    0      1      1      0   =>   no                  0
      //    0      1      1      1   =>   no                  0
      //    1      0      0      0   =>   yes filled above    1
      //    1      0      0      1   =>   no                  0
      //    1      0      1      0   =>   yes filled above    1
      //    1      0      1      1   =>   no                  0
      //    1      1      0      0   =>   no                  0
      //    1      1      0      1   =>   no                  0
      //    1      1      1      0   =>   no                  0
      //    1      1      1      1   =>   no                  0
      return select(segments, [4, 2, 1, 0, 2, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], log);
    }
    // prettier-ignore
  }, {
    key: "intersect",
    value: function intersect(segments, log) {
      // primary & secondary
      // above1 below1 above2 below2    Keep?               Value
      //    0      0      0      0   =>   no                  0
      //    0      0      0      1   =>   no                  0
      //    0      0      1      0   =>   no                  0
      //    0      0      1      1   =>   yes if open         4
      //    0      1      0      0   =>   no                  0
      //    0      1      0      1   =>   yes filled below    2
      //    0      1      1      0   =>   no                  0
      //    0      1      1      1   =>   yes filled below    2
      //    1      0      0      0   =>   no                  0
      //    1      0      0      1   =>   no                  0
      //    1      0      1      0   =>   yes filled above    1
      //    1      0      1      1   =>   yes filled above    1
      //    1      1      0      0   =>   yes if open         4
      //    1      1      0      1   =>   yes filled below    2
      //    1      1      1      0   =>   yes filled above    1
      //    1      1      1      1   =>   no                  0
      return select(segments, [0, 0, 0, 4, 0, 2, 0, 2, 0, 0, 1, 1, 4, 2, 1, 0], log);
    }
    // prettier-ignore
  }, {
    key: "difference",
    value: function difference(segments, log) {
      // primary - secondary
      // above1 below1 above2 below2    Keep?               Value
      //    0      0      0      0   =>   yes if open         4
      //    0      0      0      1   =>   no                  0
      //    0      0      1      0   =>   no                  0
      //    0      0      1      1   =>   no                  0
      //    0      1      0      0   =>   yes filled below    2
      //    0      1      0      1   =>   no                  0
      //    0      1      1      0   =>   yes filled below    2
      //    0      1      1      1   =>   no                  0
      //    1      0      0      0   =>   yes filled above    1
      //    1      0      0      1   =>   yes filled above    1
      //    1      0      1      0   =>   no                  0
      //    1      0      1      1   =>   no                  0
      //    1      1      0      0   =>   no                  0
      //    1      1      0      1   =>   yes filled above    1
      //    1      1      1      0   =>   yes filled below    2
      //    1      1      1      1   =>   no                  0
      return select(segments, [4, 0, 0, 0, 2, 0, 2, 0, 1, 1, 0, 0, 0, 1, 2, 0], log);
    }
    // prettier-ignore
  }, {
    key: "differenceRev",
    value: function differenceRev(segments, log) {
      // secondary - primary
      // above1 below1 above2 below2    Keep?               Value
      //    0      0      0      0   =>   yes if open         4
      //    0      0      0      1   =>   yes filled below    2
      //    0      0      1      0   =>   yes filled above    1
      //    0      0      1      1   =>   no                  0
      //    0      1      0      0   =>   no                  0
      //    0      1      0      1   =>   no                  0
      //    0      1      1      0   =>   yes filled above    1
      //    0      1      1      1   =>   yes filled above    1
      //    1      0      0      0   =>   no                  0
      //    1      0      0      1   =>   yes filled below    2
      //    1      0      1      0   =>   no                  0
      //    1      0      1      1   =>   yes filled below    2
      //    1      1      0      0   =>   no                  0
      //    1      1      0      1   =>   no                  0
      //    1      1      1      0   =>   no                  0
      //    1      1      1      1   =>   no                  0
      return select(segments, [4, 2, 1, 0, 0, 0, 1, 1, 0, 2, 0, 2, 0, 0, 0, 0], log);
    }
    // prettier-ignore
  }, {
    key: "xor",
    value: function xor(segments, log) {
      // primary ^ secondary
      // above1 below1 above2 below2    Keep?               Value
      //    0      0      0      0   =>   yes if open         4
      //    0      0      0      1   =>   yes filled below    2
      //    0      0      1      0   =>   yes filled above    1
      //    0      0      1      1   =>   no                  0
      //    0      1      0      0   =>   yes filled below    2
      //    0      1      0      1   =>   no                  0
      //    0      1      1      0   =>   no                  0
      //    0      1      1      1   =>   yes filled above    1
      //    1      0      0      0   =>   yes filled above    1
      //    1      0      0      1   =>   no                  0
      //    1      0      1      0   =>   no                  0
      //    1      0      1      1   =>   yes filled below    2
      //    1      1      0      0   =>   no                  0
      //    1      1      0      1   =>   yes filled above    1
      //    1      1      1      0   =>   yes filled below    2
      //    1      1      1      1   =>   no                  0
      return select(segments, [4, 2, 1, 0, 2, 0, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0], log);
    }
  }]);
}(); //
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
function joinLines(seg1, seg2, geo) {
  if (geo.isCollinear(seg1.p0, seg1.p1, seg2.p1)) {
    return new SegmentLine(seg1.p0, seg2.p1, geo);
  }
  return false;
}
function joinCurves(seg1, seg2, geo) {
  if (geo.isCollinear(seg1.p2, seg1.p3, seg2.p1)) {
    var dx = seg2.p1[0] - seg1.p2[0];
    var dy = seg2.p1[1] - seg1.p2[1];
    var t = Math.abs(dx) > Math.abs(dy) ? (seg1.p3[0] - seg1.p2[0]) / dx : (seg1.p3[1] - seg1.p2[1]) / dy;
    var ts = geo.snap01(t);
    if (ts !== 0 && ts !== 1) {
      var ns = new SegmentCurve(seg1.p0, [seg1.p0[0] + (seg1.p1[0] - seg1.p0[0]) / t, seg1.p0[1] + (seg1.p1[1] - seg1.p0[1]) / t], [seg2.p2[0] - t * (seg2.p3[0] - seg2.p2[0]) / (1 - t), seg2.p2[1] - t * (seg2.p3[1] - seg2.p2[1]) / (1 - t)], seg2.p3, geo);
      // double check that if we split at T, we get seg1/seg2 back
      var _ns$split = ns.split([t]),
        _ns$split2 = _slicedToArray(_ns$split, 2),
        left = _ns$split2[0],
        right = _ns$split2[1];
      if (left.isEqual(seg1) && right.isEqual(seg2)) {
        return ns;
      }
    }
  }
  return false;
}
function joinSegments(seg1, seg2, geo) {
  if (seg1 === seg2) {
    return false;
  }
  if (seg1 instanceof SegmentLine && seg2 instanceof SegmentLine) {
    return joinLines(seg1, seg2, geo);
  }
  if (seg1 instanceof SegmentCurve && seg2 instanceof SegmentCurve) {
    return joinCurves(seg1, seg2, geo);
  }
  return false;
}
function SegmentChainer(segments, geo, log) {
  var closedChains = [];
  var openChains = [];
  var regions = [];
  var _iterator14 = _createForOfIteratorHelper(segments),
    _step14;
  try {
    var _loop2 = function _loop2() {
      var segb = _step14.value;
      var seg = segb.data;
      var closed = segb.closed;
      var chains = closed ? closedChains : openChains;
      var pt1 = seg.start();
      var pt2 = seg.end();
      var reverseChain = function reverseChain(index) {
        log === null || log === void 0 ? void 0 : log.chainReverse(index, closed);
        var newChain = [];
        var _iterator15 = _createForOfIteratorHelper(chains[index].segs),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var _seg = _step15.value;
            newChain.unshift(_seg.reverse());
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
        chains[index] = {
          segs: newChain,
          fill: !chains[index].fill
        };
        return newChain;
      };
      if (seg instanceof SegmentLine && geo.isEqualVec2(pt1, pt2)) {
        console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is " + "probably too small or too large");
        return 1; // continue
      }
      log === null || log === void 0 ? void 0 : log.chainStart({
        seg: seg,
        fill: !!segb.myFill.above
      }, closed);
      // search for two chains that this segment matches
      var firstMatch = {
        index: 0,
        matchesHead: false,
        matchesPt1: false
      };
      var secondMatch = {
        index: 0,
        matchesHead: false,
        matchesPt1: false
      };
      var nextMatch = firstMatch;
      function setMatch(index, matchesHead, matchesPt1) {
        // return true if we've matched twice
        if (nextMatch) {
          nextMatch.index = index;
          nextMatch.matchesHead = matchesHead;
          nextMatch.matchesPt1 = matchesPt1;
        }
        if (nextMatch === firstMatch) {
          nextMatch = secondMatch;
          return false;
        }
        nextMatch = null;
        return true; // we've matched twice, we're done here
      }
      for (var i = 0; i < chains.length; i++) {
        var chain = chains[i].segs;
        var head = chain[0].start();
        var tail = chain[chain.length - 1].end();
        if (geo.isEqualVec2(head, pt1)) {
          if (setMatch(i, true, true)) {
            break;
          }
        } else if (geo.isEqualVec2(head, pt2)) {
          if (setMatch(i, true, false)) {
            break;
          }
        } else if (geo.isEqualVec2(tail, pt1)) {
          if (setMatch(i, false, true)) {
            break;
          }
        } else if (geo.isEqualVec2(tail, pt2)) {
          if (setMatch(i, false, false)) {
            break;
          }
        }
      }
      if (nextMatch === firstMatch) {
        // we didn't match anything, so create a new chain
        var fill = !!segb.myFill.above;
        chains.push({
          segs: [seg],
          fill: fill
        });
        log === null || log === void 0 ? void 0 : log.chainNew({
          seg: seg,
          fill: fill
        }, closed);
      } else if (nextMatch === secondMatch) {
        // we matched a single chain
        var index = firstMatch.index;
        log === null || log === void 0 ? void 0 : log.chainMatch(index, closed);
        // add the other point to the apporpriate end
        var _chains$index = chains[index],
          _chain = _chains$index.segs,
          _fill = _chains$index.fill;
        if (firstMatch.matchesHead) {
          if (firstMatch.matchesPt1) {
            seg = seg.reverse();
            log === null || log === void 0 ? void 0 : log.chainAddHead(index, {
              seg: seg,
              fill: _fill
            }, closed);
            _chain.unshift(seg);
          } else {
            log === null || log === void 0 ? void 0 : log.chainAddHead(index, {
              seg: seg,
              fill: _fill
            }, closed);
            _chain.unshift(seg);
          }
        } else {
          if (firstMatch.matchesPt1) {
            log === null || log === void 0 ? void 0 : log.chainAddTail(index, {
              seg: seg,
              fill: _fill
            }, closed);
            _chain.push(seg);
          } else {
            seg = seg.reverse();
            log === null || log === void 0 ? void 0 : log.chainAddTail(index, {
              seg: seg,
              fill: _fill
            }, closed);
            _chain.push(seg);
          }
        }
        // simplify chain
        if (firstMatch.matchesHead) {
          var next = _chain[1];
          var newSeg = joinSegments(seg, next, geo);
          if (newSeg) {
            _chain.shift();
            _chain[0] = newSeg;
            log === null || log === void 0 ? void 0 : log.chainSimplifyHead(index, {
              seg: newSeg,
              fill: _fill
            }, closed);
          }
        } else {
          var _next = _chain[_chain.length - 2];
          var _newSeg = joinSegments(_next, seg, geo);
          if (_newSeg) {
            _chain.pop();
            _chain[_chain.length - 1] = _newSeg;
            log === null || log === void 0 ? void 0 : log.chainSimplifyTail(index, {
              seg: _newSeg,
              fill: _fill
            }, closed);
          }
        }
        // check for closed chain
        if (closed) {
          var finalChain = _chain;
          var segS = finalChain[0];
          var segE = finalChain[finalChain.length - 1];
          if (finalChain.length > 0 && geo.isEqualVec2(segS.start(), segE.end())) {
            // see if chain is clockwise
            var winding = 0;
            var last = finalChain[0].start();
            var _iterator16 = _createForOfIteratorHelper(finalChain),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var _seg2 = _step16.value;
                var here = _seg2.end();
                winding += here[1] * last[0] - here[0] * last[1];
                last = here;
              }
              // this assumes Cartesian coordinates (Y is positive going up)
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            var isClockwise = winding < 0;
            if (isClockwise === _fill) {
              finalChain = reverseChain(index);
              segS = finalChain[0];
              segE = finalChain[finalChain.length - 1];
            }
            var newStart = joinSegments(segE, segS, geo);
            if (newStart) {
              finalChain.pop();
              finalChain[0] = newStart;
              log === null || log === void 0 ? void 0 : log.chainSimplifyClose(index, {
                seg: newStart,
                fill: _fill
              }, closed);
            }
            // we have a closed chain!
            log === null || log === void 0 ? void 0 : log.chainClose(index, closed);
            chains.splice(index, 1);
            regions.push(finalChain);
          }
        }
      } else {
        // otherwise, we matched two chains, so we need to combine those chains together
        var appendChain = function appendChain(index1, index2) {
          // index1 gets index2 appended to it, and index2 is removed
          var _chains$index2 = chains[index1],
            chain1 = _chains$index2.segs,
            fill = _chains$index2.fill;
          var chain2 = chains[index2].segs;
          // add seg to chain1's tail
          log === null || log === void 0 ? void 0 : log.chainAddTail(index1, {
            seg: seg,
            fill: fill
          }, closed);
          chain1.push(seg);
          // simplify chain1's tail
          var next = chain1[chain1.length - 2];
          var newEnd = joinSegments(next, seg, geo);
          if (newEnd) {
            chain1.pop();
            chain1[chain1.length - 1] = newEnd;
            log === null || log === void 0 ? void 0 : log.chainSimplifyTail(index1, {
              seg: newEnd,
              fill: fill
            }, closed);
          }
          // simplify chain2's head
          var tail = chain1[chain1.length - 1];
          var head = chain2[0];
          var newJoin = joinSegments(tail, head, geo);
          if (newJoin) {
            chain2.shift();
            chain1[chain1.length - 1] = newJoin;
            log === null || log === void 0 ? void 0 : log.chainSimplifyJoin(index1, index2, {
              seg: newJoin,
              fill: fill
            }, closed);
          }
          log === null || log === void 0 ? void 0 : log.chainJoin(index1, index2, closed);
          chains[index1].segs = chain1.concat(chain2);
          chains.splice(index2, 1);
        };
        var F = firstMatch.index;
        var S = secondMatch.index;
        log === null || log === void 0 ? void 0 : log.chainConnect(F, S, closed);
        // reverse the shorter chain, if needed
        var reverseF = chains[F].segs.length < chains[S].segs.length;
        if (firstMatch.matchesHead) {
          if (secondMatch.matchesHead) {
            if (reverseF) {
              if (!firstMatch.matchesPt1) {
                // <<<< F <<<< <-- >>>> S >>>>
                seg = seg.reverse();
              }
              // <<<< F <<<< --> >>>> S >>>>
              reverseChain(F);
              // >>>> F >>>> --> >>>> S >>>>
              appendChain(F, S);
            } else {
              if (firstMatch.matchesPt1) {
                // <<<< F <<<< --> >>>> S >>>>
                seg = seg.reverse();
              }
              // <<<< F <<<< <-- >>>> S >>>>
              reverseChain(S);
              // <<<< F <<<< <-- <<<< S <<<<   logically same as:
              // >>>> S >>>> --> >>>> F >>>>
              appendChain(S, F);
            }
          } else {
            if (firstMatch.matchesPt1) {
              // <<<< F <<<< --> >>>> S >>>>
              seg = seg.reverse();
            }
            // <<<< F <<<< <-- <<<< S <<<<   logically same as:
            // >>>> S >>>> --> >>>> F >>>>
            appendChain(S, F);
          }
        } else {
          if (secondMatch.matchesHead) {
            if (!firstMatch.matchesPt1) {
              // >>>> F >>>> <-- >>>> S >>>>
              seg = seg.reverse();
            }
            // >>>> F >>>> --> >>>> S >>>>
            appendChain(F, S);
          } else {
            if (reverseF) {
              if (firstMatch.matchesPt1) {
                // >>>> F >>>> --> <<<< S <<<<
                seg = seg.reverse();
              }
              // >>>> F >>>> <-- <<<< S <<<<
              reverseChain(F);
              // <<<< F <<<< <-- <<<< S <<<<   logically same as:
              // >>>> S >>>> --> >>>> F >>>>
              appendChain(S, F);
            } else {
              if (!firstMatch.matchesPt1) {
                // >>>> F >>>> <-- <<<< S <<<<
                seg = seg.reverse();
              }
              // >>>> F >>>> --> <<<< S <<<<
              reverseChain(S);
              // >>>> F >>>> --> >>>> S >>>>
              appendChain(F, S);
            }
          }
        }
      }
    };
    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
      if (_loop2()) continue;
    }
  } catch (err) {
    _iterator14.e(err);
  } finally {
    _iterator14.f();
  }
  for (var _i = 0, _openChains = openChains; _i < _openChains.length; _i++) {
    var segs = _openChains[_i].segs;
    regions.push(segs);
  }
  return regions;
}
function segmentsToReceiver(segments, geo, receiver, matrix) {
  var _matrix = _slicedToArray(matrix, 6),
    a = _matrix[0],
    b = _matrix[1],
    c = _matrix[2],
    d = _matrix[3],
    e = _matrix[4],
    f = _matrix[5];
  receiver.beginPath();
  var _iterator17 = _createForOfIteratorHelper(segments),
    _step17;
  try {
    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
      var region = _step17.value;
      if (region.length <= 0) {
        continue;
      }
      for (var i = 0; i < region.length; i++) {
        var seg = region[i];
        if (i === 0) {
          var _seg$start = seg.start(),
            _seg$start2 = _slicedToArray(_seg$start, 2),
            p0x = _seg$start2[0],
            p0y = _seg$start2[1];
          receiver.moveTo(a * p0x + c * p0y + e, b * p0x + d * p0y + f);
        }
        if (seg instanceof SegmentLine) {
          var _seg$p = _slicedToArray(seg.p1, 2),
            p1x = _seg$p[0],
            p1y = _seg$p[1];
          receiver.lineTo(a * p1x + c * p1y + e, b * p1x + d * p1y + f);
        } else if (seg instanceof SegmentCurve) {
          var _seg$p2 = _slicedToArray(seg.p1, 2),
            _p1x = _seg$p2[0],
            _p1y = _seg$p2[1];
          var _seg$p3 = _slicedToArray(seg.p2, 2),
            p2x = _seg$p3[0],
            p2y = _seg$p3[1];
          var _seg$p4 = _slicedToArray(seg.p3, 2),
            p3x = _seg$p4[0],
            p3y = _seg$p4[1];
          receiver.bezierCurveTo(a * _p1x + c * _p1y + e, b * _p1x + d * _p1y + f, a * p2x + c * p2y + e, b * p2x + d * p2y + f, a * p3x + c * p3y + e, b * p3x + d * p3y + f);
        } else {
          throw new Error("PolyBool: Unknown segment instance");
        }
      }
      var first = region[0];
      var last = region[region.length - 1];
      if (geo.isEqualVec2(first.start(), last.end())) {
        receiver.closePath();
      }
    }
  } catch (err) {
    _iterator17.e(err);
  } finally {
    _iterator17.f();
  }
  return receiver;
}

//
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
var Shape = /*#__PURE__*/function () {
  function Shape(geo) {
    var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    _classCallCheck(this, Shape);
    this.pathState = {
      kind: "beginPath"
    };
    this.saveStack = [];
    this.matrix = [1, 0, 0, 1, 0, 0];
    this.geo = geo;
    this.log = log;
    if (segments) {
      this.resultState = {
        state: "seg",
        segments: segments
      };
    } else {
      this.resultState = {
        state: "new",
        selfIntersect: new Intersecter(true, this.geo, this.log)
      };
    }
  }
  return _createClass(Shape, [{
    key: "setTransform",
    value: function setTransform(a, b, c, d, e, f) {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      this.matrix = [a, b, c, d, e, f];
      return this;
    }
  }, {
    key: "resetTransform",
    value: function resetTransform() {
      this.matrix = [1, 0, 0, 1, 0, 0];
      return this;
    }
  }, {
    key: "getTransform",
    value: function getTransform() {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      var _this$matrix = _slicedToArray(this.matrix, 6),
        a = _this$matrix[0],
        b = _this$matrix[1],
        c = _this$matrix[2],
        d = _this$matrix[3],
        e = _this$matrix[4],
        f = _this$matrix[5];
      return {
        a: a,
        b: b,
        c: c,
        d: d,
        e: e,
        f: f
      };
    }
  }, {
    key: "transform",
    value: function transform(a, b, c, d, e, f) {
      var _this$matrix2 = _slicedToArray(this.matrix, 6),
        a0 = _this$matrix2[0],
        b0 = _this$matrix2[1],
        c0 = _this$matrix2[2],
        d0 = _this$matrix2[3],
        e0 = _this$matrix2[4],
        f0 = _this$matrix2[5];
      this.matrix = [a0 * a + c0 * b, b0 * a + d0 * b, a0 * c + c0 * d, b0 * c + d0 * d, a0 * e + c0 * f + e0, b0 * e + d0 * f + f0];
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate(angle) {
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var _this$matrix3 = _slicedToArray(this.matrix, 6),
        a0 = _this$matrix3[0],
        b0 = _this$matrix3[1],
        c0 = _this$matrix3[2],
        d0 = _this$matrix3[3],
        e0 = _this$matrix3[4],
        f0 = _this$matrix3[5];
      this.matrix = [a0 * cos + c0 * sin, b0 * cos + d0 * sin, c0 * cos - a0 * sin, d0 * cos - b0 * sin, e0, f0];
      return this;
    }
  }, {
    key: "rotateDeg",
    value: function rotateDeg(angle) {
      var ang = (angle % 360 + 360) % 360;
      if (ang === 0) {
        return this;
      }
      var cos = 0;
      var sin = 0;
      if (ang === 90) {
        sin = 1;
      } else if (ang === 180) {
        cos = -1;
      } else if (ang === 270) {
        sin = -1;
      } else if (ang === 45) {
        cos = sin = Math.SQRT1_2;
      } else if (ang === 135) {
        sin = Math.SQRT1_2;
        cos = -Math.SQRT1_2;
      } else if (ang === 225) {
        cos = sin = -Math.SQRT1_2;
      } else if (ang === 315) {
        cos = Math.SQRT1_2;
        sin = -Math.SQRT1_2;
      } else if (ang === 30) {
        cos = Math.sqrt(3) / 2;
        sin = 0.5;
      } else if (ang === 60) {
        cos = 0.5;
        sin = Math.sqrt(3) / 2;
      } else if (ang === 120) {
        cos = -0.5;
        sin = Math.sqrt(3) / 2;
      } else if (ang === 150) {
        cos = -Math.sqrt(3) / 2;
        sin = 0.5;
      } else if (ang === 210) {
        cos = -Math.sqrt(3) / 2;
        sin = -0.5;
      } else if (ang === 240) {
        cos = -0.5;
        sin = -Math.sqrt(3) / 2;
      } else if (ang === 300) {
        cos = 0.5;
        sin = -Math.sqrt(3) / 2;
      } else if (ang === 330) {
        cos = Math.sqrt(3) / 2;
        sin = -0.5;
      } else {
        var rad = Math.PI * ang / 180;
        cos = Math.cos(rad);
        sin = Math.sin(rad);
      }
      var _this$matrix4 = _slicedToArray(this.matrix, 6),
        a0 = _this$matrix4[0],
        b0 = _this$matrix4[1],
        c0 = _this$matrix4[2],
        d0 = _this$matrix4[3],
        e0 = _this$matrix4[4],
        f0 = _this$matrix4[5];
      this.matrix = [a0 * cos + c0 * sin, b0 * cos + d0 * sin, c0 * cos - a0 * sin, d0 * cos - b0 * sin, e0, f0];
      return this;
    }
  }, {
    key: "scale",
    value: function scale(sx, sy) {
      var _this$matrix5 = _slicedToArray(this.matrix, 6),
        a0 = _this$matrix5[0],
        b0 = _this$matrix5[1],
        c0 = _this$matrix5[2],
        d0 = _this$matrix5[3],
        e0 = _this$matrix5[4],
        f0 = _this$matrix5[5];
      this.matrix = [a0 * sx, b0 * sx, c0 * sy, d0 * sy, e0, f0];
      return this;
    }
  }, {
    key: "translate",
    value: function translate(tx, ty) {
      var _this$matrix6 = _slicedToArray(this.matrix, 6),
        a0 = _this$matrix6[0],
        b0 = _this$matrix6[1],
        c0 = _this$matrix6[2],
        d0 = _this$matrix6[3],
        e0 = _this$matrix6[4],
        f0 = _this$matrix6[5];
      this.matrix = [a0, b0, c0, d0, a0 * tx + c0 * ty + e0, b0 * tx + d0 * ty + f0];
      return this;
    }
  }, {
    key: "save",
    value: function save() {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      this.saveStack.push({
        matrix: this.matrix
      });
      return this;
    }
  }, {
    key: "restore",
    value: function restore() {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      var s = this.saveStack.pop();
      if (s) {
        this.matrix = s.matrix;
      }
      return this;
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(x, y) {
      var _this$matrix7 = _slicedToArray(this.matrix, 6),
        a = _this$matrix7[0],
        b = _this$matrix7[1],
        c = _this$matrix7[2],
        d = _this$matrix7[3],
        e = _this$matrix7[4],
        f = _this$matrix7[5];
      return [a * x + c * y + e, b * x + d * y + f];
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      this.resultState.selfIntersect.beginPath();
      return this.endPath();
    }
  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      if (this.pathState.kind !== "beginPath") {
        this.beginPath();
      }
      var current = this.transformPoint(x, y);
      this.pathState = {
        kind: "moveTo",
        start: current,
        current: current
      };
      return this;
    }
  }, {
    key: "lineTo",
    value: function lineTo(x, y) {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      if (this.pathState.kind !== "moveTo") {
        throw new Error("PolyBool: Must call moveTo prior to calling lineTo");
      }
      var current = this.transformPoint(x, y);
      this.resultState.selfIntersect.addLine(this.pathState.current, current);
      this.pathState.current = current;
      return this;
    }
  }, {
    key: "rect",
    value: function rect(x, y, width, height) {
      return this.moveTo(x, y).lineTo(x + width, y).lineTo(x + width, y + height).lineTo(x, y + height).closePath().moveTo(x, y);
    }
  }, {
    key: "bezierCurveTo",
    value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      if (this.pathState.kind !== "moveTo") {
        throw new Error("PolyBool: Must call moveTo prior to calling bezierCurveTo");
      }
      var current = this.transformPoint(x, y);
      this.resultState.selfIntersect.addCurve(this.pathState.current, this.transformPoint(cp1x, cp1y), this.transformPoint(cp2x, cp2y), current);
      this.pathState.current = current;
      return this;
    }
  }, {
    key: "closePath",
    value: function closePath() {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      // close with a line if needed
      if (this.pathState.kind === "moveTo" && !this.geo.isEqualVec2(this.pathState.start, this.pathState.current)) {
        this.resultState.selfIntersect.addLine(this.pathState.current, this.pathState.start);
        this.pathState.current = this.pathState.start;
      }
      this.resultState.selfIntersect.closePath();
      return this.endPath();
    }
  }, {
    key: "endPath",
    value: function endPath() {
      if (this.resultState.state !== "new") {
        throw new Error("PolyBool: Cannot change shape after using it in an operation");
      }
      this.pathState = {
        kind: "beginPath"
      };
      return this;
    }
  }, {
    key: "selfIntersect",
    value: function selfIntersect() {
      if (this.resultState.state === "new") {
        this.resultState = {
          state: "seg",
          segments: this.resultState.selfIntersect.calculate()
        };
      }
      return this.resultState.segments;
    }
  }, {
    key: "segments",
    value: function segments() {
      if (this.resultState.state !== "reg") {
        var seg = this.selfIntersect();
        this.resultState = {
          state: "reg",
          segments: seg,
          regions: SegmentChainer(seg, this.geo, this.log)
        };
      }
      return this.resultState.regions;
    }
  }, {
    key: "output",
    value: function output(receiver) {
      var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 0, 0, 1, 0, 0];
      return segmentsToReceiver(this.segments(), this.geo, receiver, matrix);
    }
  }, {
    key: "combine",
    value: function combine(shape) {
      var int = new Intersecter(false, this.geo, this.log);
      var _iterator18 = _createForOfIteratorHelper(this.selfIntersect()),
        _step18;
      try {
        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
          var seg = _step18.value;
          int.addSegment(copySegmentBool(seg, this.log), true);
        }
      } catch (err) {
        _iterator18.e(err);
      } finally {
        _iterator18.f();
      }
      var _iterator19 = _createForOfIteratorHelper(shape.selfIntersect()),
        _step19;
      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var _seg3 = _step19.value;
          int.addSegment(copySegmentBool(_seg3, this.log), false);
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }
      return new ShapeCombined(int.calculate(), this.geo, this.log);
    }
  }]);
}();
var ShapeCombined = /*#__PURE__*/function () {
  function ShapeCombined(segments, geo) {
    var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    _classCallCheck(this, ShapeCombined);
    this.geo = geo;
    this.segments = segments;
    this.log = log;
  }
  return _createClass(ShapeCombined, [{
    key: "union",
    value: function union() {
      return new Shape(this.geo, SegmentSelector.union(this.segments, this.log), this.log);
    }
  }, {
    key: "intersect",
    value: function intersect() {
      return new Shape(this.geo, SegmentSelector.intersect(this.segments, this.log), this.log);
    }
  }, {
    key: "difference",
    value: function difference() {
      return new Shape(this.geo, SegmentSelector.difference(this.segments, this.log), this.log);
    }
  }, {
    key: "differenceRev",
    value: function differenceRev() {
      return new Shape(this.geo, SegmentSelector.differenceRev(this.segments, this.log), this.log);
    }
  }, {
    key: "xor",
    value: function xor() {
      return new Shape(this.geo, SegmentSelector.xor(this.segments, this.log), this.log);
    }
  }]);
}(); //
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
var BuildLog = /*#__PURE__*/function () {
  function BuildLog() {
    _classCallCheck(this, BuildLog);
    this.list = [];
    this.nextSegmentId = 0;
    this.curVert = NaN;
  }
  return _createClass(BuildLog, [{
    key: "push",
    value: function push(type, data) {
      this.list.push({
        type: type,
        data: JSON.parse(JSON.stringify(data))
      });
    }
  }, {
    key: "info",
    value: function info(msg, data) {
      this.push("info", {
        msg: msg,
        data: data
      });
    }
  }, {
    key: "segmentId",
    value: function segmentId() {
      return this.nextSegmentId++;
    }
  }, {
    key: "checkIntersection",
    value: function checkIntersection(seg1, seg2) {
      this.push("check", {
        seg1: seg1,
        seg2: seg2
      });
    }
  }, {
    key: "segmentDivide",
    value: function segmentDivide(seg, p) {
      this.push("div_seg", {
        seg: seg,
        p: p
      });
    }
  }, {
    key: "segmentChop",
    value: function segmentChop(seg) {
      this.push("chop", {
        seg: seg
      });
    }
  }, {
    key: "statusRemove",
    value: function statusRemove(seg) {
      this.push("pop_seg", {
        seg: seg
      });
    }
  }, {
    key: "segmentUpdate",
    value: function segmentUpdate(seg) {
      this.push("seg_update", {
        seg: seg
      });
    }
  }, {
    key: "segmentNew",
    value: function segmentNew(seg, primary) {
      this.push("new_seg", {
        seg: seg,
        primary: primary
      });
    }
  }, {
    key: "tempStatus",
    value: function tempStatus(seg, above, below) {
      this.push("temp_status", {
        seg: seg,
        above: above,
        below: below
      });
    }
  }, {
    key: "rewind",
    value: function rewind(seg) {
      this.push("rewind", {
        seg: seg
      });
    }
  }, {
    key: "status",
    value: function status(seg, above, below) {
      this.push("status", {
        seg: seg,
        above: above,
        below: below
      });
    }
  }, {
    key: "vert",
    value: function vert(x) {
      if (x !== this.curVert) {
        this.push("vert", {
          x: x
        });
        this.curVert = x;
      }
    }
  }, {
    key: "selected",
    value: function selected(segs) {
      this.push("selected", {
        segs: segs
      });
    }
  }, {
    key: "chainStart",
    value: function chainStart(sf, closed) {
      this.push("chain_start", {
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainNew",
    value: function chainNew(sf, closed) {
      this.push("chain_new", {
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainMatch",
    value: function chainMatch(index, closed) {
      this.push("chain_match", {
        index: index,
        closed: closed
      });
    }
  }, {
    key: "chainClose",
    value: function chainClose(index, closed) {
      this.push("chain_close", {
        index: index,
        closed: closed
      });
    }
  }, {
    key: "chainAddHead",
    value: function chainAddHead(index, sf, closed) {
      this.push("chain_add_head", {
        index: index,
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainAddTail",
    value: function chainAddTail(index, sf, closed) {
      this.push("chain_add_tail", {
        index: index,
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainSimplifyHead",
    value: function chainSimplifyHead(index, sf, closed) {
      this.push("chain_simp_head", {
        index: index,
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainSimplifyTail",
    value: function chainSimplifyTail(index, sf, closed) {
      this.push("chain_simp_tail", {
        index: index,
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainSimplifyClose",
    value: function chainSimplifyClose(index, sf, closed) {
      this.push("chain_simp_close", {
        index: index,
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainSimplifyJoin",
    value: function chainSimplifyJoin(index1, index2, sf, closed) {
      this.push("chain_simp_join", {
        index1: index1,
        index2: index2,
        sf: sf,
        closed: closed
      });
    }
  }, {
    key: "chainConnect",
    value: function chainConnect(index1, index2, closed) {
      this.push("chain_con", {
        index1: index1,
        index2: index2,
        closed: closed
      });
    }
  }, {
    key: "chainReverse",
    value: function chainReverse(index, closed) {
      this.push("chain_rev", {
        index: index,
        closed: closed
      });
    }
  }, {
    key: "chainJoin",
    value: function chainJoin(index1, index2, closed) {
      this.push("chain_join", {
        index1: index1,
        index2: index2,
        closed: closed
      });
    }
  }, {
    key: "done",
    value: function done() {
      this.push("done", null);
    }
  }]);
}(); //
// polybool - Boolean operations on polygons (union, intersection, etc)
// by Sean Connelly (@velipso), https://sean.fun
// Project Home: https://github.com/velipso/polybool
// SPDX-License-Identifier: 0BSD
//
var PolyBool = /*#__PURE__*/function () {
  function PolyBool() {
    var geo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new GeometryEpsilon();
    var log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    _classCallCheck(this, PolyBool);
    this.geo = geo;
    this.log = log;
  }
  return _createClass(PolyBool, [{
    key: "shape",
    value: function shape() {
      return new Shape(this.geo, null, this.log);
    }
  }, {
    key: "buildLog",
    value: function buildLog(enable) {
      var _a;
      this.log = enable ? new BuildLog() : null;
      return (_a = this.log) === null || _a === void 0 ? void 0 : _a.list;
    }
  }, {
    key: "segments",
    value: function segments(poly) {
      var shape = this.shape();
      shape.beginPath();
      var _iterator20 = _createForOfIteratorHelper(poly.regions),
        _step20;
      try {
        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
          var region = _step20.value;
          var lastPoint = region[region.length - 1];
          shape.moveTo(lastPoint[lastPoint.length - 2], lastPoint[lastPoint.length - 1]);
          var _iterator21 = _createForOfIteratorHelper(region),
            _step21;
          try {
            for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
              var p = _step21.value;
              if (p.length === 2) {
                shape.lineTo(p[0], p[1]);
              } else if (p.length === 6) {
                shape.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
              } else {
                throw new Error("PolyBool: Invalid point in region");
              }
            }
          } catch (err) {
            _iterator21.e(err);
          } finally {
            _iterator21.f();
          }
          shape.closePath();
        }
      } catch (err) {
        _iterator20.e(err);
      } finally {
        _iterator20.f();
      }
      return {
        shape: shape,
        inverted: poly.inverted
      };
    }
  }, {
    key: "combine",
    value: function combine(segments1, segments2) {
      return {
        shape: segments1.shape.combine(segments2.shape),
        inverted1: segments1.inverted,
        inverted2: segments2.inverted
      };
    }
  }, {
    key: "selectUnion",
    value: function selectUnion(combined) {
      return {
        shape: combined.inverted1 ? combined.inverted2 ? combined.shape.intersect() : combined.shape.difference() : combined.inverted2 ? combined.shape.differenceRev() : combined.shape.union(),
        inverted: combined.inverted1 || combined.inverted2
      };
    }
  }, {
    key: "selectIntersect",
    value: function selectIntersect(combined) {
      return {
        shape: combined.inverted1 ? combined.inverted2 ? combined.shape.union() : combined.shape.differenceRev() : combined.inverted2 ? combined.shape.difference() : combined.shape.intersect(),
        inverted: combined.inverted1 && combined.inverted2
      };
    }
  }, {
    key: "selectDifference",
    value: function selectDifference(combined) {
      return {
        shape: combined.inverted1 ? combined.inverted2 ? combined.shape.differenceRev() : combined.shape.union() : combined.inverted2 ? combined.shape.intersect() : combined.shape.difference(),
        inverted: combined.inverted1 && !combined.inverted2
      };
    }
  }, {
    key: "selectDifferenceRev",
    value: function selectDifferenceRev(combined) {
      return {
        shape: combined.inverted1 ? combined.inverted2 ? combined.shape.difference() : combined.shape.intersect() : combined.inverted2 ? combined.shape.union() : combined.shape.differenceRev(),
        inverted: !combined.inverted1 && combined.inverted2
      };
    }
  }, {
    key: "selectXor",
    value: function selectXor(combined) {
      return {
        shape: combined.shape.xor(),
        inverted: combined.inverted1 !== combined.inverted2
      };
    }
  }, {
    key: "polygon",
    value: function polygon(segments) {
      var regions = [];
      var receiver = {
        beginPath: function beginPath() {},
        moveTo: function moveTo() {
          regions.push([]);
        },
        lineTo: function lineTo(x, y) {
          regions[regions.length - 1].push([x, y]);
        },
        bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
          regions[regions.length - 1].push([c1x, c1y, c2x, c2y, x, y]);
        },
        closePath: function closePath() {}
      };
      segments.shape.output(receiver);
      return {
        regions: regions,
        inverted: segments.inverted
      };
    }
    // helper functions for common operations
  }, {
    key: "union",
    value: function union(poly1, poly2) {
      var seg1 = this.segments(poly1);
      var seg2 = this.segments(poly2);
      var comb = this.combine(seg1, seg2);
      var seg3 = this.selectUnion(comb);
      return this.polygon(seg3);
    }
  }, {
    key: "intersect",
    value: function intersect(poly1, poly2) {
      var seg1 = this.segments(poly1);
      var seg2 = this.segments(poly2);
      var comb = this.combine(seg1, seg2);
      var seg3 = this.selectIntersect(comb);
      return this.polygon(seg3);
    }
  }, {
    key: "difference",
    value: function difference(poly1, poly2) {
      var seg1 = this.segments(poly1);
      var seg2 = this.segments(poly2);
      var comb = this.combine(seg1, seg2);
      var seg3 = this.selectDifference(comb);
      return this.polygon(seg3);
    }
  }, {
    key: "differenceRev",
    value: function differenceRev(poly1, poly2) {
      var seg1 = this.segments(poly1);
      var seg2 = this.segments(poly2);
      var comb = this.combine(seg1, seg2);
      var seg3 = this.selectDifferenceRev(comb);
      return this.polygon(seg3);
    }
  }, {
    key: "xor",
    value: function xor(poly1, poly2) {
      var seg1 = this.segments(poly1);
      var seg2 = this.segments(poly2);
      var comb = this.combine(seg1, seg2);
      var seg3 = this.selectXor(comb);
      return this.polygon(seg3);
    }
  }]);
}();
var polybool = new PolyBool();
exports.EventBool = EventBool;
exports.Geometry = Geometry;
exports.GeometryEpsilon = GeometryEpsilon;
exports.Intersecter = Intersecter;
exports.ListBool = ListBool;
exports.PolyBool = PolyBool;
exports.SegmentBase = SegmentBase;
exports.SegmentBoolBase = SegmentBoolBase;
exports.SegmentBoolCurve = SegmentBoolCurve;
exports.SegmentBoolLine = SegmentBoolLine;
exports.SegmentChainer = SegmentChainer;
exports.SegmentCurve = SegmentCurve;
exports.SegmentLine = SegmentLine;
exports.SegmentSelector = SegmentSelector;
exports.SegmentTValuePairsBuilder = SegmentTValuePairsBuilder;
exports.SegmentTValuesBuilder = SegmentTValuesBuilder;
exports.Shape = Shape;
exports.ShapeCombined = ShapeCombined;
exports.boundingBoxesIntersect = boundingBoxesIntersect;
exports.copySegmentBool = copySegmentBool;
exports["default"] = polybool;
exports.joinCurves = joinCurves;
exports.joinLines = joinLines;
exports.joinSegments = joinSegments;
exports.lerp = lerp;
exports.lerpVec2 = lerpVec2;
exports.projectPointOntoSegmentLine = projectPointOntoSegmentLine;
exports.segmentCurveIntersectSegmentCurve = segmentCurveIntersectSegmentCurve;
exports.segmentLineIntersectSegmentCurve = segmentLineIntersectSegmentCurve;
exports.segmentLineIntersectSegmentLine = segmentLineIntersectSegmentLine;
exports.segmentsIntersect = segmentsIntersect;
exports.segmentsToReceiver = segmentsToReceiver;

/***/ }),

/***/ 3087:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var colors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
for (var key in colors) Object.freeze(colors[key]);
/* harmony default export */ __webpack_exports__["default"] = (Object.freeze(colors));

/***/ }),

/***/ 9747:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ earcut; },
/* harmony export */   deviation: function() { return /* binding */ deviation; },
/* harmony export */   flatten: function() { return /* binding */ flatten; }
/* harmony export */ });
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function earcut(data, holeIndices) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var outerNode = linkedList(data, 0, outerLen, dim, true);
  var triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  var minX, minY, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
  if (data.length > 80 * dim) {
    minX = data[0];
    minY = data[1];
    var maxX = minX;
    var maxY = minY;
    for (var i = dim; i < outerLen; i += dim) {
      var x = data[i];
      var y = data[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }

    // minX, minY and invSize are later used to transform coords into integers for z-order calculation
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
  var last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (var i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
  } else {
    for (var _i = end - dim; _i >= start; _i -= dim) last = insertNode(_i / dim | 0, data[_i], data[_i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  var p = start,
    again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;

  // interlink polygon nodes in z-order
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  var stop = ear;

  // iterate through ears, slicing them one by one
  while (ear.prev !== ear.next) {
    var prev = ear.prev;
    var next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i, ear.i, next.i); // cut off the triangle

      removeNode(ear);

      // skipping the next vertex leads to less sliver triangles
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;

    // if we looped through the whole remaining polygon and can't find any more ears
    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

        // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

        // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
  var a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  // now make sure we don't have other points inside the potential ear
  var ax = a.x,
    bx = b.x,
    cx = c.x,
    ay = a.y,
    by = b.y,
    cy = c.y;

  // triangle bbox
  var x0 = Math.min(ax, bx, cx),
    y0 = Math.min(ay, by, cy),
    x1 = Math.max(ax, bx, cx),
    y1 = Math.max(ay, by, cy);
  var p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

  var ax = a.x,
    bx = b.x,
    cx = c.x,
    ay = a.y,
    by = b.y,
    cy = c.y;

  // triangle bbox
  var x0 = Math.min(ax, bx, cx),
    y0 = Math.min(ay, by, cy),
    x1 = Math.max(ax, bx, cx),
    y1 = Math.max(ay, by, cy);

  // z-order range for the current triangle bbox;
  var minZ = zOrder(x0, y0, minX, minY, invSize),
    maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ,
    n = ear.nextZ;

  // look for points inside the triangle in both directions
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  // look for remaining points in decreasing z-order
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }

  // look for remaining points in increasing z-order
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles) {
  var p = start;
  do {
    var a = p.prev,
      b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i, p.i, b.i);

      // remove two nodes involved
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        var c = splitPolygon(a, b);

        // filter colinear points around the cuts
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);

        // run earcut on each half
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [];
  for (var i = 0, len = holeIndices.length; i < len; i++) {
    var start = holeIndices[i] * dim;
    var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    var list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareXYSlope);

  // process holes from left to right
  for (var _i2 = 0; _i2 < queue.length; _i2++) {
    outerNode = eliminateHole(queue[_i2], outerNode);
  }
  return outerNode;
}
function compareXYSlope(a, b) {
  var result = a.x - b.x;
  // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find
  // the bridge to the outer shell is always the point that they meet at.
  if (result === 0) {
    result = a.y - b.y;
    if (result === 0) {
      var aSlope = (a.next.y - a.y) / (a.next.x - a.x);
      var bSlope = (b.next.y - b.y) / (b.next.x - b.x);
      result = aSlope - bSlope;
    }
  }
  return result;
}

// find a bridge between vertices that connects hole with an outer ring and link it
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);

  // filter collinear points around the cuts
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
  var p = outerNode;
  var hx = hole.x;
  var hy = hole.y;
  var qx = -Infinity;
  var m;

  // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point
  // unless they intersect at a vertex, then choose the vertex
  if (equals(hole, p)) return p;
  do {
    if (equals(hole, p.next)) return p.next;else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;

  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  var stop = m;
  var mx = m.x;
  var my = m.y;
  var tanMin = Infinity;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      var tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
  var numMerges;
  var inSize = 1;
  do {
    var p = list;
    var e = void 0;
    list = null;
    var tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      var q = p;
      var pSize = 0;
      for (var i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      var qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
  var p = start,
    leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}

// check if a point lies within a convex triangle but false if its equal to the first point of the triangle
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
  return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
  // doesn't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
  // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
  // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
  var p = a;
  var inside = false;
  var px = (a.x + b.x) / 2;
  var py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
  var a2 = createNode(a.i, a.x, a.y),
    b2 = createNode(b.i, b.x, b.y),
    an = a.next,
    bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
  var p = createNode(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function createNode(i, x, y) {
  return {
    i: i,
    // vertex index in coordinates array
    x: x,
    y: y,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: false // indicates whether this is a steiner point
  };
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
function deviation(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (var _i3 = 0; _i3 < triangles.length; _i3 += 3) {
    var a = triangles[_i3] * dim;
    var b = triangles[_i3 + 1] * dim;
    var c = triangles[_i3 + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
}
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
function flatten(data) {
  var vertices = [];
  var holes = [];
  var dimensions = data[0][0].length;
  var holeIndex = 0;
  var prevLen = 0;
  var _iterator = _createForOfIteratorHelper(data),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var ring = _step.value;
      var _iterator2 = _createForOfIteratorHelper(ring),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var p = _step2.value;
          for (var d = 0; d < dimensions; d++) vertices.push(p[d]);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (prevLen) {
        holeIndex += prevLen;
        holes.push(holeIndex);
      }
      prevLen = ring.length;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    vertices: vertices,
    holes: holes,
    dimensions: dimensions
  };
}

/***/ }),

/***/ 4279:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ KDBush; }
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];

/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */

var VERSION = 1; // serialized format version
var HEADER_SIZE = 8;
var KDBush = /*#__PURE__*/function () {
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  function KDBush(numItems) {
    var nodeSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float64Array;
    var data = arguments.length > 3 ? arguments[3] : undefined;
    _classCallCheck(this, KDBush);
    if (isNaN(numItems) || numItems < 0) throw new Error("Unpexpected numItems value: ".concat(numItems, "."));
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;
    var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    var coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;
    var idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;
    var padCoords = (8 - idsByteSize % 8) % 8;
    if (arrayTypeIndex < 0) {
      throw new Error("Unexpected typed array class: ".concat(ArrayType, "."));
    }
    if (data && data instanceof ArrayBuffer) {
      // reconstruct an index from a buffer
      this.data = data;
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = numItems * 2;
      this._finished = true;
    } else {
      // initialize a new index
      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = 0;
      this._finished = false;

      // set header
      new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
  }

  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  return _createClass(KDBush, [{
    key: "add",
    value: function add(x, y) {
      var index = this._pos >> 1;
      this.ids[index] = index;
      this.coords[this._pos++] = x;
      this.coords[this._pos++] = y;
      return index;
    }

    /**
     * Perform indexing of the added points.
     */
  }, {
    key: "finish",
    value: function finish() {
      var numAdded = this._pos >> 1;
      if (numAdded !== this.numItems) {
        throw new Error("Added ".concat(numAdded, " items when expected ").concat(this.numItems, "."));
      }
      // kd-sort both arrays for efficient search
      sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);
      this._finished = true;
      return this;
    }

    /**
     * Search the index for items within a given bounding box.
     * @param {number} minX
     * @param {number} minY
     * @param {number} maxX
     * @param {number} maxY
     * @returns {number[]} An array of indices correponding to the found items.
     */
  }, {
    key: "range",
    value: function range(minX, minY, maxX, maxY) {
      if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');
      var ids = this.ids,
        coords = this.coords,
        nodeSize = this.nodeSize;
      var stack = [0, ids.length - 1, 0];
      var result = [];

      // recursively search for items in range in the kd-sorted arrays
      while (stack.length) {
        var axis = stack.pop() || 0;
        var right = stack.pop() || 0;
        var left = stack.pop() || 0;

        // if we reached "tree node", search linearly
        if (right - left <= nodeSize) {
          for (var i = left; i <= right; i++) {
            var _x = coords[2 * i];
            var _y = coords[2 * i + 1];
            if (_x >= minX && _x <= maxX && _y >= minY && _y <= maxY) result.push(ids[i]);
          }
          continue;
        }

        // otherwise find the middle index
        var m = left + right >> 1;

        // include the middle item if it's in range
        var x = coords[2 * m];
        var y = coords[2 * m + 1];
        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);

        // queue search in halves that intersect the query
        if (axis === 0 ? minX <= x : minY <= y) {
          stack.push(left);
          stack.push(m - 1);
          stack.push(1 - axis);
        }
        if (axis === 0 ? maxX >= x : maxY >= y) {
          stack.push(m + 1);
          stack.push(right);
          stack.push(1 - axis);
        }
      }
      return result;
    }

    /**
     * Search the index for items within a given radius.
     * @param {number} qx
     * @param {number} qy
     * @param {number} r Query radius.
     * @returns {number[]} An array of indices correponding to the found items.
     */
  }, {
    key: "within",
    value: function within(qx, qy, r) {
      if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');
      var ids = this.ids,
        coords = this.coords,
        nodeSize = this.nodeSize;
      var stack = [0, ids.length - 1, 0];
      var result = [];
      var r2 = r * r;

      // recursively search for items within radius in the kd-sorted arrays
      while (stack.length) {
        var axis = stack.pop() || 0;
        var right = stack.pop() || 0;
        var left = stack.pop() || 0;

        // if we reached "tree node", search linearly
        if (right - left <= nodeSize) {
          for (var i = left; i <= right; i++) {
            if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
          }
          continue;
        }

        // otherwise find the middle index
        var m = left + right >> 1;

        // include the middle item if it's in range
        var x = coords[2 * m];
        var y = coords[2 * m + 1];
        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);

        // queue search in halves that intersect the query
        if (axis === 0 ? qx - r <= x : qy - r <= y) {
          stack.push(left);
          stack.push(m - 1);
          stack.push(1 - axis);
        }
        if (axis === 0 ? qx + r >= x : qy + r >= y) {
          stack.push(m + 1);
          stack.push(right);
          stack.push(1 - axis);
        }
      }
      return result;
    }
  }], [{
    key: "from",
    value:
    /**
     * Creates an index from raw `ArrayBuffer` data.
     * @param {ArrayBuffer} data
     */
    function from(data) {
      if (!(data instanceof ArrayBuffer)) {
        throw new Error('Data must be an instance of ArrayBuffer.');
      }
      var _Uint8Array = new Uint8Array(data, 0, 2),
        _Uint8Array2 = _slicedToArray(_Uint8Array, 2),
        magic = _Uint8Array2[0],
        versionAndType = _Uint8Array2[1];
      if (magic !== 0xdb) {
        throw new Error('Data does not appear to be in a KDBush format.');
      }
      var version = versionAndType >> 4;
      if (version !== VERSION) {
        throw new Error("Got v".concat(version, " data when expected v").concat(VERSION, "."));
      }
      var ArrayType = ARRAY_TYPES[versionAndType & 0x0f];
      if (!ArrayType) {
        throw new Error('Unrecognized array type.');
      }
      var _Uint16Array = new Uint16Array(data, 2, 1),
        _Uint16Array2 = _slicedToArray(_Uint16Array, 1),
        nodeSize = _Uint16Array2[0];
      var _Uint32Array = new Uint32Array(data, 4, 1),
        _Uint32Array2 = _slicedToArray(_Uint32Array, 1),
        numItems = _Uint32Array2[0];
      return new KDBush(numItems, nodeSize, ArrayType, data);
    }
  }]);
}();
/**
 * @param {Uint16Array | Uint32Array} ids
 * @param {InstanceType<TypedArrayConstructor>} coords
 * @param {number} nodeSize
 * @param {number} left
 * @param {number} right
 * @param {number} axis
 */

function sort(ids, coords, nodeSize, left, right, axis) {
  if (right - left <= nodeSize) return;
  var m = left + right >> 1; // middle index

  // sort ids and coords around the middle index so that the halves lie
  // either left/right or top/bottom correspondingly (taking turns)
  select(ids, coords, m, left, right, axis);

  // recursively kd-sort first half and second half on the opposite axis
  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);
  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);
}

/**
 * Custom Floyd-Rivest selection algorithm: sort ids and coords so that
 * [left..k-1] items are smaller than k-th item (on either x or y axis)
 * @param {Uint16Array | Uint32Array} ids
 * @param {InstanceType<TypedArrayConstructor>} coords
 * @param {number} k
 * @param {number} left
 * @param {number} right
 * @param {number} axis
 */
function select(ids, coords, k, left, right, axis) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      select(ids, coords, k, newLeft, newRight, axis);
    }
    var t = coords[2 * k + axis];
    var i = left;
    var j = right;
    swapItem(ids, coords, left, k);
    if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);
    while (i < j) {
      swapItem(ids, coords, i, j);
      i++;
      j--;
      while (coords[2 * i + axis] < t) i++;
      while (coords[2 * j + axis] > t) j--;
    }
    if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);else {
      j++;
      swapItem(ids, coords, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}

/**
 * @param {Uint16Array | Uint32Array} ids
 * @param {InstanceType<TypedArrayConstructor>} coords
 * @param {number} i
 * @param {number} j
 */
function swapItem(ids, coords, i, j) {
  swap(ids, i, j);
  swap(coords, 2 * i, 2 * j);
  swap(coords, 2 * i + 1, 2 * j + 1);
}

/**
 * @param {InstanceType<TypedArrayConstructor>} arr
 * @param {number} i
 * @param {number} j
 */
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}

/**
 * @param {number} ax
 * @param {number} ay
 * @param {number} bx
 * @param {number} by
 */
function sqDist(ax, ay, bx, by) {
  var dx = ax - bx;
  var dy = ay - by;
  return dx * dx + dy * dy;
}

/***/ }),

/***/ 6082:
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: function() { return /* binding */ wkt_parser; }
});

;// ../node_modules/wkt-parser/PROJJSONBuilderBase.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var PROJJSONBuilderBase = /*#__PURE__*/function () {
  function PROJJSONBuilderBase() {
    _classCallCheck(this, PROJJSONBuilderBase);
  }
  return _createClass(PROJJSONBuilderBase, null, [{
    key: "getId",
    value: function getId(node) {
      var idNode = node.find(function (child) {
        return Array.isArray(child) && child[0] === 'ID';
      });
      if (idNode && idNode.length >= 3) {
        return {
          authority: idNode[1],
          code: parseInt(idNode[2], 10)
        };
      }
      return null;
    }
  }, {
    key: "convertUnit",
    value: function convertUnit(node) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unit';
      if (!node || node.length < 3) {
        return {
          type: type,
          name: 'unknown',
          conversion_factor: null
        };
      }
      var name = node[1];
      var conversionFactor = parseFloat(node[2]) || null;
      var idNode = node.find(function (child) {
        return Array.isArray(child) && child[0] === 'ID';
      });
      var id = idNode ? {
        authority: idNode[1],
        code: parseInt(idNode[2], 10)
      } : null;
      return {
        type: type,
        name: name,
        conversion_factor: conversionFactor,
        id: id
      };
    }
  }, {
    key: "convertAxis",
    value: function convertAxis(node) {
      var name = node[1] || 'Unknown';

      // Determine the direction
      var direction;
      var abbreviationMatch = name.match(/^\((.)\)$/); // Match abbreviations like "(E)" or "(N)"
      if (abbreviationMatch) {
        // Use the abbreviation to determine the direction
        var abbreviation = abbreviationMatch[1].toUpperCase();
        if (abbreviation === 'E') direction = 'east';else if (abbreviation === 'N') direction = 'north';else if (abbreviation === 'U') direction = 'up';else throw new Error("Unknown axis abbreviation: ".concat(abbreviation));
      } else {
        // Use the explicit direction provided in the AXIS node
        direction = node[2] ? node[2].toLowerCase() : 'unknown';
      }
      var orderNode = node.find(function (child) {
        return Array.isArray(child) && child[0] === 'ORDER';
      });
      var order = orderNode ? parseInt(orderNode[1], 10) : null;
      var unitNode = node.find(function (child) {
        return Array.isArray(child) && (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT');
      });
      var unit = this.convertUnit(unitNode);
      return {
        name: name,
        direction: direction,
        // Use the valid PROJJSON direction value
        unit: unit,
        order: order
      };
    }
  }, {
    key: "extractAxes",
    value: function extractAxes(node) {
      var _this = this;
      return node.filter(function (child) {
        return Array.isArray(child) && child[0] === 'AXIS';
      }).map(function (axis) {
        return _this.convertAxis(axis);
      }).sort(function (a, b) {
        return (a.order || 0) - (b.order || 0);
      }); // Sort by the "order" property
    }
  }, {
    key: "convert",
    value: function convert(node) {
      var _this2 = this;
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      switch (node[0]) {
        case 'PROJCRS':
          result.type = 'ProjectedCRS';
          result.name = node[1];
          result.base_crs = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'BASEGEOGCRS';
          }) ? this.convert(node.find(function (child) {
            return Array.isArray(child) && child[0] === 'BASEGEOGCRS';
          })) : null;
          result.conversion = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'CONVERSION';
          }) ? this.convert(node.find(function (child) {
            return Array.isArray(child) && child[0] === 'CONVERSION';
          })) : null;
          var csNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'CS';
          });
          if (csNode) {
            result.coordinate_system = {
              type: csNode[1],
              axis: this.extractAxes(node)
            };
          }
          var lengthUnitNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'LENGTHUNIT';
          });
          if (lengthUnitNode) {
            var _unit = this.convertUnit(lengthUnitNode);
            result.coordinate_system.unit = _unit; // Add unit to coordinate_system
          }
          result.id = this.getId(node);
          break;
        case 'BASEGEOGCRS':
        case 'GEOGCRS':
          result.type = 'GeographicCRS';
          result.name = node[1];

          // Handle DATUM or ENSEMBLE
          var datumOrEnsembleNode = node.find(function (child) {
            return Array.isArray(child) && (child[0] === 'DATUM' || child[0] === 'ENSEMBLE');
          });
          if (datumOrEnsembleNode) {
            var datumOrEnsemble = this.convert(datumOrEnsembleNode);
            if (datumOrEnsembleNode[0] === 'ENSEMBLE') {
              result.datum_ensemble = datumOrEnsemble;
            } else {
              result.datum = datumOrEnsemble;
            }
            var primem = node.find(function (child) {
              return Array.isArray(child) && child[0] === 'PRIMEM';
            });
            if (primem && primem[1] !== 'Greenwich') {
              datumOrEnsemble.prime_meridian = {
                name: primem[1],
                longitude: parseFloat(primem[2])
              };
            }
          }
          result.coordinate_system = {
            type: 'ellipsoidal',
            axis: this.extractAxes(node)
          };
          result.id = this.getId(node);
          break;
        case 'DATUM':
          result.type = 'GeodeticReferenceFrame';
          result.name = node[1];
          result.ellipsoid = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'ELLIPSOID';
          }) ? this.convert(node.find(function (child) {
            return Array.isArray(child) && child[0] === 'ELLIPSOID';
          })) : null;
          break;
        case 'ENSEMBLE':
          result.type = 'DatumEnsemble';
          result.name = node[1];

          // Extract ensemble members
          result.members = node.filter(function (child) {
            return Array.isArray(child) && child[0] === 'MEMBER';
          }).map(function (member) {
            return {
              type: 'DatumEnsembleMember',
              name: member[1],
              id: _this2.getId(member) // Extract ID as { authority, code }
            };
          });

          // Extract accuracy
          var accuracyNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'ENSEMBLEACCURACY';
          });
          if (accuracyNode) {
            result.accuracy = parseFloat(accuracyNode[1]);
          }

          // Extract ellipsoid
          var ellipsoidNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'ELLIPSOID';
          });
          if (ellipsoidNode) {
            result.ellipsoid = this.convert(ellipsoidNode); // Convert the ellipsoid node
          }

          // Extract identifier for the ensemble
          result.id = this.getId(node);
          break;
        case 'ELLIPSOID':
          result.type = 'Ellipsoid';
          result.name = node[1];
          result.semi_major_axis = parseFloat(node[2]);
          result.inverse_flattening = parseFloat(node[3]);
          var units = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'LENGTHUNIT';
          }) ? this.convert(node.find(function (child) {
            return Array.isArray(child) && child[0] === 'LENGTHUNIT';
          }), result) : null;
          break;
        case 'CONVERSION':
          result.type = 'Conversion';
          result.name = node[1];
          result.method = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'METHOD';
          }) ? this.convert(node.find(function (child) {
            return Array.isArray(child) && child[0] === 'METHOD';
          })) : null;
          result.parameters = node.filter(function (child) {
            return Array.isArray(child) && child[0] === 'PARAMETER';
          }).map(function (param) {
            return _this2.convert(param);
          });
          break;
        case 'METHOD':
          result.type = 'Method';
          result.name = node[1];
          result.id = this.getId(node);
          break;
        case 'PARAMETER':
          result.type = 'Parameter';
          result.name = node[1];
          result.value = parseFloat(node[2]);
          result.unit = this.convertUnit(node.find(function (child) {
            return Array.isArray(child) && (child[0] === 'LENGTHUNIT' || child[0] === 'ANGLEUNIT' || child[0] === 'SCALEUNIT');
          }));
          result.id = this.getId(node);
          break;
        case 'BOUNDCRS':
          result.type = 'BoundCRS';

          // Process SOURCECRS
          var sourceCrsNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'SOURCECRS';
          });
          if (sourceCrsNode) {
            var sourceCrsContent = sourceCrsNode.find(function (child) {
              return Array.isArray(child);
            });
            result.source_crs = sourceCrsContent ? this.convert(sourceCrsContent) : null;
          }

          // Process TARGETCRS
          var targetCrsNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'TARGETCRS';
          });
          if (targetCrsNode) {
            var targetCrsContent = targetCrsNode.find(function (child) {
              return Array.isArray(child);
            });
            result.target_crs = targetCrsContent ? this.convert(targetCrsContent) : null;
          }

          // Process ABRIDGEDTRANSFORMATION
          var transformationNode = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'ABRIDGEDTRANSFORMATION';
          });
          if (transformationNode) {
            result.transformation = this.convert(transformationNode);
          } else {
            result.transformation = null;
          }
          break;
        case 'ABRIDGEDTRANSFORMATION':
          result.type = 'Transformation';
          result.name = node[1];
          result.method = node.find(function (child) {
            return Array.isArray(child) && child[0] === 'METHOD';
          }) ? this.convert(node.find(function (child) {
            return Array.isArray(child) && child[0] === 'METHOD';
          })) : null;
          result.parameters = node.filter(function (child) {
            return Array.isArray(child) && (child[0] === 'PARAMETER' || child[0] === 'PARAMETERFILE');
          }).map(function (param) {
            if (param[0] === 'PARAMETER') {
              return _this2.convert(param);
            } else if (param[0] === 'PARAMETERFILE') {
              return {
                name: param[1],
                value: param[2],
                id: {
                  'authority': 'EPSG',
                  'code': 8656
                }
              };
            }
          });

          // Adjust the Scale difference parameter if present
          if (result.parameters.length === 7) {
            var scaleDifference = result.parameters[6];
            if (scaleDifference.name === 'Scale difference') {
              scaleDifference.value = Math.round((scaleDifference.value - 1) * 1e12) / 1e6;
            }
          }
          result.id = this.getId(node);
          break;
        case 'AXIS':
          if (!result.coordinate_system) {
            result.coordinate_system = {
              type: 'unspecified',
              axis: []
            };
          }
          result.coordinate_system.axis.push(this.convertAxis(node));
          break;
        case 'LENGTHUNIT':
          var unit = this.convertUnit(node, 'LinearUnit');
          if (result.coordinate_system && result.coordinate_system.axis) {
            result.coordinate_system.axis.forEach(function (axis) {
              if (!axis.unit) {
                axis.unit = unit;
              }
            });
          }
          if (unit.conversion_factor && unit.conversion_factor !== 1) {
            if (result.semi_major_axis) {
              result.semi_major_axis = {
                value: result.semi_major_axis,
                unit: unit
              };
            }
          }
          break;
        default:
          result.keyword = node[0];
          break;
      }
      return result;
    }
  }]);
}();
/* harmony default export */ var wkt_parser_PROJJSONBuilderBase = (PROJJSONBuilderBase);
;// ../node_modules/wkt-parser/PROJJSONBuilder2015.js
function PROJJSONBuilder2015_typeof(o) { "@babel/helpers - typeof"; return PROJJSONBuilder2015_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, PROJJSONBuilder2015_typeof(o); }
function PROJJSONBuilder2015_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function PROJJSONBuilder2015_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, PROJJSONBuilder2015_toPropertyKey(o.key), o); } }
function PROJJSONBuilder2015_createClass(e, r, t) { return r && PROJJSONBuilder2015_defineProperties(e.prototype, r), t && PROJJSONBuilder2015_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function PROJJSONBuilder2015_toPropertyKey(t) { var i = PROJJSONBuilder2015_toPrimitive(t, "string"); return "symbol" == PROJJSONBuilder2015_typeof(i) ? i : i + ""; }
function PROJJSONBuilder2015_toPrimitive(t, r) { if ("object" != PROJJSONBuilder2015_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != PROJJSONBuilder2015_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == PROJJSONBuilder2015_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }

var PROJJSONBuilder2015 = /*#__PURE__*/function (_PROJJSONBuilderBase) {
  function PROJJSONBuilder2015() {
    PROJJSONBuilder2015_classCallCheck(this, PROJJSONBuilder2015);
    return _callSuper(this, PROJJSONBuilder2015, arguments);
  }
  _inherits(PROJJSONBuilder2015, _PROJJSONBuilderBase);
  return PROJJSONBuilder2015_createClass(PROJJSONBuilder2015, null, [{
    key: "convert",
    value: function convert(node) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _superPropGet(PROJJSONBuilder2015, "convert", this, 2)([node, result]);

      // Skip `CS` and `USAGE` nodes for WKT2-2015
      if (result.coordinate_system && result.coordinate_system.subtype === 'Cartesian') {
        delete result.coordinate_system;
      }
      if (result.usage) {
        delete result.usage;
      }
      return result;
    }
  }]);
}(wkt_parser_PROJJSONBuilderBase);
/* harmony default export */ var wkt_parser_PROJJSONBuilder2015 = (PROJJSONBuilder2015);
;// ../node_modules/wkt-parser/PROJJSONBuilder2019.js
function PROJJSONBuilder2019_typeof(o) { "@babel/helpers - typeof"; return PROJJSONBuilder2019_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, PROJJSONBuilder2019_typeof(o); }
function PROJJSONBuilder2019_classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function PROJJSONBuilder2019_defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, PROJJSONBuilder2019_toPropertyKey(o.key), o); } }
function PROJJSONBuilder2019_createClass(e, r, t) { return r && PROJJSONBuilder2019_defineProperties(e.prototype, r), t && PROJJSONBuilder2019_defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function PROJJSONBuilder2019_toPropertyKey(t) { var i = PROJJSONBuilder2019_toPrimitive(t, "string"); return "symbol" == PROJJSONBuilder2019_typeof(i) ? i : i + ""; }
function PROJJSONBuilder2019_toPrimitive(t, r) { if ("object" != PROJJSONBuilder2019_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != PROJJSONBuilder2019_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function PROJJSONBuilder2019_callSuper(t, o, e) { return o = PROJJSONBuilder2019_getPrototypeOf(o), PROJJSONBuilder2019_possibleConstructorReturn(t, PROJJSONBuilder2019_isNativeReflectConstruct() ? Reflect.construct(o, e || [], PROJJSONBuilder2019_getPrototypeOf(t).constructor) : o.apply(t, e)); }
function PROJJSONBuilder2019_possibleConstructorReturn(t, e) { if (e && ("object" == PROJJSONBuilder2019_typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return PROJJSONBuilder2019_assertThisInitialized(t); }
function PROJJSONBuilder2019_assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function PROJJSONBuilder2019_isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (PROJJSONBuilder2019_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function PROJJSONBuilder2019_superPropGet(t, o, e, r) { var p = PROJJSONBuilder2019_get(PROJJSONBuilder2019_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
function PROJJSONBuilder2019_get() { return PROJJSONBuilder2019_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = PROJJSONBuilder2019_superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, PROJJSONBuilder2019_get.apply(null, arguments); }
function PROJJSONBuilder2019_superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = PROJJSONBuilder2019_getPrototypeOf(t));); return t; }
function PROJJSONBuilder2019_getPrototypeOf(t) { return PROJJSONBuilder2019_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, PROJJSONBuilder2019_getPrototypeOf(t); }
function PROJJSONBuilder2019_inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && PROJJSONBuilder2019_setPrototypeOf(t, e); }
function PROJJSONBuilder2019_setPrototypeOf(t, e) { return PROJJSONBuilder2019_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, PROJJSONBuilder2019_setPrototypeOf(t, e); }

var PROJJSONBuilder2019 = /*#__PURE__*/function (_PROJJSONBuilderBase) {
  function PROJJSONBuilder2019() {
    PROJJSONBuilder2019_classCallCheck(this, PROJJSONBuilder2019);
    return PROJJSONBuilder2019_callSuper(this, PROJJSONBuilder2019, arguments);
  }
  PROJJSONBuilder2019_inherits(PROJJSONBuilder2019, _PROJJSONBuilderBase);
  return PROJJSONBuilder2019_createClass(PROJJSONBuilder2019, null, [{
    key: "convert",
    value: function convert(node) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      PROJJSONBuilder2019_superPropGet(PROJJSONBuilder2019, "convert", this, 2)([node, result]);

      // Handle `CS` node for WKT2-2019
      var csNode = node.find(function (child) {
        return Array.isArray(child) && child[0] === 'CS';
      });
      if (csNode) {
        result.coordinate_system = {
          subtype: csNode[1],
          axis: this.extractAxes(node)
        };
      }

      // Handle `USAGE` node for WKT2-2019
      var usageNode = node.find(function (child) {
        return Array.isArray(child) && child[0] === 'USAGE';
      });
      if (usageNode) {
        var scope = usageNode.find(function (child) {
          return Array.isArray(child) && child[0] === 'SCOPE';
        });
        var area = usageNode.find(function (child) {
          return Array.isArray(child) && child[0] === 'AREA';
        });
        var bbox = usageNode.find(function (child) {
          return Array.isArray(child) && child[0] === 'BBOX';
        });
        result.usage = {};
        if (scope) {
          result.usage.scope = scope[1];
        }
        if (area) {
          result.usage.area = area[1];
        }
        if (bbox) {
          result.usage.bbox = bbox.slice(1);
        }
      }
      return result;
    }
  }]);
}(wkt_parser_PROJJSONBuilderBase);
/* harmony default export */ var wkt_parser_PROJJSONBuilder2019 = (PROJJSONBuilder2019);
;// ../node_modules/wkt-parser/buildPROJJSON.js



/**
 * Detects the WKT2 version based on the structure of the WKT.
 * @param {Array} root The root WKT array node.
 * @returns {string} The detected version ("2015" or "2019").
 */
function detectWKT2Version(root) {
  // Check for WKT2-2019-specific nodes
  if (root.find(function (child) {
    return Array.isArray(child) && child[0] === 'USAGE';
  })) {
    return '2019'; // `USAGE` is specific to WKT2-2019
  }

  // Check for WKT2-2015-specific nodes
  if (root.find(function (child) {
    return Array.isArray(child) && child[0] === 'CS';
  })) {
    return '2015'; // `CS` is valid in both, but default to 2015 unless `USAGE` is present
  }
  if (root[0] === 'BOUNDCRS' || root[0] === 'PROJCRS' || root[0] === 'GEOGCRS') {
    return '2015'; // These are valid in both, but default to 2015
  }

  // Default to WKT2-2015 if no specific indicators are found
  return '2015';
}

/**
 * Builds a PROJJSON object from a WKT array structure.
 * @param {Array} root The root WKT array node.
 * @returns {Object} The PROJJSON object.
 */
function buildPROJJSON(root) {
  var version = detectWKT2Version(root);
  var builder = version === '2019' ? wkt_parser_PROJJSONBuilder2019 : wkt_parser_PROJJSONBuilder2015;
  return builder.convert(root);
}
;// ../node_modules/wkt-parser/detectWKTVersion.js
/**
 * Detects whether the WKT string is WKT1 or WKT2.
 * @param {string} wkt The WKT string.
 * @returns {string} The detected version ("WKT1" or "WKT2").
 */
function detectWKTVersion(wkt) {
  // Normalize the WKT string for easier keyword matching
  var normalizedWKT = wkt.toUpperCase();

  // Check for WKT2-specific keywords
  if (normalizedWKT.includes('PROJCRS') || normalizedWKT.includes('GEOGCRS') || normalizedWKT.includes('BOUNDCRS') || normalizedWKT.includes('VERTCRS') || normalizedWKT.includes('LENGTHUNIT') || normalizedWKT.includes('ANGLEUNIT') || normalizedWKT.includes('SCALEUNIT')) {
    return 'WKT2';
  }

  // Check for WKT1-specific keywords
  if (normalizedWKT.includes('PROJCS') || normalizedWKT.includes('GEOGCS') || normalizedWKT.includes('LOCAL_CS') || normalizedWKT.includes('VERT_CS') || normalizedWKT.includes('UNIT')) {
    return 'WKT1';
  }

  // Default to WKT1 if no specific indicators are found
  return 'WKT1';
}
;// ../node_modules/wkt-parser/parser.js
/* harmony default export */ var parser = (parseString);
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function () {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char);
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function (char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' + char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function (char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }
    return;
  }
};
Parser.prototype.number = function (char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' + char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function (char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function (char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' + char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function (char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' + char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function () {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
;// ../node_modules/wkt-parser/process.js
function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;
  var out = value.reduce(function (newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj[key] = out;
  }
}
function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }
  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'LOCAL_DATUM':
    case 'DATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'FITTED_CS':
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'ENGCRS':
    case 'ENGINEERINGCRS':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      obj[key].type = key;
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}
;// ../node_modules/wkt-parser/util.js
var D2R = 0.01745329251994329577;
function d2r(input) {
  return input * D2R;
}
function applyProjectionDefaults(wkt) {
  // Normalize projName for WKT2 compatibility
  var normalizedProjName = (wkt.projName || '').toLowerCase().replace(/_/g, ' ');
  if (!wkt.long0 && wkt.longc && (normalizedProjName === 'albers conic equal area' || normalizedProjName === 'lambert azimuthal equal area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (normalizedProjName === 'stereographic south pole' || normalizedProjName === 'polar stereographic (variant b)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
    delete wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && (normalizedProjName === 'polar stereographic' || normalizedProjName === 'polar stereographic (variant a)')) {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    delete wkt.lat1;
  }
}
;// ../node_modules/wkt-parser/transformPROJJSON.js
function transformPROJJSON_typeof(o) { "@babel/helpers - typeof"; return transformPROJJSON_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, transformPROJJSON_typeof(o); }


// Helper function to process units and to_meter
function processUnit(unit) {
  var result = {
    units: null,
    to_meter: undefined
  };
  if (typeof unit === 'string') {
    result.units = unit.toLowerCase();
    if (result.units === 'metre') {
      result.units = 'meter'; // Normalize 'metre' to 'meter'
    }
    if (result.units === 'meter') {
      result.to_meter = 1; // Only set to_meter if units are 'meter'
    }
  } else if (unit && unit.name) {
    result.units = unit.name.toLowerCase();
    if (result.units === 'metre') {
      result.units = 'meter'; // Normalize 'metre' to 'meter'
    }
    result.to_meter = unit.conversion_factor;
  }
  return result;
}
function toValue(valueOrObject) {
  if (transformPROJJSON_typeof(valueOrObject) === 'object') {
    return valueOrObject.value * valueOrObject.unit.conversion_factor;
  }
  return valueOrObject;
}
function calculateEllipsoid(value, result) {
  if (value.ellipsoid.radius) {
    result.a = value.ellipsoid.radius;
    result.rf = 0;
  } else {
    result.a = toValue(value.ellipsoid.semi_major_axis);
    if (value.ellipsoid.inverse_flattening !== undefined) {
      result.rf = value.ellipsoid.inverse_flattening;
    } else if (value.ellipsoid.semi_major_axis !== undefined && value.ellipsoid.semi_minor_axis !== undefined) {
      result.rf = result.a / (result.a - toValue(value.ellipsoid.semi_minor_axis));
    }
  }
}
function transformPROJJSON(projjson) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!projjson || transformPROJJSON_typeof(projjson) !== 'object') {
    return projjson; // Return primitive values as-is
  }
  if (projjson.type === 'BoundCRS') {
    transformPROJJSON(projjson.source_crs, result);
    if (projjson.transformation) {
      if (projjson.transformation.method && projjson.transformation.method.name === 'NTv2') {
        // Set nadgrids to the filename from the parameterfile
        result.nadgrids = projjson.transformation.parameters[0].value;
      } else {
        // Populate datum_params if no parameterfile is found
        result.datum_params = projjson.transformation.parameters.map(function (param) {
          return param.value;
        });
      }
    }
    return result; // Return early for BoundCRS
  }

  // Handle specific keys in PROJJSON
  Object.keys(projjson).forEach(function (key) {
    var value = projjson[key];
    if (value === null) {
      return;
    }
    switch (key) {
      case 'name':
        if (result.srsCode) {
          break;
        }
        result.name = value;
        result.srsCode = value; // Map `name` to `srsCode`
        break;
      case 'type':
        if (value === 'GeographicCRS') {
          result.projName = 'longlat';
        } else if (value === 'ProjectedCRS' && projjson.conversion && projjson.conversion.method) {
          result.projName = projjson.conversion.method.name; // Retain original capitalization
        }
        break;
      case 'datum':
      case 'datum_ensemble':
        // Handle both datum and ensemble
        if (value.ellipsoid) {
          // Extract ellipsoid properties
          result.ellps = value.ellipsoid.name;
          calculateEllipsoid(value, result);
        }
        if (value.prime_meridian) {
          result.from_greenwich = value.prime_meridian.longitude * Math.PI / 180; // Convert to radians
        }
        break;
      case 'ellipsoid':
        result.ellps = value.name;
        calculateEllipsoid(value, result);
        break;
      case 'prime_meridian':
        result.long0 = (value.longitude || 0) * Math.PI / 180; // Convert to radians
        break;
      case 'coordinate_system':
        if (value.axis) {
          result.axis = value.axis.map(function (axis) {
            var direction = axis.direction;
            if (direction === 'east') return 'e';
            if (direction === 'north') return 'n';
            if (direction === 'west') return 'w';
            if (direction === 'south') return 's';
            throw new Error("Unknown axis direction: ".concat(direction));
          }).join('') + 'u'; // Combine into a single string (e.g., "enu")

          if (value.unit) {
            var _processUnit = processUnit(value.unit),
              units = _processUnit.units,
              to_meter = _processUnit.to_meter;
            result.units = units;
            result.to_meter = to_meter;
          } else if (value.axis[0] && value.axis[0].unit) {
            var _processUnit2 = processUnit(value.axis[0].unit),
              _units = _processUnit2.units,
              _to_meter = _processUnit2.to_meter;
            result.units = _units;
            result.to_meter = _to_meter;
          }
        }
        break;
      case 'id':
        if (value.authority && value.code) {
          result.title = value.authority + ':' + value.code;
        }
        break;
      case 'conversion':
        if (value.method && value.method.name) {
          result.projName = value.method.name; // Retain original capitalization
        }
        if (value.parameters) {
          value.parameters.forEach(function (param) {
            var paramName = param.name.toLowerCase().replace(/\s+/g, '_');
            var paramValue = param.value;
            if (param.unit && param.unit.conversion_factor) {
              result[paramName] = paramValue * param.unit.conversion_factor; // Convert to radians or meters
            } else if (param.unit === 'degree') {
              result[paramName] = paramValue * Math.PI / 180; // Convert to radians
            } else {
              result[paramName] = paramValue;
            }
          });
        }
        break;
      case 'unit':
        if (value.name) {
          result.units = value.name.toLowerCase();
          if (result.units === 'metre') {
            result.units = 'meter';
          }
        }
        if (value.conversion_factor) {
          result.to_meter = value.conversion_factor;
        }
        break;
      case 'base_crs':
        transformPROJJSON(value, result); // Pass `result` directly
        result.datumCode = value.id ? value.id.authority + '_' + value.id.code : value.name; // Set datumCode
        break;
      default:
        // Ignore irrelevant or unneeded properties
        break;
    }
  });

  // Additional calculated properties
  if (result.latitude_of_false_origin !== undefined) {
    result.lat0 = result.latitude_of_false_origin; // Already in radians
  }
  if (result.longitude_of_false_origin !== undefined) {
    result.long0 = result.longitude_of_false_origin;
  }
  if (result.latitude_of_standard_parallel !== undefined) {
    result.lat0 = result.latitude_of_standard_parallel;
    result.lat1 = result.latitude_of_standard_parallel;
  }
  if (result.latitude_of_1st_standard_parallel !== undefined) {
    result.lat1 = result.latitude_of_1st_standard_parallel;
  }
  if (result.latitude_of_2nd_standard_parallel !== undefined) {
    result.lat2 = result.latitude_of_2nd_standard_parallel;
  }
  if (result.latitude_of_projection_centre !== undefined) {
    result.lat0 = result.latitude_of_projection_centre;
  }
  if (result.longitude_of_projection_centre !== undefined) {
    result.longc = result.longitude_of_projection_centre;
  }
  if (result.easting_at_false_origin !== undefined) {
    result.x0 = result.easting_at_false_origin;
  }
  if (result.northing_at_false_origin !== undefined) {
    result.y0 = result.northing_at_false_origin;
  }
  if (result.latitude_of_natural_origin !== undefined) {
    result.lat0 = result.latitude_of_natural_origin;
  }
  if (result.longitude_of_natural_origin !== undefined) {
    result.long0 = result.longitude_of_natural_origin;
  }
  if (result.longitude_of_origin !== undefined) {
    result.long0 = result.longitude_of_origin;
  }
  if (result.false_easting !== undefined) {
    result.x0 = result.false_easting;
  }
  if (result.easting_at_projection_centre) {
    result.x0 = result.easting_at_projection_centre;
  }
  if (result.false_northing !== undefined) {
    result.y0 = result.false_northing;
  }
  if (result.northing_at_projection_centre) {
    result.y0 = result.northing_at_projection_centre;
  }
  if (result.standard_parallel_1 !== undefined) {
    result.lat1 = result.standard_parallel_1;
  }
  if (result.standard_parallel_2 !== undefined) {
    result.lat2 = result.standard_parallel_2;
  }
  if (result.scale_factor_at_natural_origin !== undefined) {
    result.k0 = result.scale_factor_at_natural_origin;
  }
  if (result.scale_factor_at_projection_centre !== undefined) {
    result.k0 = result.scale_factor_at_projection_centre;
  }
  if (result.scale_factor_on_pseudo_standard_parallel !== undefined) {
    result.k0 = result.scale_factor_on_pseudo_standard_parallel;
  }
  if (result.azimuth !== undefined) {
    result.alpha = result.azimuth;
  }
  if (result.azimuth_at_projection_centre !== undefined) {
    result.alpha = result.azimuth_at_projection_centre;
  }
  if (result.angle_from_rectified_to_skew_grid) {
    result.rectified_grid_angle = result.angle_from_rectified_to_skew_grid;
  }

  // Apply projection defaults
  applyProjectionDefaults(result);
  return result;
}
;// ../node_modules/wkt-parser/index.js
function wkt_parser_typeof(o) { "@babel/helpers - typeof"; return wkt_parser_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, wkt_parser_typeof(o); }






var knownTypes = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS', 'GEOCCS', 'PROJCS', 'LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && inName in obj) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}
function cleanWKT(wkt) {
  var keys = Object.keys(wkt);
  for (var i = 0, ii = keys.length; i < ii; ++i) {
    var key = keys[i];
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    if (knownTypes.indexOf(key) !== -1) {
      setPropertiesFromWkt(wkt[key]);
    }
    if (wkt_parser_typeof(wkt[key]) === 'object') {
      cleanWKT(wkt[key]);
    }
  }
}
function setPropertiesFromWkt(wkt) {
  if (wkt.AUTHORITY) {
    var authority = Object.keys(wkt.AUTHORITY)[0];
    if (authority && authority in wkt.AUTHORITY) {
      wkt.title = authority + ':' + wkt.AUTHORITY[authority];
    }
  }
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (wkt_parser_typeof(wkt.PROJECTION) === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = '';
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf('north') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north') {
        axisOrder += 'n';
      } else if (axis[0].indexOf('south') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south') {
        axisOrder += 's';
      } else if (axis[0].indexOf('east') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east') {
        axisOrder += 'e';
      } else if (axis[0].indexOf('west') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west') {
        axisOrder += 'w';
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode === 'belge_1972') {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }
    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  if (wkt.rectified_grid_angle) {
    wkt.rectified_grid_angle = d2r(wkt.rectified_grid_angle);
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function renamer(a) {
    return rename(wkt, a);
  };
  var list = [['standard_parallel_1', 'Standard_Parallel_1'], ['standard_parallel_1', 'Latitude of 1st standard parallel'], ['standard_parallel_2', 'Standard_Parallel_2'], ['standard_parallel_2', 'Latitude of 2nd standard parallel'], ['false_easting', 'False_Easting'], ['false_easting', 'False easting'], ['false-easting', 'Easting at false origin'], ['false_northing', 'False_Northing'], ['false_northing', 'False northing'], ['false_northing', 'Northing at false origin'], ['central_meridian', 'Central_Meridian'], ['central_meridian', 'Longitude of natural origin'], ['central_meridian', 'Longitude of false origin'], ['latitude_of_origin', 'Latitude_Of_Origin'], ['latitude_of_origin', 'Central_Parallel'], ['latitude_of_origin', 'Latitude of natural origin'], ['latitude_of_origin', 'Latitude of false origin'], ['scale_factor', 'Scale_Factor'], ['k0', 'scale_factor'], ['latitude_of_center', 'Latitude_Of_Center'], ['latitude_of_center', 'Latitude_of_center'], ['lat0', 'latitude_of_center', d2r], ['longitude_of_center', 'Longitude_Of_Center'], ['longitude_of_center', 'Longitude_of_center'], ['longc', 'longitude_of_center', d2r], ['x0', 'false_easting', toMeter], ['y0', 'false_northing', toMeter], ['long0', 'central_meridian', d2r], ['lat0', 'latitude_of_origin', d2r], ['lat0', 'standard_parallel_1', d2r], ['lat1', 'standard_parallel_1', d2r], ['lat2', 'standard_parallel_2', d2r], ['azimuth', 'Azimuth'], ['alpha', 'azimuth', d2r], ['srsCode', 'name']];
  list.forEach(renamer);
  applyProjectionDefaults(wkt);
}
/* harmony default export */ function wkt_parser(wkt) {
  if (wkt_parser_typeof(wkt) === 'object') {
    return transformPROJJSON(wkt);
  }
  var version = detectWKTVersion(wkt);
  var lisp = parser(wkt);
  if (version === 'WKT2') {
    var projjson = buildPROJJSON(lisp);
    return transformPROJJSON(projjson);
  }
  var type = lisp[0];
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj[type];
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			294: 0,
/******/ 			692: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	!function() {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(2257);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=geo.lean.js.map